pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const ptrdiff_t = c_long;
pub const wchar_t = c_int;
pub const max_align_t = extern struct {
    __clang_max_align_nonce1: c_longlong align(8),
    __clang_max_align_nonce2: c_longdouble align(16),
};
pub const gint8 = i8;
pub const guint8 = u8;
pub const gint16 = c_short;
pub const guint16 = c_ushort;
pub const gint32 = c_int;
pub const guint32 = c_uint;
pub const gint64 = c_long;
pub const guint64 = c_ulong;
pub const gssize = c_long;
pub const gsize = c_ulong;
pub const goffset = gint64;
pub const gintptr = c_long;
pub const guintptr = c_ulong;
pub const GPid = c_int;
pub const __u_char = u8;
pub const __u_short = c_ushort;
pub const __u_int = c_uint;
pub const __u_long = c_ulong;
pub const __int8_t = i8;
pub const __uint8_t = u8;
pub const __int16_t = c_short;
pub const __uint16_t = c_ushort;
pub const __int32_t = c_int;
pub const __uint32_t = c_uint;
pub const __int64_t = c_long;
pub const __uint64_t = c_ulong;
pub const __int_least8_t = __int8_t;
pub const __uint_least8_t = __uint8_t;
pub const __int_least16_t = __int16_t;
pub const __uint_least16_t = __uint16_t;
pub const __int_least32_t = __int32_t;
pub const __uint_least32_t = __uint32_t;
pub const __int_least64_t = __int64_t;
pub const __uint_least64_t = __uint64_t;
pub const __quad_t = c_long;
pub const __u_quad_t = c_ulong;
pub const __intmax_t = c_long;
pub const __uintmax_t = c_ulong;
pub const __dev_t = c_ulong;
pub const __uid_t = c_uint;
pub const __gid_t = c_uint;
pub const __ino_t = c_ulong;
pub const __ino64_t = c_ulong;
pub const __mode_t = c_uint;
pub const __nlink_t = c_ulong;
pub const __off_t = c_long;
pub const __off64_t = c_long;
pub const __pid_t = c_int;
pub const __fsid_t = extern struct {
    __val: [2]c_int,
};
pub const __clock_t = c_long;
pub const __rlim_t = c_ulong;
pub const __rlim64_t = c_ulong;
pub const __id_t = c_uint;
pub const __time_t = c_long;
pub const __useconds_t = c_uint;
pub const __suseconds_t = c_long;
pub const __suseconds64_t = c_long;
pub const __daddr_t = c_int;
pub const __key_t = c_int;
pub const __clockid_t = c_int;
pub const __timer_t = ?*anyopaque;
pub const __blksize_t = c_long;
pub const __blkcnt_t = c_long;
pub const __blkcnt64_t = c_long;
pub const __fsblkcnt_t = c_ulong;
pub const __fsblkcnt64_t = c_ulong;
pub const __fsfilcnt_t = c_ulong;
pub const __fsfilcnt64_t = c_ulong;
pub const __fsword_t = c_long;
pub const __ssize_t = c_long;
pub const __syscall_slong_t = c_long;
pub const __syscall_ulong_t = c_ulong;
pub const __loff_t = __off64_t;
pub const __caddr_t = [*c]u8;
pub const __intptr_t = c_long;
pub const __socklen_t = c_uint;
pub const __sig_atomic_t = c_int;
pub const clock_t = __clock_t;
pub const time_t = __time_t;
pub const struct_tm = extern struct {
    tm_sec: c_int,
    tm_min: c_int,
    tm_hour: c_int,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
    tm_wday: c_int,
    tm_yday: c_int,
    tm_isdst: c_int,
    tm_gmtoff: c_long,
    tm_zone: [*c]const u8,
};
pub const struct_timespec = extern struct {
    tv_sec: __time_t,
    tv_nsec: __syscall_slong_t,
};
pub const clockid_t = __clockid_t;
pub const timer_t = __timer_t;
pub const struct_itimerspec = extern struct {
    it_interval: struct_timespec,
    it_value: struct_timespec,
};
pub const union_sigval = extern union {
    sival_int: c_int,
    sival_ptr: ?*anyopaque,
};
pub const __sigval_t = union_sigval;
pub const union_pthread_attr_t = extern union {
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_attr_t = union_pthread_attr_t;
const struct_unnamed_2 = extern struct {
    _function: ?*const fn (__sigval_t) callconv(.C) void,
    _attribute: [*c]pthread_attr_t,
};
const union_unnamed_1 = extern union {
    _pad: [12]c_int,
    _tid: __pid_t,
    _sigev_thread: struct_unnamed_2,
};
pub const struct_sigevent = extern struct {
    sigev_value: __sigval_t,
    sigev_signo: c_int,
    sigev_notify: c_int,
    _sigev_un: union_unnamed_1,
};
pub const pid_t = __pid_t;
pub const struct___locale_data = opaque {};
pub const struct___locale_struct = extern struct {
    __locales: [13]?*struct___locale_data,
    __ctype_b: [*c]const c_ushort,
    __ctype_tolower: [*c]const c_int,
    __ctype_toupper: [*c]const c_int,
    __names: [13][*c]const u8,
};
pub const __locale_t = [*c]struct___locale_struct;
pub const locale_t = __locale_t;
pub extern fn clock() clock_t;
pub extern fn time(__timer: [*c]time_t) time_t;
pub extern fn difftime(__time1: time_t, __time0: time_t) f64;
pub extern fn mktime(__tp: [*c]struct_tm) time_t;
pub extern fn strftime(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm) usize;
pub extern fn strftime_l(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm, __loc: locale_t) usize;
pub extern fn gmtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn localtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn gmtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn localtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn asctime(__tp: [*c]const struct_tm) [*c]u8;
pub extern fn ctime(__timer: [*c]const time_t) [*c]u8;
pub extern fn asctime_r(noalias __tp: [*c]const struct_tm, noalias __buf: [*c]u8) [*c]u8;
pub extern fn ctime_r(noalias __timer: [*c]const time_t, noalias __buf: [*c]u8) [*c]u8;
pub extern var __tzname: [2][*c]u8;
pub extern var __daylight: c_int;
pub extern var __timezone: c_long;
pub extern var tzname: [2][*c]u8;
pub extern fn tzset() void;
pub extern var daylight: c_int;
pub extern var timezone: c_long;
pub extern fn timegm(__tp: [*c]struct_tm) time_t;
pub extern fn timelocal(__tp: [*c]struct_tm) time_t;
pub extern fn dysize(__year: c_int) c_int;
pub extern fn nanosleep(__requested_time: [*c]const struct_timespec, __remaining: [*c]struct_timespec) c_int;
pub extern fn clock_getres(__clock_id: clockid_t, __res: [*c]struct_timespec) c_int;
pub extern fn clock_gettime(__clock_id: clockid_t, __tp: [*c]struct_timespec) c_int;
pub extern fn clock_settime(__clock_id: clockid_t, __tp: [*c]const struct_timespec) c_int;
pub extern fn clock_nanosleep(__clock_id: clockid_t, __flags: c_int, __req: [*c]const struct_timespec, __rem: [*c]struct_timespec) c_int;
pub extern fn clock_getcpuclockid(__pid: pid_t, __clock_id: [*c]clockid_t) c_int;
pub extern fn timer_create(__clock_id: clockid_t, noalias __evp: [*c]struct_sigevent, noalias __timerid: [*c]timer_t) c_int;
pub extern fn timer_delete(__timerid: timer_t) c_int;
pub extern fn timer_settime(__timerid: timer_t, __flags: c_int, noalias __value: [*c]const struct_itimerspec, noalias __ovalue: [*c]struct_itimerspec) c_int;
pub extern fn timer_gettime(__timerid: timer_t, __value: [*c]struct_itimerspec) c_int;
pub extern fn timer_getoverrun(__timerid: timer_t) c_int;
pub extern fn timespec_get(__ts: [*c]struct_timespec, __base: c_int) c_int;
pub const gchar = u8;
pub const gshort = c_short;
pub const glong = c_long;
pub const gint = c_int;
pub const gboolean = gint;
pub const guchar = u8;
pub const gushort = c_ushort;
pub const gulong = c_ulong;
pub const guint = c_uint;
pub const gfloat = f32;
pub const gdouble = f64;
pub const gpointer = ?*anyopaque;
pub const gconstpointer = ?*const anyopaque;
pub const GCompareFunc = ?*const fn (gconstpointer, gconstpointer) callconv(.C) gint;
pub const GCompareDataFunc = ?*const fn (gconstpointer, gconstpointer, gpointer) callconv(.C) gint;
pub const GEqualFunc = ?*const fn (gconstpointer, gconstpointer) callconv(.C) gboolean;
pub const GEqualFuncFull = ?*const fn (gconstpointer, gconstpointer, gpointer) callconv(.C) gboolean;
pub const GDestroyNotify = ?*const fn (gpointer) callconv(.C) void;
pub const GFunc = ?*const fn (gpointer, gpointer) callconv(.C) void;
pub const GHashFunc = ?*const fn (gconstpointer) callconv(.C) guint;
pub const GHFunc = ?*const fn (gpointer, gpointer, gpointer) callconv(.C) void;
pub const GCopyFunc = ?*const fn (gconstpointer, gpointer) callconv(.C) gpointer;
pub const GFreeFunc = ?*const fn (gpointer) callconv(.C) void;
pub const GTranslateFunc = ?*const fn ([*c]const gchar, gpointer) callconv(.C) [*c]const gchar; // /usr/include/glib-2.0/glib/gtypes.h:548:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_3 = opaque {};
pub const union__GDoubleIEEE754 = extern union {
    v_double: gdouble,
    mpn: struct_unnamed_3,
};
pub const GDoubleIEEE754 = union__GDoubleIEEE754; // /usr/include/glib-2.0/glib/gtypes.h:539:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_4 = opaque {};
pub const union__GFloatIEEE754 = extern union {
    v_float: gfloat,
    mpn: struct_unnamed_4,
};
pub const GFloatIEEE754 = union__GFloatIEEE754;
pub const struct__GTimeVal = extern struct {
    tv_sec: glong,
    tv_usec: glong,
};
pub const GTimeVal = struct__GTimeVal;
pub const grefcount = gint;
pub const gatomicrefcount = gint;
pub extern fn memcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memmove(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memccpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memset(__s: ?*anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn __memcmpeq(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: usize) c_int;
pub extern fn memchr(__s: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn strcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcat(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strxfrm(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strcoll_l(__s1: [*c]const u8, __s2: [*c]const u8, __l: locale_t) c_int;
pub extern fn strxfrm_l(__dest: [*c]u8, __src: [*c]const u8, __n: usize, __l: locale_t) usize;
pub extern fn strdup(__s: [*c]const u8) [*c]u8;
pub extern fn strndup(__string: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strrchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strchrnul(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strcspn(__s: [*c]const u8, __reject: [*c]const u8) c_ulong;
pub extern fn strspn(__s: [*c]const u8, __accept: [*c]const u8) c_ulong;
pub extern fn strpbrk(__s: [*c]const u8, __accept: [*c]const u8) [*c]u8;
pub extern fn strstr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn strtok(__s: [*c]u8, __delim: [*c]const u8) [*c]u8;
pub extern fn __strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strcasestr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn memmem(__haystack: ?*const anyopaque, __haystacklen: usize, __needle: ?*const anyopaque, __needlelen: usize) ?*anyopaque;
pub extern fn __mempcpy(noalias __dest: ?*anyopaque, noalias __src: ?*const anyopaque, __n: usize) ?*anyopaque;
pub extern fn mempcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn strlen(__s: [*c]const u8) c_ulong;
pub extern fn strnlen(__string: [*c]const u8, __maxlen: usize) usize;
pub extern fn strerror(__errnum: c_int) [*c]u8;
pub extern fn strerror_r(__errnum: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn strerror_l(__errnum: c_int, __l: locale_t) [*c]u8;
pub extern fn bcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn bcopy(__src: ?*const anyopaque, __dest: ?*anyopaque, __n: usize) void;
pub extern fn bzero(__s: ?*anyopaque, __n: c_ulong) void;
pub extern fn index(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn rindex(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn ffs(__i: c_int) c_int;
pub extern fn ffsl(__l: c_long) c_int;
pub extern fn ffsll(__ll: c_longlong) c_int;
pub extern fn strcasecmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncasecmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __loc: locale_t) c_int;
pub extern fn strncasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __n: usize, __loc: locale_t) c_int;
pub extern fn explicit_bzero(__s: ?*anyopaque, __n: usize) void;
pub extern fn strsep(noalias __stringp: [*c][*c]u8, noalias __delim: [*c]const u8) [*c]u8;
pub extern fn strsignal(__sig: c_int) [*c]u8;
pub extern fn __stpcpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8) [*c]u8;
pub extern fn stpcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn __stpncpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8, __n: usize) [*c]u8;
pub extern fn stpncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strlcpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strlcat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub const struct__GBytes = opaque {};
pub const GBytes = struct__GBytes;
pub const struct__GArray = extern struct {
    data: [*c]gchar,
    len: guint,
};
pub const GArray = struct__GArray;
pub const struct__GByteArray = extern struct {
    data: [*c]guint8,
    len: guint,
};
pub const GByteArray = struct__GByteArray;
pub const struct__GPtrArray = extern struct {
    pdata: [*c]gpointer,
    len: guint,
};
pub const GPtrArray = struct__GPtrArray;
pub extern fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint) [*c]GArray;
pub extern fn g_array_new_take(data: gpointer, len: gsize, clear: gboolean, element_size: gsize) [*c]GArray;
pub extern fn g_array_new_take_zero_terminated(data: gpointer, clear: gboolean, element_size: gsize) [*c]GArray;
pub extern fn g_array_steal(array: [*c]GArray, len: [*c]gsize) gpointer;
pub extern fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint, reserved_size: guint) [*c]GArray;
pub extern fn g_array_copy(array: [*c]GArray) [*c]GArray;
pub extern fn g_array_free(array: [*c]GArray, free_segment: gboolean) [*c]gchar;
pub extern fn g_array_ref(array: [*c]GArray) [*c]GArray;
pub extern fn g_array_unref(array: [*c]GArray) void;
pub extern fn g_array_get_element_size(array: [*c]GArray) guint;
pub extern fn g_array_append_vals(array: [*c]GArray, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_prepend_vals(array: [*c]GArray, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_insert_vals(array: [*c]GArray, index_: guint, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_set_size(array: [*c]GArray, length: guint) [*c]GArray;
pub extern fn g_array_remove_index(array: [*c]GArray, index_: guint) [*c]GArray;
pub extern fn g_array_remove_index_fast(array: [*c]GArray, index_: guint) [*c]GArray;
pub extern fn g_array_remove_range(array: [*c]GArray, index_: guint, length: guint) [*c]GArray;
pub extern fn g_array_sort(array: [*c]GArray, compare_func: GCompareFunc) void;
pub extern fn g_array_sort_with_data(array: [*c]GArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_array_binary_search(array: [*c]GArray, target: gconstpointer, compare_func: GCompareFunc, out_match_index: [*c]guint) gboolean;
pub extern fn g_array_set_clear_func(array: [*c]GArray, clear_func: GDestroyNotify) void;
pub extern fn g_ptr_array_new() [*c]GPtrArray;
pub extern fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_new_take(data: [*c]gpointer, len: gsize, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_new_from_array(data: [*c]gpointer, len: gsize, copy_func: GCopyFunc, copy_func_user_data: gpointer, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_steal(array: [*c]GPtrArray, len: [*c]gsize) [*c]gpointer;
pub extern fn g_ptr_array_copy(array: [*c]GPtrArray, func: GCopyFunc, user_data: gpointer) [*c]GPtrArray;
pub extern fn g_ptr_array_sized_new(reserved_size: guint) [*c]GPtrArray;
pub extern fn g_ptr_array_new_full(reserved_size: guint, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_new_null_terminated(reserved_size: guint, element_free_func: GDestroyNotify, null_terminated: gboolean) [*c]GPtrArray;
pub extern fn g_ptr_array_new_take_null_terminated(data: [*c]gpointer, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_new_from_null_terminated_array(data: [*c]gpointer, copy_func: GCopyFunc, copy_func_user_data: gpointer, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_free(array: [*c]GPtrArray, free_seg: gboolean) [*c]gpointer;
pub extern fn g_ptr_array_ref(array: [*c]GPtrArray) [*c]GPtrArray;
pub extern fn g_ptr_array_unref(array: [*c]GPtrArray) void;
pub extern fn g_ptr_array_set_free_func(array: [*c]GPtrArray, element_free_func: GDestroyNotify) void;
pub extern fn g_ptr_array_set_size(array: [*c]GPtrArray, length: gint) void;
pub extern fn g_ptr_array_remove_index(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_remove_index_fast(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_steal_index(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_steal_index_fast(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_remove(array: [*c]GPtrArray, data: gpointer) gboolean;
pub extern fn g_ptr_array_remove_fast(array: [*c]GPtrArray, data: gpointer) gboolean;
pub extern fn g_ptr_array_remove_range(array: [*c]GPtrArray, index_: guint, length: guint) [*c]GPtrArray;
pub extern fn g_ptr_array_add(array: [*c]GPtrArray, data: gpointer) void;
pub extern fn g_ptr_array_extend(array_to_extend: [*c]GPtrArray, array: [*c]GPtrArray, func: GCopyFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_extend_and_steal(array_to_extend: [*c]GPtrArray, array: [*c]GPtrArray) void;
pub extern fn g_ptr_array_insert(array: [*c]GPtrArray, index_: gint, data: gpointer) void;
pub extern fn g_ptr_array_sort(array: [*c]GPtrArray, compare_func: GCompareFunc) void;
pub extern fn g_ptr_array_sort_with_data(array: [*c]GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_sort_values(array: [*c]GPtrArray, compare_func: GCompareFunc) void;
pub extern fn g_ptr_array_sort_values_with_data(array: [*c]GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_foreach(array: [*c]GPtrArray, func: GFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_find(haystack: [*c]GPtrArray, needle: gconstpointer, index_: [*c]guint) gboolean;
pub extern fn g_ptr_array_find_with_equal_func(haystack: [*c]GPtrArray, needle: gconstpointer, equal_func: GEqualFunc, index_: [*c]guint) gboolean;
pub extern fn g_ptr_array_is_null_terminated(array: [*c]GPtrArray) gboolean;
pub extern fn g_byte_array_new() [*c]GByteArray;
pub extern fn g_byte_array_new_take(data: [*c]guint8, len: gsize) [*c]GByteArray;
pub extern fn g_byte_array_steal(array: [*c]GByteArray, len: [*c]gsize) [*c]guint8;
pub extern fn g_byte_array_sized_new(reserved_size: guint) [*c]GByteArray;
pub extern fn g_byte_array_free(array: [*c]GByteArray, free_segment: gboolean) [*c]guint8;
pub extern fn g_byte_array_free_to_bytes(array: [*c]GByteArray) ?*GBytes;
pub extern fn g_byte_array_ref(array: [*c]GByteArray) [*c]GByteArray;
pub extern fn g_byte_array_unref(array: [*c]GByteArray) void;
pub extern fn g_byte_array_append(array: [*c]GByteArray, data: [*c]const guint8, len: guint) [*c]GByteArray;
pub extern fn g_byte_array_prepend(array: [*c]GByteArray, data: [*c]const guint8, len: guint) [*c]GByteArray;
pub extern fn g_byte_array_set_size(array: [*c]GByteArray, length: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_index(array: [*c]GByteArray, index_: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_index_fast(array: [*c]GByteArray, index_: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_range(array: [*c]GByteArray, index_: guint, length: guint) [*c]GByteArray;
pub extern fn g_byte_array_sort(array: [*c]GByteArray, compare_func: GCompareFunc) void;
pub extern fn g_byte_array_sort_with_data(array: [*c]GByteArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_atomic_int_get(atomic: [*c]const volatile gint) gint;
pub extern fn g_atomic_int_set(atomic: [*c]volatile gint, newval: gint) void;
pub extern fn g_atomic_int_inc(atomic: [*c]volatile gint) void;
pub extern fn g_atomic_int_dec_and_test(atomic: [*c]volatile gint) gboolean;
pub extern fn g_atomic_int_compare_and_exchange(atomic: [*c]volatile gint, oldval: gint, newval: gint) gboolean;
pub extern fn g_atomic_int_compare_and_exchange_full(atomic: [*c]gint, oldval: gint, newval: gint, preval: [*c]gint) gboolean;
pub extern fn g_atomic_int_exchange(atomic: [*c]gint, newval: gint) gint;
pub extern fn g_atomic_int_add(atomic: [*c]volatile gint, val: gint) gint;
pub extern fn g_atomic_int_and(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_int_or(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_int_xor(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_pointer_get(atomic: ?*const volatile anyopaque) gpointer;
pub extern fn g_atomic_pointer_set(atomic: ?*volatile anyopaque, newval: gpointer) void;
pub extern fn g_atomic_pointer_compare_and_exchange(atomic: ?*volatile anyopaque, oldval: gpointer, newval: gpointer) gboolean;
pub extern fn g_atomic_pointer_compare_and_exchange_full(atomic: ?*anyopaque, oldval: gpointer, newval: gpointer, preval: ?*anyopaque) gboolean;
pub extern fn g_atomic_pointer_exchange(atomic: ?*anyopaque, newval: gpointer) gpointer;
pub extern fn g_atomic_pointer_add(atomic: ?*volatile anyopaque, val: gssize) gssize;
pub extern fn g_atomic_pointer_and(atomic: ?*volatile anyopaque, val: gsize) gsize;
pub extern fn g_atomic_pointer_or(atomic: ?*volatile anyopaque, val: gsize) gsize;
pub extern fn g_atomic_pointer_xor(atomic: ?*volatile anyopaque, val: gsize) gsize;
pub extern fn g_atomic_int_exchange_and_add(atomic: [*c]volatile gint, val: gint) gint;
pub const struct___va_list_tag = extern struct {
    gp_offset: c_uint,
    fp_offset: c_uint,
    overflow_arg_area: ?*anyopaque,
    reg_save_area: ?*anyopaque,
};
pub const __builtin_va_list = [1]struct___va_list_tag;
pub const __gnuc_va_list = __builtin_va_list;
pub const va_list = __builtin_va_list;
pub const GQuark = guint32;
pub extern fn g_quark_try_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_from_static_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_from_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_to_string(quark: GQuark) [*c]const gchar;
pub extern fn g_intern_string(string: [*c]const gchar) [*c]const gchar;
pub extern fn g_intern_static_string(string: [*c]const gchar) [*c]const gchar;
pub const struct__GError = extern struct {
    domain: GQuark,
    code: gint,
    message: [*c]gchar,
};
pub const GError = struct__GError;
pub const GErrorInitFunc = ?*const fn ([*c]GError) callconv(.C) void;
pub const GErrorCopyFunc = ?*const fn ([*c]const GError, [*c]GError) callconv(.C) void;
pub const GErrorClearFunc = ?*const fn ([*c]GError) callconv(.C) void;
pub extern fn g_error_domain_register_static(error_type_name: [*c]const u8, error_type_private_size: gsize, error_type_init: GErrorInitFunc, error_type_copy: GErrorCopyFunc, error_type_clear: GErrorClearFunc) GQuark;
pub extern fn g_error_domain_register(error_type_name: [*c]const u8, error_type_private_size: gsize, error_type_init: GErrorInitFunc, error_type_copy: GErrorCopyFunc, error_type_clear: GErrorClearFunc) GQuark;
pub extern fn g_error_new(domain: GQuark, code: gint, format: [*c]const gchar, ...) [*c]GError;
pub extern fn g_error_new_literal(domain: GQuark, code: gint, message: [*c]const gchar) [*c]GError;
pub extern fn g_error_new_valist(domain: GQuark, code: gint, format: [*c]const gchar, args: [*c]struct___va_list_tag) [*c]GError;
pub extern fn g_error_free(@"error": [*c]GError) void;
pub extern fn g_error_copy(@"error": [*c]const GError) [*c]GError;
pub extern fn g_error_matches(@"error": [*c]const GError, domain: GQuark, code: gint) gboolean;
pub extern fn g_set_error(err: [*c][*c]GError, domain: GQuark, code: gint, format: [*c]const gchar, ...) void;
pub extern fn g_set_error_literal(err: [*c][*c]GError, domain: GQuark, code: gint, message: [*c]const gchar) void;
pub extern fn g_propagate_error(dest: [*c][*c]GError, src: [*c]GError) void;
pub extern fn g_clear_error(err: [*c][*c]GError) void;
pub extern fn g_prefix_error(err: [*c][*c]GError, format: [*c]const gchar, ...) void;
pub extern fn g_prefix_error_literal(err: [*c][*c]GError, prefix: [*c]const gchar) void;
pub extern fn g_propagate_prefixed_error(dest: [*c][*c]GError, src: [*c]GError, format: [*c]const gchar, ...) void;
pub extern fn g_get_user_name() [*c]const gchar;
pub extern fn g_get_real_name() [*c]const gchar;
pub extern fn g_get_home_dir() [*c]const gchar;
pub extern fn g_get_tmp_dir() [*c]const gchar;
pub extern fn g_get_host_name() [*c]const gchar;
pub extern fn g_get_prgname() [*c]const gchar;
pub extern fn g_set_prgname(prgname: [*c]const gchar) void;
pub extern fn g_get_application_name() [*c]const gchar;
pub extern fn g_set_application_name(application_name: [*c]const gchar) void;
pub extern fn g_get_os_info(key_name: [*c]const gchar) [*c]gchar;
pub extern fn g_reload_user_special_dirs_cache() void;
pub extern fn g_get_user_data_dir() [*c]const gchar;
pub extern fn g_get_user_config_dir() [*c]const gchar;
pub extern fn g_get_user_cache_dir() [*c]const gchar;
pub extern fn g_get_user_state_dir() [*c]const gchar;
pub extern fn g_get_system_data_dirs() [*c]const [*c]const gchar;
pub extern fn g_get_system_config_dirs() [*c]const [*c]const gchar;
pub extern fn g_get_user_runtime_dir() [*c]const gchar;
pub const G_USER_DIRECTORY_DESKTOP: c_int = 0;
pub const G_USER_DIRECTORY_DOCUMENTS: c_int = 1;
pub const G_USER_DIRECTORY_DOWNLOAD: c_int = 2;
pub const G_USER_DIRECTORY_MUSIC: c_int = 3;
pub const G_USER_DIRECTORY_PICTURES: c_int = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE: c_int = 5;
pub const G_USER_DIRECTORY_TEMPLATES: c_int = 6;
pub const G_USER_DIRECTORY_VIDEOS: c_int = 7;
pub const G_USER_N_DIRECTORIES: c_int = 8;
pub const GUserDirectory = c_uint;
pub extern fn g_get_user_special_dir(directory: GUserDirectory) [*c]const gchar;
pub const struct__GDebugKey = extern struct {
    key: [*c]const gchar,
    value: guint,
};
pub const GDebugKey = struct__GDebugKey;
pub extern fn g_parse_debug_string(string: [*c]const gchar, keys: [*c]const GDebugKey, nkeys: guint) guint;
pub extern fn g_snprintf(string: [*c]gchar, n: gulong, format: [*c]const gchar, ...) gint;
pub extern fn g_vsnprintf(string: [*c]gchar, n: gulong, format: [*c]const gchar, args: [*c]struct___va_list_tag) gint;
pub extern fn g_nullify_pointer(nullify_location: [*c]gpointer) void;
pub const G_FORMAT_SIZE_DEFAULT: c_int = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT: c_int = 1;
pub const G_FORMAT_SIZE_IEC_UNITS: c_int = 2;
pub const G_FORMAT_SIZE_BITS: c_int = 4;
pub const G_FORMAT_SIZE_ONLY_VALUE: c_int = 8;
pub const G_FORMAT_SIZE_ONLY_UNIT: c_int = 16;
pub const GFormatSizeFlags = c_uint;
pub extern fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) [*c]gchar;
pub extern fn g_format_size(size: guint64) [*c]gchar;
pub extern fn g_format_size_for_display(size: goffset) [*c]gchar;
pub const GVoidFunc = ?*const fn () callconv(.C) void;
pub extern fn g_atexit(func: GVoidFunc) void;
pub extern fn g_find_program_in_path(program: [*c]const gchar) [*c]gchar;
pub extern fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) gint;
pub extern fn g_bit_nth_msf(mask: gulong, nth_bit: gint) gint;
pub extern fn g_bit_storage(number: gulong) guint;
pub fn g_bit_nth_lsf_impl(arg_mask: gulong, arg_nth_bit: gint) callconv(.C) gint {
    var mask = arg_mask;
    var nth_bit = arg_nth_bit;
    if (nth_bit < -@as(c_int, 1)) {
        nth_bit = -@as(c_int, 1);
    }
    while (nth_bit < ((@as(c_int, 8) * @as(c_int, 8)) - @as(c_int, 1))) {
        nth_bit += 1;
        if ((mask & (@as(c_ulong, 1) << @intCast(nth_bit))) != 0) return nth_bit;
    }
    return -@as(c_int, 1);
}
pub fn g_bit_nth_msf_impl(arg_mask: gulong, arg_nth_bit: gint) callconv(.C) gint {
    var mask = arg_mask;
    var nth_bit = arg_nth_bit;
    if ((nth_bit < @as(c_int, 0)) or (nth_bit > (@as(c_int, 8) * @as(c_int, 8)))) {
        nth_bit = @as(c_int, 8) * @as(c_int, 8);
    }
    while (nth_bit > @as(c_int, 0)) {
        nth_bit -= 1;
        if ((mask & (@as(c_ulong, 1) << @intCast(nth_bit))) != 0) return nth_bit;
    }
    return -@as(c_int, 1);
}
pub fn g_bit_storage_impl(arg_number: gulong) callconv(.C) guint {
    var number = arg_number;
    var n_bits: guint = 0;
    while (true) {
        n_bits +%= 1;
        number >>= @intCast(@as(c_int, 1));
        if (!(number != 0)) break;
    }
    return n_bits;
}
pub const _Float32 = f32;
pub const _Float64 = f64;
pub const _Float32x = f64;
pub const _Float64x = c_longdouble;
pub const div_t = extern struct {
    quot: c_int,
    rem: c_int,
};
pub const ldiv_t = extern struct {
    quot: c_long,
    rem: c_long,
};
pub const lldiv_t = extern struct {
    quot: c_longlong,
    rem: c_longlong,
};
pub extern fn __ctype_get_mb_cur_max() usize;
pub extern fn atof(__nptr: [*c]const u8) f64;
pub extern fn atoi(__nptr: [*c]const u8) c_int;
pub extern fn atol(__nptr: [*c]const u8) c_long;
pub extern fn atoll(__nptr: [*c]const u8) c_longlong;
pub extern fn strtod(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f64;
pub extern fn strtof(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f32;
pub extern fn strtold(__nptr: [*c]const u8, __endptr: [*c][*c]u8) c_longdouble;
pub extern fn strtol(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtoul(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strtoll(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoull(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn l64a(__n: c_long) [*c]u8;
pub extern fn a64l(__s: [*c]const u8) c_long;
pub const u_char = __u_char;
pub const u_short = __u_short;
pub const u_int = __u_int;
pub const u_long = __u_long;
pub const quad_t = __quad_t;
pub const u_quad_t = __u_quad_t;
pub const fsid_t = __fsid_t;
pub const loff_t = __loff_t;
pub const ino_t = __ino_t;
pub const dev_t = __dev_t;
pub const gid_t = __gid_t;
pub const mode_t = __mode_t;
pub const nlink_t = __nlink_t;
pub const uid_t = __uid_t;
pub const off_t = __off_t;
pub const id_t = __id_t;
pub const daddr_t = __daddr_t;
pub const caddr_t = __caddr_t;
pub const key_t = __key_t;
pub const ulong = c_ulong;
pub const ushort = c_ushort;
pub const uint = c_uint;
pub const u_int8_t = __uint8_t;
pub const u_int16_t = __uint16_t;
pub const u_int32_t = __uint32_t;
pub const u_int64_t = __uint64_t;
pub const register_t = c_long;
pub fn __bswap_16(arg___bsx: __uint16_t) callconv(.C) __uint16_t {
    var __bsx = arg___bsx;
    return @as(__uint16_t, @bitCast(@as(c_short, @truncate(((@as(c_int, @bitCast(@as(c_uint, __bsx))) >> @intCast(8)) & @as(c_int, 255)) | ((@as(c_int, @bitCast(@as(c_uint, __bsx))) & @as(c_int, 255)) << @intCast(8))))));
}
pub fn __bswap_32(arg___bsx: __uint32_t) callconv(.C) __uint32_t {
    var __bsx = arg___bsx;
    return ((((__bsx & @as(c_uint, 4278190080)) >> @intCast(24)) | ((__bsx & @as(c_uint, 16711680)) >> @intCast(8))) | ((__bsx & @as(c_uint, 65280)) << @intCast(8))) | ((__bsx & @as(c_uint, 255)) << @intCast(24));
}
pub fn __bswap_64(arg___bsx: __uint64_t) callconv(.C) __uint64_t {
    var __bsx = arg___bsx;
    return @as(__uint64_t, @bitCast(@as(c_ulong, @truncate(((((((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 18374686479671623680)) >> @intCast(56)) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 71776119061217280)) >> @intCast(40))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 280375465082880)) >> @intCast(24))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 1095216660480)) >> @intCast(8))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 4278190080)) << @intCast(8))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 16711680)) << @intCast(24))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 65280)) << @intCast(40))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 255)) << @intCast(56))))));
}
pub fn __uint16_identity(arg___x: __uint16_t) callconv(.C) __uint16_t {
    var __x = arg___x;
    return __x;
}
pub fn __uint32_identity(arg___x: __uint32_t) callconv(.C) __uint32_t {
    var __x = arg___x;
    return __x;
}
pub fn __uint64_identity(arg___x: __uint64_t) callconv(.C) __uint64_t {
    var __x = arg___x;
    return __x;
}
pub const __sigset_t = extern struct {
    __val: [16]c_ulong,
};
pub const sigset_t = __sigset_t;
pub const struct_timeval = extern struct {
    tv_sec: __time_t,
    tv_usec: __suseconds_t,
};
pub const suseconds_t = __suseconds_t;
pub const __fd_mask = c_long;
pub const fd_set = extern struct {
    __fds_bits: [16]__fd_mask,
};
pub const fd_mask = __fd_mask;
pub extern fn select(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]struct_timeval) c_int;
pub extern fn pselect(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]const struct_timespec, noalias __sigmask: [*c]const __sigset_t) c_int;
pub const blksize_t = __blksize_t;
pub const blkcnt_t = __blkcnt_t;
pub const fsblkcnt_t = __fsblkcnt_t;
pub const fsfilcnt_t = __fsfilcnt_t;
const struct_unnamed_5 = extern struct {
    __low: c_uint,
    __high: c_uint,
};
pub const __atomic_wide_counter = extern union {
    __value64: c_ulonglong,
    __value32: struct_unnamed_5,
};
pub const struct___pthread_internal_list = extern struct {
    __prev: [*c]struct___pthread_internal_list,
    __next: [*c]struct___pthread_internal_list,
};
pub const __pthread_list_t = struct___pthread_internal_list;
pub const struct___pthread_internal_slist = extern struct {
    __next: [*c]struct___pthread_internal_slist,
};
pub const __pthread_slist_t = struct___pthread_internal_slist;
pub const struct___pthread_mutex_s = extern struct {
    __lock: c_int,
    __count: c_uint,
    __owner: c_int,
    __nusers: c_uint,
    __kind: c_int,
    __spins: c_short,
    __elision: c_short,
    __list: __pthread_list_t,
};
pub const struct___pthread_rwlock_arch_t = extern struct {
    __readers: c_uint,
    __writers: c_uint,
    __wrphase_futex: c_uint,
    __writers_futex: c_uint,
    __pad3: c_uint,
    __pad4: c_uint,
    __cur_writer: c_int,
    __shared: c_int,
    __rwelision: i8,
    __pad1: [7]u8,
    __pad2: c_ulong,
    __flags: c_uint,
};
pub const struct___pthread_cond_s = extern struct {
    __wseq: __atomic_wide_counter,
    __g1_start: __atomic_wide_counter,
    __g_refs: [2]c_uint,
    __g_size: [2]c_uint,
    __g1_orig_size: c_uint,
    __wrefs: c_uint,
    __g_signals: [2]c_uint,
};
pub const __tss_t = c_uint;
pub const __thrd_t = c_ulong;
pub const __once_flag = extern struct {
    __data: c_int,
};
pub const pthread_t = c_ulong;
pub const pthread_mutexattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_condattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_key_t = c_uint;
pub const pthread_once_t = c_int;
pub const pthread_mutex_t = extern union {
    __data: struct___pthread_mutex_s,
    __size: [40]u8,
    __align: c_long,
};
pub const pthread_cond_t = extern union {
    __data: struct___pthread_cond_s,
    __size: [48]u8,
    __align: c_longlong,
};
pub const pthread_rwlock_t = extern union {
    __data: struct___pthread_rwlock_arch_t,
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_rwlockattr_t = extern union {
    __size: [8]u8,
    __align: c_long,
};
pub const pthread_spinlock_t = c_int;
pub const pthread_barrier_t = extern union {
    __size: [32]u8,
    __align: c_long,
};
pub const pthread_barrierattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub extern fn random() c_long;
pub extern fn srandom(__seed: c_uint) void;
pub extern fn initstate(__seed: c_uint, __statebuf: [*c]u8, __statelen: usize) [*c]u8;
pub extern fn setstate(__statebuf: [*c]u8) [*c]u8;
pub const struct_random_data = extern struct {
    fptr: [*c]i32,
    rptr: [*c]i32,
    state: [*c]i32,
    rand_type: c_int,
    rand_deg: c_int,
    rand_sep: c_int,
    end_ptr: [*c]i32,
};
pub extern fn random_r(noalias __buf: [*c]struct_random_data, noalias __result: [*c]i32) c_int;
pub extern fn srandom_r(__seed: c_uint, __buf: [*c]struct_random_data) c_int;
pub extern fn initstate_r(__seed: c_uint, noalias __statebuf: [*c]u8, __statelen: usize, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn setstate_r(noalias __statebuf: [*c]u8, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn rand() c_int;
pub extern fn srand(__seed: c_uint) void;
pub extern fn rand_r(__seed: [*c]c_uint) c_int;
pub extern fn drand48() f64;
pub extern fn erand48(__xsubi: [*c]c_ushort) f64;
pub extern fn lrand48() c_long;
pub extern fn nrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn mrand48() c_long;
pub extern fn jrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn srand48(__seedval: c_long) void;
pub extern fn seed48(__seed16v: [*c]c_ushort) [*c]c_ushort;
pub extern fn lcong48(__param: [*c]c_ushort) void;
pub const struct_drand48_data = extern struct {
    __x: [3]c_ushort,
    __old_x: [3]c_ushort,
    __c: c_ushort,
    __init: c_ushort,
    __a: c_ulonglong,
};
pub extern fn drand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn erand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn lrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn nrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn mrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn jrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn srand48_r(__seedval: c_long, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn seed48_r(__seed16v: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn lcong48_r(__param: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn arc4random() __uint32_t;
pub extern fn arc4random_buf(__buf: ?*anyopaque, __size: usize) void;
pub extern fn arc4random_uniform(__upper_bound: __uint32_t) __uint32_t;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__nmemb: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn free(__ptr: ?*anyopaque) void;
pub extern fn reallocarray(__ptr: ?*anyopaque, __nmemb: usize, __size: usize) ?*anyopaque;
pub extern fn alloca(__size: c_ulong) ?*anyopaque;
pub extern fn valloc(__size: usize) ?*anyopaque;
pub extern fn posix_memalign(__memptr: [*c]?*anyopaque, __alignment: usize, __size: usize) c_int;
pub extern fn aligned_alloc(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn abort() noreturn;
pub extern fn atexit(__func: ?*const fn () callconv(.C) void) c_int;
pub extern fn at_quick_exit(__func: ?*const fn () callconv(.C) void) c_int;
pub extern fn on_exit(__func: ?*const fn (c_int, ?*anyopaque) callconv(.C) void, __arg: ?*anyopaque) c_int;
pub extern fn exit(__status: c_int) noreturn;
pub extern fn quick_exit(__status: c_int) noreturn;
pub extern fn _Exit(__status: c_int) noreturn;
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
pub extern fn putenv(__string: [*c]u8) c_int;
pub extern fn setenv(__name: [*c]const u8, __value: [*c]const u8, __replace: c_int) c_int;
pub extern fn unsetenv(__name: [*c]const u8) c_int;
pub extern fn clearenv() c_int;
pub extern fn mktemp(__template: [*c]u8) [*c]u8;
pub extern fn mkstemp(__template: [*c]u8) c_int;
pub extern fn mkstemps(__template: [*c]u8, __suffixlen: c_int) c_int;
pub extern fn mkdtemp(__template: [*c]u8) [*c]u8;
pub extern fn system(__command: [*c]const u8) c_int;
pub extern fn realpath(noalias __name: [*c]const u8, noalias __resolved: [*c]u8) [*c]u8;
pub const __compar_fn_t = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int;
pub extern fn bsearch(__key: ?*const anyopaque, __base: ?*const anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) ?*anyopaque;
pub extern fn qsort(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) void;
pub extern fn abs(__x: c_int) c_int;
pub extern fn labs(__x: c_long) c_long;
pub extern fn llabs(__x: c_longlong) c_longlong;
pub extern fn div(__numer: c_int, __denom: c_int) div_t;
pub extern fn ldiv(__numer: c_long, __denom: c_long) ldiv_t;
pub extern fn lldiv(__numer: c_longlong, __denom: c_longlong) lldiv_t;
pub extern fn ecvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn fcvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn gcvt(__value: f64, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn qecvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qfcvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qgcvt(__value: c_longdouble, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn ecvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn fcvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qecvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qfcvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn mblen(__s: [*c]const u8, __n: usize) c_int;
pub extern fn mbtowc(noalias __pwc: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) c_int;
pub extern fn wctomb(__s: [*c]u8, __wchar: wchar_t) c_int;
pub extern fn mbstowcs(noalias __pwcs: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) usize;
pub extern fn wcstombs(noalias __s: [*c]u8, noalias __pwcs: [*c]const wchar_t, __n: usize) usize;
pub extern fn rpmatch(__response: [*c]const u8) c_int;
pub extern fn getsubopt(noalias __optionp: [*c][*c]u8, noalias __tokens: [*c]const [*c]u8, noalias __valuep: [*c][*c]u8) c_int;
pub extern fn getloadavg(__loadavg: [*c]f64, __nelem: c_int) c_int;
pub extern fn g_thread_error_quark() GQuark;
pub const G_THREAD_ERROR_AGAIN: c_int = 0;
pub const GThreadError = c_uint;
pub const GThreadFunc = ?*const fn (gpointer) callconv(.C) gpointer;
pub const struct__GThread = extern struct {
    func: GThreadFunc,
    data: gpointer,
    joinable: gboolean,
    priority: GThreadPriority,
};
pub const GThread = struct__GThread;
pub const union__GMutex = extern union {
    p: gpointer,
    i: [2]guint,
};
pub const GMutex = union__GMutex;
pub const struct__GRecMutex = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GRecMutex = struct__GRecMutex;
pub const struct__GRWLock = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GRWLock = struct__GRWLock;
pub const struct__GCond = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GCond = struct__GCond;
pub const struct__GPrivate = extern struct {
    p: gpointer,
    notify: GDestroyNotify,
    future: [2]gpointer,
};
pub const GPrivate = struct__GPrivate;
pub const struct__GOnce = extern struct {
    status: GOnceStatus,
    retval: gpointer,
};
pub const GOnce = struct__GOnce;
pub const G_ONCE_STATUS_NOTCALLED: c_int = 0;
pub const G_ONCE_STATUS_PROGRESS: c_int = 1;
pub const G_ONCE_STATUS_READY: c_int = 2;
pub const GOnceStatus = c_uint;
pub extern fn g_thread_ref(thread: [*c]GThread) [*c]GThread;
pub extern fn g_thread_unref(thread: [*c]GThread) void;
pub extern fn g_thread_new(name: [*c]const gchar, func: GThreadFunc, data: gpointer) [*c]GThread;
pub extern fn g_thread_try_new(name: [*c]const gchar, func: GThreadFunc, data: gpointer, @"error": [*c][*c]GError) [*c]GThread;
pub extern fn g_thread_self() [*c]GThread;
pub extern fn g_thread_exit(retval: gpointer) noreturn;
pub extern fn g_thread_join(thread: [*c]GThread) gpointer;
pub extern fn g_thread_yield() void;
pub extern fn g_mutex_init(mutex: [*c]GMutex) void;
pub extern fn g_mutex_clear(mutex: [*c]GMutex) void;
pub extern fn g_mutex_lock(mutex: [*c]GMutex) void;
pub extern fn g_mutex_trylock(mutex: [*c]GMutex) gboolean;
pub extern fn g_mutex_unlock(mutex: [*c]GMutex) void;
pub extern fn g_rw_lock_init(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_clear(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_writer_lock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_writer_trylock(rw_lock: [*c]GRWLock) gboolean;
pub extern fn g_rw_lock_writer_unlock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_reader_lock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_reader_trylock(rw_lock: [*c]GRWLock) gboolean;
pub extern fn g_rw_lock_reader_unlock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rec_mutex_init(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_clear(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_lock(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_trylock(rec_mutex: [*c]GRecMutex) gboolean;
pub extern fn g_rec_mutex_unlock(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_cond_init(cond: [*c]GCond) void;
pub extern fn g_cond_clear(cond: [*c]GCond) void;
pub extern fn g_cond_wait(cond: [*c]GCond, mutex: [*c]GMutex) void;
pub extern fn g_cond_signal(cond: [*c]GCond) void;
pub extern fn g_cond_broadcast(cond: [*c]GCond) void;
pub extern fn g_cond_wait_until(cond: [*c]GCond, mutex: [*c]GMutex, end_time: gint64) gboolean;
pub extern fn g_private_get(key: [*c]GPrivate) gpointer;
pub extern fn g_private_set(key: [*c]GPrivate, value: gpointer) void;
pub extern fn g_private_replace(key: [*c]GPrivate, value: gpointer) void;
pub extern fn g_once_impl(once: [*c]GOnce, func: GThreadFunc, arg: gpointer) gpointer;
pub extern fn g_once_init_enter(location: ?*volatile anyopaque) gboolean;
pub extern fn g_once_init_leave(location: ?*volatile anyopaque, result: gsize) void;
pub extern fn g_get_num_processors() guint;
pub const GMutexLocker = anyopaque;
pub fn g_mutex_locker_new(arg_mutex: [*c]GMutex) callconv(.C) ?*GMutexLocker {
    var mutex = arg_mutex;
    g_mutex_lock(mutex);
    return @as(?*GMutexLocker, @ptrCast(mutex));
}
pub fn g_mutex_locker_free(arg_locker: ?*GMutexLocker) callconv(.C) void {
    var locker = arg_locker;
    g_mutex_unlock(@as([*c]GMutex, @ptrCast(@alignCast(locker))));
}
pub const GRecMutexLocker = anyopaque;
pub fn g_rec_mutex_locker_new(arg_rec_mutex: [*c]GRecMutex) callconv(.C) ?*GRecMutexLocker {
    var rec_mutex = arg_rec_mutex;
    g_rec_mutex_lock(rec_mutex);
    return @as(?*GRecMutexLocker, @ptrCast(rec_mutex));
}
pub fn g_rec_mutex_locker_free(arg_locker: ?*GRecMutexLocker) callconv(.C) void {
    var locker = arg_locker;
    g_rec_mutex_unlock(@as([*c]GRecMutex, @ptrCast(@alignCast(locker))));
}
pub const GRWLockWriterLocker = anyopaque;
pub fn g_rw_lock_writer_locker_new(arg_rw_lock: [*c]GRWLock) callconv(.C) ?*GRWLockWriterLocker {
    var rw_lock = arg_rw_lock;
    g_rw_lock_writer_lock(rw_lock);
    return @as(?*GRWLockWriterLocker, @ptrCast(rw_lock));
}
pub fn g_rw_lock_writer_locker_free(arg_locker: ?*GRWLockWriterLocker) callconv(.C) void {
    var locker = arg_locker;
    g_rw_lock_writer_unlock(@as([*c]GRWLock, @ptrCast(@alignCast(locker))));
}
pub const GRWLockReaderLocker = anyopaque;
pub fn g_rw_lock_reader_locker_new(arg_rw_lock: [*c]GRWLock) callconv(.C) ?*GRWLockReaderLocker {
    var rw_lock = arg_rw_lock;
    g_rw_lock_reader_lock(rw_lock);
    return @as(?*GRWLockReaderLocker, @ptrCast(rw_lock));
}
pub fn g_rw_lock_reader_locker_free(arg_locker: ?*GRWLockReaderLocker) callconv(.C) void {
    var locker = arg_locker;
    g_rw_lock_reader_unlock(@as([*c]GRWLock, @ptrCast(@alignCast(locker))));
}
pub const struct__GAsyncQueue = opaque {};
pub const GAsyncQueue = struct__GAsyncQueue;
pub extern fn g_async_queue_new() ?*GAsyncQueue;
pub extern fn g_async_queue_new_full(item_free_func: GDestroyNotify) ?*GAsyncQueue;
pub extern fn g_async_queue_lock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_unlock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_ref(queue: ?*GAsyncQueue) ?*GAsyncQueue;
pub extern fn g_async_queue_unref(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_ref_unlocked(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_unref_and_unlock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_push(queue: ?*GAsyncQueue, data: gpointer) void;
pub extern fn g_async_queue_push_unlocked(queue: ?*GAsyncQueue, data: gpointer) void;
pub extern fn g_async_queue_push_sorted(queue: ?*GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_push_sorted_unlocked(queue: ?*GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_pop(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_pop_unlocked(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_try_pop(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_try_pop_unlocked(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_timeout_pop(queue: ?*GAsyncQueue, timeout: guint64) gpointer;
pub extern fn g_async_queue_timeout_pop_unlocked(queue: ?*GAsyncQueue, timeout: guint64) gpointer;
pub extern fn g_async_queue_length(queue: ?*GAsyncQueue) gint;
pub extern fn g_async_queue_length_unlocked(queue: ?*GAsyncQueue) gint;
pub extern fn g_async_queue_sort(queue: ?*GAsyncQueue, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_sort_unlocked(queue: ?*GAsyncQueue, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_remove(queue: ?*GAsyncQueue, item: gpointer) gboolean;
pub extern fn g_async_queue_remove_unlocked(queue: ?*GAsyncQueue, item: gpointer) gboolean;
pub extern fn g_async_queue_push_front(queue: ?*GAsyncQueue, item: gpointer) void;
pub extern fn g_async_queue_push_front_unlocked(queue: ?*GAsyncQueue, item: gpointer) void;
pub extern fn g_async_queue_timed_pop(queue: ?*GAsyncQueue, end_time: [*c]GTimeVal) gpointer;
pub extern fn g_async_queue_timed_pop_unlocked(queue: ?*GAsyncQueue, end_time: [*c]GTimeVal) gpointer;
pub const sig_atomic_t = __sig_atomic_t;
const struct_unnamed_7 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
};
const struct_unnamed_8 = extern struct {
    si_tid: c_int,
    si_overrun: c_int,
    si_sigval: __sigval_t,
};
const struct_unnamed_9 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
    si_sigval: __sigval_t,
};
const struct_unnamed_10 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
    si_status: c_int,
    si_utime: __clock_t,
    si_stime: __clock_t,
};
const struct_unnamed_13 = extern struct {
    _lower: ?*anyopaque,
    _upper: ?*anyopaque,
};
const union_unnamed_12 = extern union {
    _addr_bnd: struct_unnamed_13,
    _pkey: __uint32_t,
};
const struct_unnamed_11 = extern struct {
    si_addr: ?*anyopaque,
    si_addr_lsb: c_short,
    _bounds: union_unnamed_12,
};
const struct_unnamed_14 = extern struct {
    si_band: c_long,
    si_fd: c_int,
};
const struct_unnamed_15 = extern struct {
    _call_addr: ?*anyopaque,
    _syscall: c_int,
    _arch: c_uint,
};
const union_unnamed_6 = extern union {
    _pad: [28]c_int,
    _kill: struct_unnamed_7,
    _timer: struct_unnamed_8,
    _rt: struct_unnamed_9,
    _sigchld: struct_unnamed_10,
    _sigfault: struct_unnamed_11,
    _sigpoll: struct_unnamed_14,
    _sigsys: struct_unnamed_15,
};
pub const siginfo_t = extern struct {
    si_signo: c_int,
    si_errno: c_int,
    si_code: c_int,
    __pad0: c_int,
    _sifields: union_unnamed_6,
};
pub const SI_ASYNCNL: c_int = -60;
pub const SI_DETHREAD: c_int = -7;
pub const SI_TKILL: c_int = -6;
pub const SI_SIGIO: c_int = -5;
pub const SI_ASYNCIO: c_int = -4;
pub const SI_MESGQ: c_int = -3;
pub const SI_TIMER: c_int = -2;
pub const SI_QUEUE: c_int = -1;
pub const SI_USER: c_int = 0;
pub const SI_KERNEL: c_int = 128;
const enum_unnamed_16 = c_int;
pub const ILL_ILLOPC: c_int = 1;
pub const ILL_ILLOPN: c_int = 2;
pub const ILL_ILLADR: c_int = 3;
pub const ILL_ILLTRP: c_int = 4;
pub const ILL_PRVOPC: c_int = 5;
pub const ILL_PRVREG: c_int = 6;
pub const ILL_COPROC: c_int = 7;
pub const ILL_BADSTK: c_int = 8;
pub const ILL_BADIADDR: c_int = 9;
const enum_unnamed_17 = c_uint;
pub const FPE_INTDIV: c_int = 1;
pub const FPE_INTOVF: c_int = 2;
pub const FPE_FLTDIV: c_int = 3;
pub const FPE_FLTOVF: c_int = 4;
pub const FPE_FLTUND: c_int = 5;
pub const FPE_FLTRES: c_int = 6;
pub const FPE_FLTINV: c_int = 7;
pub const FPE_FLTSUB: c_int = 8;
pub const FPE_FLTUNK: c_int = 14;
pub const FPE_CONDTRAP: c_int = 15;
const enum_unnamed_18 = c_uint;
pub const SEGV_MAPERR: c_int = 1;
pub const SEGV_ACCERR: c_int = 2;
pub const SEGV_BNDERR: c_int = 3;
pub const SEGV_PKUERR: c_int = 4;
pub const SEGV_ACCADI: c_int = 5;
pub const SEGV_ADIDERR: c_int = 6;
pub const SEGV_ADIPERR: c_int = 7;
pub const SEGV_MTEAERR: c_int = 8;
pub const SEGV_MTESERR: c_int = 9;
const enum_unnamed_19 = c_uint;
pub const BUS_ADRALN: c_int = 1;
pub const BUS_ADRERR: c_int = 2;
pub const BUS_OBJERR: c_int = 3;
pub const BUS_MCEERR_AR: c_int = 4;
pub const BUS_MCEERR_AO: c_int = 5;
const enum_unnamed_20 = c_uint;
pub const CLD_EXITED: c_int = 1;
pub const CLD_KILLED: c_int = 2;
pub const CLD_DUMPED: c_int = 3;
pub const CLD_TRAPPED: c_int = 4;
pub const CLD_STOPPED: c_int = 5;
pub const CLD_CONTINUED: c_int = 6;
const enum_unnamed_21 = c_uint;
pub const POLL_IN: c_int = 1;
pub const POLL_OUT: c_int = 2;
pub const POLL_MSG: c_int = 3;
pub const POLL_ERR: c_int = 4;
pub const POLL_PRI: c_int = 5;
pub const POLL_HUP: c_int = 6;
const enum_unnamed_22 = c_uint;
pub const sigval_t = __sigval_t;
pub const sigevent_t = struct_sigevent;
pub const SIGEV_SIGNAL: c_int = 0;
pub const SIGEV_NONE: c_int = 1;
pub const SIGEV_THREAD: c_int = 2;
pub const SIGEV_THREAD_ID: c_int = 4;
const enum_unnamed_23 = c_uint;
pub const __sighandler_t = ?*const fn (c_int) callconv(.C) void;
pub extern fn __sysv_signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn kill(__pid: __pid_t, __sig: c_int) c_int;
pub extern fn killpg(__pgrp: __pid_t, __sig: c_int) c_int;
pub extern fn raise(__sig: c_int) c_int;
pub extern fn ssignal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn gsignal(__sig: c_int) c_int;
pub extern fn psignal(__sig: c_int, __s: [*c]const u8) void;
pub extern fn psiginfo(__pinfo: [*c]const siginfo_t, __s: [*c]const u8) void;
pub extern fn sigblock(__mask: c_int) c_int;
pub extern fn sigsetmask(__mask: c_int) c_int;
pub extern fn siggetmask() c_int;
pub const sig_t = __sighandler_t;
pub extern fn sigemptyset(__set: [*c]sigset_t) c_int;
pub extern fn sigfillset(__set: [*c]sigset_t) c_int;
pub extern fn sigaddset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigdelset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigismember(__set: [*c]const sigset_t, __signo: c_int) c_int;
const union_unnamed_24 = extern union {
    sa_handler: __sighandler_t,
    sa_sigaction: ?*const fn (c_int, [*c]siginfo_t, ?*anyopaque) callconv(.C) void,
};
pub const struct_sigaction = extern struct {
    __sigaction_handler: union_unnamed_24,
    sa_mask: __sigset_t,
    sa_flags: c_int,
    sa_restorer: ?*const fn () callconv(.C) void,
};
pub extern fn sigprocmask(__how: c_int, noalias __set: [*c]const sigset_t, noalias __oset: [*c]sigset_t) c_int;
pub extern fn sigsuspend(__set: [*c]const sigset_t) c_int;
pub extern fn sigaction(__sig: c_int, noalias __act: [*c]const struct_sigaction, noalias __oact: [*c]struct_sigaction) c_int;
pub extern fn sigpending(__set: [*c]sigset_t) c_int;
pub extern fn sigwait(noalias __set: [*c]const sigset_t, noalias __sig: [*c]c_int) c_int;
pub extern fn sigwaitinfo(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t) c_int;
pub extern fn sigtimedwait(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t, noalias __timeout: [*c]const struct_timespec) c_int;
pub extern fn sigqueue(__pid: __pid_t, __sig: c_int, __val: union_sigval) c_int;
pub const struct__fpx_sw_bytes = extern struct {
    magic1: __uint32_t,
    extended_size: __uint32_t,
    xstate_bv: __uint64_t,
    xstate_size: __uint32_t,
    __glibc_reserved1: [7]__uint32_t,
};
pub const struct__fpreg = extern struct {
    significand: [4]c_ushort,
    exponent: c_ushort,
};
pub const struct__fpxreg = extern struct {
    significand: [4]c_ushort,
    exponent: c_ushort,
    __glibc_reserved1: [3]c_ushort,
};
pub const struct__xmmreg = extern struct {
    element: [4]__uint32_t,
};
pub const struct__fpstate = extern struct {
    cwd: __uint16_t,
    swd: __uint16_t,
    ftw: __uint16_t,
    fop: __uint16_t,
    rip: __uint64_t,
    rdp: __uint64_t,
    mxcsr: __uint32_t,
    mxcr_mask: __uint32_t,
    _st: [8]struct__fpxreg,
    _xmm: [16]struct__xmmreg,
    __glibc_reserved1: [24]__uint32_t,
};
const union_unnamed_25 = extern union {
    fpstate: [*c]struct__fpstate,
    __fpstate_word: __uint64_t,
};
pub const struct_sigcontext = extern struct {
    r8: __uint64_t,
    r9: __uint64_t,
    r10: __uint64_t,
    r11: __uint64_t,
    r12: __uint64_t,
    r13: __uint64_t,
    r14: __uint64_t,
    r15: __uint64_t,
    rdi: __uint64_t,
    rsi: __uint64_t,
    rbp: __uint64_t,
    rbx: __uint64_t,
    rdx: __uint64_t,
    rax: __uint64_t,
    rcx: __uint64_t,
    rsp: __uint64_t,
    rip: __uint64_t,
    eflags: __uint64_t,
    cs: c_ushort,
    gs: c_ushort,
    fs: c_ushort,
    __pad0: c_ushort,
    err: __uint64_t,
    trapno: __uint64_t,
    oldmask: __uint64_t,
    cr2: __uint64_t,
    unnamed_0: union_unnamed_25,
    __reserved1: [8]__uint64_t,
};
pub const struct__xsave_hdr = extern struct {
    xstate_bv: __uint64_t,
    __glibc_reserved1: [2]__uint64_t,
    __glibc_reserved2: [5]__uint64_t,
};
pub const struct__ymmh_state = extern struct {
    ymmh_space: [64]__uint32_t,
};
pub const struct__xstate = extern struct {
    fpstate: struct__fpstate,
    xstate_hdr: struct__xsave_hdr,
    ymmh: struct__ymmh_state,
};
pub extern fn sigreturn(__scp: [*c]struct_sigcontext) c_int;
pub const stack_t = extern struct {
    ss_sp: ?*anyopaque,
    ss_flags: c_int,
    ss_size: usize,
};
pub const greg_t = c_longlong;
pub const gregset_t = [23]greg_t;
pub const struct__libc_fpxreg = extern struct {
    significand: [4]c_ushort,
    exponent: c_ushort,
    __glibc_reserved1: [3]c_ushort,
};
pub const struct__libc_xmmreg = extern struct {
    element: [4]__uint32_t,
};
pub const struct__libc_fpstate = extern struct {
    cwd: __uint16_t,
    swd: __uint16_t,
    ftw: __uint16_t,
    fop: __uint16_t,
    rip: __uint64_t,
    rdp: __uint64_t,
    mxcsr: __uint32_t,
    mxcr_mask: __uint32_t,
    _st: [8]struct__libc_fpxreg,
    _xmm: [16]struct__libc_xmmreg,
    __glibc_reserved1: [24]__uint32_t,
};
pub const fpregset_t = [*c]struct__libc_fpstate;
pub const mcontext_t = extern struct {
    gregs: gregset_t,
    fpregs: fpregset_t,
    __reserved1: [8]c_ulonglong,
};
pub const struct_ucontext_t = extern struct {
    uc_flags: c_ulong,
    uc_link: [*c]struct_ucontext_t,
    uc_stack: stack_t,
    uc_mcontext: mcontext_t,
    uc_sigmask: sigset_t,
    __fpregs_mem: struct__libc_fpstate,
    __ssp: [4]c_ulonglong,
};
pub const ucontext_t = struct_ucontext_t;
pub extern fn siginterrupt(__sig: c_int, __interrupt: c_int) c_int;
pub const SS_ONSTACK: c_int = 1;
pub const SS_DISABLE: c_int = 2;
const enum_unnamed_26 = c_uint;
pub extern fn sigaltstack(noalias __ss: [*c]const stack_t, noalias __oss: [*c]stack_t) c_int;
pub const struct_sigstack = extern struct {
    ss_sp: ?*anyopaque,
    ss_onstack: c_int,
};
pub extern fn sigstack(__ss: [*c]struct_sigstack, __oss: [*c]struct_sigstack) c_int;
pub extern fn pthread_sigmask(__how: c_int, noalias __newmask: [*c]const __sigset_t, noalias __oldmask: [*c]__sigset_t) c_int;
pub extern fn pthread_kill(__threadid: pthread_t, __signo: c_int) c_int;
pub extern fn __libc_current_sigrtmin() c_int;
pub extern fn __libc_current_sigrtmax() c_int;
pub extern fn g_on_error_query(prg_name: [*c]const gchar) void;
pub extern fn g_on_error_stack_trace(prg_name: [*c]const gchar) void;
pub extern fn g_base64_encode_step(in: [*c]const guchar, len: gsize, break_lines: gboolean, out: [*c]gchar, state: [*c]gint, save: [*c]gint) gsize;
pub extern fn g_base64_encode_close(break_lines: gboolean, out: [*c]gchar, state: [*c]gint, save: [*c]gint) gsize;
pub extern fn g_base64_encode(data: [*c]const guchar, len: gsize) [*c]gchar;
pub extern fn g_base64_decode_step(in: [*c]const gchar, len: gsize, out: [*c]guchar, state: [*c]gint, save: [*c]guint) gsize;
pub extern fn g_base64_decode(text: [*c]const gchar, out_len: [*c]gsize) [*c]guchar;
pub extern fn g_base64_decode_inplace(text: [*c]gchar, out_len: [*c]gsize) [*c]guchar;
pub extern fn g_bit_lock(address: [*c]volatile gint, lock_bit: gint) void;
pub extern fn g_bit_trylock(address: [*c]volatile gint, lock_bit: gint) gboolean;
pub extern fn g_bit_unlock(address: [*c]volatile gint, lock_bit: gint) void;
pub extern fn g_pointer_bit_lock(address: ?*volatile anyopaque, lock_bit: gint) void;
pub extern fn g_pointer_bit_trylock(address: ?*volatile anyopaque, lock_bit: gint) gboolean;
pub extern fn g_pointer_bit_unlock(address: ?*volatile anyopaque, lock_bit: gint) void;
pub const struct__GTimeZone = opaque {};
pub const GTimeZone = struct__GTimeZone;
pub const G_TIME_TYPE_STANDARD: c_int = 0;
pub const G_TIME_TYPE_DAYLIGHT: c_int = 1;
pub const G_TIME_TYPE_UNIVERSAL: c_int = 2;
pub const GTimeType = c_uint;
pub extern fn g_time_zone_new(identifier: [*c]const gchar) ?*GTimeZone;
pub extern fn g_time_zone_new_identifier(identifier: [*c]const gchar) ?*GTimeZone;
pub extern fn g_time_zone_new_utc() ?*GTimeZone;
pub extern fn g_time_zone_new_local() ?*GTimeZone;
pub extern fn g_time_zone_new_offset(seconds: gint32) ?*GTimeZone;
pub extern fn g_time_zone_ref(tz: ?*GTimeZone) ?*GTimeZone;
pub extern fn g_time_zone_unref(tz: ?*GTimeZone) void;
pub extern fn g_time_zone_find_interval(tz: ?*GTimeZone, @"type": GTimeType, time_: gint64) gint;
pub extern fn g_time_zone_adjust_time(tz: ?*GTimeZone, @"type": GTimeType, time_: [*c]gint64) gint;
pub extern fn g_time_zone_get_abbreviation(tz: ?*GTimeZone, interval: gint) [*c]const gchar;
pub extern fn g_time_zone_get_offset(tz: ?*GTimeZone, interval: gint) gint32;
pub extern fn g_time_zone_is_dst(tz: ?*GTimeZone, interval: gint) gboolean;
pub extern fn g_time_zone_get_identifier(tz: ?*GTimeZone) [*c]const gchar;
pub const GTimeSpan = gint64;
pub const struct__GDateTime = opaque {};
pub const GDateTime = struct__GDateTime;
pub extern fn g_date_time_unref(datetime: ?*GDateTime) void;
pub extern fn g_date_time_ref(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_new_now(tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_new_now_local() ?*GDateTime;
pub extern fn g_date_time_new_now_utc() ?*GDateTime;
pub extern fn g_date_time_new_from_unix_local(t: gint64) ?*GDateTime;
pub extern fn g_date_time_new_from_unix_utc(t: gint64) ?*GDateTime;
pub extern fn g_date_time_new_from_timeval_local(tv: [*c]const GTimeVal) ?*GDateTime;
pub extern fn g_date_time_new_from_timeval_utc(tv: [*c]const GTimeVal) ?*GDateTime;
pub extern fn g_date_time_new_from_iso8601(text: [*c]const gchar, default_tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_new(tz: ?*GTimeZone, year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_new_local(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_add(datetime: ?*GDateTime, timespan: GTimeSpan) ?*GDateTime;
pub extern fn g_date_time_add_years(datetime: ?*GDateTime, years: gint) ?*GDateTime;
pub extern fn g_date_time_add_months(datetime: ?*GDateTime, months: gint) ?*GDateTime;
pub extern fn g_date_time_add_weeks(datetime: ?*GDateTime, weeks: gint) ?*GDateTime;
pub extern fn g_date_time_add_days(datetime: ?*GDateTime, days: gint) ?*GDateTime;
pub extern fn g_date_time_add_hours(datetime: ?*GDateTime, hours: gint) ?*GDateTime;
pub extern fn g_date_time_add_minutes(datetime: ?*GDateTime, minutes: gint) ?*GDateTime;
pub extern fn g_date_time_add_seconds(datetime: ?*GDateTime, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_add_full(datetime: ?*GDateTime, years: gint, months: gint, days: gint, hours: gint, minutes: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) gint;
pub extern fn g_date_time_difference(end: ?*GDateTime, begin: ?*GDateTime) GTimeSpan;
pub extern fn g_date_time_hash(datetime: gconstpointer) guint;
pub extern fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) gboolean;
pub extern fn g_date_time_get_ymd(datetime: ?*GDateTime, year: [*c]gint, month: [*c]gint, day: [*c]gint) void;
pub extern fn g_date_time_get_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_month(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_month(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_week_numbering_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_week_of_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_week(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_hour(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_minute(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_second(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_microsecond(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_seconds(datetime: ?*GDateTime) gdouble;
pub extern fn g_date_time_to_unix(datetime: ?*GDateTime) gint64;
pub extern fn g_date_time_to_timeval(datetime: ?*GDateTime, tv: [*c]GTimeVal) gboolean;
pub extern fn g_date_time_get_utc_offset(datetime: ?*GDateTime) GTimeSpan;
pub extern fn g_date_time_get_timezone(datetime: ?*GDateTime) ?*GTimeZone;
pub extern fn g_date_time_get_timezone_abbreviation(datetime: ?*GDateTime) [*c]const gchar;
pub extern fn g_date_time_is_daylight_savings(datetime: ?*GDateTime) gboolean;
pub extern fn g_date_time_to_timezone(datetime: ?*GDateTime, tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_to_local(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_to_utc(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_format(datetime: ?*GDateTime, format: [*c]const gchar) [*c]gchar;
pub extern fn g_date_time_format_iso8601(datetime: ?*GDateTime) [*c]gchar;
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI: c_int = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE: c_int = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: c_int = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: c_int = 3;
pub const G_BOOKMARK_FILE_ERROR_READ: c_int = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: c_int = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE: c_int = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: c_int = 7;
pub const GBookmarkFileError = c_uint;
pub extern fn g_bookmark_file_error_quark() GQuark;
pub const struct__GBookmarkFile = opaque {};
pub const GBookmarkFile = struct__GBookmarkFile;
pub extern fn g_bookmark_file_new() ?*GBookmarkFile;
pub extern fn g_bookmark_file_free(bookmark: ?*GBookmarkFile) void;
pub extern fn g_bookmark_file_copy(bookmark: ?*GBookmarkFile) ?*GBookmarkFile;
pub extern fn g_bookmark_file_load_from_file(bookmark: ?*GBookmarkFile, filename: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_load_from_data(bookmark: ?*GBookmarkFile, data: [*c]const gchar, length: gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_load_from_data_dirs(bookmark: ?*GBookmarkFile, file: [*c]const gchar, full_path: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_to_data(bookmark: ?*GBookmarkFile, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_to_file(bookmark: ?*GBookmarkFile, filename: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_title(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, title: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_title(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_set_description(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, description: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_description(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_set_mime_type(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, mime_type: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_mime_type(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_bookmark_file_set_groups(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, groups: [*c][*c]const gchar, length: gsize) void;
pub extern fn g_bookmark_file_add_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar) void;
pub extern fn g_bookmark_file_has_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_groups(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_bookmark_file_add_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]const gchar) void;
pub extern fn g_bookmark_file_has_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_applications(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_bookmark_file_set_app_info(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]const gchar, count: gint, stamp: time_t, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_application_info(bookmark: ?*GBookmarkFile, uri: [*c]const u8, name: [*c]const u8, exec: [*c]const u8, count: c_int, stamp: ?*GDateTime, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_app_info(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c][*c]gchar, count: [*c]guint, stamp: [*c]time_t, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_get_application_info(bookmark: ?*GBookmarkFile, uri: [*c]const u8, name: [*c]const u8, exec: [*c][*c]u8, count: [*c]c_uint, stamp: [*c]?*GDateTime, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_is_private(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, is_private: gboolean) void;
pub extern fn g_bookmark_file_get_is_private(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_icon(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, href: [*c]const gchar, mime_type: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_icon(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, href: [*c][*c]gchar, mime_type: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_set_added(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, added: time_t) void;
pub extern fn g_bookmark_file_set_added_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, added: ?*GDateTime) void;
pub extern fn g_bookmark_file_get_added(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) time_t;
pub extern fn g_bookmark_file_get_added_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GDateTime;
pub extern fn g_bookmark_file_set_modified(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, modified: time_t) void;
pub extern fn g_bookmark_file_set_modified_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, modified: ?*GDateTime) void;
pub extern fn g_bookmark_file_get_modified(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) time_t;
pub extern fn g_bookmark_file_get_modified_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GDateTime;
pub extern fn g_bookmark_file_set_visited(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, visited: time_t) void;
pub extern fn g_bookmark_file_set_visited_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, visited: ?*GDateTime) void;
pub extern fn g_bookmark_file_get_visited(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) time_t;
pub extern fn g_bookmark_file_get_visited_date_time(bookmark: ?*GBookmarkFile, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GDateTime;
pub extern fn g_bookmark_file_has_item(bookmark: ?*GBookmarkFile, uri: [*c]const gchar) gboolean;
pub extern fn g_bookmark_file_get_size(bookmark: ?*GBookmarkFile) gint;
pub extern fn g_bookmark_file_get_uris(bookmark: ?*GBookmarkFile, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_bookmark_file_remove_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_remove_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_remove_item(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bookmark_file_move_item(bookmark: ?*GBookmarkFile, old_uri: [*c]const gchar, new_uri: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_bytes_new(data: gconstpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_take(data: gpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_static(data: gconstpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize, free_func: GDestroyNotify, user_data: gpointer) ?*GBytes;
pub extern fn g_bytes_new_from_bytes(bytes: ?*GBytes, offset: gsize, length: gsize) ?*GBytes;
pub extern fn g_bytes_get_data(bytes: ?*GBytes, size: [*c]gsize) gconstpointer;
pub extern fn g_bytes_get_size(bytes: ?*GBytes) gsize;
pub extern fn g_bytes_ref(bytes: ?*GBytes) ?*GBytes;
pub extern fn g_bytes_unref(bytes: ?*GBytes) void;
pub extern fn g_bytes_unref_to_data(bytes: ?*GBytes, size: [*c]gsize) gpointer;
pub extern fn g_bytes_unref_to_array(bytes: ?*GBytes) [*c]GByteArray;
pub extern fn g_bytes_hash(bytes: gconstpointer) guint;
pub extern fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) gboolean;
pub extern fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) gint;
pub extern fn g_bytes_get_region(bytes: ?*GBytes, element_size: gsize, offset: gsize, n_elements: gsize) gconstpointer;
pub extern fn g_get_charset(charset: [*c][*c]const u8) gboolean;
pub extern fn g_get_codeset() [*c]gchar;
pub extern fn g_get_console_charset(charset: [*c][*c]const u8) gboolean;
pub extern fn g_get_language_names() [*c]const [*c]const gchar;
pub extern fn g_get_language_names_with_category(category_name: [*c]const gchar) [*c]const [*c]const gchar;
pub extern fn g_get_locale_variants(locale: [*c]const gchar) [*c][*c]gchar;
pub const G_CHECKSUM_MD5: c_int = 0;
pub const G_CHECKSUM_SHA1: c_int = 1;
pub const G_CHECKSUM_SHA256: c_int = 2;
pub const G_CHECKSUM_SHA512: c_int = 3;
pub const G_CHECKSUM_SHA384: c_int = 4;
pub const GChecksumType = c_uint;
pub const struct__GChecksum = opaque {};
pub const GChecksum = struct__GChecksum;
pub extern fn g_checksum_type_get_length(checksum_type: GChecksumType) gssize;
pub extern fn g_checksum_new(checksum_type: GChecksumType) ?*GChecksum;
pub extern fn g_checksum_reset(checksum: ?*GChecksum) void;
pub extern fn g_checksum_copy(checksum: ?*const GChecksum) ?*GChecksum;
pub extern fn g_checksum_free(checksum: ?*GChecksum) void;
pub extern fn g_checksum_update(checksum: ?*GChecksum, data: [*c]const guchar, length: gssize) void;
pub extern fn g_checksum_get_string(checksum: ?*GChecksum) [*c]const gchar;
pub extern fn g_checksum_get_digest(checksum: ?*GChecksum, buffer: [*c]guint8, digest_len: [*c]gsize) void;
pub extern fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: [*c]const guchar, length: gsize) [*c]gchar;
pub extern fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: ?*GBytes) [*c]gchar;
pub const G_CONVERT_ERROR_NO_CONVERSION: c_int = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE: c_int = 1;
pub const G_CONVERT_ERROR_FAILED: c_int = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT: c_int = 3;
pub const G_CONVERT_ERROR_BAD_URI: c_int = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: c_int = 5;
pub const G_CONVERT_ERROR_NO_MEMORY: c_int = 6;
pub const G_CONVERT_ERROR_EMBEDDED_NUL: c_int = 7;
pub const GConvertError = c_uint;
pub extern fn g_convert_error_quark() GQuark;
pub const struct__GIConv = opaque {};
pub const GIConv = ?*struct__GIConv;
pub extern fn g_iconv_open(to_codeset: [*c]const gchar, from_codeset: [*c]const gchar) GIConv;
pub extern fn g_iconv(converter: GIConv, inbuf: [*c][*c]gchar, inbytes_left: [*c]gsize, outbuf: [*c][*c]gchar, outbytes_left: [*c]gsize) gsize;
pub extern fn g_iconv_close(converter: GIConv) gint;
pub extern fn g_convert(str: [*c]const gchar, len: gssize, to_codeset: [*c]const gchar, from_codeset: [*c]const gchar, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_convert_with_iconv(str: [*c]const gchar, len: gssize, converter: GIConv, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_convert_with_fallback(str: [*c]const gchar, len: gssize, to_codeset: [*c]const gchar, from_codeset: [*c]const gchar, fallback: [*c]const gchar, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_locale_to_utf8(opsysstring: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_locale_from_utf8(utf8string: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_to_utf8(opsysstring: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_from_utf8(utf8string: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_from_uri(uri: [*c]const gchar, hostname: [*c][*c]gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_to_uri(filename: [*c]const gchar, hostname: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_filename_display_name(filename: [*c]const gchar) [*c]gchar;
pub extern fn g_get_filename_charsets(filename_charsets: [*c][*c][*c]const gchar) gboolean;
pub extern fn g_filename_display_basename(filename: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_list_extract_uris(uri_list: [*c]const gchar) [*c][*c]gchar;
pub const struct__GData = opaque {};
pub const GData = struct__GData;
pub const GDataForeachFunc = ?*const fn (GQuark, gpointer, gpointer) callconv(.C) void;
pub extern fn g_datalist_init(datalist: [*c]?*GData) void;
pub extern fn g_datalist_clear(datalist: [*c]?*GData) void;
pub extern fn g_datalist_id_get_data(datalist: [*c]?*GData, key_id: GQuark) gpointer;
pub extern fn g_datalist_id_set_data_full(datalist: [*c]?*GData, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify) void;
pub extern fn g_datalist_id_remove_multiple(datalist: [*c]?*GData, keys: [*c]GQuark, n_keys: gsize) void;
pub const GDuplicateFunc = ?*const fn (gpointer, gpointer) callconv(.C) gpointer;
pub extern fn g_datalist_id_dup_data(datalist: [*c]?*GData, key_id: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_datalist_id_replace_data(datalist: [*c]?*GData, key_id: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_datalist_id_remove_no_notify(datalist: [*c]?*GData, key_id: GQuark) gpointer;
pub extern fn g_datalist_foreach(datalist: [*c]?*GData, func: GDataForeachFunc, user_data: gpointer) void;
pub extern fn g_datalist_set_flags(datalist: [*c]?*GData, flags: guint) void;
pub extern fn g_datalist_unset_flags(datalist: [*c]?*GData, flags: guint) void;
pub extern fn g_datalist_get_flags(datalist: [*c]?*GData) guint;
pub extern fn g_dataset_destroy(dataset_location: gconstpointer) void;
pub extern fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) gpointer;
pub extern fn g_datalist_get_data(datalist: [*c]?*GData, key: [*c]const gchar) gpointer;
pub extern fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify) void;
pub extern fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) gpointer;
pub extern fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer) void;
pub const GTime = gint32;
pub const GDateYear = guint16;
pub const GDateDay = guint8; // /usr/include/glib-2.0/glib/gdate.h:103:9: warning: struct demoted to opaque type - has bitfield
pub const struct__GDate = opaque {};
pub const GDate = struct__GDate;
pub const G_DATE_DAY: c_int = 0;
pub const G_DATE_MONTH: c_int = 1;
pub const G_DATE_YEAR: c_int = 2;
pub const GDateDMY = c_uint;
pub const G_DATE_BAD_WEEKDAY: c_int = 0;
pub const G_DATE_MONDAY: c_int = 1;
pub const G_DATE_TUESDAY: c_int = 2;
pub const G_DATE_WEDNESDAY: c_int = 3;
pub const G_DATE_THURSDAY: c_int = 4;
pub const G_DATE_FRIDAY: c_int = 5;
pub const G_DATE_SATURDAY: c_int = 6;
pub const G_DATE_SUNDAY: c_int = 7;
pub const GDateWeekday = c_uint;
pub const G_DATE_BAD_MONTH: c_int = 0;
pub const G_DATE_JANUARY: c_int = 1;
pub const G_DATE_FEBRUARY: c_int = 2;
pub const G_DATE_MARCH: c_int = 3;
pub const G_DATE_APRIL: c_int = 4;
pub const G_DATE_MAY: c_int = 5;
pub const G_DATE_JUNE: c_int = 6;
pub const G_DATE_JULY: c_int = 7;
pub const G_DATE_AUGUST: c_int = 8;
pub const G_DATE_SEPTEMBER: c_int = 9;
pub const G_DATE_OCTOBER: c_int = 10;
pub const G_DATE_NOVEMBER: c_int = 11;
pub const G_DATE_DECEMBER: c_int = 12;
pub const GDateMonth = c_uint;
pub extern fn g_date_new() ?*GDate;
pub extern fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) ?*GDate;
pub extern fn g_date_new_julian(julian_day: guint32) ?*GDate;
pub extern fn g_date_free(date: ?*GDate) void;
pub extern fn g_date_copy(date: ?*const GDate) ?*GDate;
pub extern fn g_date_valid(date: ?*const GDate) gboolean;
pub extern fn g_date_valid_day(day: GDateDay) gboolean;
pub extern fn g_date_valid_month(month: GDateMonth) gboolean;
pub extern fn g_date_valid_year(year: GDateYear) gboolean;
pub extern fn g_date_valid_weekday(weekday: GDateWeekday) gboolean;
pub extern fn g_date_valid_julian(julian_date: guint32) gboolean;
pub extern fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) gboolean;
pub extern fn g_date_get_weekday(date: ?*const GDate) GDateWeekday;
pub extern fn g_date_get_month(date: ?*const GDate) GDateMonth;
pub extern fn g_date_get_year(date: ?*const GDate) GDateYear;
pub extern fn g_date_get_day(date: ?*const GDate) GDateDay;
pub extern fn g_date_get_julian(date: ?*const GDate) guint32;
pub extern fn g_date_get_day_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_monday_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_sunday_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_iso8601_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_clear(date: ?*GDate, n_dates: guint) void;
pub extern fn g_date_set_parse(date: ?*GDate, str: [*c]const gchar) void;
pub extern fn g_date_set_time_t(date: ?*GDate, timet: time_t) void;
pub extern fn g_date_set_time_val(date: ?*GDate, timeval: [*c]GTimeVal) void;
pub extern fn g_date_set_time(date: ?*GDate, time_: GTime) void;
pub extern fn g_date_set_month(date: ?*GDate, month: GDateMonth) void;
pub extern fn g_date_set_day(date: ?*GDate, day: GDateDay) void;
pub extern fn g_date_set_year(date: ?*GDate, year: GDateYear) void;
pub extern fn g_date_set_dmy(date: ?*GDate, day: GDateDay, month: GDateMonth, y: GDateYear) void;
pub extern fn g_date_set_julian(date: ?*GDate, julian_date: guint32) void;
pub extern fn g_date_is_first_of_month(date: ?*const GDate) gboolean;
pub extern fn g_date_is_last_of_month(date: ?*const GDate) gboolean;
pub extern fn g_date_add_days(date: ?*GDate, n_days: guint) void;
pub extern fn g_date_subtract_days(date: ?*GDate, n_days: guint) void;
pub extern fn g_date_add_months(date: ?*GDate, n_months: guint) void;
pub extern fn g_date_subtract_months(date: ?*GDate, n_months: guint) void;
pub extern fn g_date_add_years(date: ?*GDate, n_years: guint) void;
pub extern fn g_date_subtract_years(date: ?*GDate, n_years: guint) void;
pub extern fn g_date_is_leap_year(year: GDateYear) gboolean;
pub extern fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) guint8;
pub extern fn g_date_get_monday_weeks_in_year(year: GDateYear) guint8;
pub extern fn g_date_get_sunday_weeks_in_year(year: GDateYear) guint8;
pub extern fn g_date_days_between(date1: ?*const GDate, date2: ?*const GDate) gint;
pub extern fn g_date_compare(lhs: ?*const GDate, rhs: ?*const GDate) gint;
pub extern fn g_date_to_struct_tm(date: ?*const GDate, tm: [*c]struct_tm) void;
pub extern fn g_date_clamp(date: ?*GDate, min_date: ?*const GDate, max_date: ?*const GDate) void;
pub extern fn g_date_order(date1: ?*GDate, date2: ?*GDate) void;
pub extern fn g_date_strftime(s: [*c]gchar, slen: gsize, format: [*c]const gchar, date: ?*const GDate) gsize;
pub const struct_dirent = extern struct {
    d_ino: __ino_t,
    d_off: __off_t,
    d_reclen: c_ushort,
    d_type: u8,
    d_name: [256]u8,
};
pub const DT_UNKNOWN: c_int = 0;
pub const DT_FIFO: c_int = 1;
pub const DT_CHR: c_int = 2;
pub const DT_DIR: c_int = 4;
pub const DT_BLK: c_int = 6;
pub const DT_REG: c_int = 8;
pub const DT_LNK: c_int = 10;
pub const DT_SOCK: c_int = 12;
pub const DT_WHT: c_int = 14;
const enum_unnamed_27 = c_uint;
pub const struct___dirstream = opaque {};
pub const DIR = struct___dirstream;
pub extern fn closedir(__dirp: ?*DIR) c_int;
pub extern fn opendir(__name: [*c]const u8) ?*DIR;
pub extern fn fdopendir(__fd: c_int) ?*DIR;
pub extern fn readdir(__dirp: ?*DIR) [*c]struct_dirent;
pub extern fn readdir_r(noalias __dirp: ?*DIR, noalias __entry: [*c]struct_dirent, noalias __result: [*c][*c]struct_dirent) c_int;
pub extern fn rewinddir(__dirp: ?*DIR) void;
pub extern fn seekdir(__dirp: ?*DIR, __pos: c_long) void;
pub extern fn telldir(__dirp: ?*DIR) c_long;
pub extern fn dirfd(__dirp: ?*DIR) c_int;
pub extern fn scandir(noalias __dir: [*c]const u8, noalias __namelist: [*c][*c][*c]struct_dirent, __selector: ?*const fn ([*c]const struct_dirent) callconv(.C) c_int, __cmp: ?*const fn ([*c][*c]const struct_dirent, [*c][*c]const struct_dirent) callconv(.C) c_int) c_int;
pub extern fn alphasort(__e1: [*c][*c]const struct_dirent, __e2: [*c][*c]const struct_dirent) c_int;
pub extern fn getdirentries(__fd: c_int, noalias __buf: [*c]u8, __nbytes: usize, noalias __basep: [*c]__off_t) __ssize_t;
pub const struct__GDir = opaque {};
pub const GDir = struct__GDir;
pub extern fn g_dir_open(path: [*c]const gchar, flags: guint, @"error": [*c][*c]GError) ?*GDir;
pub extern fn g_dir_read_name(dir: ?*GDir) [*c]const gchar;
pub extern fn g_dir_rewind(dir: ?*GDir) void;
pub extern fn g_dir_close(dir: ?*GDir) void;
pub extern fn g_getenv(variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_setenv(variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) gboolean;
pub extern fn g_unsetenv(variable: [*c]const gchar) void;
pub extern fn g_listenv() [*c][*c]gchar;
pub extern fn g_get_environ() [*c][*c]gchar;
pub extern fn g_environ_getenv(envp: [*c][*c]gchar, variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_environ_setenv(envp: [*c][*c]gchar, variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) [*c][*c]gchar;
pub extern fn g_environ_unsetenv(envp: [*c][*c]gchar, variable: [*c]const gchar) [*c][*c]gchar;
pub const G_FILE_ERROR_EXIST: c_int = 0;
pub const G_FILE_ERROR_ISDIR: c_int = 1;
pub const G_FILE_ERROR_ACCES: c_int = 2;
pub const G_FILE_ERROR_NAMETOOLONG: c_int = 3;
pub const G_FILE_ERROR_NOENT: c_int = 4;
pub const G_FILE_ERROR_NOTDIR: c_int = 5;
pub const G_FILE_ERROR_NXIO: c_int = 6;
pub const G_FILE_ERROR_NODEV: c_int = 7;
pub const G_FILE_ERROR_ROFS: c_int = 8;
pub const G_FILE_ERROR_TXTBSY: c_int = 9;
pub const G_FILE_ERROR_FAULT: c_int = 10;
pub const G_FILE_ERROR_LOOP: c_int = 11;
pub const G_FILE_ERROR_NOSPC: c_int = 12;
pub const G_FILE_ERROR_NOMEM: c_int = 13;
pub const G_FILE_ERROR_MFILE: c_int = 14;
pub const G_FILE_ERROR_NFILE: c_int = 15;
pub const G_FILE_ERROR_BADF: c_int = 16;
pub const G_FILE_ERROR_INVAL: c_int = 17;
pub const G_FILE_ERROR_PIPE: c_int = 18;
pub const G_FILE_ERROR_AGAIN: c_int = 19;
pub const G_FILE_ERROR_INTR: c_int = 20;
pub const G_FILE_ERROR_IO: c_int = 21;
pub const G_FILE_ERROR_PERM: c_int = 22;
pub const G_FILE_ERROR_NOSYS: c_int = 23;
pub const G_FILE_ERROR_FAILED: c_int = 24;
pub const GFileError = c_uint;
pub const G_FILE_TEST_IS_REGULAR: c_int = 1;
pub const G_FILE_TEST_IS_SYMLINK: c_int = 2;
pub const G_FILE_TEST_IS_DIR: c_int = 4;
pub const G_FILE_TEST_IS_EXECUTABLE: c_int = 8;
pub const G_FILE_TEST_EXISTS: c_int = 16;
pub const GFileTest = c_uint;
pub const G_FILE_SET_CONTENTS_NONE: c_int = 0;
pub const G_FILE_SET_CONTENTS_CONSISTENT: c_int = 1;
pub const G_FILE_SET_CONTENTS_DURABLE: c_int = 2;
pub const G_FILE_SET_CONTENTS_ONLY_EXISTING: c_int = 4;
pub const GFileSetContentsFlags = c_uint;
pub extern fn g_file_error_quark() GQuark;
pub extern fn g_file_error_from_errno(err_no: gint) GFileError;
pub extern fn g_file_test(filename: [*c]const gchar, @"test": GFileTest) gboolean;
pub extern fn g_file_get_contents(filename: [*c]const gchar, contents: [*c][*c]gchar, length: [*c]gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_contents(filename: [*c]const gchar, contents: [*c]const gchar, length: gssize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_contents_full(filename: [*c]const gchar, contents: [*c]const gchar, length: gssize, flags: GFileSetContentsFlags, mode: c_int, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_read_link(filename: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_mkdtemp(tmpl: [*c]gchar) [*c]gchar;
pub extern fn g_mkdtemp_full(tmpl: [*c]gchar, mode: gint) [*c]gchar;
pub extern fn g_mkstemp(tmpl: [*c]gchar) gint;
pub extern fn g_mkstemp_full(tmpl: [*c]gchar, flags: gint, mode: gint) gint;
pub extern fn g_file_open_tmp(tmpl: [*c]const gchar, name_used: [*c][*c]gchar, @"error": [*c][*c]GError) gint;
pub extern fn g_dir_make_tmp(tmpl: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_build_path(separator: [*c]const gchar, first_element: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_build_pathv(separator: [*c]const gchar, args: [*c][*c]gchar) [*c]gchar;
pub extern fn g_build_filename(first_element: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_build_filenamev(args: [*c][*c]gchar) [*c]gchar;
pub extern fn g_build_filename_valist(first_element: [*c]const gchar, args: [*c]va_list) [*c]gchar;
pub extern fn g_mkdir_with_parents(pathname: [*c]const gchar, mode: gint) gint;
pub extern fn g_path_is_absolute(file_name: [*c]const gchar) gboolean;
pub extern fn g_path_skip_root(file_name: [*c]const gchar) [*c]const gchar;
pub extern fn g_basename(file_name: [*c]const gchar) [*c]const gchar;
pub extern fn g_get_current_dir() [*c]gchar;
pub extern fn g_path_get_basename(file_name: [*c]const gchar) [*c]gchar;
pub extern fn g_path_get_dirname(file_name: [*c]const gchar) [*c]gchar;
pub extern fn g_canonicalize_filename(filename: [*c]const gchar, relative_to: [*c]const gchar) [*c]gchar;
pub extern fn g_strip_context(msgid: [*c]const gchar, msgval: [*c]const gchar) [*c]const gchar;
pub extern fn g_dgettext(domain: [*c]const gchar, msgid: [*c]const gchar) [*c]const gchar;
pub extern fn g_dcgettext(domain: [*c]const gchar, msgid: [*c]const gchar, category: gint) [*c]const gchar;
pub extern fn g_dngettext(domain: [*c]const gchar, msgid: [*c]const gchar, msgid_plural: [*c]const gchar, n: gulong) [*c]const gchar;
pub extern fn g_dpgettext(domain: [*c]const gchar, msgctxtid: [*c]const gchar, msgidoffset: gsize) [*c]const gchar;
pub extern fn g_dpgettext2(domain: [*c]const gchar, context: [*c]const gchar, msgid: [*c]const gchar) [*c]const gchar;
pub const struct__GMemVTable = extern struct {
    malloc: ?*const fn (gsize) callconv(.C) gpointer,
    realloc: ?*const fn (gpointer, gsize) callconv(.C) gpointer,
    free: ?*const fn (gpointer) callconv(.C) void,
    calloc: ?*const fn (gsize, gsize) callconv(.C) gpointer,
    try_malloc: ?*const fn (gsize) callconv(.C) gpointer,
    try_realloc: ?*const fn (gpointer, gsize) callconv(.C) gpointer,
};
pub const GMemVTable = struct__GMemVTable;
pub extern fn g_free(mem: gpointer) void;
pub extern fn g_free_sized(mem: gpointer, size: usize) void;
pub extern fn g_clear_pointer(pp: [*c]gpointer, destroy: GDestroyNotify) void;
pub extern fn g_malloc(n_bytes: gsize) gpointer;
pub extern fn g_malloc0(n_bytes: gsize) gpointer;
pub extern fn g_realloc(mem: gpointer, n_bytes: gsize) gpointer;
pub extern fn g_try_malloc(n_bytes: gsize) gpointer;
pub extern fn g_try_malloc0(n_bytes: gsize) gpointer;
pub extern fn g_try_realloc(mem: gpointer, n_bytes: gsize) gpointer;
pub extern fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) gpointer;
pub extern fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) gpointer;
pub extern fn g_aligned_free(mem: gpointer) void;
pub extern fn g_aligned_free_sized(mem: gpointer, alignment: usize, size: usize) void;
pub fn g_steal_pointer(arg_pp: gpointer) callconv(.C) gpointer {
    var pp = arg_pp;
    var ptr: [*c]gpointer = @as([*c]gpointer, @ptrCast(@alignCast(pp)));
    var ref: gpointer = undefined;
    ref = ptr.*;
    ptr.* = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    return ref;
}
pub extern fn g_mem_set_vtable(vtable: [*c]GMemVTable) void;
pub extern fn g_mem_is_system_malloc() gboolean;
pub extern var g_mem_gc_friendly: gboolean;
pub extern var glib_mem_profiler_table: [*c]GMemVTable;
pub extern fn g_mem_profile() void;
pub const GNode = struct__GNode;
pub const struct__GNode = extern struct {
    data: gpointer,
    next: [*c]GNode,
    prev: [*c]GNode,
    parent: [*c]GNode,
    children: [*c]GNode,
};
pub const G_TRAVERSE_LEAVES: c_int = 1;
pub const G_TRAVERSE_NON_LEAVES: c_int = 2;
pub const G_TRAVERSE_ALL: c_int = 3;
pub const G_TRAVERSE_MASK: c_int = 3;
pub const G_TRAVERSE_LEAFS: c_int = 1;
pub const G_TRAVERSE_NON_LEAFS: c_int = 2;
pub const GTraverseFlags = c_uint;
pub const G_IN_ORDER: c_int = 0;
pub const G_PRE_ORDER: c_int = 1;
pub const G_POST_ORDER: c_int = 2;
pub const G_LEVEL_ORDER: c_int = 3;
pub const GTraverseType = c_uint;
pub const GNodeTraverseFunc = ?*const fn ([*c]GNode, gpointer) callconv(.C) gboolean;
pub const GNodeForeachFunc = ?*const fn ([*c]GNode, gpointer) callconv(.C) void;
pub extern fn g_node_new(data: gpointer) [*c]GNode;
pub extern fn g_node_destroy(root: [*c]GNode) void;
pub extern fn g_node_unlink(node: [*c]GNode) void;
pub extern fn g_node_copy_deep(node: [*c]GNode, copy_func: GCopyFunc, data: gpointer) [*c]GNode;
pub extern fn g_node_copy(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert(parent: [*c]GNode, position: gint, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert_before(parent: [*c]GNode, sibling: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert_after(parent: [*c]GNode, sibling: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_prepend(parent: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_n_nodes(root: [*c]GNode, flags: GTraverseFlags) guint;
pub extern fn g_node_get_root(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_is_ancestor(node: [*c]GNode, descendant: [*c]GNode) gboolean;
pub extern fn g_node_depth(node: [*c]GNode) guint;
pub extern fn g_node_find(root: [*c]GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) [*c]GNode;
pub extern fn g_node_traverse(root: [*c]GNode, order: GTraverseType, flags: GTraverseFlags, max_depth: gint, func: GNodeTraverseFunc, data: gpointer) void;
pub extern fn g_node_max_height(root: [*c]GNode) guint;
pub extern fn g_node_children_foreach(node: [*c]GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer) void;
pub extern fn g_node_reverse_children(node: [*c]GNode) void;
pub extern fn g_node_n_children(node: [*c]GNode) guint;
pub extern fn g_node_nth_child(node: [*c]GNode, n: guint) [*c]GNode;
pub extern fn g_node_last_child(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_find_child(node: [*c]GNode, flags: GTraverseFlags, data: gpointer) [*c]GNode;
pub extern fn g_node_child_position(node: [*c]GNode, child: [*c]GNode) gint;
pub extern fn g_node_child_index(node: [*c]GNode, data: gpointer) gint;
pub extern fn g_node_first_sibling(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_last_sibling(node: [*c]GNode) [*c]GNode;
pub const GList = struct__GList;
pub const struct__GList = extern struct {
    data: gpointer,
    next: [*c]GList,
    prev: [*c]GList,
};
pub extern fn g_list_alloc() [*c]GList;
pub extern fn g_list_free(list: [*c]GList) void;
pub extern fn g_list_free_1(list: [*c]GList) void;
pub extern fn g_list_free_full(list: [*c]GList, free_func: GDestroyNotify) void;
pub extern fn g_list_append(list: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_prepend(list: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_insert(list: [*c]GList, data: gpointer, position: gint) [*c]GList;
pub extern fn g_list_insert_sorted(list: [*c]GList, data: gpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_list_insert_sorted_with_data(list: [*c]GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_insert_before(list: [*c]GList, sibling: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_insert_before_link(list: [*c]GList, sibling: [*c]GList, link_: [*c]GList) [*c]GList;
pub extern fn g_list_concat(list1: [*c]GList, list2: [*c]GList) [*c]GList;
pub extern fn g_list_remove(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_remove_all(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_remove_link(list: [*c]GList, llink: [*c]GList) [*c]GList;
pub extern fn g_list_delete_link(list: [*c]GList, link_: [*c]GList) [*c]GList;
pub extern fn g_list_reverse(list: [*c]GList) [*c]GList;
pub extern fn g_list_copy(list: [*c]GList) [*c]GList;
pub extern fn g_list_copy_deep(list: [*c]GList, func: GCopyFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_nth(list: [*c]GList, n: guint) [*c]GList;
pub extern fn g_list_nth_prev(list: [*c]GList, n: guint) [*c]GList;
pub extern fn g_list_find(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_find_custom(list: [*c]GList, data: gconstpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_list_position(list: [*c]GList, llink: [*c]GList) gint;
pub extern fn g_list_index(list: [*c]GList, data: gconstpointer) gint;
pub extern fn g_list_last(list: [*c]GList) [*c]GList;
pub extern fn g_list_first(list: [*c]GList) [*c]GList;
pub extern fn g_list_length(list: [*c]GList) guint;
pub extern fn g_list_foreach(list: [*c]GList, func: GFunc, user_data: gpointer) void;
pub extern fn g_list_sort(list: [*c]GList, compare_func: GCompareFunc) [*c]GList;
pub extern fn g_list_sort_with_data(list: [*c]GList, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_nth_data(list: [*c]GList, n: guint) gpointer;
pub extern fn g_clear_list(list_ptr: [*c][*c]GList, destroy: GDestroyNotify) void;
pub const struct__GHashTable = opaque {};
pub const GHashTable = struct__GHashTable;
pub const GHRFunc = ?*const fn (gpointer, gpointer, gpointer) callconv(.C) gboolean;
pub const struct__GHashTableIter = extern struct {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: gpointer,
    dummy4: c_int,
    dummy5: gboolean,
    dummy6: gpointer,
};
pub const GHashTableIter = struct__GHashTableIter;
pub extern fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) ?*GHashTable;
pub extern fn g_hash_table_new_full(hash_func: GHashFunc, key_equal_func: GEqualFunc, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) ?*GHashTable;
pub extern fn g_hash_table_new_similar(other_hash_table: ?*GHashTable) ?*GHashTable;
pub extern fn g_hash_table_destroy(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_insert(hash_table: ?*GHashTable, key: gpointer, value: gpointer) gboolean;
pub extern fn g_hash_table_replace(hash_table: ?*GHashTable, key: gpointer, value: gpointer) gboolean;
pub extern fn g_hash_table_add(hash_table: ?*GHashTable, key: gpointer) gboolean;
pub extern fn g_hash_table_remove(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_remove_all(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_steal(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_steal_extended(hash_table: ?*GHashTable, lookup_key: gconstpointer, stolen_key: [*c]gpointer, stolen_value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_steal_all(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_steal_all_keys(hash_table: ?*GHashTable) [*c]GPtrArray;
pub extern fn g_hash_table_steal_all_values(hash_table: ?*GHashTable) [*c]GPtrArray;
pub extern fn g_hash_table_lookup(hash_table: ?*GHashTable, key: gconstpointer) gpointer;
pub extern fn g_hash_table_contains(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_lookup_extended(hash_table: ?*GHashTable, lookup_key: gconstpointer, orig_key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_foreach(hash_table: ?*GHashTable, func: GHFunc, user_data: gpointer) void;
pub extern fn g_hash_table_find(hash_table: ?*GHashTable, predicate: GHRFunc, user_data: gpointer) gpointer;
pub extern fn g_hash_table_foreach_remove(hash_table: ?*GHashTable, func: GHRFunc, user_data: gpointer) guint;
pub extern fn g_hash_table_foreach_steal(hash_table: ?*GHashTable, func: GHRFunc, user_data: gpointer) guint;
pub extern fn g_hash_table_size(hash_table: ?*GHashTable) guint;
pub extern fn g_hash_table_get_keys(hash_table: ?*GHashTable) [*c]GList;
pub extern fn g_hash_table_get_values(hash_table: ?*GHashTable) [*c]GList;
pub extern fn g_hash_table_get_keys_as_array(hash_table: ?*GHashTable, length: [*c]guint) [*c]gpointer;
pub extern fn g_hash_table_get_keys_as_ptr_array(hash_table: ?*GHashTable) [*c]GPtrArray;
pub extern fn g_hash_table_get_values_as_ptr_array(hash_table: ?*GHashTable) [*c]GPtrArray;
pub extern fn g_hash_table_iter_init(iter: [*c]GHashTableIter, hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_iter_next(iter: [*c]GHashTableIter, key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_iter_get_hash_table(iter: [*c]GHashTableIter) ?*GHashTable;
pub extern fn g_hash_table_iter_remove(iter: [*c]GHashTableIter) void;
pub extern fn g_hash_table_iter_replace(iter: [*c]GHashTableIter, value: gpointer) void;
pub extern fn g_hash_table_iter_steal(iter: [*c]GHashTableIter) void;
pub extern fn g_hash_table_ref(hash_table: ?*GHashTable) ?*GHashTable;
pub extern fn g_hash_table_unref(hash_table: ?*GHashTable) void;
pub extern fn g_str_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_str_hash(v: gconstpointer) guint;
pub extern fn g_int_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_int_hash(v: gconstpointer) guint;
pub extern fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_int64_hash(v: gconstpointer) guint;
pub extern fn g_double_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_double_hash(v: gconstpointer) guint;
pub extern fn g_direct_hash(v: gconstpointer) guint;
pub extern fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub const struct__GHmac = opaque {};
pub const GHmac = struct__GHmac;
pub extern fn g_hmac_new(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize) ?*GHmac;
pub extern fn g_hmac_copy(hmac: ?*const GHmac) ?*GHmac;
pub extern fn g_hmac_ref(hmac: ?*GHmac) ?*GHmac;
pub extern fn g_hmac_unref(hmac: ?*GHmac) void;
pub extern fn g_hmac_update(hmac: ?*GHmac, data: [*c]const guchar, length: gssize) void;
pub extern fn g_hmac_get_string(hmac: ?*GHmac) [*c]const gchar;
pub extern fn g_hmac_get_digest(hmac: ?*GHmac, buffer: [*c]guint8, digest_len: [*c]gsize) void;
pub extern fn g_compute_hmac_for_data(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize, data: [*c]const guchar, length: gsize) [*c]gchar;
pub extern fn g_compute_hmac_for_string(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize, str: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_compute_hmac_for_bytes(digest_type: GChecksumType, key: ?*GBytes, data: ?*GBytes) [*c]gchar;
pub const GHook = struct__GHook;
pub const struct__GHook = extern struct {
    data: gpointer,
    next: [*c]GHook,
    prev: [*c]GHook,
    ref_count: guint,
    hook_id: gulong,
    flags: guint,
    func: gpointer,
    destroy: GDestroyNotify,
}; // /usr/include/glib-2.0/glib/ghook.h:68:14: warning: struct demoted to opaque type - has bitfield
pub const struct__GHookList = opaque {};
pub const GHookList = struct__GHookList;
pub const GHookCompareFunc = ?*const fn ([*c]GHook, [*c]GHook) callconv(.C) gint;
pub const GHookFindFunc = ?*const fn ([*c]GHook, gpointer) callconv(.C) gboolean;
pub const GHookMarshaller = ?*const fn ([*c]GHook, gpointer) callconv(.C) void;
pub const GHookCheckMarshaller = ?*const fn ([*c]GHook, gpointer) callconv(.C) gboolean;
pub const GHookFunc = ?*const fn (gpointer) callconv(.C) void;
pub const GHookCheckFunc = ?*const fn (gpointer) callconv(.C) gboolean;
pub const GHookFinalizeFunc = ?*const fn (?*GHookList, [*c]GHook) callconv(.C) void;
pub const G_HOOK_FLAG_ACTIVE: c_int = 1;
pub const G_HOOK_FLAG_IN_CALL: c_int = 2;
pub const G_HOOK_FLAG_MASK: c_int = 15;
pub const GHookFlagMask = c_uint;
pub extern fn g_hook_list_init(hook_list: ?*GHookList, hook_size: guint) void;
pub extern fn g_hook_list_clear(hook_list: ?*GHookList) void;
pub extern fn g_hook_alloc(hook_list: ?*GHookList) [*c]GHook;
pub extern fn g_hook_free(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_ref(hook_list: ?*GHookList, hook: [*c]GHook) [*c]GHook;
pub extern fn g_hook_unref(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_destroy(hook_list: ?*GHookList, hook_id: gulong) gboolean;
pub extern fn g_hook_destroy_link(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_prepend(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_insert_before(hook_list: ?*GHookList, sibling: [*c]GHook, hook: [*c]GHook) void;
pub extern fn g_hook_insert_sorted(hook_list: ?*GHookList, hook: [*c]GHook, func: GHookCompareFunc) void;
pub extern fn g_hook_get(hook_list: ?*GHookList, hook_id: gulong) [*c]GHook;
pub extern fn g_hook_find(hook_list: ?*GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) [*c]GHook;
pub extern fn g_hook_find_data(hook_list: ?*GHookList, need_valids: gboolean, data: gpointer) [*c]GHook;
pub extern fn g_hook_find_func(hook_list: ?*GHookList, need_valids: gboolean, func: gpointer) [*c]GHook;
pub extern fn g_hook_find_func_data(hook_list: ?*GHookList, need_valids: gboolean, func: gpointer, data: gpointer) [*c]GHook;
pub extern fn g_hook_first_valid(hook_list: ?*GHookList, may_be_in_call: gboolean) [*c]GHook;
pub extern fn g_hook_next_valid(hook_list: ?*GHookList, hook: [*c]GHook, may_be_in_call: gboolean) [*c]GHook;
pub extern fn g_hook_compare_ids(new_hook: [*c]GHook, sibling: [*c]GHook) gint;
pub extern fn g_hook_list_invoke(hook_list: ?*GHookList, may_recurse: gboolean) void;
pub extern fn g_hook_list_invoke_check(hook_list: ?*GHookList, may_recurse: gboolean) void;
pub extern fn g_hook_list_marshal(hook_list: ?*GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer) void;
pub extern fn g_hook_list_marshal_check(hook_list: ?*GHookList, may_recurse: gboolean, marshaller: GHookCheckMarshaller, marshal_data: gpointer) void;
pub extern fn g_hostname_is_non_ascii(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_is_ascii_encoded(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_is_ip_address(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_to_ascii(hostname: [*c]const gchar) [*c]gchar;
pub extern fn g_hostname_to_unicode(hostname: [*c]const gchar) [*c]gchar;
pub const struct__GPollFD = extern struct {
    fd: gint,
    events: gushort,
    revents: gushort,
};
pub const GPollFD = struct__GPollFD;
pub const GPollFunc = ?*const fn ([*c]GPollFD, guint, gint) callconv(.C) gint;
pub extern fn g_poll(fds: [*c]GPollFD, nfds: guint, timeout: gint) gint;
pub const GSList = struct__GSList;
pub const struct__GSList = extern struct {
    data: gpointer,
    next: [*c]GSList,
};
pub extern fn g_slist_alloc() [*c]GSList;
pub extern fn g_slist_free(list: [*c]GSList) void;
pub extern fn g_slist_free_1(list: [*c]GSList) void;
pub extern fn g_slist_free_full(list: [*c]GSList, free_func: GDestroyNotify) void;
pub extern fn g_slist_append(list: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_prepend(list: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_insert(list: [*c]GSList, data: gpointer, position: gint) [*c]GSList;
pub extern fn g_slist_insert_sorted(list: [*c]GSList, data: gpointer, func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_insert_sorted_with_data(list: [*c]GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_insert_before(slist: [*c]GSList, sibling: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_concat(list1: [*c]GSList, list2: [*c]GSList) [*c]GSList;
pub extern fn g_slist_remove(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_remove_all(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_remove_link(list: [*c]GSList, link_: [*c]GSList) [*c]GSList;
pub extern fn g_slist_delete_link(list: [*c]GSList, link_: [*c]GSList) [*c]GSList;
pub extern fn g_slist_reverse(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_copy(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_copy_deep(list: [*c]GSList, func: GCopyFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_nth(list: [*c]GSList, n: guint) [*c]GSList;
pub extern fn g_slist_find(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_find_custom(list: [*c]GSList, data: gconstpointer, func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_position(list: [*c]GSList, llink: [*c]GSList) gint;
pub extern fn g_slist_index(list: [*c]GSList, data: gconstpointer) gint;
pub extern fn g_slist_last(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_length(list: [*c]GSList) guint;
pub extern fn g_slist_foreach(list: [*c]GSList, func: GFunc, user_data: gpointer) void;
pub extern fn g_slist_sort(list: [*c]GSList, compare_func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_sort_with_data(list: [*c]GSList, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_nth_data(list: [*c]GSList, n: guint) gpointer;
pub extern fn g_clear_slist(slist_ptr: [*c][*c]GSList, destroy: GDestroyNotify) void;
pub const G_IO_IN: c_int = 1;
pub const G_IO_OUT: c_int = 4;
pub const G_IO_PRI: c_int = 2;
pub const G_IO_ERR: c_int = 8;
pub const G_IO_HUP: c_int = 16;
pub const G_IO_NVAL: c_int = 32;
pub const GIOCondition = c_uint;
pub const G_MAIN_CONTEXT_FLAGS_NONE: c_int = 0;
pub const G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: c_int = 1;
pub const GMainContextFlags = c_uint;
pub const struct__GMainContext = opaque {};
pub const GMainContext = struct__GMainContext;
pub const struct__GMainLoop = opaque {};
pub const GMainLoop = struct__GMainLoop;
pub const GSource = struct__GSource;
pub const GSourceFunc = ?*const fn (gpointer) callconv(.C) gboolean;
pub const struct__GSourceCallbackFuncs = extern struct {
    ref: ?*const fn (gpointer) callconv(.C) void,
    unref: ?*const fn (gpointer) callconv(.C) void,
    get: ?*const fn (gpointer, [*c]GSource, [*c]GSourceFunc, [*c]gpointer) callconv(.C) void,
};
pub const GSourceCallbackFuncs = struct__GSourceCallbackFuncs;
pub const GSourceDummyMarshal = ?*const fn () callconv(.C) void;
pub const struct__GSourceFuncs = extern struct {
    prepare: ?*const fn ([*c]GSource, [*c]gint) callconv(.C) gboolean,
    check: ?*const fn ([*c]GSource) callconv(.C) gboolean,
    dispatch: ?*const fn ([*c]GSource, GSourceFunc, gpointer) callconv(.C) gboolean,
    finalize: ?*const fn ([*c]GSource) callconv(.C) void,
    closure_callback: GSourceFunc,
    closure_marshal: GSourceDummyMarshal,
};
pub const GSourceFuncs = struct__GSourceFuncs;
pub const struct__GSourcePrivate = opaque {};
pub const GSourcePrivate = struct__GSourcePrivate;
pub const struct__GSource = extern struct {
    callback_data: gpointer,
    callback_funcs: [*c]GSourceCallbackFuncs,
    source_funcs: [*c]const GSourceFuncs,
    ref_count: guint,
    context: ?*GMainContext,
    priority: gint,
    flags: guint,
    source_id: guint,
    poll_fds: [*c]GSList,
    prev: [*c]GSource,
    next: [*c]GSource,
    name: [*c]u8,
    priv: ?*GSourcePrivate,
};
pub const GSourceOnceFunc = ?*const fn (gpointer) callconv(.C) void;
pub const GChildWatchFunc = ?*const fn (GPid, gint, gpointer) callconv(.C) void;
pub const GSourceDisposeFunc = ?*const fn ([*c]GSource) callconv(.C) void;
pub extern fn g_main_context_new() ?*GMainContext;
pub extern fn g_main_context_new_with_flags(flags: GMainContextFlags) ?*GMainContext;
pub extern fn g_main_context_ref(context: ?*GMainContext) ?*GMainContext;
pub extern fn g_main_context_unref(context: ?*GMainContext) void;
pub extern fn g_main_context_default() ?*GMainContext;
pub extern fn g_main_context_iteration(context: ?*GMainContext, may_block: gboolean) gboolean;
pub extern fn g_main_context_pending(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_find_source_by_id(context: ?*GMainContext, source_id: guint) [*c]GSource;
pub extern fn g_main_context_find_source_by_user_data(context: ?*GMainContext, user_data: gpointer) [*c]GSource;
pub extern fn g_main_context_find_source_by_funcs_user_data(context: ?*GMainContext, funcs: [*c]GSourceFuncs, user_data: gpointer) [*c]GSource;
pub extern fn g_main_context_wakeup(context: ?*GMainContext) void;
pub extern fn g_main_context_acquire(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_release(context: ?*GMainContext) void;
pub extern fn g_main_context_is_owner(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_wait(context: ?*GMainContext, cond: [*c]GCond, mutex: [*c]GMutex) gboolean;
pub extern fn g_main_context_prepare(context: ?*GMainContext, priority: [*c]gint) gboolean;
pub extern fn g_main_context_query(context: ?*GMainContext, max_priority: gint, timeout_: [*c]gint, fds: [*c]GPollFD, n_fds: gint) gint;
pub extern fn g_main_context_check(context: ?*GMainContext, max_priority: gint, fds: [*c]GPollFD, n_fds: gint) gboolean;
pub extern fn g_main_context_dispatch(context: ?*GMainContext) void;
pub extern fn g_main_context_set_poll_func(context: ?*GMainContext, func: GPollFunc) void;
pub extern fn g_main_context_get_poll_func(context: ?*GMainContext) GPollFunc;
pub extern fn g_main_context_add_poll(context: ?*GMainContext, fd: [*c]GPollFD, priority: gint) void;
pub extern fn g_main_context_remove_poll(context: ?*GMainContext, fd: [*c]GPollFD) void;
pub extern fn g_main_depth() gint;
pub extern fn g_main_current_source() [*c]GSource;
pub extern fn g_main_context_push_thread_default(context: ?*GMainContext) void;
pub extern fn g_main_context_pop_thread_default(context: ?*GMainContext) void;
pub extern fn g_main_context_get_thread_default() ?*GMainContext;
pub extern fn g_main_context_ref_thread_default() ?*GMainContext;
pub const GMainContextPusher = anyopaque;
pub fn g_main_context_pusher_new(arg_main_context: ?*GMainContext) callconv(.C) ?*GMainContextPusher {
    var main_context = arg_main_context;
    g_main_context_push_thread_default(main_context);
    return @as(?*GMainContextPusher, @ptrCast(main_context));
}
pub fn g_main_context_pusher_free(arg_pusher: ?*GMainContextPusher) callconv(.C) void {
    var pusher = arg_pusher;
    g_main_context_pop_thread_default(@as(?*GMainContext, @ptrCast(pusher)));
}
pub extern fn g_main_loop_new(context: ?*GMainContext, is_running: gboolean) ?*GMainLoop;
pub extern fn g_main_loop_run(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_quit(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_ref(loop: ?*GMainLoop) ?*GMainLoop;
pub extern fn g_main_loop_unref(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_is_running(loop: ?*GMainLoop) gboolean;
pub extern fn g_main_loop_get_context(loop: ?*GMainLoop) ?*GMainContext;
pub extern fn g_source_new(source_funcs: [*c]GSourceFuncs, struct_size: guint) [*c]GSource;
pub extern fn g_source_set_dispose_function(source: [*c]GSource, dispose: GSourceDisposeFunc) void;
pub extern fn g_source_ref(source: [*c]GSource) [*c]GSource;
pub extern fn g_source_unref(source: [*c]GSource) void;
pub extern fn g_source_attach(source: [*c]GSource, context: ?*GMainContext) guint;
pub extern fn g_source_destroy(source: [*c]GSource) void;
pub extern fn g_source_set_priority(source: [*c]GSource, priority: gint) void;
pub extern fn g_source_get_priority(source: [*c]GSource) gint;
pub extern fn g_source_set_can_recurse(source: [*c]GSource, can_recurse: gboolean) void;
pub extern fn g_source_get_can_recurse(source: [*c]GSource) gboolean;
pub extern fn g_source_get_id(source: [*c]GSource) guint;
pub extern fn g_source_get_context(source: [*c]GSource) ?*GMainContext;
pub extern fn g_source_set_callback(source: [*c]GSource, func: GSourceFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_source_set_funcs(source: [*c]GSource, funcs: [*c]GSourceFuncs) void;
pub extern fn g_source_is_destroyed(source: [*c]GSource) gboolean;
pub extern fn g_source_set_name(source: [*c]GSource, name: [*c]const u8) void;
pub extern fn g_source_set_static_name(source: [*c]GSource, name: [*c]const u8) void;
pub extern fn g_source_get_name(source: [*c]GSource) [*c]const u8;
pub extern fn g_source_set_name_by_id(tag: guint, name: [*c]const u8) void;
pub extern fn g_source_set_ready_time(source: [*c]GSource, ready_time: gint64) void;
pub extern fn g_source_get_ready_time(source: [*c]GSource) gint64;
pub extern fn g_source_add_unix_fd(source: [*c]GSource, fd: gint, events: GIOCondition) gpointer;
pub extern fn g_source_modify_unix_fd(source: [*c]GSource, tag: gpointer, new_events: GIOCondition) void;
pub extern fn g_source_remove_unix_fd(source: [*c]GSource, tag: gpointer) void;
pub extern fn g_source_query_unix_fd(source: [*c]GSource, tag: gpointer) GIOCondition;
pub extern fn g_source_set_callback_indirect(source: [*c]GSource, callback_data: gpointer, callback_funcs: [*c]GSourceCallbackFuncs) void;
pub extern fn g_source_add_poll(source: [*c]GSource, fd: [*c]GPollFD) void;
pub extern fn g_source_remove_poll(source: [*c]GSource, fd: [*c]GPollFD) void;
pub extern fn g_source_add_child_source(source: [*c]GSource, child_source: [*c]GSource) void;
pub extern fn g_source_remove_child_source(source: [*c]GSource, child_source: [*c]GSource) void;
pub extern fn g_source_get_current_time(source: [*c]GSource, timeval: [*c]GTimeVal) void;
pub extern fn g_source_get_time(source: [*c]GSource) gint64;
pub extern fn g_idle_source_new() [*c]GSource;
pub extern fn g_child_watch_source_new(pid: GPid) [*c]GSource;
pub extern fn g_timeout_source_new(interval: guint) [*c]GSource;
pub extern fn g_timeout_source_new_seconds(interval: guint) [*c]GSource;
pub extern fn g_get_current_time(result: [*c]GTimeVal) void;
pub extern fn g_get_monotonic_time() gint64;
pub extern fn g_get_real_time() gint64;
pub extern fn g_source_remove(tag: guint) gboolean;
pub extern fn g_source_remove_by_user_data(user_data: gpointer) gboolean;
pub extern fn g_source_remove_by_funcs_user_data(funcs: [*c]GSourceFuncs, user_data: gpointer) gboolean;
pub const GClearHandleFunc = ?*const fn (guint) callconv(.C) void;
pub extern fn g_clear_handle_id(tag_ptr: [*c]guint, clear_func: GClearHandleFunc) void;
pub extern fn g_timeout_add_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) guint;
pub extern fn g_timeout_add_seconds_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn g_timeout_add_seconds_once(interval: guint, function: GSourceOnceFunc, data: gpointer) guint;
pub extern fn g_child_watch_add_full(priority: gint, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) guint;
pub extern fn g_idle_add(function: GSourceFunc, data: gpointer) guint;
pub extern fn g_idle_add_full(priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) guint;
pub extern fn g_idle_remove_by_data(data: gpointer) gboolean;
pub extern fn g_main_context_invoke_full(context: ?*GMainContext, priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_main_context_invoke(context: ?*GMainContext, function: GSourceFunc, data: gpointer) void;
pub fn g_steal_fd(arg_fd_ptr: [*c]c_int) callconv(.C) c_int {
    var fd_ptr = arg_fd_ptr;
    var fd: c_int = fd_ptr.*;
    fd_ptr.* = -@as(c_int, 1);
    return fd;
}
pub extern var g_timeout_funcs: GSourceFuncs;
pub extern var g_child_watch_funcs: GSourceFuncs;
pub extern var g_idle_funcs: GSourceFuncs;
pub extern var g_unix_signal_funcs: GSourceFuncs;
pub extern var g_unix_fd_source_funcs: GSourceFuncs;
pub const gunichar = guint32;
pub const gunichar2 = guint16;
pub const G_UNICODE_CONTROL: c_int = 0;
pub const G_UNICODE_FORMAT: c_int = 1;
pub const G_UNICODE_UNASSIGNED: c_int = 2;
pub const G_UNICODE_PRIVATE_USE: c_int = 3;
pub const G_UNICODE_SURROGATE: c_int = 4;
pub const G_UNICODE_LOWERCASE_LETTER: c_int = 5;
pub const G_UNICODE_MODIFIER_LETTER: c_int = 6;
pub const G_UNICODE_OTHER_LETTER: c_int = 7;
pub const G_UNICODE_TITLECASE_LETTER: c_int = 8;
pub const G_UNICODE_UPPERCASE_LETTER: c_int = 9;
pub const G_UNICODE_SPACING_MARK: c_int = 10;
pub const G_UNICODE_ENCLOSING_MARK: c_int = 11;
pub const G_UNICODE_NON_SPACING_MARK: c_int = 12;
pub const G_UNICODE_DECIMAL_NUMBER: c_int = 13;
pub const G_UNICODE_LETTER_NUMBER: c_int = 14;
pub const G_UNICODE_OTHER_NUMBER: c_int = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION: c_int = 16;
pub const G_UNICODE_DASH_PUNCTUATION: c_int = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION: c_int = 18;
pub const G_UNICODE_FINAL_PUNCTUATION: c_int = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION: c_int = 20;
pub const G_UNICODE_OTHER_PUNCTUATION: c_int = 21;
pub const G_UNICODE_OPEN_PUNCTUATION: c_int = 22;
pub const G_UNICODE_CURRENCY_SYMBOL: c_int = 23;
pub const G_UNICODE_MODIFIER_SYMBOL: c_int = 24;
pub const G_UNICODE_MATH_SYMBOL: c_int = 25;
pub const G_UNICODE_OTHER_SYMBOL: c_int = 26;
pub const G_UNICODE_LINE_SEPARATOR: c_int = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR: c_int = 28;
pub const G_UNICODE_SPACE_SEPARATOR: c_int = 29;
pub const GUnicodeType = c_uint;
pub const G_UNICODE_BREAK_MANDATORY: c_int = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN: c_int = 1;
pub const G_UNICODE_BREAK_LINE_FEED: c_int = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK: c_int = 3;
pub const G_UNICODE_BREAK_SURROGATE: c_int = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE: c_int = 5;
pub const G_UNICODE_BREAK_INSEPARABLE: c_int = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE: c_int = 7;
pub const G_UNICODE_BREAK_CONTINGENT: c_int = 8;
pub const G_UNICODE_BREAK_SPACE: c_int = 9;
pub const G_UNICODE_BREAK_AFTER: c_int = 10;
pub const G_UNICODE_BREAK_BEFORE: c_int = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER: c_int = 12;
pub const G_UNICODE_BREAK_HYPHEN: c_int = 13;
pub const G_UNICODE_BREAK_NON_STARTER: c_int = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION: c_int = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION: c_int = 16;
pub const G_UNICODE_BREAK_QUOTATION: c_int = 17;
pub const G_UNICODE_BREAK_EXCLAMATION: c_int = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC: c_int = 19;
pub const G_UNICODE_BREAK_NUMERIC: c_int = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR: c_int = 21;
pub const G_UNICODE_BREAK_SYMBOL: c_int = 22;
pub const G_UNICODE_BREAK_ALPHABETIC: c_int = 23;
pub const G_UNICODE_BREAK_PREFIX: c_int = 24;
pub const G_UNICODE_BREAK_POSTFIX: c_int = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT: c_int = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS: c_int = 27;
pub const G_UNICODE_BREAK_UNKNOWN: c_int = 28;
pub const G_UNICODE_BREAK_NEXT_LINE: c_int = 29;
pub const G_UNICODE_BREAK_WORD_JOINER: c_int = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO: c_int = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO: c_int = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO: c_int = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: c_int = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: c_int = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS: c_int = 36;
pub const G_UNICODE_BREAK_CLOSE_PARENTHESIS: c_int = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: c_int = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER: c_int = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR: c_int = 39;
pub const G_UNICODE_BREAK_EMOJI_BASE: c_int = 40;
pub const G_UNICODE_BREAK_EMOJI_MODIFIER: c_int = 41;
pub const G_UNICODE_BREAK_ZERO_WIDTH_JOINER: c_int = 42;
pub const GUnicodeBreakType = c_uint;
pub const G_UNICODE_SCRIPT_INVALID_CODE: c_int = -1;
pub const G_UNICODE_SCRIPT_COMMON: c_int = 0;
pub const G_UNICODE_SCRIPT_INHERITED: c_int = 1;
pub const G_UNICODE_SCRIPT_ARABIC: c_int = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN: c_int = 3;
pub const G_UNICODE_SCRIPT_BENGALI: c_int = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO: c_int = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE: c_int = 6;
pub const G_UNICODE_SCRIPT_COPTIC: c_int = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC: c_int = 8;
pub const G_UNICODE_SCRIPT_DESERET: c_int = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI: c_int = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC: c_int = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN: c_int = 12;
pub const G_UNICODE_SCRIPT_GOTHIC: c_int = 13;
pub const G_UNICODE_SCRIPT_GREEK: c_int = 14;
pub const G_UNICODE_SCRIPT_GUJARATI: c_int = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI: c_int = 16;
pub const G_UNICODE_SCRIPT_HAN: c_int = 17;
pub const G_UNICODE_SCRIPT_HANGUL: c_int = 18;
pub const G_UNICODE_SCRIPT_HEBREW: c_int = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA: c_int = 20;
pub const G_UNICODE_SCRIPT_KANNADA: c_int = 21;
pub const G_UNICODE_SCRIPT_KATAKANA: c_int = 22;
pub const G_UNICODE_SCRIPT_KHMER: c_int = 23;
pub const G_UNICODE_SCRIPT_LAO: c_int = 24;
pub const G_UNICODE_SCRIPT_LATIN: c_int = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM: c_int = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN: c_int = 27;
pub const G_UNICODE_SCRIPT_MYANMAR: c_int = 28;
pub const G_UNICODE_SCRIPT_OGHAM: c_int = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC: c_int = 30;
pub const G_UNICODE_SCRIPT_ORIYA: c_int = 31;
pub const G_UNICODE_SCRIPT_RUNIC: c_int = 32;
pub const G_UNICODE_SCRIPT_SINHALA: c_int = 33;
pub const G_UNICODE_SCRIPT_SYRIAC: c_int = 34;
pub const G_UNICODE_SCRIPT_TAMIL: c_int = 35;
pub const G_UNICODE_SCRIPT_TELUGU: c_int = 36;
pub const G_UNICODE_SCRIPT_THAANA: c_int = 37;
pub const G_UNICODE_SCRIPT_THAI: c_int = 38;
pub const G_UNICODE_SCRIPT_TIBETAN: c_int = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: c_int = 40;
pub const G_UNICODE_SCRIPT_YI: c_int = 41;
pub const G_UNICODE_SCRIPT_TAGALOG: c_int = 42;
pub const G_UNICODE_SCRIPT_HANUNOO: c_int = 43;
pub const G_UNICODE_SCRIPT_BUHID: c_int = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA: c_int = 45;
pub const G_UNICODE_SCRIPT_BRAILLE: c_int = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT: c_int = 47;
pub const G_UNICODE_SCRIPT_LIMBU: c_int = 48;
pub const G_UNICODE_SCRIPT_OSMANYA: c_int = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN: c_int = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B: c_int = 51;
pub const G_UNICODE_SCRIPT_TAI_LE: c_int = 52;
pub const G_UNICODE_SCRIPT_UGARITIC: c_int = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE: c_int = 54;
pub const G_UNICODE_SCRIPT_BUGINESE: c_int = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC: c_int = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH: c_int = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI: c_int = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN: c_int = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI: c_int = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN: c_int = 61;
pub const G_UNICODE_SCRIPT_BALINESE: c_int = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM: c_int = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN: c_int = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA: c_int = 65;
pub const G_UNICODE_SCRIPT_NKO: c_int = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI: c_int = 67;
pub const G_UNICODE_SCRIPT_LEPCHA: c_int = 68;
pub const G_UNICODE_SCRIPT_REJANG: c_int = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE: c_int = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA: c_int = 71;
pub const G_UNICODE_SCRIPT_CHAM: c_int = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI: c_int = 73;
pub const G_UNICODE_SCRIPT_VAI: c_int = 74;
pub const G_UNICODE_SCRIPT_CARIAN: c_int = 75;
pub const G_UNICODE_SCRIPT_LYCIAN: c_int = 76;
pub const G_UNICODE_SCRIPT_LYDIAN: c_int = 77;
pub const G_UNICODE_SCRIPT_AVESTAN: c_int = 78;
pub const G_UNICODE_SCRIPT_BAMUM: c_int = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: c_int = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: c_int = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: c_int = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: c_int = 83;
pub const G_UNICODE_SCRIPT_JAVANESE: c_int = 84;
pub const G_UNICODE_SCRIPT_KAITHI: c_int = 85;
pub const G_UNICODE_SCRIPT_LISU: c_int = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK: c_int = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: c_int = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC: c_int = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN: c_int = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM: c_int = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET: c_int = 92;
pub const G_UNICODE_SCRIPT_BATAK: c_int = 93;
pub const G_UNICODE_SCRIPT_BRAHMI: c_int = 94;
pub const G_UNICODE_SCRIPT_MANDAIC: c_int = 95;
pub const G_UNICODE_SCRIPT_CHAKMA: c_int = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE: c_int = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: c_int = 98;
pub const G_UNICODE_SCRIPT_MIAO: c_int = 99;
pub const G_UNICODE_SCRIPT_SHARADA: c_int = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG: c_int = 101;
pub const G_UNICODE_SCRIPT_TAKRI: c_int = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH: c_int = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: c_int = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN: c_int = 105;
pub const G_UNICODE_SCRIPT_ELBASAN: c_int = 106;
pub const G_UNICODE_SCRIPT_GRANTHA: c_int = 107;
pub const G_UNICODE_SCRIPT_KHOJKI: c_int = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI: c_int = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A: c_int = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI: c_int = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN: c_int = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI: c_int = 113;
pub const G_UNICODE_SCRIPT_MODI: c_int = 114;
pub const G_UNICODE_SCRIPT_MRO: c_int = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN: c_int = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: c_int = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC: c_int = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG: c_int = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE: c_int = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU: c_int = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI: c_int = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM: c_int = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA: c_int = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI: c_int = 125;
pub const G_UNICODE_SCRIPT_AHOM: c_int = 126;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: c_int = 127;
pub const G_UNICODE_SCRIPT_HATRAN: c_int = 128;
pub const G_UNICODE_SCRIPT_MULTANI: c_int = 129;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN: c_int = 130;
pub const G_UNICODE_SCRIPT_SIGNWRITING: c_int = 131;
pub const G_UNICODE_SCRIPT_ADLAM: c_int = 132;
pub const G_UNICODE_SCRIPT_BHAIKSUKI: c_int = 133;
pub const G_UNICODE_SCRIPT_MARCHEN: c_int = 134;
pub const G_UNICODE_SCRIPT_NEWA: c_int = 135;
pub const G_UNICODE_SCRIPT_OSAGE: c_int = 136;
pub const G_UNICODE_SCRIPT_TANGUT: c_int = 137;
pub const G_UNICODE_SCRIPT_MASARAM_GONDI: c_int = 138;
pub const G_UNICODE_SCRIPT_NUSHU: c_int = 139;
pub const G_UNICODE_SCRIPT_SOYOMBO: c_int = 140;
pub const G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: c_int = 141;
pub const G_UNICODE_SCRIPT_DOGRA: c_int = 142;
pub const G_UNICODE_SCRIPT_GUNJALA_GONDI: c_int = 143;
pub const G_UNICODE_SCRIPT_HANIFI_ROHINGYA: c_int = 144;
pub const G_UNICODE_SCRIPT_MAKASAR: c_int = 145;
pub const G_UNICODE_SCRIPT_MEDEFAIDRIN: c_int = 146;
pub const G_UNICODE_SCRIPT_OLD_SOGDIAN: c_int = 147;
pub const G_UNICODE_SCRIPT_SOGDIAN: c_int = 148;
pub const G_UNICODE_SCRIPT_ELYMAIC: c_int = 149;
pub const G_UNICODE_SCRIPT_NANDINAGARI: c_int = 150;
pub const G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: c_int = 151;
pub const G_UNICODE_SCRIPT_WANCHO: c_int = 152;
pub const G_UNICODE_SCRIPT_CHORASMIAN: c_int = 153;
pub const G_UNICODE_SCRIPT_DIVES_AKURU: c_int = 154;
pub const G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: c_int = 155;
pub const G_UNICODE_SCRIPT_YEZIDI: c_int = 156;
pub const G_UNICODE_SCRIPT_CYPRO_MINOAN: c_int = 157;
pub const G_UNICODE_SCRIPT_OLD_UYGHUR: c_int = 158;
pub const G_UNICODE_SCRIPT_TANGSA: c_int = 159;
pub const G_UNICODE_SCRIPT_TOTO: c_int = 160;
pub const G_UNICODE_SCRIPT_VITHKUQI: c_int = 161;
pub const G_UNICODE_SCRIPT_MATH: c_int = 162;
pub const G_UNICODE_SCRIPT_KAWI: c_int = 163;
pub const G_UNICODE_SCRIPT_NAG_MUNDARI: c_int = 164;
pub const GUnicodeScript = c_int;
pub extern fn g_unicode_script_to_iso15924(script: GUnicodeScript) guint32;
pub extern fn g_unicode_script_from_iso15924(iso15924: guint32) GUnicodeScript;
pub extern fn g_unichar_isalnum(c: gunichar) gboolean;
pub extern fn g_unichar_isalpha(c: gunichar) gboolean;
pub extern fn g_unichar_iscntrl(c: gunichar) gboolean;
pub extern fn g_unichar_isdigit(c: gunichar) gboolean;
pub extern fn g_unichar_isgraph(c: gunichar) gboolean;
pub extern fn g_unichar_islower(c: gunichar) gboolean;
pub extern fn g_unichar_isprint(c: gunichar) gboolean;
pub extern fn g_unichar_ispunct(c: gunichar) gboolean;
pub extern fn g_unichar_isspace(c: gunichar) gboolean;
pub extern fn g_unichar_isupper(c: gunichar) gboolean;
pub extern fn g_unichar_isxdigit(c: gunichar) gboolean;
pub extern fn g_unichar_istitle(c: gunichar) gboolean;
pub extern fn g_unichar_isdefined(c: gunichar) gboolean;
pub extern fn g_unichar_iswide(c: gunichar) gboolean;
pub extern fn g_unichar_iswide_cjk(c: gunichar) gboolean;
pub extern fn g_unichar_iszerowidth(c: gunichar) gboolean;
pub extern fn g_unichar_ismark(c: gunichar) gboolean;
pub extern fn g_unichar_toupper(c: gunichar) gunichar;
pub extern fn g_unichar_tolower(c: gunichar) gunichar;
pub extern fn g_unichar_totitle(c: gunichar) gunichar;
pub extern fn g_unichar_digit_value(c: gunichar) gint;
pub extern fn g_unichar_xdigit_value(c: gunichar) gint;
pub extern fn g_unichar_type(c: gunichar) GUnicodeType;
pub extern fn g_unichar_break_type(c: gunichar) GUnicodeBreakType;
pub extern fn g_unichar_combining_class(uc: gunichar) gint;
pub extern fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: [*c]gunichar) gboolean;
pub extern fn g_unichar_get_script(ch: gunichar) GUnicodeScript;
pub extern fn g_unichar_validate(ch: gunichar) gboolean;
pub extern fn g_unichar_compose(a: gunichar, b: gunichar, ch: [*c]gunichar) gboolean;
pub extern fn g_unichar_decompose(ch: gunichar, a: [*c]gunichar, b: [*c]gunichar) gboolean;
pub extern fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean, result: [*c]gunichar, result_len: gsize) gsize;
pub extern fn g_unicode_canonical_ordering(string: [*c]gunichar, len: gsize) void;
pub extern fn g_unicode_canonical_decomposition(ch: gunichar, result_len: [*c]gsize) [*c]gunichar;
pub extern const g_utf8_skip: [*c]const gchar;
pub extern fn g_utf8_get_char(p: [*c]const gchar) gunichar;
pub extern fn g_utf8_get_char_validated(p: [*c]const gchar, max_len: gssize) gunichar;
pub extern fn g_utf8_offset_to_pointer(str: [*c]const gchar, offset: glong) [*c]gchar;
pub extern fn g_utf8_pointer_to_offset(str: [*c]const gchar, pos: [*c]const gchar) glong;
pub extern fn g_utf8_prev_char(p: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_find_next_char(p: [*c]const gchar, end: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_find_prev_char(str: [*c]const gchar, p: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_strlen(p: [*c]const gchar, max: gssize) glong;
pub extern fn g_utf8_substring(str: [*c]const gchar, start_pos: glong, end_pos: glong) [*c]gchar;
pub extern fn g_utf8_strncpy(dest: [*c]gchar, src: [*c]const gchar, n: gsize) [*c]gchar;
pub extern fn g_utf8_truncate_middle(string: [*c]const gchar, truncate_length: gsize) [*c]gchar;
pub extern fn g_utf8_strchr(p: [*c]const gchar, len: gssize, c: gunichar) [*c]gchar;
pub extern fn g_utf8_strrchr(p: [*c]const gchar, len: gssize, c: gunichar) [*c]gchar;
pub extern fn g_utf8_strreverse(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_to_utf16(str: [*c]const gchar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar2;
pub extern fn g_utf8_to_ucs4(str: [*c]const gchar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar;
pub extern fn g_utf8_to_ucs4_fast(str: [*c]const gchar, len: glong, items_written: [*c]glong) [*c]gunichar;
pub extern fn g_utf16_to_ucs4(str: [*c]const gunichar2, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar;
pub extern fn g_utf16_to_utf8(str: [*c]const gunichar2, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_ucs4_to_utf16(str: [*c]const gunichar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gunichar2;
pub extern fn g_ucs4_to_utf8(str: [*c]const gunichar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_unichar_to_utf8(c: gunichar, outbuf: [*c]gchar) gint;
pub extern fn g_utf8_validate(str: [*c]const gchar, max_len: gssize, end: [*c][*c]const gchar) gboolean;
pub extern fn g_utf8_validate_len(str: [*c]const gchar, max_len: gsize, end: [*c][*c]const gchar) gboolean;
pub extern fn g_utf8_strup(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_strdown(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_casefold(str: [*c]const gchar, len: gssize) [*c]gchar;
pub const G_NORMALIZE_DEFAULT: c_int = 0;
pub const G_NORMALIZE_NFD: c_int = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE: c_int = 1;
pub const G_NORMALIZE_NFC: c_int = 1;
pub const G_NORMALIZE_ALL: c_int = 2;
pub const G_NORMALIZE_NFKD: c_int = 2;
pub const G_NORMALIZE_ALL_COMPOSE: c_int = 3;
pub const G_NORMALIZE_NFKC: c_int = 3;
pub const GNormalizeMode = c_uint;
pub extern fn g_utf8_normalize(str: [*c]const gchar, len: gssize, mode: GNormalizeMode) [*c]gchar;
pub extern fn g_utf8_collate(str1: [*c]const gchar, str2: [*c]const gchar) gint;
pub extern fn g_utf8_collate_key(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_collate_key_for_filename(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_make_valid(str: [*c]const gchar, len: gssize) [*c]gchar;
pub const G_ASCII_ALNUM: c_int = 1;
pub const G_ASCII_ALPHA: c_int = 2;
pub const G_ASCII_CNTRL: c_int = 4;
pub const G_ASCII_DIGIT: c_int = 8;
pub const G_ASCII_GRAPH: c_int = 16;
pub const G_ASCII_LOWER: c_int = 32;
pub const G_ASCII_PRINT: c_int = 64;
pub const G_ASCII_PUNCT: c_int = 128;
pub const G_ASCII_SPACE: c_int = 256;
pub const G_ASCII_UPPER: c_int = 512;
pub const G_ASCII_XDIGIT: c_int = 1024;
pub const GAsciiType = c_uint;
pub extern const g_ascii_table: [*c]const guint16;
pub extern fn g_ascii_tolower(c: gchar) gchar;
pub extern fn g_ascii_toupper(c: gchar) gchar;
pub extern fn g_ascii_digit_value(c: gchar) gint;
pub extern fn g_ascii_xdigit_value(c: gchar) gint;
pub extern fn g_strdelimit(string: [*c]gchar, delimiters: [*c]const gchar, new_delimiter: gchar) [*c]gchar;
pub extern fn g_strcanon(string: [*c]gchar, valid_chars: [*c]const gchar, substitutor: gchar) [*c]gchar;
pub extern fn g_strerror(errnum: gint) [*c]const gchar;
pub extern fn g_strsignal(signum: gint) [*c]const gchar;
pub extern fn g_strreverse(string: [*c]gchar) [*c]gchar;
pub extern fn g_strlcpy(dest: [*c]gchar, src: [*c]const gchar, dest_size: gsize) gsize;
pub extern fn g_strlcat(dest: [*c]gchar, src: [*c]const gchar, dest_size: gsize) gsize;
pub extern fn g_strstr_len(haystack: [*c]const gchar, haystack_len: gssize, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_strrstr(haystack: [*c]const gchar, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_strrstr_len(haystack: [*c]const gchar, haystack_len: gssize, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_str_has_suffix(str: [*c]const gchar, suffix: [*c]const gchar) gboolean;
pub extern fn g_str_has_prefix(str: [*c]const gchar, prefix: [*c]const gchar) gboolean;
pub extern fn g_strtod(nptr: [*c]const gchar, endptr: [*c][*c]gchar) gdouble;
pub extern fn g_ascii_strtod(nptr: [*c]const gchar, endptr: [*c][*c]gchar) gdouble;
pub extern fn g_ascii_strtoull(nptr: [*c]const gchar, endptr: [*c][*c]gchar, base: guint) guint64;
pub extern fn g_ascii_strtoll(nptr: [*c]const gchar, endptr: [*c][*c]gchar, base: guint) gint64;
pub extern fn g_ascii_dtostr(buffer: [*c]gchar, buf_len: gint, d: gdouble) [*c]gchar;
pub extern fn g_ascii_formatd(buffer: [*c]gchar, buf_len: gint, format: [*c]const gchar, d: gdouble) [*c]gchar;
pub extern fn g_strchug(string: [*c]gchar) [*c]gchar;
pub extern fn g_strchomp(string: [*c]gchar) [*c]gchar;
pub extern fn g_ascii_strcasecmp(s1: [*c]const gchar, s2: [*c]const gchar) gint;
pub extern fn g_ascii_strncasecmp(s1: [*c]const gchar, s2: [*c]const gchar, n: gsize) gint;
pub extern fn g_ascii_strdown(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_ascii_strup(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_str_is_ascii(str: [*c]const gchar) gboolean;
pub extern fn g_strcasecmp(s1: [*c]const gchar, s2: [*c]const gchar) gint;
pub extern fn g_strncasecmp(s1: [*c]const gchar, s2: [*c]const gchar, n: guint) gint;
pub extern fn g_strdown(string: [*c]gchar) [*c]gchar;
pub extern fn g_strup(string: [*c]gchar) [*c]gchar;
pub extern fn g_strdup(str: [*c]const gchar) [*c]gchar;
pub extern fn g_strdup_printf(format: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strdup_vprintf(format: [*c]const gchar, args: [*c]struct___va_list_tag) [*c]gchar;
pub extern fn g_strndup(str: [*c]const gchar, n: gsize) [*c]gchar;
pub extern fn g_strnfill(length: gsize, fill_char: gchar) [*c]gchar;
pub extern fn g_strconcat(string1: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strjoin(separator: [*c]const gchar, ...) [*c]gchar;
pub inline fn g_strdup_inline(arg_str: [*c]const u8) [*c]u8 {
    var str = arg_str;
    if ((__builtin_constant_p(!(str != null)) != 0) and !(str != null)) return null;
    if (((__builtin_constant_p(!!(str != null)) != 0) and !!(str != null)) and (__builtin_constant_p(strlen(str)) != 0)) {
        const len: usize = strlen(str) +% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1))));
        var dup_str: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(g_malloc(len))));
        return @as([*c]u8, @ptrCast(@alignCast(memcpy(@as(?*anyopaque, @ptrCast(dup_str)), @as(?*const anyopaque, @ptrCast(str)), len))));
    }
    return g_strdup(str);
}
pub extern fn g_strcompress(source: [*c]const gchar) [*c]gchar;
pub extern fn g_strescape(source: [*c]const gchar, exceptions: [*c]const gchar) [*c]gchar;
pub extern fn g_memdup(mem: gconstpointer, byte_size: guint) gpointer;
pub extern fn g_memdup2(mem: gconstpointer, byte_size: gsize) gpointer;
pub const GStrv = [*c][*c]gchar;
pub extern fn g_strsplit(string: [*c]const gchar, delimiter: [*c]const gchar, max_tokens: gint) [*c][*c]gchar;
pub extern fn g_strsplit_set(string: [*c]const gchar, delimiters: [*c]const gchar, max_tokens: gint) [*c][*c]gchar;
pub extern fn g_strjoinv(separator: [*c]const gchar, str_array: [*c][*c]gchar) [*c]gchar;
pub extern fn g_strfreev(str_array: [*c][*c]gchar) void;
pub extern fn g_strdupv(str_array: [*c][*c]gchar) [*c][*c]gchar;
pub extern fn g_strv_length(str_array: [*c][*c]gchar) guint;
pub extern fn g_stpcpy(dest: [*c]gchar, src: [*c]const u8) [*c]gchar;
pub extern fn g_str_to_ascii(str: [*c]const gchar, from_locale: [*c]const gchar) [*c]gchar;
pub extern fn g_str_tokenize_and_fold(string: [*c]const gchar, translit_locale: [*c]const gchar, ascii_alternates: [*c][*c][*c]gchar) [*c][*c]gchar;
pub extern fn g_str_match_string(search_term: [*c]const gchar, potential_hit: [*c]const gchar, accept_alternates: gboolean) gboolean;
pub extern fn g_strv_contains(strv: [*c]const [*c]const gchar, str: [*c]const gchar) gboolean;
pub extern fn g_strv_equal(strv1: [*c]const [*c]const gchar, strv2: [*c]const [*c]const gchar) gboolean;
pub const G_NUMBER_PARSER_ERROR_INVALID: c_int = 0;
pub const G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: c_int = 1;
pub const GNumberParserError = c_uint;
pub extern fn g_number_parser_error_quark() GQuark;
pub extern fn g_ascii_string_to_signed(str: [*c]const gchar, base: guint, min: gint64, max: gint64, out_num: [*c]gint64, @"error": [*c][*c]GError) gboolean;
pub extern fn g_ascii_string_to_unsigned(str: [*c]const gchar, base: guint, min: guint64, max: guint64, out_num: [*c]guint64, @"error": [*c][*c]GError) gboolean;
pub fn g_set_str(arg_str_pointer: [*c][*c]u8, arg_new_str: [*c]const u8) callconv(.C) gboolean {
    var str_pointer = arg_str_pointer;
    var new_str = arg_new_str;
    var copy: [*c]u8 = undefined;
    if ((str_pointer.* == @as([*c]u8, @ptrCast(@volatileCast(@constCast(new_str))))) or (((str_pointer.* != null) and (new_str != null)) and (strcmp(str_pointer.*, new_str) == @as(c_int, 0)))) return @as(c_int, 0);
    copy = g_strdup_inline(new_str);
    g_free(@as(gpointer, @ptrCast(str_pointer.*)));
    str_pointer.* = copy;
    return @intFromBool(!(@as(c_int, 0) != 0));
}
pub const struct__GString = extern struct {
    str: [*c]gchar,
    len: gsize,
    allocated_len: gsize,
};
pub const GString = struct__GString;
pub extern fn g_string_new(init: [*c]const gchar) [*c]GString;
pub extern fn g_string_new_take(init: [*c]gchar) [*c]GString;
pub extern fn g_string_new_len(init: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_sized_new(dfl_size: gsize) [*c]GString;
pub extern fn g_string_free(string: [*c]GString, free_segment: gboolean) [*c]gchar;
pub extern fn g_string_free_and_steal(string: [*c]GString) [*c]gchar;
pub extern fn g_string_free_to_bytes(string: [*c]GString) ?*GBytes;
pub extern fn g_string_equal(v: [*c]const GString, v2: [*c]const GString) gboolean;
pub extern fn g_string_hash(str: [*c]const GString) guint;
pub extern fn g_string_assign(string: [*c]GString, rval: [*c]const gchar) [*c]GString;
pub extern fn g_string_truncate(string: [*c]GString, len: gsize) [*c]GString;
pub extern fn g_string_set_size(string: [*c]GString, len: gsize) [*c]GString;
pub extern fn g_string_insert_len(string: [*c]GString, pos: gssize, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_append(string: [*c]GString, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_append_len(string: [*c]GString, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_append_c(string: [*c]GString, c: gchar) [*c]GString;
pub extern fn g_string_append_unichar(string: [*c]GString, wc: gunichar) [*c]GString;
pub extern fn g_string_prepend(string: [*c]GString, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_prepend_c(string: [*c]GString, c: gchar) [*c]GString;
pub extern fn g_string_prepend_unichar(string: [*c]GString, wc: gunichar) [*c]GString;
pub extern fn g_string_prepend_len(string: [*c]GString, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_insert(string: [*c]GString, pos: gssize, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_insert_c(string: [*c]GString, pos: gssize, c: gchar) [*c]GString;
pub extern fn g_string_insert_unichar(string: [*c]GString, pos: gssize, wc: gunichar) [*c]GString;
pub extern fn g_string_overwrite(string: [*c]GString, pos: gsize, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_overwrite_len(string: [*c]GString, pos: gsize, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_erase(string: [*c]GString, pos: gssize, len: gssize) [*c]GString;
pub extern fn g_string_replace(string: [*c]GString, find: [*c]const gchar, replace: [*c]const gchar, limit: guint) guint;
pub extern fn g_string_ascii_down(string: [*c]GString) [*c]GString;
pub extern fn g_string_ascii_up(string: [*c]GString) [*c]GString;
pub extern fn g_string_vprintf(string: [*c]GString, format: [*c]const gchar, args: [*c]struct___va_list_tag) void;
pub extern fn g_string_printf(string: [*c]GString, format: [*c]const gchar, ...) void;
pub extern fn g_string_append_vprintf(string: [*c]GString, format: [*c]const gchar, args: [*c]struct___va_list_tag) void;
pub extern fn g_string_append_printf(string: [*c]GString, format: [*c]const gchar, ...) void;
pub extern fn g_string_append_uri_escaped(string: [*c]GString, unescaped: [*c]const gchar, reserved_chars_allowed: [*c]const gchar, allow_utf8: gboolean) [*c]GString;
pub inline fn g_string_append_c_inline(arg_gstring: [*c]GString, arg_c: gchar) [*c]GString {
    var gstring = arg_gstring;
    var c = arg_c;
    if ((gstring != @as([*c]GString, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) and ((gstring.*.len +% @as(gsize, @bitCast(@as(c_long, @as(c_int, 1))))) < gstring.*.allocated_len)) {
        gstring.*.str[blk: {
                const ref = &gstring.*.len;
                const tmp = ref.*;
                ref.* +%= 1;
                break :blk tmp;
            }] = c;
        gstring.*.str[gstring.*.len] = 0;
    } else {
        _ = g_string_insert_c(gstring, @as(gssize, @bitCast(@as(c_long, -@as(c_int, 1)))), c);
    }
    return gstring;
}
pub inline fn g_string_append_len_inline(arg_gstring: [*c]GString, arg_val: [*c]const u8, arg_len: gssize) [*c]GString {
    var gstring = arg_gstring;
    var val = arg_val;
    var len = arg_len;
    var len_unsigned: gsize = undefined;
    if (gstring == @as([*c]GString, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) return g_string_append_len(gstring, val, len);
    if (val == @as([*c]const u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) return if (len != @as(gssize, @bitCast(@as(c_long, @as(c_int, 0))))) g_string_append_len(gstring, val, len) else gstring;
    if (len < @as(gssize, @bitCast(@as(c_long, @as(c_int, 0))))) {
        len_unsigned = strlen(val);
    } else {
        len_unsigned = @as(gsize, @bitCast(len));
    }
    if ((gstring.*.len +% len_unsigned) < gstring.*.allocated_len) {
        var end: [*c]u8 = gstring.*.str + gstring.*.len;
        if (((val + len_unsigned) <= @as([*c]const u8, @ptrCast(@alignCast(end)))) or (val > @as([*c]const u8, @ptrCast(@alignCast(end + len_unsigned))))) {
            _ = memcpy(@as(?*anyopaque, @ptrCast(end)), @as(?*const anyopaque, @ptrCast(val)), len_unsigned);
        } else {
            _ = memmove(@as(?*anyopaque, @ptrCast(end)), @as(?*const anyopaque, @ptrCast(val)), len_unsigned);
        }
        gstring.*.len +%= len_unsigned;
        gstring.*.str[gstring.*.len] = 0;
        return gstring;
    } else return g_string_insert_len(gstring, @as(gssize, @bitCast(@as(c_long, -@as(c_int, 1)))), val, len);
    return null;
}
pub inline fn g_string_truncate_inline(arg_gstring: [*c]GString, arg_len: gsize) [*c]GString {
    var gstring = arg_gstring;
    var len = arg_len;
    gstring.*.len = if (len < gstring.*.len) len else gstring.*.len;
    gstring.*.str[gstring.*.len] = '\x00';
    return gstring;
}
pub extern fn g_string_down(string: [*c]GString) [*c]GString;
pub extern fn g_string_up(string: [*c]GString) [*c]GString;
pub const GIOChannel = struct__GIOChannel;
pub const struct__GIOFuncs = extern struct {
    io_read: ?*const fn (?*GIOChannel, [*c]gchar, gsize, [*c]gsize, [*c][*c]GError) callconv(.C) GIOStatus,
    io_write: ?*const fn (?*GIOChannel, [*c]const gchar, gsize, [*c]gsize, [*c][*c]GError) callconv(.C) GIOStatus,
    io_seek: ?*const fn (?*GIOChannel, gint64, GSeekType, [*c][*c]GError) callconv(.C) GIOStatus,
    io_close: ?*const fn (?*GIOChannel, [*c][*c]GError) callconv(.C) GIOStatus,
    io_create_watch: ?*const fn (?*GIOChannel, GIOCondition) callconv(.C) [*c]GSource,
    io_free: ?*const fn (?*GIOChannel) callconv(.C) void,
    io_set_flags: ?*const fn (?*GIOChannel, GIOFlags, [*c][*c]GError) callconv(.C) GIOStatus,
    io_get_flags: ?*const fn (?*GIOChannel) callconv(.C) GIOFlags,
};
pub const GIOFuncs = struct__GIOFuncs; // /usr/include/glib-2.0/glib/giochannel.h:120:9: warning: struct demoted to opaque type - has bitfield
pub const struct__GIOChannel = opaque {};
pub const G_IO_ERROR_NONE: c_int = 0;
pub const G_IO_ERROR_AGAIN: c_int = 1;
pub const G_IO_ERROR_INVAL: c_int = 2;
pub const G_IO_ERROR_UNKNOWN: c_int = 3;
pub const GIOError = c_uint;
pub const G_IO_CHANNEL_ERROR_FBIG: c_int = 0;
pub const G_IO_CHANNEL_ERROR_INVAL: c_int = 1;
pub const G_IO_CHANNEL_ERROR_IO: c_int = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR: c_int = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC: c_int = 4;
pub const G_IO_CHANNEL_ERROR_NXIO: c_int = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW: c_int = 6;
pub const G_IO_CHANNEL_ERROR_PIPE: c_int = 7;
pub const G_IO_CHANNEL_ERROR_FAILED: c_int = 8;
pub const GIOChannelError = c_uint;
pub const G_IO_STATUS_ERROR: c_int = 0;
pub const G_IO_STATUS_NORMAL: c_int = 1;
pub const G_IO_STATUS_EOF: c_int = 2;
pub const G_IO_STATUS_AGAIN: c_int = 3;
pub const GIOStatus = c_uint;
pub const G_SEEK_CUR: c_int = 0;
pub const G_SEEK_SET: c_int = 1;
pub const G_SEEK_END: c_int = 2;
pub const GSeekType = c_uint;
pub const G_IO_FLAG_NONE: c_int = 0;
pub const G_IO_FLAG_APPEND: c_int = 1;
pub const G_IO_FLAG_NONBLOCK: c_int = 2;
pub const G_IO_FLAG_IS_READABLE: c_int = 4;
pub const G_IO_FLAG_IS_WRITABLE: c_int = 8;
pub const G_IO_FLAG_IS_WRITEABLE: c_int = 8;
pub const G_IO_FLAG_IS_SEEKABLE: c_int = 16;
pub const G_IO_FLAG_MASK: c_int = 31;
pub const G_IO_FLAG_GET_MASK: c_int = 31;
pub const G_IO_FLAG_SET_MASK: c_int = 3;
pub const GIOFlags = c_uint;
pub const GIOFunc = ?*const fn (?*GIOChannel, GIOCondition, gpointer) callconv(.C) gboolean;
pub extern fn g_io_channel_init(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_ref(channel: ?*GIOChannel) ?*GIOChannel;
pub extern fn g_io_channel_unref(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_read(channel: ?*GIOChannel, buf: [*c]gchar, count: gsize, bytes_read: [*c]gsize) GIOError;
pub extern fn g_io_channel_write(channel: ?*GIOChannel, buf: [*c]const gchar, count: gsize, bytes_written: [*c]gsize) GIOError;
pub extern fn g_io_channel_seek(channel: ?*GIOChannel, offset: gint64, @"type": GSeekType) GIOError;
pub extern fn g_io_channel_close(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_shutdown(channel: ?*GIOChannel, flush: gboolean, err: [*c][*c]GError) GIOStatus;
pub extern fn g_io_add_watch_full(channel: ?*GIOChannel, priority: gint, condition: GIOCondition, func: GIOFunc, user_data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_io_create_watch(channel: ?*GIOChannel, condition: GIOCondition) [*c]GSource;
pub extern fn g_io_add_watch(channel: ?*GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) guint;
pub extern fn g_io_channel_set_buffer_size(channel: ?*GIOChannel, size: gsize) void;
pub extern fn g_io_channel_get_buffer_size(channel: ?*GIOChannel) gsize;
pub extern fn g_io_channel_get_buffer_condition(channel: ?*GIOChannel) GIOCondition;
pub extern fn g_io_channel_set_flags(channel: ?*GIOChannel, flags: GIOFlags, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_get_flags(channel: ?*GIOChannel) GIOFlags;
pub extern fn g_io_channel_set_line_term(channel: ?*GIOChannel, line_term: [*c]const gchar, length: gint) void;
pub extern fn g_io_channel_get_line_term(channel: ?*GIOChannel, length: [*c]gint) [*c]const gchar;
pub extern fn g_io_channel_set_buffered(channel: ?*GIOChannel, buffered: gboolean) void;
pub extern fn g_io_channel_get_buffered(channel: ?*GIOChannel) gboolean;
pub extern fn g_io_channel_set_encoding(channel: ?*GIOChannel, encoding: [*c]const gchar, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_get_encoding(channel: ?*GIOChannel) [*c]const gchar;
pub extern fn g_io_channel_set_close_on_unref(channel: ?*GIOChannel, do_close: gboolean) void;
pub extern fn g_io_channel_get_close_on_unref(channel: ?*GIOChannel) gboolean;
pub extern fn g_io_channel_flush(channel: ?*GIOChannel, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_line(channel: ?*GIOChannel, str_return: [*c][*c]gchar, length: [*c]gsize, terminator_pos: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_line_string(channel: ?*GIOChannel, buffer: [*c]GString, terminator_pos: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_to_end(channel: ?*GIOChannel, str_return: [*c][*c]gchar, length: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_chars(channel: ?*GIOChannel, buf: [*c]gchar, count: gsize, bytes_read: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_read_unichar(channel: ?*GIOChannel, thechar: [*c]gunichar, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_write_chars(channel: ?*GIOChannel, buf: [*c]const gchar, count: gssize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_write_unichar(channel: ?*GIOChannel, thechar: gunichar, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_seek_position(channel: ?*GIOChannel, offset: gint64, @"type": GSeekType, @"error": [*c][*c]GError) GIOStatus;
pub extern fn g_io_channel_new_file(filename: [*c]const gchar, mode: [*c]const gchar, @"error": [*c][*c]GError) ?*GIOChannel;
pub extern fn g_io_channel_error_quark() GQuark;
pub extern fn g_io_channel_error_from_errno(en: gint) GIOChannelError;
pub extern fn g_io_channel_unix_new(fd: c_int) ?*GIOChannel;
pub extern fn g_io_channel_unix_get_fd(channel: ?*GIOChannel) gint;
pub extern var g_io_watch_funcs: GSourceFuncs;
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING: c_int = 0;
pub const G_KEY_FILE_ERROR_PARSE: c_int = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND: c_int = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND: c_int = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND: c_int = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE: c_int = 5;
pub const GKeyFileError = c_uint;
pub extern fn g_key_file_error_quark() GQuark;
pub const struct__GKeyFile = opaque {};
pub const GKeyFile = struct__GKeyFile;
pub const G_KEY_FILE_NONE: c_int = 0;
pub const G_KEY_FILE_KEEP_COMMENTS: c_int = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS: c_int = 2;
pub const GKeyFileFlags = c_uint;
pub extern fn g_key_file_new() ?*GKeyFile;
pub extern fn g_key_file_ref(key_file: ?*GKeyFile) ?*GKeyFile;
pub extern fn g_key_file_unref(key_file: ?*GKeyFile) void;
pub extern fn g_key_file_free(key_file: ?*GKeyFile) void;
pub extern fn g_key_file_set_list_separator(key_file: ?*GKeyFile, separator: gchar) void;
pub extern fn g_key_file_load_from_file(key_file: ?*GKeyFile, file: [*c]const gchar, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_data(key_file: ?*GKeyFile, data: [*c]const gchar, length: gsize, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_bytes(key_file: ?*GKeyFile, bytes: ?*GBytes, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_dirs(key_file: ?*GKeyFile, file: [*c]const gchar, search_dirs: [*c][*c]const gchar, full_path: [*c][*c]gchar, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_load_from_data_dirs(key_file: ?*GKeyFile, file: [*c]const gchar, full_path: [*c][*c]gchar, flags: GKeyFileFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_to_data(key_file: ?*GKeyFile, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_save_to_file(key_file: ?*GKeyFile, filename: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_get_start_group(key_file: ?*GKeyFile) [*c]gchar;
pub extern fn g_key_file_get_groups(key_file: ?*GKeyFile, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_key_file_get_keys(key_file: ?*GKeyFile, group_name: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_key_file_has_group(key_file: ?*GKeyFile, group_name: [*c]const gchar) gboolean;
pub extern fn g_key_file_has_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_get_value(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_set_value(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn g_key_file_get_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_set_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, string: [*c]const gchar) void;
pub extern fn g_key_file_get_locale_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_get_locale_for_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar) [*c]gchar;
pub extern fn g_key_file_set_locale_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, string: [*c]const gchar) void;
pub extern fn g_key_file_get_boolean(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_set_boolean(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gboolean) void;
pub extern fn g_key_file_get_integer(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gint;
pub extern fn g_key_file_set_integer(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gint) void;
pub extern fn g_key_file_get_int64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gint64;
pub extern fn g_key_file_set_int64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gint64) void;
pub extern fn g_key_file_get_uint64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) guint64;
pub extern fn g_key_file_set_uint64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: guint64) void;
pub extern fn g_key_file_get_double(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gdouble;
pub extern fn g_key_file_set_double(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gdouble) void;
pub extern fn g_key_file_get_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_key_file_set_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]const [*c]const gchar, length: gsize) void;
pub extern fn g_key_file_get_locale_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_key_file_set_locale_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, list: [*c]const [*c]const gchar, length: gsize) void;
pub extern fn g_key_file_get_boolean_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gboolean;
pub extern fn g_key_file_set_boolean_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gboolean, length: gsize) void;
pub extern fn g_key_file_get_integer_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gint;
pub extern fn g_key_file_set_double_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gdouble, length: gsize) void;
pub extern fn g_key_file_get_double_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c][*c]GError) [*c]gdouble;
pub extern fn g_key_file_set_integer_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gint, length: gsize) void;
pub extern fn g_key_file_set_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, comment: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_get_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_key_file_remove_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_remove_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_key_file_remove_group(key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub const struct__GMappedFile = opaque {};
pub const GMappedFile = struct__GMappedFile;
pub extern fn g_mapped_file_new(filename: [*c]const gchar, writable: gboolean, @"error": [*c][*c]GError) ?*GMappedFile;
pub extern fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean, @"error": [*c][*c]GError) ?*GMappedFile;
pub extern fn g_mapped_file_get_length(file: ?*GMappedFile) gsize;
pub extern fn g_mapped_file_get_contents(file: ?*GMappedFile) [*c]gchar;
pub extern fn g_mapped_file_get_bytes(file: ?*GMappedFile) ?*GBytes;
pub extern fn g_mapped_file_ref(file: ?*GMappedFile) ?*GMappedFile;
pub extern fn g_mapped_file_unref(file: ?*GMappedFile) void;
pub extern fn g_mapped_file_free(file: ?*GMappedFile) void;
pub const G_MARKUP_ERROR_BAD_UTF8: c_int = 0;
pub const G_MARKUP_ERROR_EMPTY: c_int = 1;
pub const G_MARKUP_ERROR_PARSE: c_int = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT: c_int = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: c_int = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT: c_int = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE: c_int = 6;
pub const GMarkupError = c_uint;
pub extern fn g_markup_error_quark() GQuark;
pub const G_MARKUP_DEFAULT_FLAGS: c_int = 0;
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: c_int = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT: c_int = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION: c_int = 4;
pub const G_MARKUP_IGNORE_QUALIFIED: c_int = 8;
pub const GMarkupParseFlags = c_uint;
pub const struct__GMarkupParseContext = opaque {};
pub const GMarkupParseContext = struct__GMarkupParseContext;
pub const struct__GMarkupParser = extern struct {
    start_element: ?*const fn (?*GMarkupParseContext, [*c]const gchar, [*c][*c]const gchar, [*c][*c]const gchar, gpointer, [*c][*c]GError) callconv(.C) void,
    end_element: ?*const fn (?*GMarkupParseContext, [*c]const gchar, gpointer, [*c][*c]GError) callconv(.C) void,
    text: ?*const fn (?*GMarkupParseContext, [*c]const gchar, gsize, gpointer, [*c][*c]GError) callconv(.C) void,
    passthrough: ?*const fn (?*GMarkupParseContext, [*c]const gchar, gsize, gpointer, [*c][*c]GError) callconv(.C) void,
    @"error": ?*const fn (?*GMarkupParseContext, [*c]GError, gpointer) callconv(.C) void,
};
pub const GMarkupParser = struct__GMarkupParser;
pub extern fn g_markup_parse_context_new(parser: [*c]const GMarkupParser, flags: GMarkupParseFlags, user_data: gpointer, user_data_dnotify: GDestroyNotify) ?*GMarkupParseContext;
pub extern fn g_markup_parse_context_ref(context: ?*GMarkupParseContext) ?*GMarkupParseContext;
pub extern fn g_markup_parse_context_unref(context: ?*GMarkupParseContext) void;
pub extern fn g_markup_parse_context_free(context: ?*GMarkupParseContext) void;
pub extern fn g_markup_parse_context_parse(context: ?*GMarkupParseContext, text: [*c]const gchar, text_len: gssize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_markup_parse_context_push(context: ?*GMarkupParseContext, parser: [*c]const GMarkupParser, user_data: gpointer) void;
pub extern fn g_markup_parse_context_pop(context: ?*GMarkupParseContext) gpointer;
pub extern fn g_markup_parse_context_end_parse(context: ?*GMarkupParseContext, @"error": [*c][*c]GError) gboolean;
pub extern fn g_markup_parse_context_get_element(context: ?*GMarkupParseContext) [*c]const gchar;
pub extern fn g_markup_parse_context_get_element_stack(context: ?*GMarkupParseContext) [*c]const GSList;
pub extern fn g_markup_parse_context_get_position(context: ?*GMarkupParseContext, line_number: [*c]gint, char_number: [*c]gint) void;
pub extern fn g_markup_parse_context_get_user_data(context: ?*GMarkupParseContext) gpointer;
pub extern fn g_markup_escape_text(text: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_markup_printf_escaped(format: [*c]const u8, ...) [*c]gchar;
pub extern fn g_markup_vprintf_escaped(format: [*c]const u8, args: [*c]struct___va_list_tag) [*c]gchar;
pub const G_MARKUP_COLLECT_INVALID: c_int = 0;
pub const G_MARKUP_COLLECT_STRING: c_int = 1;
pub const G_MARKUP_COLLECT_STRDUP: c_int = 2;
pub const G_MARKUP_COLLECT_BOOLEAN: c_int = 3;
pub const G_MARKUP_COLLECT_TRISTATE: c_int = 4;
pub const G_MARKUP_COLLECT_OPTIONAL: c_int = 65536;
pub const GMarkupCollectType = c_uint;
pub extern fn g_markup_collect_attributes(element_name: [*c]const gchar, attribute_names: [*c][*c]const gchar, attribute_values: [*c][*c]const gchar, @"error": [*c][*c]GError, first_type: GMarkupCollectType, first_attr: [*c]const gchar, ...) gboolean;
pub const struct__GVariantType = opaque {};
pub const GVariantType = struct__GVariantType;
pub extern fn g_variant_type_string_is_valid(type_string: [*c]const gchar) gboolean;
pub extern fn g_variant_type_string_scan(string: [*c]const gchar, limit: [*c]const gchar, endptr: [*c][*c]const gchar) gboolean;
pub extern fn g_variant_type_free(@"type": ?*GVariantType) void;
pub extern fn g_variant_type_copy(@"type": ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new(type_string: [*c]const gchar) ?*GVariantType;
pub extern fn g_variant_type_get_string_length(@"type": ?*const GVariantType) gsize;
pub extern fn g_variant_type_peek_string(@"type": ?*const GVariantType) [*c]const gchar;
pub extern fn g_variant_type_dup_string(@"type": ?*const GVariantType) [*c]gchar;
pub extern fn g_variant_type_is_definite(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_container(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_basic(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_maybe(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_array(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_tuple(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_dict_entry(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_variant(@"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_type_hash(@"type": gconstpointer) guint;
pub extern fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) gboolean;
pub extern fn g_variant_type_is_subtype_of(@"type": ?*const GVariantType, supertype: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_element(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_first(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_next(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_n_items(@"type": ?*const GVariantType) gsize;
pub extern fn g_variant_type_key(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_value(@"type": ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_new_array(element: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new_maybe(element: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new_tuple(items: [*c]const ?*const GVariantType, length: gint) ?*GVariantType;
pub extern fn g_variant_type_new_dict_entry(key: ?*const GVariantType, value: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_checked_([*c]const gchar) ?*const GVariantType;
pub extern fn g_variant_type_string_get_depth_(type_string: [*c]const gchar) gsize;
pub const struct__GVariant = opaque {};
pub const GVariant = struct__GVariant;
pub const G_VARIANT_CLASS_BOOLEAN: c_int = 98;
pub const G_VARIANT_CLASS_BYTE: c_int = 121;
pub const G_VARIANT_CLASS_INT16: c_int = 110;
pub const G_VARIANT_CLASS_UINT16: c_int = 113;
pub const G_VARIANT_CLASS_INT32: c_int = 105;
pub const G_VARIANT_CLASS_UINT32: c_int = 117;
pub const G_VARIANT_CLASS_INT64: c_int = 120;
pub const G_VARIANT_CLASS_UINT64: c_int = 116;
pub const G_VARIANT_CLASS_HANDLE: c_int = 104;
pub const G_VARIANT_CLASS_DOUBLE: c_int = 100;
pub const G_VARIANT_CLASS_STRING: c_int = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH: c_int = 111;
pub const G_VARIANT_CLASS_SIGNATURE: c_int = 103;
pub const G_VARIANT_CLASS_VARIANT: c_int = 118;
pub const G_VARIANT_CLASS_MAYBE: c_int = 109;
pub const G_VARIANT_CLASS_ARRAY: c_int = 97;
pub const G_VARIANT_CLASS_TUPLE: c_int = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY: c_int = 123;
pub const GVariantClass = c_uint;
pub extern fn g_variant_unref(value: ?*GVariant) void;
pub extern fn g_variant_ref(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_ref_sink(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_is_floating(value: ?*GVariant) gboolean;
pub extern fn g_variant_take_ref(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_type(value: ?*GVariant) ?*const GVariantType;
pub extern fn g_variant_get_type_string(value: ?*GVariant) [*c]const gchar;
pub extern fn g_variant_is_of_type(value: ?*GVariant, @"type": ?*const GVariantType) gboolean;
pub extern fn g_variant_is_container(value: ?*GVariant) gboolean;
pub extern fn g_variant_classify(value: ?*GVariant) GVariantClass;
pub extern fn g_variant_new_boolean(value: gboolean) ?*GVariant;
pub extern fn g_variant_new_byte(value: guint8) ?*GVariant;
pub extern fn g_variant_new_int16(value: gint16) ?*GVariant;
pub extern fn g_variant_new_uint16(value: guint16) ?*GVariant;
pub extern fn g_variant_new_int32(value: gint32) ?*GVariant;
pub extern fn g_variant_new_uint32(value: guint32) ?*GVariant;
pub extern fn g_variant_new_int64(value: gint64) ?*GVariant;
pub extern fn g_variant_new_uint64(value: guint64) ?*GVariant;
pub extern fn g_variant_new_handle(value: gint32) ?*GVariant;
pub extern fn g_variant_new_double(value: gdouble) ?*GVariant;
pub extern fn g_variant_new_string(string: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_new_take_string(string: [*c]gchar) ?*GVariant;
pub extern fn g_variant_new_printf(format_string: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_new_object_path(object_path: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_is_object_path(string: [*c]const gchar) gboolean;
pub extern fn g_variant_new_signature(signature: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_is_signature(string: [*c]const gchar) gboolean;
pub extern fn g_variant_new_variant(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_strv(strv: [*c]const [*c]const gchar, length: gssize) ?*GVariant;
pub extern fn g_variant_new_objv(strv: [*c]const [*c]const gchar, length: gssize) ?*GVariant;
pub extern fn g_variant_new_bytestring(string: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_new_bytestring_array(strv: [*c]const [*c]const gchar, length: gssize) ?*GVariant;
pub extern fn g_variant_new_fixed_array(element_type: ?*const GVariantType, elements: gconstpointer, n_elements: gsize, element_size: gsize) ?*GVariant;
pub extern fn g_variant_get_boolean(value: ?*GVariant) gboolean;
pub extern fn g_variant_get_byte(value: ?*GVariant) guint8;
pub extern fn g_variant_get_int16(value: ?*GVariant) gint16;
pub extern fn g_variant_get_uint16(value: ?*GVariant) guint16;
pub extern fn g_variant_get_int32(value: ?*GVariant) gint32;
pub extern fn g_variant_get_uint32(value: ?*GVariant) guint32;
pub extern fn g_variant_get_int64(value: ?*GVariant) gint64;
pub extern fn g_variant_get_uint64(value: ?*GVariant) guint64;
pub extern fn g_variant_get_handle(value: ?*GVariant) gint32;
pub extern fn g_variant_get_double(value: ?*GVariant) gdouble;
pub extern fn g_variant_get_variant(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_string(value: ?*GVariant, length: [*c]gsize) [*c]const gchar;
pub extern fn g_variant_dup_string(value: ?*GVariant, length: [*c]gsize) [*c]gchar;
pub extern fn g_variant_get_strv(value: ?*GVariant, length: [*c]gsize) [*c][*c]const gchar;
pub extern fn g_variant_dup_strv(value: ?*GVariant, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_variant_get_objv(value: ?*GVariant, length: [*c]gsize) [*c][*c]const gchar;
pub extern fn g_variant_dup_objv(value: ?*GVariant, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_variant_get_bytestring(value: ?*GVariant) [*c]const gchar;
pub extern fn g_variant_dup_bytestring(value: ?*GVariant, length: [*c]gsize) [*c]gchar;
pub extern fn g_variant_get_bytestring_array(value: ?*GVariant, length: [*c]gsize) [*c][*c]const gchar;
pub extern fn g_variant_dup_bytestring_array(value: ?*GVariant, length: [*c]gsize) [*c][*c]gchar;
pub extern fn g_variant_new_maybe(child_type: ?*const GVariantType, child: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_array(child_type: ?*const GVariantType, children: [*c]const ?*GVariant, n_children: gsize) ?*GVariant;
pub extern fn g_variant_new_tuple(children: [*c]const ?*GVariant, n_children: gsize) ?*GVariant;
pub extern fn g_variant_new_dict_entry(key: ?*GVariant, value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_maybe(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_n_children(value: ?*GVariant) gsize;
pub extern fn g_variant_get_child(value: ?*GVariant, index_: gsize, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_get_child_value(value: ?*GVariant, index_: gsize) ?*GVariant;
pub extern fn g_variant_lookup(dictionary: ?*GVariant, key: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_lookup_value(dictionary: ?*GVariant, key: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_variant_get_fixed_array(value: ?*GVariant, n_elements: [*c]gsize, element_size: gsize) gconstpointer;
pub extern fn g_variant_get_size(value: ?*GVariant) gsize;
pub extern fn g_variant_get_data(value: ?*GVariant) gconstpointer;
pub extern fn g_variant_get_data_as_bytes(value: ?*GVariant) ?*GBytes;
pub extern fn g_variant_store(value: ?*GVariant, data: gpointer) void;
pub extern fn g_variant_print(value: ?*GVariant, type_annotate: gboolean) [*c]gchar;
pub extern fn g_variant_print_string(value: ?*GVariant, string: [*c]GString, type_annotate: gboolean) [*c]GString;
pub extern fn g_variant_hash(value: gconstpointer) guint;
pub extern fn g_variant_equal(one: gconstpointer, two: gconstpointer) gboolean;
pub extern fn g_variant_get_normal_form(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_is_normal_form(value: ?*GVariant) gboolean;
pub extern fn g_variant_byteswap(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_from_bytes(@"type": ?*const GVariantType, bytes: ?*GBytes, trusted: gboolean) ?*GVariant;
pub extern fn g_variant_new_from_data(@"type": ?*const GVariantType, data: gconstpointer, size: gsize, trusted: gboolean, notify: GDestroyNotify, user_data: gpointer) ?*GVariant;
pub const struct__GVariantIter = extern struct {
    x: [16]guintptr,
};
pub const GVariantIter = struct__GVariantIter;
pub extern fn g_variant_iter_new(value: ?*GVariant) [*c]GVariantIter;
pub extern fn g_variant_iter_init(iter: [*c]GVariantIter, value: ?*GVariant) gsize;
pub extern fn g_variant_iter_copy(iter: [*c]GVariantIter) [*c]GVariantIter;
pub extern fn g_variant_iter_n_children(iter: [*c]GVariantIter) gsize;
pub extern fn g_variant_iter_free(iter: [*c]GVariantIter) void;
pub extern fn g_variant_iter_next_value(iter: [*c]GVariantIter) ?*GVariant;
pub extern fn g_variant_iter_next(iter: [*c]GVariantIter, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_iter_loop(iter: [*c]GVariantIter, format_string: [*c]const gchar, ...) gboolean;
const struct_unnamed_29 = extern struct {
    partial_magic: gsize,
    type: ?*const GVariantType,
    y: [14]guintptr,
};
const union_unnamed_28 = extern union {
    s: struct_unnamed_29,
    x: [16]guintptr,
};
pub const struct__GVariantBuilder = extern struct {
    u: union_unnamed_28,
};
pub const GVariantBuilder = struct__GVariantBuilder;
pub const G_VARIANT_PARSE_ERROR_FAILED: c_int = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: c_int = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: c_int = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: c_int = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: c_int = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: c_int = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: c_int = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: c_int = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: c_int = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: c_int = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: c_int = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: c_int = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: c_int = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR: c_int = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: c_int = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: c_int = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: c_int = 16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: c_int = 17;
pub const G_VARIANT_PARSE_ERROR_RECURSION: c_int = 18;
pub const GVariantParseError = c_uint;
pub extern fn g_variant_parser_get_error_quark() GQuark;
pub extern fn g_variant_parse_error_quark() GQuark;
pub extern fn g_variant_builder_new(@"type": ?*const GVariantType) [*c]GVariantBuilder;
pub extern fn g_variant_builder_unref(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_ref(builder: [*c]GVariantBuilder) [*c]GVariantBuilder;
pub extern fn g_variant_builder_init(builder: [*c]GVariantBuilder, @"type": ?*const GVariantType) void;
pub extern fn g_variant_builder_end(builder: [*c]GVariantBuilder) ?*GVariant;
pub extern fn g_variant_builder_clear(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_open(builder: [*c]GVariantBuilder, @"type": ?*const GVariantType) void;
pub extern fn g_variant_builder_close(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_add_value(builder: [*c]GVariantBuilder, value: ?*GVariant) void;
pub extern fn g_variant_builder_add(builder: [*c]GVariantBuilder, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_builder_add_parsed(builder: [*c]GVariantBuilder, format: [*c]const gchar, ...) void;
pub extern fn g_variant_new(format_string: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_get(value: ?*GVariant, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_new_va(format_string: [*c]const gchar, endptr: [*c][*c]const gchar, app: [*c]va_list) ?*GVariant;
pub extern fn g_variant_get_va(value: ?*GVariant, format_string: [*c]const gchar, endptr: [*c][*c]const gchar, app: [*c]va_list) void;
pub extern fn g_variant_check_format_string(value: ?*GVariant, format_string: [*c]const gchar, copy_only: gboolean) gboolean;
pub extern fn g_variant_parse(@"type": ?*const GVariantType, text: [*c]const gchar, limit: [*c]const gchar, endptr: [*c][*c]const gchar, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_variant_new_parsed(format: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_new_parsed_va(format: [*c]const gchar, app: [*c]va_list) ?*GVariant;
pub extern fn g_variant_parse_error_print_context(@"error": [*c]GError, source_str: [*c]const gchar) [*c]gchar;
pub extern fn g_variant_compare(one: gconstpointer, two: gconstpointer) gint;
const struct_unnamed_31 = extern struct {
    asv: ?*GVariant,
    partial_magic: gsize,
    y: [14]guintptr,
};
const union_unnamed_30 = extern union {
    s: struct_unnamed_31,
    x: [16]guintptr,
};
pub const struct__GVariantDict = extern struct {
    u: union_unnamed_30,
};
pub const GVariantDict = struct__GVariantDict;
pub extern fn g_variant_dict_new(from_asv: ?*GVariant) [*c]GVariantDict;
pub extern fn g_variant_dict_init(dict: [*c]GVariantDict, from_asv: ?*GVariant) void;
pub extern fn g_variant_dict_lookup(dict: [*c]GVariantDict, key: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_dict_lookup_value(dict: [*c]GVariantDict, key: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_variant_dict_contains(dict: [*c]GVariantDict, key: [*c]const gchar) gboolean;
pub extern fn g_variant_dict_insert(dict: [*c]GVariantDict, key: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_dict_insert_value(dict: [*c]GVariantDict, key: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_variant_dict_remove(dict: [*c]GVariantDict, key: [*c]const gchar) gboolean;
pub extern fn g_variant_dict_clear(dict: [*c]GVariantDict) void;
pub extern fn g_variant_dict_end(dict: [*c]GVariantDict) ?*GVariant;
pub extern fn g_variant_dict_ref(dict: [*c]GVariantDict) [*c]GVariantDict;
pub extern fn g_variant_dict_unref(dict: [*c]GVariantDict) void;
pub extern fn g_printf_string_upper_bound(format: [*c]const gchar, args: [*c]struct___va_list_tag) gsize;
pub const G_LOG_FLAG_RECURSION: c_int = 1;
pub const G_LOG_FLAG_FATAL: c_int = 2;
pub const G_LOG_LEVEL_ERROR: c_int = 4;
pub const G_LOG_LEVEL_CRITICAL: c_int = 8;
pub const G_LOG_LEVEL_WARNING: c_int = 16;
pub const G_LOG_LEVEL_MESSAGE: c_int = 32;
pub const G_LOG_LEVEL_INFO: c_int = 64;
pub const G_LOG_LEVEL_DEBUG: c_int = 128;
pub const G_LOG_LEVEL_MASK: c_int = -4;
pub const GLogLevelFlags = c_int;
pub const GLogFunc = ?*const fn ([*c]const gchar, GLogLevelFlags, [*c]const gchar, gpointer) callconv(.C) void;
pub extern fn g_log_set_handler(log_domain: [*c]const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) guint;
pub extern fn g_log_set_handler_full(log_domain: [*c]const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer, destroy: GDestroyNotify) guint;
pub extern fn g_log_remove_handler(log_domain: [*c]const gchar, handler_id: guint) void;
pub extern fn g_log_default_handler(log_domain: [*c]const gchar, log_level: GLogLevelFlags, message: [*c]const gchar, unused_data: gpointer) void;
pub extern fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) GLogFunc;
pub extern fn g_log(log_domain: [*c]const gchar, log_level: GLogLevelFlags, format: [*c]const gchar, ...) void;
pub extern fn g_logv(log_domain: [*c]const gchar, log_level: GLogLevelFlags, format: [*c]const gchar, args: [*c]struct___va_list_tag) void;
pub extern fn g_log_set_fatal_mask(log_domain: [*c]const gchar, fatal_mask: GLogLevelFlags) GLogLevelFlags;
pub extern fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) GLogLevelFlags;
pub const G_LOG_WRITER_HANDLED: c_int = 1;
pub const G_LOG_WRITER_UNHANDLED: c_int = 0;
pub const GLogWriterOutput = c_uint;
pub const struct__GLogField = extern struct {
    key: [*c]const gchar,
    value: gconstpointer,
    length: gssize,
};
pub const GLogField = struct__GLogField;
pub const GLogWriterFunc = ?*const fn (GLogLevelFlags, [*c]const GLogField, gsize, gpointer) callconv(.C) GLogWriterOutput;
pub extern fn g_log_structured(log_domain: [*c]const gchar, log_level: GLogLevelFlags, ...) void;
pub extern fn g_log_structured_array(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize) void;
pub extern fn g_log_variant(log_domain: [*c]const gchar, log_level: GLogLevelFlags, fields: ?*GVariant) void;
pub extern fn g_log_set_writer_func(func: GLogWriterFunc, user_data: gpointer, user_data_free: GDestroyNotify) void;
pub extern fn g_log_writer_supports_color(output_fd: gint) gboolean;
pub extern fn g_log_writer_is_journald(output_fd: gint) gboolean;
pub extern fn g_log_writer_format_fields(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, use_color: gboolean) [*c]gchar;
pub extern fn g_log_writer_journald(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_standard_streams(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_default(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_default_set_use_stderr(use_stderr: gboolean) void;
pub extern fn g_log_writer_default_would_drop(log_level: GLogLevelFlags, log_domain: [*c]const u8) gboolean;
pub extern fn g_log_get_debug_enabled() gboolean;
pub extern fn g_log_set_debug_enabled(enabled: gboolean) void;
pub extern fn _g_log_fallback_handler(log_domain: [*c]const gchar, log_level: GLogLevelFlags, message: [*c]const gchar, unused_data: gpointer) void;
pub extern fn g_return_if_fail_warning(log_domain: [*c]const u8, pretty_function: [*c]const u8, expression: [*c]const u8) void;
pub extern fn g_warn_message(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, warnexpr: [*c]const u8) void;
pub extern fn g_assert_warning(log_domain: [*c]const u8, file: [*c]const u8, line: c_int, pretty_function: [*c]const u8, expression: [*c]const u8) noreturn;
pub extern fn g_log_structured_standard(log_domain: [*c]const gchar, log_level: GLogLevelFlags, file: [*c]const gchar, line: [*c]const gchar, func: [*c]const gchar, message_format: [*c]const gchar, ...) void;
pub const GPrintFunc = ?*const fn ([*c]const gchar) callconv(.C) void;
pub extern fn g_print(format: [*c]const gchar, ...) void;
pub extern fn g_set_print_handler(func: GPrintFunc) GPrintFunc;
pub extern fn g_printerr(format: [*c]const gchar, ...) void;
pub extern fn g_set_printerr_handler(func: GPrintFunc) GPrintFunc;
pub const struct__GOptionContext = opaque {};
pub const GOptionContext = struct__GOptionContext;
pub const struct__GOptionGroup = opaque {};
pub const GOptionGroup = struct__GOptionGroup;
pub const struct__GOptionEntry = extern struct {
    long_name: [*c]const gchar,
    short_name: gchar,
    flags: gint,
    arg: GOptionArg,
    arg_data: gpointer,
    description: [*c]const gchar,
    arg_description: [*c]const gchar,
};
pub const GOptionEntry = struct__GOptionEntry;
pub const G_OPTION_FLAG_NONE: c_int = 0;
pub const G_OPTION_FLAG_HIDDEN: c_int = 1;
pub const G_OPTION_FLAG_IN_MAIN: c_int = 2;
pub const G_OPTION_FLAG_REVERSE: c_int = 4;
pub const G_OPTION_FLAG_NO_ARG: c_int = 8;
pub const G_OPTION_FLAG_FILENAME: c_int = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG: c_int = 32;
pub const G_OPTION_FLAG_NOALIAS: c_int = 64;
pub const GOptionFlags = c_uint;
pub const G_OPTION_ARG_NONE: c_int = 0;
pub const G_OPTION_ARG_STRING: c_int = 1;
pub const G_OPTION_ARG_INT: c_int = 2;
pub const G_OPTION_ARG_CALLBACK: c_int = 3;
pub const G_OPTION_ARG_FILENAME: c_int = 4;
pub const G_OPTION_ARG_STRING_ARRAY: c_int = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY: c_int = 6;
pub const G_OPTION_ARG_DOUBLE: c_int = 7;
pub const G_OPTION_ARG_INT64: c_int = 8;
pub const GOptionArg = c_uint;
pub const GOptionArgFunc = ?*const fn ([*c]const gchar, [*c]const gchar, gpointer, [*c][*c]GError) callconv(.C) gboolean;
pub const GOptionParseFunc = ?*const fn (?*GOptionContext, ?*GOptionGroup, gpointer, [*c][*c]GError) callconv(.C) gboolean;
pub const GOptionErrorFunc = ?*const fn (?*GOptionContext, ?*GOptionGroup, gpointer, [*c][*c]GError) callconv(.C) void;
pub const G_OPTION_ERROR_UNKNOWN_OPTION: c_int = 0;
pub const G_OPTION_ERROR_BAD_VALUE: c_int = 1;
pub const G_OPTION_ERROR_FAILED: c_int = 2;
pub const GOptionError = c_uint;
pub extern fn g_option_error_quark() GQuark;
pub extern fn g_option_context_new(parameter_string: [*c]const gchar) ?*GOptionContext;
pub extern fn g_option_context_set_summary(context: ?*GOptionContext, summary: [*c]const gchar) void;
pub extern fn g_option_context_get_summary(context: ?*GOptionContext) [*c]const gchar;
pub extern fn g_option_context_set_description(context: ?*GOptionContext, description: [*c]const gchar) void;
pub extern fn g_option_context_get_description(context: ?*GOptionContext) [*c]const gchar;
pub extern fn g_option_context_free(context: ?*GOptionContext) void;
pub extern fn g_option_context_set_help_enabled(context: ?*GOptionContext, help_enabled: gboolean) void;
pub extern fn g_option_context_get_help_enabled(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_set_ignore_unknown_options(context: ?*GOptionContext, ignore_unknown: gboolean) void;
pub extern fn g_option_context_get_ignore_unknown_options(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_set_strict_posix(context: ?*GOptionContext, strict_posix: gboolean) void;
pub extern fn g_option_context_get_strict_posix(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_add_main_entries(context: ?*GOptionContext, entries: [*c]const GOptionEntry, translation_domain: [*c]const gchar) void;
pub extern fn g_option_context_parse(context: ?*GOptionContext, argc: [*c]gint, argv: [*c][*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_option_context_parse_strv(context: ?*GOptionContext, arguments: [*c][*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_option_context_set_translate_func(context: ?*GOptionContext, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn g_option_context_set_translation_domain(context: ?*GOptionContext, domain: [*c]const gchar) void;
pub extern fn g_option_context_add_group(context: ?*GOptionContext, group: ?*GOptionGroup) void;
pub extern fn g_option_context_set_main_group(context: ?*GOptionContext, group: ?*GOptionGroup) void;
pub extern fn g_option_context_get_main_group(context: ?*GOptionContext) ?*GOptionGroup;
pub extern fn g_option_context_get_help(context: ?*GOptionContext, main_help: gboolean, group: ?*GOptionGroup) [*c]gchar;
pub extern fn g_option_group_new(name: [*c]const gchar, description: [*c]const gchar, help_description: [*c]const gchar, user_data: gpointer, destroy: GDestroyNotify) ?*GOptionGroup;
pub extern fn g_option_group_set_parse_hooks(group: ?*GOptionGroup, pre_parse_func: GOptionParseFunc, post_parse_func: GOptionParseFunc) void;
pub extern fn g_option_group_set_error_hook(group: ?*GOptionGroup, error_func: GOptionErrorFunc) void;
pub extern fn g_option_group_free(group: ?*GOptionGroup) void;
pub extern fn g_option_group_ref(group: ?*GOptionGroup) ?*GOptionGroup;
pub extern fn g_option_group_unref(group: ?*GOptionGroup) void;
pub extern fn g_option_group_add_entries(group: ?*GOptionGroup, entries: [*c]const GOptionEntry) void;
pub extern fn g_option_group_set_translate_func(group: ?*GOptionGroup, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn g_option_group_set_translation_domain(group: ?*GOptionGroup, domain: [*c]const gchar) void;
pub const struct__GPathBuf = extern struct {
    dummy: [8]gpointer,
};
pub const GPathBuf = struct__GPathBuf;
pub extern fn g_path_buf_new() [*c]GPathBuf;
pub extern fn g_path_buf_new_from_path(path: [*c]const u8) [*c]GPathBuf;
pub extern fn g_path_buf_init(buf: [*c]GPathBuf) [*c]GPathBuf;
pub extern fn g_path_buf_init_from_path(buf: [*c]GPathBuf, path: [*c]const u8) [*c]GPathBuf;
pub extern fn g_path_buf_clear(buf: [*c]GPathBuf) void;
pub extern fn g_path_buf_clear_to_path(buf: [*c]GPathBuf) [*c]u8;
pub extern fn g_path_buf_free(buf: [*c]GPathBuf) void;
pub extern fn g_path_buf_free_to_path(buf: [*c]GPathBuf) [*c]u8;
pub extern fn g_path_buf_copy(buf: [*c]GPathBuf) [*c]GPathBuf;
pub extern fn g_path_buf_push(buf: [*c]GPathBuf, path: [*c]const u8) [*c]GPathBuf;
pub extern fn g_path_buf_pop(buf: [*c]GPathBuf) gboolean;
pub extern fn g_path_buf_set_filename(buf: [*c]GPathBuf, file_name: [*c]const u8) gboolean;
pub extern fn g_path_buf_set_extension(buf: [*c]GPathBuf, extension: [*c]const u8) gboolean;
pub extern fn g_path_buf_to_path(buf: [*c]GPathBuf) [*c]u8;
pub extern fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub const struct__GPatternSpec = opaque {};
pub const GPatternSpec = struct__GPatternSpec;
pub extern fn g_pattern_spec_new(pattern: [*c]const gchar) ?*GPatternSpec;
pub extern fn g_pattern_spec_free(pspec: ?*GPatternSpec) void;
pub extern fn g_pattern_spec_copy(pspec: ?*GPatternSpec) ?*GPatternSpec;
pub extern fn g_pattern_spec_equal(pspec1: ?*GPatternSpec, pspec2: ?*GPatternSpec) gboolean;
pub extern fn g_pattern_spec_match(pspec: ?*GPatternSpec, string_length: gsize, string: [*c]const gchar, string_reversed: [*c]const gchar) gboolean;
pub extern fn g_pattern_spec_match_string(pspec: ?*GPatternSpec, string: [*c]const gchar) gboolean;
pub extern fn g_pattern_match(pspec: ?*GPatternSpec, string_length: guint, string: [*c]const gchar, string_reversed: [*c]const gchar) gboolean;
pub extern fn g_pattern_match_string(pspec: ?*GPatternSpec, string: [*c]const gchar) gboolean;
pub extern fn g_pattern_match_simple(pattern: [*c]const gchar, string: [*c]const gchar) gboolean;
pub extern fn g_spaced_primes_closest(num: guint) guint;
pub extern fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint, size: gsize, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub const struct__GQueue = extern struct {
    head: [*c]GList,
    tail: [*c]GList,
    length: guint,
};
pub const GQueue = struct__GQueue;
pub extern fn g_queue_new() [*c]GQueue;
pub extern fn g_queue_free(queue: [*c]GQueue) void;
pub extern fn g_queue_free_full(queue: [*c]GQueue, free_func: GDestroyNotify) void;
pub extern fn g_queue_init(queue: [*c]GQueue) void;
pub extern fn g_queue_clear(queue: [*c]GQueue) void;
pub extern fn g_queue_is_empty(queue: [*c]GQueue) gboolean;
pub extern fn g_queue_clear_full(queue: [*c]GQueue, free_func: GDestroyNotify) void;
pub extern fn g_queue_get_length(queue: [*c]GQueue) guint;
pub extern fn g_queue_reverse(queue: [*c]GQueue) void;
pub extern fn g_queue_copy(queue: [*c]GQueue) [*c]GQueue;
pub extern fn g_queue_foreach(queue: [*c]GQueue, func: GFunc, user_data: gpointer) void;
pub extern fn g_queue_find(queue: [*c]GQueue, data: gconstpointer) [*c]GList;
pub extern fn g_queue_find_custom(queue: [*c]GQueue, data: gconstpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_queue_sort(queue: [*c]GQueue, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_queue_push_head(queue: [*c]GQueue, data: gpointer) void;
pub extern fn g_queue_push_tail(queue: [*c]GQueue, data: gpointer) void;
pub extern fn g_queue_push_nth(queue: [*c]GQueue, data: gpointer, n: gint) void;
pub extern fn g_queue_pop_head(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_pop_tail(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_pop_nth(queue: [*c]GQueue, n: guint) gpointer;
pub extern fn g_queue_peek_head(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_peek_tail(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_peek_nth(queue: [*c]GQueue, n: guint) gpointer;
pub extern fn g_queue_index(queue: [*c]GQueue, data: gconstpointer) gint;
pub extern fn g_queue_remove(queue: [*c]GQueue, data: gconstpointer) gboolean;
pub extern fn g_queue_remove_all(queue: [*c]GQueue, data: gconstpointer) guint;
pub extern fn g_queue_insert_before(queue: [*c]GQueue, sibling: [*c]GList, data: gpointer) void;
pub extern fn g_queue_insert_before_link(queue: [*c]GQueue, sibling: [*c]GList, link_: [*c]GList) void;
pub extern fn g_queue_insert_after(queue: [*c]GQueue, sibling: [*c]GList, data: gpointer) void;
pub extern fn g_queue_insert_after_link(queue: [*c]GQueue, sibling: [*c]GList, link_: [*c]GList) void;
pub extern fn g_queue_insert_sorted(queue: [*c]GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_queue_push_head_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_push_tail_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_push_nth_link(queue: [*c]GQueue, n: gint, link_: [*c]GList) void;
pub extern fn g_queue_pop_head_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_pop_tail_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_pop_nth_link(queue: [*c]GQueue, n: guint) [*c]GList;
pub extern fn g_queue_peek_head_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_peek_tail_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_peek_nth_link(queue: [*c]GQueue, n: guint) [*c]GList;
pub extern fn g_queue_link_index(queue: [*c]GQueue, link_: [*c]GList) gint;
pub extern fn g_queue_unlink(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_delete_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub const struct__GRand = opaque {};
pub const GRand = struct__GRand;
pub extern fn g_rand_new_with_seed(seed: guint32) ?*GRand;
pub extern fn g_rand_new_with_seed_array(seed: [*c]const guint32, seed_length: guint) ?*GRand;
pub extern fn g_rand_new() ?*GRand;
pub extern fn g_rand_free(rand_: ?*GRand) void;
pub extern fn g_rand_copy(rand_: ?*GRand) ?*GRand;
pub extern fn g_rand_set_seed(rand_: ?*GRand, seed: guint32) void;
pub extern fn g_rand_set_seed_array(rand_: ?*GRand, seed: [*c]const guint32, seed_length: guint) void;
pub extern fn g_rand_int(rand_: ?*GRand) guint32;
pub extern fn g_rand_int_range(rand_: ?*GRand, begin: gint32, end: gint32) gint32;
pub extern fn g_rand_double(rand_: ?*GRand) gdouble;
pub extern fn g_rand_double_range(rand_: ?*GRand, begin: gdouble, end: gdouble) gdouble;
pub extern fn g_random_set_seed(seed: guint32) void;
pub extern fn g_random_int() guint32;
pub extern fn g_random_int_range(begin: gint32, end: gint32) gint32;
pub extern fn g_random_double() gdouble;
pub extern fn g_random_double_range(begin: gdouble, end: gdouble) gdouble;
pub extern fn g_rc_box_alloc(block_size: gsize) gpointer;
pub extern fn g_rc_box_alloc0(block_size: gsize) gpointer;
pub extern fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_rc_box_acquire(mem_block: gpointer) gpointer;
pub extern fn g_rc_box_release(mem_block: gpointer) void;
pub extern fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify) void;
pub extern fn g_rc_box_get_size(mem_block: gpointer) gsize;
pub extern fn g_atomic_rc_box_alloc(block_size: gsize) gpointer;
pub extern fn g_atomic_rc_box_alloc0(block_size: gsize) gpointer;
pub extern fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_atomic_rc_box_acquire(mem_block: gpointer) gpointer;
pub extern fn g_atomic_rc_box_release(mem_block: gpointer) void;
pub extern fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify) void;
pub extern fn g_atomic_rc_box_get_size(mem_block: gpointer) gsize;
pub extern fn g_ref_count_init(rc: [*c]grefcount) void;
pub extern fn g_ref_count_inc(rc: [*c]grefcount) void;
pub extern fn g_ref_count_dec(rc: [*c]grefcount) gboolean;
pub extern fn g_ref_count_compare(rc: [*c]grefcount, val: gint) gboolean;
pub extern fn g_atomic_ref_count_init(arc: [*c]gatomicrefcount) void;
pub extern fn g_atomic_ref_count_inc(arc: [*c]gatomicrefcount) void;
pub extern fn g_atomic_ref_count_dec(arc: [*c]gatomicrefcount) gboolean;
pub extern fn g_atomic_ref_count_compare(arc: [*c]gatomicrefcount, val: gint) gboolean;
pub extern fn g_ref_string_new(str: [*c]const u8) [*c]u8;
pub extern fn g_ref_string_new_len(str: [*c]const u8, len: gssize) [*c]u8;
pub extern fn g_ref_string_new_intern(str: [*c]const u8) [*c]u8;
pub extern fn g_ref_string_acquire(str: [*c]u8) [*c]u8;
pub extern fn g_ref_string_release(str: [*c]u8) void;
pub extern fn g_ref_string_length(str: [*c]u8) gsize;
pub const GRefString = u8;
pub const G_REGEX_ERROR_COMPILE: c_int = 0;
pub const G_REGEX_ERROR_OPTIMIZE: c_int = 1;
pub const G_REGEX_ERROR_REPLACE: c_int = 2;
pub const G_REGEX_ERROR_MATCH: c_int = 3;
pub const G_REGEX_ERROR_INTERNAL: c_int = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH: c_int = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR: c_int = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: c_int = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: c_int = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG: c_int = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: c_int = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: c_int = 107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER: c_int = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT: c_int = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: c_int = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: c_int = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS: c_int = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: c_int = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT: c_int = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE: c_int = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR: c_int = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: c_int = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION: c_int = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: c_int = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED: c_int = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: c_int = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: c_int = 131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE: c_int = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION: c_int = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: c_int = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP: c_int = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: c_int = 142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: c_int = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY: c_int = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY: c_int = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: c_int = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: c_int = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE: c_int = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: c_int = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION: c_int = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: c_int = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE: c_int = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: c_int = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: c_int = 159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: c_int = 160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG: c_int = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: c_int = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT: c_int = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER: c_int = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: c_int = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: c_int = 166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR: c_int = 168;
pub const G_REGEX_ERROR_MISSING_NAME: c_int = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: c_int = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: c_int = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG: c_int = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: c_int = 176;
pub const GRegexError = c_uint;
pub extern fn g_regex_error_quark() GQuark;
pub const G_REGEX_DEFAULT: c_int = 0;
pub const G_REGEX_CASELESS: c_int = 1;
pub const G_REGEX_MULTILINE: c_int = 2;
pub const G_REGEX_DOTALL: c_int = 4;
pub const G_REGEX_EXTENDED: c_int = 8;
pub const G_REGEX_ANCHORED: c_int = 16;
pub const G_REGEX_DOLLAR_ENDONLY: c_int = 32;
pub const G_REGEX_UNGREEDY: c_int = 512;
pub const G_REGEX_RAW: c_int = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE: c_int = 4096;
pub const G_REGEX_OPTIMIZE: c_int = 8192;
pub const G_REGEX_FIRSTLINE: c_int = 262144;
pub const G_REGEX_DUPNAMES: c_int = 524288;
pub const G_REGEX_NEWLINE_CR: c_int = 1048576;
pub const G_REGEX_NEWLINE_LF: c_int = 2097152;
pub const G_REGEX_NEWLINE_CRLF: c_int = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF: c_int = 5242880;
pub const G_REGEX_BSR_ANYCRLF: c_int = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT: c_int = 33554432;
pub const GRegexCompileFlags = c_uint;
pub const G_REGEX_MATCH_DEFAULT: c_int = 0;
pub const G_REGEX_MATCH_ANCHORED: c_int = 16;
pub const G_REGEX_MATCH_NOTBOL: c_int = 128;
pub const G_REGEX_MATCH_NOTEOL: c_int = 256;
pub const G_REGEX_MATCH_NOTEMPTY: c_int = 1024;
pub const G_REGEX_MATCH_PARTIAL: c_int = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR: c_int = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF: c_int = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF: c_int = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY: c_int = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF: c_int = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF: c_int = 8388608;
pub const G_REGEX_MATCH_BSR_ANY: c_int = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT: c_int = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD: c_int = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART: c_int = 268435456;
pub const GRegexMatchFlags = c_uint;
pub const struct__GRegex = opaque {};
pub const GRegex = struct__GRegex;
pub const struct__GMatchInfo = opaque {};
pub const GMatchInfo = struct__GMatchInfo;
pub const GRegexEvalCallback = ?*const fn (?*const GMatchInfo, [*c]GString, gpointer) callconv(.C) gboolean;
pub extern fn g_regex_new(pattern: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags, @"error": [*c][*c]GError) ?*GRegex;
pub extern fn g_regex_ref(regex: ?*GRegex) ?*GRegex;
pub extern fn g_regex_unref(regex: ?*GRegex) void;
pub extern fn g_regex_get_pattern(regex: ?*const GRegex) [*c]const gchar;
pub extern fn g_regex_get_max_backref(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_capture_count(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_has_cr_or_lf(regex: ?*const GRegex) gboolean;
pub extern fn g_regex_get_max_lookbehind(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_string_number(regex: ?*const GRegex, name: [*c]const gchar) gint;
pub extern fn g_regex_escape_string(string: [*c]const gchar, length: gint) [*c]gchar;
pub extern fn g_regex_escape_nul(string: [*c]const gchar, length: gint) [*c]gchar;
pub extern fn g_regex_get_compile_flags(regex: ?*const GRegex) GRegexCompileFlags;
pub extern fn g_regex_get_match_flags(regex: ?*const GRegex) GRegexMatchFlags;
pub extern fn g_regex_match_simple(pattern: [*c]const gchar, string: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) gboolean;
pub extern fn g_regex_match(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo) gboolean;
pub extern fn g_regex_match_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_regex_match_all(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo) gboolean;
pub extern fn g_regex_match_all_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: [*c]?*GMatchInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_regex_split_simple(pattern: [*c]const gchar, string: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) [*c][*c]gchar;
pub extern fn g_regex_split(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags) [*c][*c]gchar;
pub extern fn g_regex_split_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, max_tokens: gint, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_regex_replace(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, replacement: [*c]const gchar, match_options: GRegexMatchFlags, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_regex_replace_literal(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, replacement: [*c]const gchar, match_options: GRegexMatchFlags, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_regex_replace_eval(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, eval: GRegexEvalCallback, user_data: gpointer, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_regex_check_replacement(replacement: [*c]const gchar, has_references: [*c]gboolean, @"error": [*c][*c]GError) gboolean;
pub extern fn g_match_info_get_regex(match_info: ?*const GMatchInfo) ?*GRegex;
pub extern fn g_match_info_get_string(match_info: ?*const GMatchInfo) [*c]const gchar;
pub extern fn g_match_info_ref(match_info: ?*GMatchInfo) ?*GMatchInfo;
pub extern fn g_match_info_unref(match_info: ?*GMatchInfo) void;
pub extern fn g_match_info_free(match_info: ?*GMatchInfo) void;
pub extern fn g_match_info_next(match_info: ?*GMatchInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_match_info_matches(match_info: ?*const GMatchInfo) gboolean;
pub extern fn g_match_info_get_match_count(match_info: ?*const GMatchInfo) gint;
pub extern fn g_match_info_is_partial_match(match_info: ?*const GMatchInfo) gboolean;
pub extern fn g_match_info_expand_references(match_info: ?*const GMatchInfo, string_to_expand: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_match_info_fetch(match_info: ?*const GMatchInfo, match_num: gint) [*c]gchar;
pub extern fn g_match_info_fetch_pos(match_info: ?*const GMatchInfo, match_num: gint, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn g_match_info_fetch_named(match_info: ?*const GMatchInfo, name: [*c]const gchar) [*c]gchar;
pub extern fn g_match_info_fetch_named_pos(match_info: ?*const GMatchInfo, name: [*c]const gchar, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn g_match_info_fetch_all(match_info: ?*const GMatchInfo) [*c][*c]gchar; // /usr/include/glib-2.0/glib/gscanner.h:140:10: warning: struct demoted to opaque type - has bitfield
pub const struct__GScannerConfig = opaque {};
pub const GScannerConfig = struct__GScannerConfig;
pub const union__GTokenValue = extern union {
    v_symbol: gpointer,
    v_identifier: [*c]gchar,
    v_binary: gulong,
    v_octal: gulong,
    v_int: gulong,
    v_int64: guint64,
    v_float: gdouble,
    v_hex: gulong,
    v_string: [*c]gchar,
    v_comment: [*c]gchar,
    v_char: guchar,
    v_error: guint,
};
pub const GTokenValue = union__GTokenValue;
pub const GScanner = struct__GScanner;
pub const GScannerMsgFunc = ?*const fn ([*c]GScanner, [*c]gchar, gboolean) callconv(.C) void;
pub const struct__GScanner = extern struct {
    user_data: gpointer,
    max_parse_errors: guint,
    parse_errors: guint,
    input_name: [*c]const gchar,
    qdata: ?*GData,
    config: ?*GScannerConfig,
    token: GTokenType,
    value: GTokenValue,
    line: guint,
    position: guint,
    next_token: GTokenType,
    next_value: GTokenValue,
    next_line: guint,
    next_position: guint,
    symbol_table: ?*GHashTable,
    input_fd: gint,
    text: [*c]const gchar,
    text_end: [*c]const gchar,
    buffer: [*c]gchar,
    scope_id: guint,
    msg_handler: GScannerMsgFunc,
};
pub const G_ERR_UNKNOWN: c_int = 0;
pub const G_ERR_UNEXP_EOF: c_int = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING: c_int = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT: c_int = 3;
pub const G_ERR_NON_DIGIT_IN_CONST: c_int = 4;
pub const G_ERR_DIGIT_RADIX: c_int = 5;
pub const G_ERR_FLOAT_RADIX: c_int = 6;
pub const G_ERR_FLOAT_MALFORMED: c_int = 7;
pub const GErrorType = c_uint;
pub const G_TOKEN_EOF: c_int = 0;
pub const G_TOKEN_LEFT_PAREN: c_int = 40;
pub const G_TOKEN_RIGHT_PAREN: c_int = 41;
pub const G_TOKEN_LEFT_CURLY: c_int = 123;
pub const G_TOKEN_RIGHT_CURLY: c_int = 125;
pub const G_TOKEN_LEFT_BRACE: c_int = 91;
pub const G_TOKEN_RIGHT_BRACE: c_int = 93;
pub const G_TOKEN_EQUAL_SIGN: c_int = 61;
pub const G_TOKEN_COMMA: c_int = 44;
pub const G_TOKEN_NONE: c_int = 256;
pub const G_TOKEN_ERROR: c_int = 257;
pub const G_TOKEN_CHAR: c_int = 258;
pub const G_TOKEN_BINARY: c_int = 259;
pub const G_TOKEN_OCTAL: c_int = 260;
pub const G_TOKEN_INT: c_int = 261;
pub const G_TOKEN_HEX: c_int = 262;
pub const G_TOKEN_FLOAT: c_int = 263;
pub const G_TOKEN_STRING: c_int = 264;
pub const G_TOKEN_SYMBOL: c_int = 265;
pub const G_TOKEN_IDENTIFIER: c_int = 266;
pub const G_TOKEN_IDENTIFIER_NULL: c_int = 267;
pub const G_TOKEN_COMMENT_SINGLE: c_int = 268;
pub const G_TOKEN_COMMENT_MULTI: c_int = 269;
pub const G_TOKEN_LAST: c_int = 270;
pub const GTokenType = c_uint;
pub extern fn g_scanner_new(config_templ: ?*const GScannerConfig) [*c]GScanner;
pub extern fn g_scanner_destroy(scanner: [*c]GScanner) void;
pub extern fn g_scanner_input_file(scanner: [*c]GScanner, input_fd: gint) void;
pub extern fn g_scanner_sync_file_offset(scanner: [*c]GScanner) void;
pub extern fn g_scanner_input_text(scanner: [*c]GScanner, text: [*c]const gchar, text_len: guint) void;
pub extern fn g_scanner_get_next_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_peek_next_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_cur_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_cur_value(scanner: [*c]GScanner) GTokenValue;
pub extern fn g_scanner_cur_line(scanner: [*c]GScanner) guint;
pub extern fn g_scanner_cur_position(scanner: [*c]GScanner) guint;
pub extern fn g_scanner_eof(scanner: [*c]GScanner) gboolean;
pub extern fn g_scanner_set_scope(scanner: [*c]GScanner, scope_id: guint) guint;
pub extern fn g_scanner_scope_add_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar, value: gpointer) void;
pub extern fn g_scanner_scope_remove_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar) void;
pub extern fn g_scanner_scope_lookup_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar) gpointer;
pub extern fn g_scanner_scope_foreach_symbol(scanner: [*c]GScanner, scope_id: guint, func: GHFunc, user_data: gpointer) void;
pub extern fn g_scanner_lookup_symbol(scanner: [*c]GScanner, symbol: [*c]const gchar) gpointer;
pub extern fn g_scanner_unexp_token(scanner: [*c]GScanner, expected_token: GTokenType, identifier_spec: [*c]const gchar, symbol_spec: [*c]const gchar, symbol_name: [*c]const gchar, message: [*c]const gchar, is_error: gint) void;
pub extern fn g_scanner_error(scanner: [*c]GScanner, format: [*c]const gchar, ...) void;
pub extern fn g_scanner_warn(scanner: [*c]GScanner, format: [*c]const gchar, ...) void;
pub const struct__GSequence = opaque {};
pub const GSequence = struct__GSequence;
pub const struct__GSequenceNode = opaque {};
pub const GSequenceIter = struct__GSequenceNode;
pub const GSequenceIterCompareFunc = ?*const fn (?*GSequenceIter, ?*GSequenceIter, gpointer) callconv(.C) gint;
pub extern fn g_sequence_new(data_destroy: GDestroyNotify) ?*GSequence;
pub extern fn g_sequence_free(seq: ?*GSequence) void;
pub extern fn g_sequence_get_length(seq: ?*GSequence) gint;
pub extern fn g_sequence_foreach(seq: ?*GSequence, func: GFunc, user_data: gpointer) void;
pub extern fn g_sequence_foreach_range(begin: ?*GSequenceIter, end: ?*GSequenceIter, func: GFunc, user_data: gpointer) void;
pub extern fn g_sequence_sort(seq: ?*GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_sort_iter(seq: ?*GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_is_empty(seq: ?*GSequence) gboolean;
pub extern fn g_sequence_get_begin_iter(seq: ?*GSequence) ?*GSequenceIter;
pub extern fn g_sequence_get_end_iter(seq: ?*GSequence) ?*GSequenceIter;
pub extern fn g_sequence_get_iter_at_pos(seq: ?*GSequence, pos: gint) ?*GSequenceIter;
pub extern fn g_sequence_append(seq: ?*GSequence, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_prepend(seq: ?*GSequence, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_insert_before(iter: ?*GSequenceIter, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_move(src: ?*GSequenceIter, dest: ?*GSequenceIter) void;
pub extern fn g_sequence_swap(a: ?*GSequenceIter, b: ?*GSequenceIter) void;
pub extern fn g_sequence_insert_sorted(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_insert_sorted_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_sort_changed(iter: ?*GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_sort_changed_iter(iter: ?*GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_remove(iter: ?*GSequenceIter) void;
pub extern fn g_sequence_remove_range(begin: ?*GSequenceIter, end: ?*GSequenceIter) void;
pub extern fn g_sequence_move_range(dest: ?*GSequenceIter, begin: ?*GSequenceIter, end: ?*GSequenceIter) void;
pub extern fn g_sequence_search(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_search_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_lookup(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_lookup_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_get(iter: ?*GSequenceIter) gpointer;
pub extern fn g_sequence_set(iter: ?*GSequenceIter, data: gpointer) void;
pub extern fn g_sequence_iter_is_begin(iter: ?*GSequenceIter) gboolean;
pub extern fn g_sequence_iter_is_end(iter: ?*GSequenceIter) gboolean;
pub extern fn g_sequence_iter_next(iter: ?*GSequenceIter) ?*GSequenceIter;
pub extern fn g_sequence_iter_prev(iter: ?*GSequenceIter) ?*GSequenceIter;
pub extern fn g_sequence_iter_get_position(iter: ?*GSequenceIter) gint;
pub extern fn g_sequence_iter_move(iter: ?*GSequenceIter, delta: gint) ?*GSequenceIter;
pub extern fn g_sequence_iter_get_sequence(iter: ?*GSequenceIter) ?*GSequence;
pub extern fn g_sequence_iter_compare(a: ?*GSequenceIter, b: ?*GSequenceIter) gint;
pub extern fn g_sequence_range_get_midpoint(begin: ?*GSequenceIter, end: ?*GSequenceIter) ?*GSequenceIter;
pub const G_SHELL_ERROR_BAD_QUOTING: c_int = 0;
pub const G_SHELL_ERROR_EMPTY_STRING: c_int = 1;
pub const G_SHELL_ERROR_FAILED: c_int = 2;
pub const GShellError = c_uint;
pub extern fn g_shell_error_quark() GQuark;
pub extern fn g_shell_quote(unquoted_string: [*c]const gchar) [*c]gchar;
pub extern fn g_shell_unquote(quoted_string: [*c]const gchar, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_shell_parse_argv(command_line: [*c]const gchar, argcp: [*c]gint, argvp: [*c][*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_slice_alloc(block_size: gsize) gpointer;
pub extern fn g_slice_alloc0(block_size: gsize) gpointer;
pub extern fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_slice_free1(block_size: gsize, mem_block: gpointer) void;
pub extern fn g_slice_free_chain_with_offset(block_size: gsize, mem_chain: gpointer, next_offset: gsize) void;
pub const G_SLICE_CONFIG_ALWAYS_MALLOC: c_int = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES: c_int = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS: c_int = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT: c_int = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES: c_int = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER: c_int = 6;
pub const GSliceConfig = c_uint;
pub extern fn g_slice_set_config(ckey: GSliceConfig, value: gint64) void;
pub extern fn g_slice_get_config(ckey: GSliceConfig) gint64;
pub extern fn g_slice_get_config_state(ckey: GSliceConfig, address: gint64, n_values: [*c]guint) [*c]gint64;
pub const G_SPAWN_ERROR_FORK: c_int = 0;
pub const G_SPAWN_ERROR_READ: c_int = 1;
pub const G_SPAWN_ERROR_CHDIR: c_int = 2;
pub const G_SPAWN_ERROR_ACCES: c_int = 3;
pub const G_SPAWN_ERROR_PERM: c_int = 4;
pub const G_SPAWN_ERROR_TOO_BIG: c_int = 5;
pub const G_SPAWN_ERROR_2BIG: c_int = 5;
pub const G_SPAWN_ERROR_NOEXEC: c_int = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG: c_int = 7;
pub const G_SPAWN_ERROR_NOENT: c_int = 8;
pub const G_SPAWN_ERROR_NOMEM: c_int = 9;
pub const G_SPAWN_ERROR_NOTDIR: c_int = 10;
pub const G_SPAWN_ERROR_LOOP: c_int = 11;
pub const G_SPAWN_ERROR_TXTBUSY: c_int = 12;
pub const G_SPAWN_ERROR_IO: c_int = 13;
pub const G_SPAWN_ERROR_NFILE: c_int = 14;
pub const G_SPAWN_ERROR_MFILE: c_int = 15;
pub const G_SPAWN_ERROR_INVAL: c_int = 16;
pub const G_SPAWN_ERROR_ISDIR: c_int = 17;
pub const G_SPAWN_ERROR_LIBBAD: c_int = 18;
pub const G_SPAWN_ERROR_FAILED: c_int = 19;
pub const GSpawnError = c_uint;
pub const GSpawnChildSetupFunc = ?*const fn (gpointer) callconv(.C) void;
pub const G_SPAWN_DEFAULT: c_int = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN: c_int = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD: c_int = 2;
pub const G_SPAWN_SEARCH_PATH: c_int = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL: c_int = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL: c_int = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN: c_int = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO: c_int = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP: c_int = 128;
pub const G_SPAWN_CLOEXEC_PIPES: c_int = 256;
pub const G_SPAWN_CHILD_INHERITS_STDOUT: c_int = 512;
pub const G_SPAWN_CHILD_INHERITS_STDERR: c_int = 1024;
pub const G_SPAWN_STDIN_FROM_DEV_NULL: c_int = 2048;
pub const GSpawnFlags = c_uint;
pub extern fn g_spawn_error_quark() GQuark;
pub extern fn g_spawn_exit_error_quark() GQuark;
pub extern fn g_spawn_async(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_async_with_pipes(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, standard_input: [*c]gint, standard_output: [*c]gint, standard_error: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_async_with_pipes_and_fds(working_directory: [*c]const gchar, argv: [*c]const [*c]const gchar, envp: [*c]const [*c]const gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, stdin_fd: gint, stdout_fd: gint, stderr_fd: gint, source_fds: [*c]const gint, target_fds: [*c]const gint, n_fds: gsize, child_pid_out: [*c]GPid, stdin_pipe_out: [*c]gint, stdout_pipe_out: [*c]gint, stderr_pipe_out: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_async_with_fds(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, stdin_fd: gint, stdout_fd: gint, stderr_fd: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_sync(working_directory: [*c]const gchar, argv: [*c][*c]gchar, envp: [*c][*c]gchar, flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, standard_output: [*c][*c]gchar, standard_error: [*c][*c]gchar, wait_status: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_command_line_sync(command_line: [*c]const gchar, standard_output: [*c][*c]gchar, standard_error: [*c][*c]gchar, wait_status: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_command_line_async(command_line: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_check_wait_status(wait_status: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_check_exit_status(wait_status: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_spawn_close_pid(pid: GPid) void;
pub const struct__GStringChunk = opaque {};
pub const GStringChunk = struct__GStringChunk;
pub extern fn g_string_chunk_new(size: gsize) ?*GStringChunk;
pub extern fn g_string_chunk_free(chunk: ?*GStringChunk) void;
pub extern fn g_string_chunk_clear(chunk: ?*GStringChunk) void;
pub extern fn g_string_chunk_insert(chunk: ?*GStringChunk, string: [*c]const gchar) [*c]gchar;
pub extern fn g_string_chunk_insert_len(chunk: ?*GStringChunk, string: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_string_chunk_insert_const(chunk: ?*GStringChunk, string: [*c]const gchar) [*c]gchar;
pub const struct__GStrvBuilder = opaque {};
pub const GStrvBuilder = struct__GStrvBuilder;
pub extern fn g_strv_builder_new() ?*GStrvBuilder;
pub extern fn g_strv_builder_unref(builder: ?*GStrvBuilder) void;
pub extern fn g_strv_builder_ref(builder: ?*GStrvBuilder) ?*GStrvBuilder;
pub extern fn g_strv_builder_add(builder: ?*GStrvBuilder, value: [*c]const u8) void;
pub extern fn g_strv_builder_addv(builder: ?*GStrvBuilder, value: [*c][*c]const u8) void;
pub extern fn g_strv_builder_add_many(builder: ?*GStrvBuilder, ...) void;
pub extern fn g_strv_builder_end(builder: ?*GStrvBuilder) GStrv;
pub extern fn __errno_location() [*c]c_int;
pub const struct_GTestCase = opaque {};
pub const GTestCase = struct_GTestCase;
pub const struct_GTestSuite = opaque {};
pub const GTestSuite = struct_GTestSuite;
pub const GTestFunc = ?*const fn () callconv(.C) void;
pub const GTestDataFunc = ?*const fn (gconstpointer) callconv(.C) void;
pub const GTestFixtureFunc = ?*const fn (gpointer, gconstpointer) callconv(.C) void;
pub extern fn g_strcmp0(str1: [*c]const u8, str2: [*c]const u8) c_int;
pub extern fn g_test_minimized_result(minimized_quantity: f64, format: [*c]const u8, ...) void;
pub extern fn g_test_maximized_result(maximized_quantity: f64, format: [*c]const u8, ...) void;
pub extern fn g_test_init(argc: [*c]c_int, argv: [*c][*c][*c]u8, ...) void;
pub extern fn g_test_subprocess() gboolean;
pub extern fn g_test_run() c_int;
pub extern fn g_test_add_func(testpath: [*c]const u8, test_func: GTestFunc) void;
pub extern fn g_test_add_data_func(testpath: [*c]const u8, test_data: gconstpointer, test_func: GTestDataFunc) void;
pub extern fn g_test_add_data_func_full(testpath: [*c]const u8, test_data: gpointer, test_func: GTestDataFunc, data_free_func: GDestroyNotify) void;
pub extern fn g_test_get_path() [*c]const u8;
pub extern fn g_test_fail() void;
pub extern fn g_test_fail_printf(format: [*c]const u8, ...) void;
pub extern fn g_test_incomplete(msg: [*c]const gchar) void;
pub extern fn g_test_incomplete_printf(format: [*c]const u8, ...) void;
pub extern fn g_test_skip(msg: [*c]const gchar) void;
pub extern fn g_test_skip_printf(format: [*c]const u8, ...) void;
pub extern fn g_test_failed() gboolean;
pub extern fn g_test_set_nonfatal_assertions() void;
pub extern fn g_test_disable_crash_reporting() void;
pub extern fn g_test_message(format: [*c]const u8, ...) void;
pub extern fn g_test_bug_base(uri_pattern: [*c]const u8) void;
pub extern fn g_test_bug(bug_uri_snippet: [*c]const u8) void;
pub extern fn g_test_summary(summary: [*c]const u8) void;
pub extern fn g_test_timer_start() void;
pub extern fn g_test_timer_elapsed() f64;
pub extern fn g_test_timer_last() f64;
pub extern fn g_test_queue_free(gfree_pointer: gpointer) void;
pub extern fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer) void;
pub const G_TEST_TRAP_DEFAULT: c_int = 0;
pub const G_TEST_TRAP_SILENCE_STDOUT: c_int = 128;
pub const G_TEST_TRAP_SILENCE_STDERR: c_int = 256;
pub const G_TEST_TRAP_INHERIT_STDIN: c_int = 512;
pub const GTestTrapFlags = c_uint;
pub extern fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) gboolean;
pub const G_TEST_SUBPROCESS_DEFAULT: c_int = 0;
pub const G_TEST_SUBPROCESS_INHERIT_STDIN: c_int = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT: c_int = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR: c_int = 4;
pub const GTestSubprocessFlags = c_uint;
pub extern fn g_test_trap_subprocess(test_path: [*c]const u8, usec_timeout: guint64, test_flags: GTestSubprocessFlags) void;
pub extern fn g_test_trap_has_passed() gboolean;
pub extern fn g_test_trap_reached_timeout() gboolean;
pub extern fn g_test_rand_int() gint32;
pub extern fn g_test_rand_int_range(begin: gint32, end: gint32) gint32;
pub extern fn g_test_rand_double() f64;
pub extern fn g_test_rand_double_range(range_start: f64, range_end: f64) f64;
pub extern fn g_test_create_case(test_name: [*c]const u8, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) ?*GTestCase;
pub extern fn g_test_create_suite(suite_name: [*c]const u8) ?*GTestSuite;
pub extern fn g_test_get_root() ?*GTestSuite;
pub extern fn g_test_suite_add(suite: ?*GTestSuite, test_case: ?*GTestCase) void;
pub extern fn g_test_suite_add_suite(suite: ?*GTestSuite, nestedsuite: ?*GTestSuite) void;
pub extern fn g_test_run_suite(suite: ?*GTestSuite) c_int;
pub extern fn g_test_case_free(test_case: ?*GTestCase) void;
pub extern fn g_test_suite_free(suite: ?*GTestSuite) void;
pub extern fn g_test_trap_assertions(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, assertion_flags: guint64, pattern: [*c]const u8) void;
pub extern fn g_assertion_message(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, message: [*c]const u8) void;
pub extern fn g_assertion_message_expr(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8) noreturn;
pub extern fn g_assertion_message_cmpstr(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: [*c]const u8, cmp: [*c]const u8, arg2: [*c]const u8) void;
pub extern fn g_assertion_message_cmpstrv(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: [*c]const [*c]const u8, arg2: [*c]const [*c]const u8, first_wrong_idx: gsize) void;
pub extern fn g_assertion_message_cmpint(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: guint64, cmp: [*c]const u8, arg2: guint64, numtype: u8) void;
pub extern fn g_assertion_message_cmpnum(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: c_longdouble, cmp: [*c]const u8, arg2: c_longdouble, numtype: u8) void;
pub extern fn g_assertion_message_error(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, @"error": [*c]const GError, error_domain: GQuark, error_code: c_int) void;
pub extern fn g_test_add_vtable(testpath: [*c]const u8, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) void;
pub const GTestConfig = extern struct {
    test_initialized: gboolean,
    test_quick: gboolean,
    test_perf: gboolean,
    test_verbose: gboolean,
    test_quiet: gboolean,
    test_undefined: gboolean,
};
pub extern const g_test_config_vars: [*c]const GTestConfig;
pub const G_TEST_RUN_SUCCESS: c_int = 0;
pub const G_TEST_RUN_SKIPPED: c_int = 1;
pub const G_TEST_RUN_FAILURE: c_int = 2;
pub const G_TEST_RUN_INCOMPLETE: c_int = 3;
pub const GTestResult = c_uint;
pub const G_TEST_LOG_NONE: c_int = 0;
pub const G_TEST_LOG_ERROR: c_int = 1;
pub const G_TEST_LOG_START_BINARY: c_int = 2;
pub const G_TEST_LOG_LIST_CASE: c_int = 3;
pub const G_TEST_LOG_SKIP_CASE: c_int = 4;
pub const G_TEST_LOG_START_CASE: c_int = 5;
pub const G_TEST_LOG_STOP_CASE: c_int = 6;
pub const G_TEST_LOG_MIN_RESULT: c_int = 7;
pub const G_TEST_LOG_MAX_RESULT: c_int = 8;
pub const G_TEST_LOG_MESSAGE: c_int = 9;
pub const G_TEST_LOG_START_SUITE: c_int = 10;
pub const G_TEST_LOG_STOP_SUITE: c_int = 11;
pub const GTestLogType = c_uint;
pub const GTestLogMsg = extern struct {
    log_type: GTestLogType,
    n_strings: guint,
    strings: [*c][*c]gchar,
    n_nums: guint,
    nums: [*c]c_longdouble,
};
pub const GTestLogBuffer = extern struct {
    data: [*c]GString,
    msgs: [*c]GSList,
};
pub extern fn g_test_log_type_name(log_type: GTestLogType) [*c]const u8;
pub extern fn g_test_log_buffer_new() [*c]GTestLogBuffer;
pub extern fn g_test_log_buffer_free(tbuffer: [*c]GTestLogBuffer) void;
pub extern fn g_test_log_buffer_push(tbuffer: [*c]GTestLogBuffer, n_bytes: guint, bytes: [*c]const guint8) void;
pub extern fn g_test_log_buffer_pop(tbuffer: [*c]GTestLogBuffer) [*c]GTestLogMsg;
pub extern fn g_test_log_msg_free(tmsg: [*c]GTestLogMsg) void;
pub const GTestLogFatalFunc = ?*const fn ([*c]const gchar, GLogLevelFlags, [*c]const gchar, gpointer) callconv(.C) gboolean;
pub extern fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer) void;
pub extern fn g_test_expect_message(log_domain: [*c]const gchar, log_level: GLogLevelFlags, pattern: [*c]const gchar) void;
pub extern fn g_test_assert_expected_messages_internal(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8) void;
pub const G_TEST_DIST: c_int = 0;
pub const G_TEST_BUILT: c_int = 1;
pub const GTestFileType = c_uint;
pub extern fn g_test_build_filename(file_type: GTestFileType, first_path: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_test_get_dir(file_type: GTestFileType) [*c]const gchar;
pub extern fn g_test_get_filename(file_type: GTestFileType, first_path: [*c]const gchar, ...) [*c]const gchar;
pub const struct__GThreadPool = extern struct {
    func: GFunc,
    user_data: gpointer,
    exclusive: gboolean,
};
pub const GThreadPool = struct__GThreadPool;
pub extern fn g_thread_pool_new(func: GFunc, user_data: gpointer, max_threads: gint, exclusive: gboolean, @"error": [*c][*c]GError) [*c]GThreadPool;
pub extern fn g_thread_pool_new_full(func: GFunc, user_data: gpointer, item_free_func: GDestroyNotify, max_threads: gint, exclusive: gboolean, @"error": [*c][*c]GError) [*c]GThreadPool;
pub extern fn g_thread_pool_free(pool: [*c]GThreadPool, immediate: gboolean, wait_: gboolean) void;
pub extern fn g_thread_pool_push(pool: [*c]GThreadPool, data: gpointer, @"error": [*c][*c]GError) gboolean;
pub extern fn g_thread_pool_unprocessed(pool: [*c]GThreadPool) guint;
pub extern fn g_thread_pool_set_sort_function(pool: [*c]GThreadPool, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_thread_pool_move_to_front(pool: [*c]GThreadPool, data: gpointer) gboolean;
pub extern fn g_thread_pool_set_max_threads(pool: [*c]GThreadPool, max_threads: gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_thread_pool_get_max_threads(pool: [*c]GThreadPool) gint;
pub extern fn g_thread_pool_get_num_threads(pool: [*c]GThreadPool) guint;
pub extern fn g_thread_pool_set_max_unused_threads(max_threads: gint) void;
pub extern fn g_thread_pool_get_max_unused_threads() gint;
pub extern fn g_thread_pool_get_num_unused_threads() guint;
pub extern fn g_thread_pool_stop_unused_threads() void;
pub extern fn g_thread_pool_set_max_idle_time(interval: guint) void;
pub extern fn g_thread_pool_get_max_idle_time() guint;
pub const struct__GTimer = opaque {};
pub const GTimer = struct__GTimer;
pub extern fn g_timer_new() ?*GTimer;
pub extern fn g_timer_destroy(timer: ?*GTimer) void;
pub extern fn g_timer_start(timer: ?*GTimer) void;
pub extern fn g_timer_stop(timer: ?*GTimer) void;
pub extern fn g_timer_reset(timer: ?*GTimer) void;
pub extern fn g_timer_continue(timer: ?*GTimer) void;
pub extern fn g_timer_elapsed(timer: ?*GTimer, microseconds: [*c]gulong) gdouble;
pub extern fn g_timer_is_active(timer: ?*GTimer) gboolean;
pub extern fn g_usleep(microseconds: gulong) void;
pub extern fn g_time_val_add(time_: [*c]GTimeVal, microseconds: glong) void;
pub extern fn g_time_val_from_iso8601(iso_date: [*c]const gchar, time_: [*c]GTimeVal) gboolean;
pub extern fn g_time_val_to_iso8601(time_: [*c]GTimeVal) [*c]gchar;
pub const GTrashStack = struct__GTrashStack;
pub const struct__GTrashStack = extern struct {
    next: [*c]GTrashStack,
};
pub extern fn g_trash_stack_push(stack_p: [*c][*c]GTrashStack, data_p: gpointer) void;
pub extern fn g_trash_stack_pop(stack_p: [*c][*c]GTrashStack) gpointer;
pub extern fn g_trash_stack_peek(stack_p: [*c][*c]GTrashStack) gpointer;
pub extern fn g_trash_stack_height(stack_p: [*c][*c]GTrashStack) guint;
pub const struct__GTree = opaque {};
pub const GTree = struct__GTree;
pub const struct__GTreeNode = opaque {};
pub const GTreeNode = struct__GTreeNode;
pub const GTraverseFunc = ?*const fn (gpointer, gpointer, gpointer) callconv(.C) gboolean;
pub const GTraverseNodeFunc = ?*const fn (?*GTreeNode, gpointer) callconv(.C) gboolean;
pub extern fn g_tree_new(key_compare_func: GCompareFunc) ?*GTree;
pub extern fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) ?*GTree;
pub extern fn g_tree_new_full(key_compare_func: GCompareDataFunc, key_compare_data: gpointer, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) ?*GTree;
pub extern fn g_tree_node_first(tree: ?*GTree) ?*GTreeNode;
pub extern fn g_tree_node_last(tree: ?*GTree) ?*GTreeNode;
pub extern fn g_tree_node_previous(node: ?*GTreeNode) ?*GTreeNode;
pub extern fn g_tree_node_next(node: ?*GTreeNode) ?*GTreeNode;
pub extern fn g_tree_ref(tree: ?*GTree) ?*GTree;
pub extern fn g_tree_unref(tree: ?*GTree) void;
pub extern fn g_tree_destroy(tree: ?*GTree) void;
pub extern fn g_tree_insert_node(tree: ?*GTree, key: gpointer, value: gpointer) ?*GTreeNode;
pub extern fn g_tree_insert(tree: ?*GTree, key: gpointer, value: gpointer) void;
pub extern fn g_tree_replace_node(tree: ?*GTree, key: gpointer, value: gpointer) ?*GTreeNode;
pub extern fn g_tree_replace(tree: ?*GTree, key: gpointer, value: gpointer) void;
pub extern fn g_tree_remove(tree: ?*GTree, key: gconstpointer) gboolean;
pub extern fn g_tree_remove_all(tree: ?*GTree) void;
pub extern fn g_tree_steal(tree: ?*GTree, key: gconstpointer) gboolean;
pub extern fn g_tree_node_key(node: ?*GTreeNode) gpointer;
pub extern fn g_tree_node_value(node: ?*GTreeNode) gpointer;
pub extern fn g_tree_lookup_node(tree: ?*GTree, key: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_lookup(tree: ?*GTree, key: gconstpointer) gpointer;
pub extern fn g_tree_lookup_extended(tree: ?*GTree, lookup_key: gconstpointer, orig_key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_tree_foreach(tree: ?*GTree, func: GTraverseFunc, user_data: gpointer) void;
pub extern fn g_tree_foreach_node(tree: ?*GTree, func: GTraverseNodeFunc, user_data: gpointer) void;
pub extern fn g_tree_traverse(tree: ?*GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer) void;
pub extern fn g_tree_search_node(tree: ?*GTree, search_func: GCompareFunc, user_data: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_search(tree: ?*GTree, search_func: GCompareFunc, user_data: gconstpointer) gpointer;
pub extern fn g_tree_lower_bound(tree: ?*GTree, key: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_upper_bound(tree: ?*GTree, key: gconstpointer) ?*GTreeNode;
pub extern fn g_tree_height(tree: ?*GTree) gint;
pub extern fn g_tree_nnodes(tree: ?*GTree) gint;
pub const struct__GUri = opaque {};
pub const GUri = struct__GUri;
pub extern fn g_uri_ref(uri: ?*GUri) ?*GUri;
pub extern fn g_uri_unref(uri: ?*GUri) void;
pub const G_URI_FLAGS_NONE: c_int = 0;
pub const G_URI_FLAGS_PARSE_RELAXED: c_int = 1;
pub const G_URI_FLAGS_HAS_PASSWORD: c_int = 2;
pub const G_URI_FLAGS_HAS_AUTH_PARAMS: c_int = 4;
pub const G_URI_FLAGS_ENCODED: c_int = 8;
pub const G_URI_FLAGS_NON_DNS: c_int = 16;
pub const G_URI_FLAGS_ENCODED_QUERY: c_int = 32;
pub const G_URI_FLAGS_ENCODED_PATH: c_int = 64;
pub const G_URI_FLAGS_ENCODED_FRAGMENT: c_int = 128;
pub const G_URI_FLAGS_SCHEME_NORMALIZE: c_int = 256;
pub const GUriFlags = c_uint;
pub extern fn g_uri_split(uri_ref: [*c]const gchar, flags: GUriFlags, scheme: [*c][*c]gchar, userinfo: [*c][*c]gchar, host: [*c][*c]gchar, port: [*c]gint, path: [*c][*c]gchar, query: [*c][*c]gchar, fragment: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_split_with_user(uri_ref: [*c]const gchar, flags: GUriFlags, scheme: [*c][*c]gchar, user: [*c][*c]gchar, password: [*c][*c]gchar, auth_params: [*c][*c]gchar, host: [*c][*c]gchar, port: [*c]gint, path: [*c][*c]gchar, query: [*c][*c]gchar, fragment: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_split_network(uri_string: [*c]const gchar, flags: GUriFlags, scheme: [*c][*c]gchar, host: [*c][*c]gchar, port: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_is_valid(uri_string: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_join(flags: GUriFlags, scheme: [*c]const gchar, userinfo: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_join_with_user(flags: GUriFlags, scheme: [*c]const gchar, user: [*c]const gchar, password: [*c]const gchar, auth_params: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_parse(uri_string: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) ?*GUri;
pub extern fn g_uri_parse_relative(base_uri: ?*GUri, uri_ref: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) ?*GUri;
pub extern fn g_uri_resolve_relative(base_uri_string: [*c]const gchar, uri_ref: [*c]const gchar, flags: GUriFlags, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_uri_build(flags: GUriFlags, scheme: [*c]const gchar, userinfo: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) ?*GUri;
pub extern fn g_uri_build_with_user(flags: GUriFlags, scheme: [*c]const gchar, user: [*c]const gchar, password: [*c]const gchar, auth_params: [*c]const gchar, host: [*c]const gchar, port: gint, path: [*c]const gchar, query: [*c]const gchar, fragment: [*c]const gchar) ?*GUri;
pub const G_URI_HIDE_NONE: c_int = 0;
pub const G_URI_HIDE_USERINFO: c_int = 1;
pub const G_URI_HIDE_PASSWORD: c_int = 2;
pub const G_URI_HIDE_AUTH_PARAMS: c_int = 4;
pub const G_URI_HIDE_QUERY: c_int = 8;
pub const G_URI_HIDE_FRAGMENT: c_int = 16;
pub const GUriHideFlags = c_uint;
pub extern fn g_uri_to_string(uri: ?*GUri) [*c]u8;
pub extern fn g_uri_to_string_partial(uri: ?*GUri, flags: GUriHideFlags) [*c]u8;
pub extern fn g_uri_get_scheme(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_userinfo(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_user(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_password(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_auth_params(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_host(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_port(uri: ?*GUri) gint;
pub extern fn g_uri_get_path(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_query(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_fragment(uri: ?*GUri) [*c]const gchar;
pub extern fn g_uri_get_flags(uri: ?*GUri) GUriFlags;
pub const G_URI_PARAMS_NONE: c_int = 0;
pub const G_URI_PARAMS_CASE_INSENSITIVE: c_int = 1;
pub const G_URI_PARAMS_WWW_FORM: c_int = 2;
pub const G_URI_PARAMS_PARSE_RELAXED: c_int = 4;
pub const GUriParamsFlags = c_uint;
pub extern fn g_uri_parse_params(params: [*c]const gchar, length: gssize, separators: [*c]const gchar, flags: GUriParamsFlags, @"error": [*c][*c]GError) ?*GHashTable;
pub const struct__GUriParamsIter = extern struct {
    dummy0: gint,
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: [256]guint8,
};
pub const GUriParamsIter = struct__GUriParamsIter;
pub extern fn g_uri_params_iter_init(iter: [*c]GUriParamsIter, params: [*c]const gchar, length: gssize, separators: [*c]const gchar, flags: GUriParamsFlags) void;
pub extern fn g_uri_params_iter_next(iter: [*c]GUriParamsIter, attribute: [*c][*c]gchar, value: [*c][*c]gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_uri_error_quark() GQuark;
pub const G_URI_ERROR_FAILED: c_int = 0;
pub const G_URI_ERROR_BAD_SCHEME: c_int = 1;
pub const G_URI_ERROR_BAD_USER: c_int = 2;
pub const G_URI_ERROR_BAD_PASSWORD: c_int = 3;
pub const G_URI_ERROR_BAD_AUTH_PARAMS: c_int = 4;
pub const G_URI_ERROR_BAD_HOST: c_int = 5;
pub const G_URI_ERROR_BAD_PORT: c_int = 6;
pub const G_URI_ERROR_BAD_PATH: c_int = 7;
pub const G_URI_ERROR_BAD_QUERY: c_int = 8;
pub const G_URI_ERROR_BAD_FRAGMENT: c_int = 9;
pub const GUriError = c_uint;
pub extern fn g_uri_unescape_string(escaped_string: [*c]const u8, illegal_characters: [*c]const u8) [*c]u8;
pub extern fn g_uri_unescape_segment(escaped_string: [*c]const u8, escaped_string_end: [*c]const u8, illegal_characters: [*c]const u8) [*c]u8;
pub extern fn g_uri_parse_scheme(uri: [*c]const u8) [*c]u8;
pub extern fn g_uri_peek_scheme(uri: [*c]const u8) [*c]const u8;
pub extern fn g_uri_escape_string(unescaped: [*c]const u8, reserved_chars_allowed: [*c]const u8, allow_utf8: gboolean) [*c]u8;
pub extern fn g_uri_unescape_bytes(escaped_string: [*c]const u8, length: gssize, illegal_characters: [*c]const u8, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_uri_escape_bytes(unescaped: [*c]const guint8, length: gsize, reserved_chars_allowed: [*c]const u8) [*c]u8;
pub extern fn g_uuid_string_is_valid(str: [*c]const gchar) gboolean;
pub extern fn g_uuid_string_random() [*c]gchar;
pub extern const glib_major_version: guint;
pub extern const glib_minor_version: guint;
pub extern const glib_micro_version: guint;
pub extern const glib_interface_age: guint;
pub extern const glib_binary_age: guint;
pub extern fn glib_check_version(required_major: guint, required_minor: guint, required_micro: guint) [*c]const gchar;
pub const struct__GAllocator = opaque {};
pub const GAllocator = struct__GAllocator;
pub const struct__GMemChunk = opaque {};
pub const GMemChunk = struct__GMemChunk;
pub extern fn g_mem_chunk_new(name: [*c]const gchar, atom_size: gint, area_size: gsize, @"type": gint) ?*GMemChunk;
pub extern fn g_mem_chunk_destroy(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_alloc(mem_chunk: ?*GMemChunk) gpointer;
pub extern fn g_mem_chunk_alloc0(mem_chunk: ?*GMemChunk) gpointer;
pub extern fn g_mem_chunk_free(mem_chunk: ?*GMemChunk, mem: gpointer) void;
pub extern fn g_mem_chunk_clean(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_reset(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_print(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_info() void;
pub extern fn g_blow_chunks() void;
pub extern fn g_allocator_new(name: [*c]const gchar, n_preallocs: guint) ?*GAllocator;
pub extern fn g_allocator_free(allocator: ?*GAllocator) void;
pub extern fn g_list_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_list_pop_allocator() void;
pub extern fn g_slist_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_slist_pop_allocator() void;
pub extern fn g_node_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_node_pop_allocator() void;
pub const struct__GCache = opaque {};
pub const GCache = struct__GCache;
pub const GCacheNewFunc = ?*const fn (gpointer) callconv(.C) gpointer;
pub const GCacheDupFunc = ?*const fn (gpointer) callconv(.C) gpointer;
pub const GCacheDestroyFunc = ?*const fn (gpointer) callconv(.C) void;
pub extern fn g_cache_new(value_new_func: GCacheNewFunc, value_destroy_func: GCacheDestroyFunc, key_dup_func: GCacheDupFunc, key_destroy_func: GCacheDestroyFunc, hash_key_func: GHashFunc, hash_value_func: GHashFunc, key_equal_func: GEqualFunc) ?*GCache;
pub extern fn g_cache_destroy(cache: ?*GCache) void;
pub extern fn g_cache_insert(cache: ?*GCache, key: gpointer) gpointer;
pub extern fn g_cache_remove(cache: ?*GCache, value: gconstpointer) void;
pub extern fn g_cache_key_foreach(cache: ?*GCache, func: GHFunc, user_data: gpointer) void;
pub extern fn g_cache_value_foreach(cache: ?*GCache, func: GHFunc, user_data: gpointer) void;
pub const GCompletionFunc = ?*const fn (gpointer) callconv(.C) [*c]gchar;
pub const GCompletionStrncmpFunc = ?*const fn ([*c]const gchar, [*c]const gchar, gsize) callconv(.C) gint;
pub const struct__GCompletion = extern struct {
    items: [*c]GList,
    func: GCompletionFunc,
    prefix: [*c]gchar,
    cache: [*c]GList,
    strncmp_func: GCompletionStrncmpFunc,
};
pub const GCompletion = struct__GCompletion;
pub extern fn g_completion_new(func: GCompletionFunc) [*c]GCompletion;
pub extern fn g_completion_add_items(cmp: [*c]GCompletion, items: [*c]GList) void;
pub extern fn g_completion_remove_items(cmp: [*c]GCompletion, items: [*c]GList) void;
pub extern fn g_completion_clear_items(cmp: [*c]GCompletion) void;
pub extern fn g_completion_complete(cmp: [*c]GCompletion, prefix: [*c]const gchar, new_prefix: [*c][*c]gchar) [*c]GList;
pub extern fn g_completion_complete_utf8(cmp: [*c]GCompletion, prefix: [*c]const gchar, new_prefix: [*c][*c]gchar) [*c]GList;
pub extern fn g_completion_set_compare(cmp: [*c]GCompletion, strncmp_func: GCompletionStrncmpFunc) void;
pub extern fn g_completion_free(cmp: [*c]GCompletion) void;
pub const struct__GRelation = opaque {};
pub const GRelation = struct__GRelation;
pub const struct__GTuples = extern struct {
    len: guint,
};
pub const GTuples = struct__GTuples;
pub extern fn g_relation_new(fields: gint) ?*GRelation;
pub extern fn g_relation_destroy(relation: ?*GRelation) void;
pub extern fn g_relation_index(relation: ?*GRelation, field: gint, hash_func: GHashFunc, key_equal_func: GEqualFunc) void;
pub extern fn g_relation_insert(relation: ?*GRelation, ...) void;
pub extern fn g_relation_delete(relation: ?*GRelation, key: gconstpointer, field: gint) gint;
pub extern fn g_relation_select(relation: ?*GRelation, key: gconstpointer, field: gint) [*c]GTuples;
pub extern fn g_relation_count(relation: ?*GRelation, key: gconstpointer, field: gint) gint;
pub extern fn g_relation_exists(relation: ?*GRelation, ...) gboolean;
pub extern fn g_relation_print(relation: ?*GRelation) void;
pub extern fn g_tuples_destroy(tuples: [*c]GTuples) void;
pub extern fn g_tuples_index(tuples: [*c]GTuples, index_: gint, field: gint) gpointer;
pub const G_THREAD_PRIORITY_LOW: c_int = 0;
pub const G_THREAD_PRIORITY_NORMAL: c_int = 1;
pub const G_THREAD_PRIORITY_HIGH: c_int = 2;
pub const G_THREAD_PRIORITY_URGENT: c_int = 3;
pub const GThreadPriority = c_uint;
pub const struct__GThreadFunctions = extern struct {
    mutex_new: ?*const fn () callconv(.C) [*c]GMutex,
    mutex_lock: ?*const fn ([*c]GMutex) callconv(.C) void,
    mutex_trylock: ?*const fn ([*c]GMutex) callconv(.C) gboolean,
    mutex_unlock: ?*const fn ([*c]GMutex) callconv(.C) void,
    mutex_free: ?*const fn ([*c]GMutex) callconv(.C) void,
    cond_new: ?*const fn () callconv(.C) [*c]GCond,
    cond_signal: ?*const fn ([*c]GCond) callconv(.C) void,
    cond_broadcast: ?*const fn ([*c]GCond) callconv(.C) void,
    cond_wait: ?*const fn ([*c]GCond, [*c]GMutex) callconv(.C) void,
    cond_timed_wait: ?*const fn ([*c]GCond, [*c]GMutex, [*c]GTimeVal) callconv(.C) gboolean,
    cond_free: ?*const fn ([*c]GCond) callconv(.C) void,
    private_new: ?*const fn (GDestroyNotify) callconv(.C) [*c]GPrivate,
    private_get: ?*const fn ([*c]GPrivate) callconv(.C) gpointer,
    private_set: ?*const fn ([*c]GPrivate, gpointer) callconv(.C) void,
    thread_create: ?*const fn (GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, [*c][*c]GError) callconv(.C) void,
    thread_yield: ?*const fn () callconv(.C) void,
    thread_join: ?*const fn (gpointer) callconv(.C) void,
    thread_exit: ?*const fn () callconv(.C) void,
    thread_set_priority: ?*const fn (gpointer, GThreadPriority) callconv(.C) void,
    thread_self: ?*const fn (gpointer) callconv(.C) void,
    thread_equal: ?*const fn (gpointer, gpointer) callconv(.C) gboolean,
};
pub const GThreadFunctions = struct__GThreadFunctions;
pub extern var g_thread_functions_for_glib_use: GThreadFunctions;
pub extern var g_thread_use_default_impl: gboolean;
pub extern var g_thread_gettime: ?*const fn () callconv(.C) guint64;
pub extern fn g_thread_create(func: GThreadFunc, data: gpointer, joinable: gboolean, @"error": [*c][*c]GError) [*c]GThread;
pub extern fn g_thread_create_full(func: GThreadFunc, data: gpointer, stack_size: gulong, joinable: gboolean, bound: gboolean, priority: GThreadPriority, @"error": [*c][*c]GError) [*c]GThread;
pub extern fn g_thread_set_priority(thread: [*c]GThread, priority: GThreadPriority) void;
pub extern fn g_thread_foreach(thread_func: GFunc, user_data: gpointer) void;
pub const struct_sched_param = extern struct {
    sched_priority: c_int,
};
pub const __cpu_mask = c_ulong;
pub const cpu_set_t = extern struct {
    __bits: [16]__cpu_mask,
};
pub extern fn __sched_cpucount(__setsize: usize, __setp: [*c]const cpu_set_t) c_int;
pub extern fn __sched_cpualloc(__count: usize) [*c]cpu_set_t;
pub extern fn __sched_cpufree(__set: [*c]cpu_set_t) void;
pub extern fn sched_setparam(__pid: __pid_t, __param: [*c]const struct_sched_param) c_int;
pub extern fn sched_getparam(__pid: __pid_t, __param: [*c]struct_sched_param) c_int;
pub extern fn sched_setscheduler(__pid: __pid_t, __policy: c_int, __param: [*c]const struct_sched_param) c_int;
pub extern fn sched_getscheduler(__pid: __pid_t) c_int;
pub extern fn sched_yield() c_int;
pub extern fn sched_get_priority_max(__algorithm: c_int) c_int;
pub extern fn sched_get_priority_min(__algorithm: c_int) c_int;
pub extern fn sched_rr_get_interval(__pid: __pid_t, __t: [*c]struct_timespec) c_int;
pub const __jmp_buf = [8]c_long;
pub const struct___jmp_buf_tag = extern struct {
    __jmpbuf: __jmp_buf,
    __mask_was_saved: c_int,
    __saved_mask: __sigset_t,
};
pub const PTHREAD_CREATE_JOINABLE: c_int = 0;
pub const PTHREAD_CREATE_DETACHED: c_int = 1;
const enum_unnamed_32 = c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: c_int = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: c_int = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: c_int = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: c_int = 3;
pub const PTHREAD_MUTEX_NORMAL: c_int = 0;
pub const PTHREAD_MUTEX_RECURSIVE: c_int = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: c_int = 2;
pub const PTHREAD_MUTEX_DEFAULT: c_int = 0;
const enum_unnamed_33 = c_uint;
pub const PTHREAD_MUTEX_STALLED: c_int = 0;
pub const PTHREAD_MUTEX_STALLED_NP: c_int = 0;
pub const PTHREAD_MUTEX_ROBUST: c_int = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: c_int = 1;
const enum_unnamed_34 = c_uint;
pub const PTHREAD_PRIO_NONE: c_int = 0;
pub const PTHREAD_PRIO_INHERIT: c_int = 1;
pub const PTHREAD_PRIO_PROTECT: c_int = 2;
const enum_unnamed_35 = c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: c_int = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: c_int = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: c_int = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: c_int = 0;
const enum_unnamed_36 = c_uint;
pub const PTHREAD_INHERIT_SCHED: c_int = 0;
pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
const enum_unnamed_37 = c_uint;
pub const PTHREAD_SCOPE_SYSTEM: c_int = 0;
pub const PTHREAD_SCOPE_PROCESS: c_int = 1;
const enum_unnamed_38 = c_uint;
pub const PTHREAD_PROCESS_PRIVATE: c_int = 0;
pub const PTHREAD_PROCESS_SHARED: c_int = 1;
const enum_unnamed_39 = c_uint;
pub const struct__pthread_cleanup_buffer = extern struct {
    __routine: ?*const fn (?*anyopaque) callconv(.C) void,
    __arg: ?*anyopaque,
    __canceltype: c_int,
    __prev: [*c]struct__pthread_cleanup_buffer,
};
pub const PTHREAD_CANCEL_ENABLE: c_int = 0;
pub const PTHREAD_CANCEL_DISABLE: c_int = 1;
const enum_unnamed_40 = c_uint;
pub const PTHREAD_CANCEL_DEFERRED: c_int = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: c_int = 1;
const enum_unnamed_41 = c_uint;
pub extern fn pthread_create(noalias __newthread: [*c]pthread_t, noalias __attr: [*c]const pthread_attr_t, __start_routine: ?*const fn (?*anyopaque) callconv(.C) ?*anyopaque, noalias __arg: ?*anyopaque) c_int;
pub extern fn pthread_exit(__retval: ?*anyopaque) noreturn;
pub extern fn pthread_join(__th: pthread_t, __thread_return: [*c]?*anyopaque) c_int;
pub extern fn pthread_detach(__th: pthread_t) c_int;
pub extern fn pthread_self() pthread_t;
pub extern fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) c_int;
pub extern fn pthread_attr_init(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_destroy(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_getdetachstate(__attr: [*c]const pthread_attr_t, __detachstate: [*c]c_int) c_int;
pub extern fn pthread_attr_setdetachstate(__attr: [*c]pthread_attr_t, __detachstate: c_int) c_int;
pub extern fn pthread_attr_getguardsize(__attr: [*c]const pthread_attr_t, __guardsize: [*c]usize) c_int;
pub extern fn pthread_attr_setguardsize(__attr: [*c]pthread_attr_t, __guardsize: usize) c_int;
pub extern fn pthread_attr_getschedparam(noalias __attr: [*c]const pthread_attr_t, noalias __param: [*c]struct_sched_param) c_int;
pub extern fn pthread_attr_setschedparam(noalias __attr: [*c]pthread_attr_t, noalias __param: [*c]const struct_sched_param) c_int;
pub extern fn pthread_attr_getschedpolicy(noalias __attr: [*c]const pthread_attr_t, noalias __policy: [*c]c_int) c_int;
pub extern fn pthread_attr_setschedpolicy(__attr: [*c]pthread_attr_t, __policy: c_int) c_int;
pub extern fn pthread_attr_getinheritsched(noalias __attr: [*c]const pthread_attr_t, noalias __inherit: [*c]c_int) c_int;
pub extern fn pthread_attr_setinheritsched(__attr: [*c]pthread_attr_t, __inherit: c_int) c_int;
pub extern fn pthread_attr_getscope(noalias __attr: [*c]const pthread_attr_t, noalias __scope: [*c]c_int) c_int;
pub extern fn pthread_attr_setscope(__attr: [*c]pthread_attr_t, __scope: c_int) c_int;
pub extern fn pthread_attr_getstackaddr(noalias __attr: [*c]const pthread_attr_t, noalias __stackaddr: [*c]?*anyopaque) c_int;
pub extern fn pthread_attr_setstackaddr(__attr: [*c]pthread_attr_t, __stackaddr: ?*anyopaque) c_int;
pub extern fn pthread_attr_getstacksize(noalias __attr: [*c]const pthread_attr_t, noalias __stacksize: [*c]usize) c_int;
pub extern fn pthread_attr_setstacksize(__attr: [*c]pthread_attr_t, __stacksize: usize) c_int;
pub extern fn pthread_attr_getstack(noalias __attr: [*c]const pthread_attr_t, noalias __stackaddr: [*c]?*anyopaque, noalias __stacksize: [*c]usize) c_int;
pub extern fn pthread_attr_setstack(__attr: [*c]pthread_attr_t, __stackaddr: ?*anyopaque, __stacksize: usize) c_int;
pub extern fn pthread_setschedparam(__target_thread: pthread_t, __policy: c_int, __param: [*c]const struct_sched_param) c_int;
pub extern fn pthread_getschedparam(__target_thread: pthread_t, noalias __policy: [*c]c_int, noalias __param: [*c]struct_sched_param) c_int;
pub extern fn pthread_setschedprio(__target_thread: pthread_t, __prio: c_int) c_int;
pub extern fn pthread_once(__once_control: [*c]pthread_once_t, __init_routine: ?*const fn () callconv(.C) void) c_int;
pub extern fn pthread_setcancelstate(__state: c_int, __oldstate: [*c]c_int) c_int;
pub extern fn pthread_setcanceltype(__type: c_int, __oldtype: [*c]c_int) c_int;
pub extern fn pthread_cancel(__th: pthread_t) c_int;
pub extern fn pthread_testcancel() void;
pub const struct___cancel_jmp_buf_tag = extern struct {
    __cancel_jmp_buf: __jmp_buf,
    __mask_was_saved: c_int,
};
pub const __pthread_unwind_buf_t = extern struct {
    __cancel_jmp_buf: [1]struct___cancel_jmp_buf_tag,
    __pad: [4]?*anyopaque,
};
pub const struct___pthread_cleanup_frame = extern struct {
    __cancel_routine: ?*const fn (?*anyopaque) callconv(.C) void,
    __cancel_arg: ?*anyopaque,
    __do_it: c_int,
    __cancel_type: c_int,
};
pub extern fn __pthread_register_cancel(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unregister_cancel(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unwind_next(__buf: [*c]__pthread_unwind_buf_t) noreturn;
pub extern fn __sigsetjmp(__env: [*c]struct___jmp_buf_tag, __savemask: c_int) c_int;
pub extern fn pthread_mutex_init(__mutex: [*c]pthread_mutex_t, __mutexattr: [*c]const pthread_mutexattr_t) c_int;
pub extern fn pthread_mutex_destroy(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_trylock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_lock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_timedlock(noalias __mutex: [*c]pthread_mutex_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_mutex_unlock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_getprioceiling(noalias __mutex: [*c]const pthread_mutex_t, noalias __prioceiling: [*c]c_int) c_int;
pub extern fn pthread_mutex_setprioceiling(noalias __mutex: [*c]pthread_mutex_t, __prioceiling: c_int, noalias __old_ceiling: [*c]c_int) c_int;
pub extern fn pthread_mutex_consistent(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutexattr_init(__attr: [*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_destroy(__attr: [*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_getpshared(noalias __attr: [*c]const pthread_mutexattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setpshared(__attr: [*c]pthread_mutexattr_t, __pshared: c_int) c_int;
pub extern fn pthread_mutexattr_gettype(noalias __attr: [*c]const pthread_mutexattr_t, noalias __kind: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_settype(__attr: [*c]pthread_mutexattr_t, __kind: c_int) c_int;
pub extern fn pthread_mutexattr_getprotocol(noalias __attr: [*c]const pthread_mutexattr_t, noalias __protocol: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setprotocol(__attr: [*c]pthread_mutexattr_t, __protocol: c_int) c_int;
pub extern fn pthread_mutexattr_getprioceiling(noalias __attr: [*c]const pthread_mutexattr_t, noalias __prioceiling: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setprioceiling(__attr: [*c]pthread_mutexattr_t, __prioceiling: c_int) c_int;
pub extern fn pthread_mutexattr_getrobust(__attr: [*c]const pthread_mutexattr_t, __robustness: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setrobust(__attr: [*c]pthread_mutexattr_t, __robustness: c_int) c_int;
pub extern fn pthread_rwlock_init(noalias __rwlock: [*c]pthread_rwlock_t, noalias __attr: [*c]const pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlock_destroy(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_rdlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_tryrdlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_timedrdlock(noalias __rwlock: [*c]pthread_rwlock_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_wrlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_trywrlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_timedwrlock(noalias __rwlock: [*c]pthread_rwlock_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_unlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlockattr_init(__attr: [*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_destroy(__attr: [*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_getpshared(noalias __attr: [*c]const pthread_rwlockattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_setpshared(__attr: [*c]pthread_rwlockattr_t, __pshared: c_int) c_int;
pub extern fn pthread_rwlockattr_getkind_np(noalias __attr: [*c]const pthread_rwlockattr_t, noalias __pref: [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_setkind_np(__attr: [*c]pthread_rwlockattr_t, __pref: c_int) c_int;
pub extern fn pthread_cond_init(noalias __cond: [*c]pthread_cond_t, noalias __cond_attr: [*c]const pthread_condattr_t) c_int;
pub extern fn pthread_cond_destroy(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_signal(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_broadcast(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_wait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_cond_timedwait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_condattr_init(__attr: [*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_destroy(__attr: [*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_getpshared(noalias __attr: [*c]const pthread_condattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_condattr_setpshared(__attr: [*c]pthread_condattr_t, __pshared: c_int) c_int;
pub extern fn pthread_condattr_getclock(noalias __attr: [*c]const pthread_condattr_t, noalias __clock_id: [*c]__clockid_t) c_int;
pub extern fn pthread_condattr_setclock(__attr: [*c]pthread_condattr_t, __clock_id: __clockid_t) c_int;
pub extern fn pthread_spin_init(__lock: [*c]volatile pthread_spinlock_t, __pshared: c_int) c_int;
pub extern fn pthread_spin_destroy(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_lock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_trylock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_unlock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_barrier_init(noalias __barrier: [*c]pthread_barrier_t, noalias __attr: [*c]const pthread_barrierattr_t, __count: c_uint) c_int;
pub extern fn pthread_barrier_destroy(__barrier: [*c]pthread_barrier_t) c_int;
pub extern fn pthread_barrier_wait(__barrier: [*c]pthread_barrier_t) c_int;
pub extern fn pthread_barrierattr_init(__attr: [*c]pthread_barrierattr_t) c_int;
pub extern fn pthread_barrierattr_destroy(__attr: [*c]pthread_barrierattr_t) c_int;
pub extern fn pthread_barrierattr_getpshared(noalias __attr: [*c]const pthread_barrierattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_barrierattr_setpshared(__attr: [*c]pthread_barrierattr_t, __pshared: c_int) c_int;
pub extern fn pthread_key_create(__key: [*c]pthread_key_t, __destr_function: ?*const fn (?*anyopaque) callconv(.C) void) c_int;
pub extern fn pthread_key_delete(__key: pthread_key_t) c_int;
pub extern fn pthread_getspecific(__key: pthread_key_t) ?*anyopaque;
pub extern fn pthread_setspecific(__key: pthread_key_t, __pointer: ?*const anyopaque) c_int;
pub extern fn pthread_getcpuclockid(__thread_id: pthread_t, __clock_id: [*c]__clockid_t) c_int;
pub extern fn pthread_atfork(__prepare: ?*const fn () callconv(.C) void, __parent: ?*const fn () callconv(.C) void, __child: ?*const fn () callconv(.C) void) c_int;
pub const GStaticMutex = extern struct {
    mutex: [*c]GMutex,
    unused: pthread_mutex_t,
};
pub extern fn g_static_mutex_init(mutex: [*c]GStaticMutex) void;
pub extern fn g_static_mutex_free(mutex: [*c]GStaticMutex) void;
pub extern fn g_static_mutex_get_mutex_impl(mutex: [*c]GStaticMutex) [*c]GMutex;
const union_unnamed_42 = extern union {
    owner: pthread_t,
    dummy: gdouble,
};
pub const struct__GStaticRecMutex = extern struct {
    mutex: GStaticMutex,
    depth: guint,
    unused: union_unnamed_42,
};
pub const GStaticRecMutex = struct__GStaticRecMutex;
pub extern fn g_static_rec_mutex_init(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_lock(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_trylock(mutex: [*c]GStaticRecMutex) gboolean;
pub extern fn g_static_rec_mutex_unlock(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_lock_full(mutex: [*c]GStaticRecMutex, depth: guint) void;
pub extern fn g_static_rec_mutex_unlock_full(mutex: [*c]GStaticRecMutex) guint;
pub extern fn g_static_rec_mutex_free(mutex: [*c]GStaticRecMutex) void;
pub const struct__GStaticRWLock = extern struct {
    mutex: GStaticMutex,
    read_cond: [*c]GCond,
    write_cond: [*c]GCond,
    read_counter: guint,
    have_writer: gboolean,
    want_to_read: guint,
    want_to_write: guint,
};
pub const GStaticRWLock = struct__GStaticRWLock;
pub extern fn g_static_rw_lock_init(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_reader_lock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_reader_trylock(lock: [*c]GStaticRWLock) gboolean;
pub extern fn g_static_rw_lock_reader_unlock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_writer_lock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_writer_trylock(lock: [*c]GStaticRWLock) gboolean;
pub extern fn g_static_rw_lock_writer_unlock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_free(lock: [*c]GStaticRWLock) void;
pub extern fn g_private_new(notify: GDestroyNotify) [*c]GPrivate;
pub const struct__GStaticPrivate = extern struct {
    index: guint,
};
pub const GStaticPrivate = struct__GStaticPrivate;
pub extern fn g_static_private_init(private_key: [*c]GStaticPrivate) void;
pub extern fn g_static_private_get(private_key: [*c]GStaticPrivate) gpointer;
pub extern fn g_static_private_set(private_key: [*c]GStaticPrivate, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_static_private_free(private_key: [*c]GStaticPrivate) void;
pub extern fn g_once_init_enter_impl(location: [*c]volatile gsize) gboolean;
pub extern fn g_thread_init(vtable: gpointer) void;
pub extern fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer) void;
pub extern fn g_thread_get_initialized() gboolean;
pub extern var g_threads_got_initialized: gboolean;
pub extern fn g_mutex_new() [*c]GMutex;
pub extern fn g_mutex_free(mutex: [*c]GMutex) void;
pub extern fn g_cond_new() [*c]GCond;
pub extern fn g_cond_free(cond: [*c]GCond) void;
pub extern fn g_cond_timed_wait(cond: [*c]GCond, mutex: [*c]GMutex, timeval: [*c]GTimeVal) gboolean;
pub fn g_autoptr_cleanup_generic_gfree(arg_p: ?*anyopaque) callconv(.C) void {
    var p = arg_p;
    var pp: [*c]?*anyopaque = @as([*c]?*anyopaque, @ptrCast(@alignCast(p)));
    g_free(pp.*);
}
pub fn g_autoptr_cleanup_gstring_free(arg_string: [*c]GString) callconv(.C) void {
    var string = arg_string;
    if (string != null) {
        _ = if (__builtin_constant_p(!(@as(c_int, 0) != 0)) != 0) if (!(@as(c_int, 0) != 0)) g_string_free(string, @intFromBool(!(@as(c_int, 0) != 0))) else g_string_free_and_steal(string) else g_string_free(string, @intFromBool(!(@as(c_int, 0) != 0)));
    }
}
pub const GAsyncQueue_autoptr = ?*GAsyncQueue;
pub const GAsyncQueue_listautoptr = [*c]GList;
pub const GAsyncQueue_slistautoptr = [*c]GSList;
pub const GAsyncQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncQueue(arg__ptr: ?*GAsyncQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_async_queue_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GAsyncQueue(arg__ptr: [*c]?*GAsyncQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAsyncQueue(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAsyncQueue(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_async_queue_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAsyncQueue(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_async_queue_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAsyncQueue(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_async_queue_unref)))))));
    }
}
pub const GBookmarkFile_autoptr = ?*GBookmarkFile;
pub const GBookmarkFile_listautoptr = [*c]GList;
pub const GBookmarkFile_slistautoptr = [*c]GSList;
pub const GBookmarkFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBookmarkFile(arg__ptr: ?*GBookmarkFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_bookmark_file_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GBookmarkFile(arg__ptr: [*c]?*GBookmarkFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBookmarkFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBookmarkFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_bookmark_file_free)))))));
}
pub fn glib_slistautoptr_cleanup_GBookmarkFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_bookmark_file_free)))))));
}
pub fn glib_queueautoptr_cleanup_GBookmarkFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_bookmark_file_free)))))));
    }
}
pub const GBytes_autoptr = ?*GBytes;
pub const GBytes_listautoptr = [*c]GList;
pub const GBytes_slistautoptr = [*c]GSList;
pub const GBytes_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBytes(arg__ptr: ?*GBytes) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_bytes_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GBytes(arg__ptr: [*c]?*GBytes) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBytes(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBytes(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_bytes_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GBytes(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_bytes_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GBytes(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_bytes_unref)))))));
    }
}
pub const GChecksum_autoptr = ?*GChecksum;
pub const GChecksum_listautoptr = [*c]GList;
pub const GChecksum_slistautoptr = [*c]GSList;
pub const GChecksum_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GChecksum(arg__ptr: ?*GChecksum) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_checksum_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GChecksum(arg__ptr: [*c]?*GChecksum) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GChecksum(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GChecksum(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_checksum_free)))))));
}
pub fn glib_slistautoptr_cleanup_GChecksum(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_checksum_free)))))));
}
pub fn glib_queueautoptr_cleanup_GChecksum(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_checksum_free)))))));
    }
}
pub const GDateTime_autoptr = ?*GDateTime;
pub const GDateTime_listautoptr = [*c]GList;
pub const GDateTime_slistautoptr = [*c]GSList;
pub const GDateTime_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDateTime(arg__ptr: ?*GDateTime) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_date_time_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDateTime(arg__ptr: [*c]?*GDateTime) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDateTime(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDateTime(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_date_time_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDateTime(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_date_time_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDateTime(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_date_time_unref)))))));
    }
}
pub const GDate_autoptr = ?*GDate;
pub const GDate_listautoptr = [*c]GList;
pub const GDate_slistautoptr = [*c]GSList;
pub const GDate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDate(arg__ptr: ?*GDate) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_date_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDate(arg__ptr: [*c]?*GDate) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDate(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDate(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_date_free)))))));
}
pub fn glib_slistautoptr_cleanup_GDate(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_date_free)))))));
}
pub fn glib_queueautoptr_cleanup_GDate(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_date_free)))))));
    }
}
pub const GDir_autoptr = ?*GDir;
pub const GDir_listautoptr = [*c]GList;
pub const GDir_slistautoptr = [*c]GSList;
pub const GDir_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDir(arg__ptr: ?*GDir) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_dir_close(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDir(arg__ptr: [*c]?*GDir) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDir(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDir(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_dir_close)))))));
}
pub fn glib_slistautoptr_cleanup_GDir(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_dir_close)))))));
}
pub fn glib_queueautoptr_cleanup_GDir(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_dir_close)))))));
    }
}
pub const GError_autoptr = [*c]GError;
pub const GError_listautoptr = [*c]GList;
pub const GError_slistautoptr = [*c]GSList;
pub const GError_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GError(arg__ptr: [*c]GError) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_error_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GError(arg__ptr: [*c][*c]GError) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GError(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GError(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_error_free)))))));
}
pub fn glib_slistautoptr_cleanup_GError(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_error_free)))))));
}
pub fn glib_queueautoptr_cleanup_GError(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_error_free)))))));
    }
}
pub const GHashTable_autoptr = ?*GHashTable;
pub const GHashTable_listautoptr = [*c]GList;
pub const GHashTable_slistautoptr = [*c]GSList;
pub const GHashTable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GHashTable(arg__ptr: ?*GHashTable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_hash_table_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GHashTable(arg__ptr: [*c]?*GHashTable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GHashTable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GHashTable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_hash_table_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GHashTable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_hash_table_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GHashTable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_hash_table_unref)))))));
    }
}
pub const GHmac_autoptr = ?*GHmac;
pub const GHmac_listautoptr = [*c]GList;
pub const GHmac_slistautoptr = [*c]GSList;
pub const GHmac_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GHmac(arg__ptr: ?*GHmac) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_hmac_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GHmac(arg__ptr: [*c]?*GHmac) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GHmac(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GHmac(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_hmac_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GHmac(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_hmac_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GHmac(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_hmac_unref)))))));
    }
}
pub const GIOChannel_autoptr = ?*GIOChannel;
pub const GIOChannel_listautoptr = [*c]GList;
pub const GIOChannel_slistautoptr = [*c]GSList;
pub const GIOChannel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOChannel(arg__ptr: ?*GIOChannel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_io_channel_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GIOChannel(arg__ptr: [*c]?*GIOChannel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GIOChannel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GIOChannel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_io_channel_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GIOChannel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_io_channel_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GIOChannel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_io_channel_unref)))))));
    }
}
pub const GKeyFile_autoptr = ?*GKeyFile;
pub const GKeyFile_listautoptr = [*c]GList;
pub const GKeyFile_slistautoptr = [*c]GSList;
pub const GKeyFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GKeyFile(arg__ptr: ?*GKeyFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_key_file_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GKeyFile(arg__ptr: [*c]?*GKeyFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GKeyFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GKeyFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_key_file_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GKeyFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_key_file_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GKeyFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_key_file_unref)))))));
    }
}
pub const GList_autoptr = [*c]GList;
pub const GList_listautoptr = [*c]GList;
pub const GList_slistautoptr = [*c]GSList;
pub const GList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GList(arg__ptr: [*c]GList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_list_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GList(arg__ptr: [*c][*c]GList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_list_free)))))));
}
pub fn glib_slistautoptr_cleanup_GList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_list_free)))))));
}
pub fn glib_queueautoptr_cleanup_GList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_list_free)))))));
    }
}
pub const GArray_autoptr = [*c]GArray;
pub const GArray_listautoptr = [*c]GList;
pub const GArray_slistautoptr = [*c]GSList;
pub const GArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GArray(arg__ptr: [*c]GArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_array_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GArray(arg__ptr: [*c][*c]GArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_array_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_array_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_array_unref)))))));
    }
}
pub const GPtrArray_autoptr = [*c]GPtrArray;
pub const GPtrArray_listautoptr = [*c]GList;
pub const GPtrArray_slistautoptr = [*c]GSList;
pub const GPtrArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPtrArray(arg__ptr: [*c]GPtrArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_ptr_array_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GPtrArray(arg__ptr: [*c][*c]GPtrArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPtrArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPtrArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_ptr_array_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GPtrArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_ptr_array_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GPtrArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_ptr_array_unref)))))));
    }
}
pub const GByteArray_autoptr = [*c]GByteArray;
pub const GByteArray_listautoptr = [*c]GList;
pub const GByteArray_slistautoptr = [*c]GSList;
pub const GByteArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GByteArray(arg__ptr: [*c]GByteArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_byte_array_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GByteArray(arg__ptr: [*c][*c]GByteArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GByteArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GByteArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_byte_array_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GByteArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_byte_array_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GByteArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_byte_array_unref)))))));
    }
}
pub const GMainContext_autoptr = ?*GMainContext;
pub const GMainContext_listautoptr = [*c]GList;
pub const GMainContext_slistautoptr = [*c]GSList;
pub const GMainContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainContext(arg__ptr: ?*GMainContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_main_context_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMainContext(arg__ptr: [*c]?*GMainContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMainContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMainContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_context_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMainContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_context_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMainContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_context_unref)))))));
    }
}
pub const GMainContextPusher_autoptr = ?*GMainContextPusher;
pub const GMainContextPusher_listautoptr = [*c]GList;
pub const GMainContextPusher_slistautoptr = [*c]GSList;
pub const GMainContextPusher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainContextPusher(arg__ptr: ?*GMainContextPusher) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_main_context_pusher_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMainContextPusher(arg__ptr: [*c]?*GMainContextPusher) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMainContextPusher(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMainContextPusher(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_context_pusher_free)))))));
}
pub fn glib_slistautoptr_cleanup_GMainContextPusher(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_context_pusher_free)))))));
}
pub fn glib_queueautoptr_cleanup_GMainContextPusher(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_context_pusher_free)))))));
    }
}
pub const GMainLoop_autoptr = ?*GMainLoop;
pub const GMainLoop_listautoptr = [*c]GList;
pub const GMainLoop_slistautoptr = [*c]GSList;
pub const GMainLoop_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainLoop(arg__ptr: ?*GMainLoop) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_main_loop_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMainLoop(arg__ptr: [*c]?*GMainLoop) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMainLoop(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMainLoop(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_loop_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMainLoop(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_loop_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMainLoop(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_main_loop_unref)))))));
    }
}
pub const GSource_autoptr = [*c]GSource;
pub const GSource_listautoptr = [*c]GList;
pub const GSource_slistautoptr = [*c]GSList;
pub const GSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSource(arg__ptr: [*c]GSource) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_source_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSource(arg__ptr: [*c][*c]GSource) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSource(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSource(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_source_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSource(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_source_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSource(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_source_unref)))))));
    }
}
pub const GMappedFile_autoptr = ?*GMappedFile;
pub const GMappedFile_listautoptr = [*c]GList;
pub const GMappedFile_slistautoptr = [*c]GSList;
pub const GMappedFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMappedFile(arg__ptr: ?*GMappedFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_mapped_file_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMappedFile(arg__ptr: [*c]?*GMappedFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMappedFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMappedFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_mapped_file_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMappedFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_mapped_file_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMappedFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_mapped_file_unref)))))));
    }
}
pub const GMarkupParseContext_autoptr = ?*GMarkupParseContext;
pub const GMarkupParseContext_listautoptr = [*c]GList;
pub const GMarkupParseContext_slistautoptr = [*c]GSList;
pub const GMarkupParseContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMarkupParseContext(arg__ptr: ?*GMarkupParseContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_markup_parse_context_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMarkupParseContext(arg__ptr: [*c]?*GMarkupParseContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMarkupParseContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMarkupParseContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_markup_parse_context_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMarkupParseContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_markup_parse_context_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMarkupParseContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_markup_parse_context_unref)))))));
    }
}
pub const GNode_autoptr = [*c]GNode;
pub const GNode_listautoptr = [*c]GList;
pub const GNode_slistautoptr = [*c]GSList;
pub const GNode_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNode(arg__ptr: [*c]GNode) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_node_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GNode(arg__ptr: [*c][*c]GNode) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNode(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNode(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_node_destroy)))))));
}
pub fn glib_slistautoptr_cleanup_GNode(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_node_destroy)))))));
}
pub fn glib_queueautoptr_cleanup_GNode(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_node_destroy)))))));
    }
}
pub const GOptionContext_autoptr = ?*GOptionContext;
pub const GOptionContext_listautoptr = [*c]GList;
pub const GOptionContext_slistautoptr = [*c]GSList;
pub const GOptionContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOptionContext(arg__ptr: ?*GOptionContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_option_context_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GOptionContext(arg__ptr: [*c]?*GOptionContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GOptionContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GOptionContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_option_context_free)))))));
}
pub fn glib_slistautoptr_cleanup_GOptionContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_option_context_free)))))));
}
pub fn glib_queueautoptr_cleanup_GOptionContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_option_context_free)))))));
    }
}
pub const GOptionGroup_autoptr = ?*GOptionGroup;
pub const GOptionGroup_listautoptr = [*c]GList;
pub const GOptionGroup_slistautoptr = [*c]GSList;
pub const GOptionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOptionGroup(arg__ptr: ?*GOptionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_option_group_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GOptionGroup(arg__ptr: [*c]?*GOptionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GOptionGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GOptionGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_option_group_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GOptionGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_option_group_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GOptionGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_option_group_unref)))))));
    }
}
pub const GPatternSpec_autoptr = ?*GPatternSpec;
pub const GPatternSpec_listautoptr = [*c]GList;
pub const GPatternSpec_slistautoptr = [*c]GSList;
pub const GPatternSpec_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPatternSpec(arg__ptr: ?*GPatternSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_pattern_spec_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GPatternSpec(arg__ptr: [*c]?*GPatternSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPatternSpec(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPatternSpec(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_pattern_spec_free)))))));
}
pub fn glib_slistautoptr_cleanup_GPatternSpec(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_pattern_spec_free)))))));
}
pub fn glib_queueautoptr_cleanup_GPatternSpec(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_pattern_spec_free)))))));
    }
}
pub const GQueue_autoptr = [*c]GQueue;
pub const GQueue_listautoptr = [*c]GList;
pub const GQueue_slistautoptr = [*c]GSList;
pub const GQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GQueue(arg__ptr: [*c]GQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_queue_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GQueue(arg__ptr: [*c][*c]GQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GQueue(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GQueue(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_queue_free)))))));
}
pub fn glib_slistautoptr_cleanup_GQueue(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_queue_free)))))));
}
pub fn glib_queueautoptr_cleanup_GQueue(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_queue_free)))))));
    }
}
pub fn glib_auto_cleanup_GQueue(arg__ptr: [*c]GQueue) callconv(.C) void {
    var _ptr = arg__ptr;
    g_queue_clear(_ptr);
}
pub const GRand_autoptr = ?*GRand;
pub const GRand_listautoptr = [*c]GList;
pub const GRand_slistautoptr = [*c]GSList;
pub const GRand_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRand(arg__ptr: ?*GRand) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rand_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRand(arg__ptr: [*c]?*GRand) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRand(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRand(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rand_free)))))));
}
pub fn glib_slistautoptr_cleanup_GRand(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rand_free)))))));
}
pub fn glib_queueautoptr_cleanup_GRand(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rand_free)))))));
    }
}
pub const GRegex_autoptr = ?*GRegex;
pub const GRegex_listautoptr = [*c]GList;
pub const GRegex_slistautoptr = [*c]GSList;
pub const GRegex_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRegex(arg__ptr: ?*GRegex) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_regex_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRegex(arg__ptr: [*c]?*GRegex) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRegex(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRegex(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_regex_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GRegex(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_regex_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GRegex(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_regex_unref)))))));
    }
}
pub const GMatchInfo_autoptr = ?*GMatchInfo;
pub const GMatchInfo_listautoptr = [*c]GList;
pub const GMatchInfo_slistautoptr = [*c]GSList;
pub const GMatchInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMatchInfo(arg__ptr: ?*GMatchInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_match_info_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMatchInfo(arg__ptr: [*c]?*GMatchInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMatchInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMatchInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_match_info_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMatchInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_match_info_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMatchInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_match_info_unref)))))));
    }
}
pub const GScanner_autoptr = [*c]GScanner;
pub const GScanner_listautoptr = [*c]GList;
pub const GScanner_slistautoptr = [*c]GSList;
pub const GScanner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GScanner(arg__ptr: [*c]GScanner) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_scanner_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GScanner(arg__ptr: [*c][*c]GScanner) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GScanner(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GScanner(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_scanner_destroy)))))));
}
pub fn glib_slistautoptr_cleanup_GScanner(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_scanner_destroy)))))));
}
pub fn glib_queueautoptr_cleanup_GScanner(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_scanner_destroy)))))));
    }
}
pub const GSequence_autoptr = ?*GSequence;
pub const GSequence_listautoptr = [*c]GList;
pub const GSequence_slistautoptr = [*c]GSList;
pub const GSequence_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSequence(arg__ptr: ?*GSequence) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_sequence_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSequence(arg__ptr: [*c]?*GSequence) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSequence(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSequence(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_sequence_free)))))));
}
pub fn glib_slistautoptr_cleanup_GSequence(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_sequence_free)))))));
}
pub fn glib_queueautoptr_cleanup_GSequence(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_sequence_free)))))));
    }
}
pub const GSList_autoptr = [*c]GSList;
pub const GSList_listautoptr = [*c]GList;
pub const GSList_slistautoptr = [*c]GSList;
pub const GSList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSList(arg__ptr: [*c]GSList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_slist_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSList(arg__ptr: [*c][*c]GSList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_slist_free)))))));
}
pub fn glib_slistautoptr_cleanup_GSList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_slist_free)))))));
}
pub fn glib_queueautoptr_cleanup_GSList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_slist_free)))))));
    }
}
pub const GString_autoptr = [*c]GString;
pub const GString_listautoptr = [*c]GList;
pub const GString_slistautoptr = [*c]GSList;
pub const GString_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GString(arg__ptr: [*c]GString) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_autoptr_cleanup_gstring_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GString(arg__ptr: [*c][*c]GString) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GString(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GString(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_autoptr_cleanup_gstring_free)))))));
}
pub fn glib_slistautoptr_cleanup_GString(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_autoptr_cleanup_gstring_free)))))));
}
pub fn glib_queueautoptr_cleanup_GString(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_autoptr_cleanup_gstring_free)))))));
    }
}
pub const GStringChunk_autoptr = ?*GStringChunk;
pub const GStringChunk_listautoptr = [*c]GList;
pub const GStringChunk_slistautoptr = [*c]GSList;
pub const GStringChunk_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GStringChunk(arg__ptr: ?*GStringChunk) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_string_chunk_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GStringChunk(arg__ptr: [*c]?*GStringChunk) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GStringChunk(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GStringChunk(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_string_chunk_free)))))));
}
pub fn glib_slistautoptr_cleanup_GStringChunk(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_string_chunk_free)))))));
}
pub fn glib_queueautoptr_cleanup_GStringChunk(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_string_chunk_free)))))));
    }
}
pub const GStrvBuilder_autoptr = ?*GStrvBuilder;
pub const GStrvBuilder_listautoptr = [*c]GList;
pub const GStrvBuilder_slistautoptr = [*c]GSList;
pub const GStrvBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GStrvBuilder(arg__ptr: ?*GStrvBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_strv_builder_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GStrvBuilder(arg__ptr: [*c]?*GStrvBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GStrvBuilder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GStrvBuilder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_strv_builder_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GStrvBuilder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_strv_builder_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GStrvBuilder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_strv_builder_unref)))))));
    }
}
pub const GThread_autoptr = [*c]GThread;
pub const GThread_listautoptr = [*c]GList;
pub const GThread_slistautoptr = [*c]GSList;
pub const GThread_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThread(arg__ptr: [*c]GThread) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_thread_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GThread(arg__ptr: [*c][*c]GThread) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GThread(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GThread(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_thread_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GThread(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_thread_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GThread(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_thread_unref)))))));
    }
}
pub fn glib_auto_cleanup_GMutex(arg__ptr: [*c]GMutex) callconv(.C) void {
    var _ptr = arg__ptr;
    g_mutex_clear(_ptr);
}
pub const GMutexLocker_autoptr = ?*GMutexLocker;
pub const GMutexLocker_listautoptr = [*c]GList;
pub const GMutexLocker_slistautoptr = [*c]GSList;
pub const GMutexLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMutexLocker(arg__ptr: ?*GMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_mutex_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GMutexLocker(arg__ptr: [*c]?*GMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMutexLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMutexLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_mutex_locker_free)))))));
}
pub fn glib_slistautoptr_cleanup_GMutexLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_mutex_locker_free)))))));
}
pub fn glib_queueautoptr_cleanup_GMutexLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_mutex_locker_free)))))));
    }
}
pub const GRecMutexLocker_autoptr = ?*GRecMutexLocker;
pub const GRecMutexLocker_listautoptr = [*c]GList;
pub const GRecMutexLocker_slistautoptr = [*c]GSList;
pub const GRecMutexLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRecMutexLocker(arg__ptr: ?*GRecMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rec_mutex_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRecMutexLocker(arg__ptr: [*c]?*GRecMutexLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRecMutexLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRecMutexLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rec_mutex_locker_free)))))));
}
pub fn glib_slistautoptr_cleanup_GRecMutexLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rec_mutex_locker_free)))))));
}
pub fn glib_queueautoptr_cleanup_GRecMutexLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rec_mutex_locker_free)))))));
    }
}
pub const GRWLockWriterLocker_autoptr = ?*GRWLockWriterLocker;
pub const GRWLockWriterLocker_listautoptr = [*c]GList;
pub const GRWLockWriterLocker_slistautoptr = [*c]GSList;
pub const GRWLockWriterLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRWLockWriterLocker(arg__ptr: ?*GRWLockWriterLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rw_lock_writer_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRWLockWriterLocker(arg__ptr: [*c]?*GRWLockWriterLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRWLockWriterLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRWLockWriterLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rw_lock_writer_locker_free)))))));
}
pub fn glib_slistautoptr_cleanup_GRWLockWriterLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rw_lock_writer_locker_free)))))));
}
pub fn glib_queueautoptr_cleanup_GRWLockWriterLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rw_lock_writer_locker_free)))))));
    }
}
pub const GRWLockReaderLocker_autoptr = ?*GRWLockReaderLocker;
pub const GRWLockReaderLocker_listautoptr = [*c]GList;
pub const GRWLockReaderLocker_slistautoptr = [*c]GSList;
pub const GRWLockReaderLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRWLockReaderLocker(arg__ptr: ?*GRWLockReaderLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_rw_lock_reader_locker_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRWLockReaderLocker(arg__ptr: [*c]?*GRWLockReaderLocker) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRWLockReaderLocker(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRWLockReaderLocker(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rw_lock_reader_locker_free)))))));
}
pub fn glib_slistautoptr_cleanup_GRWLockReaderLocker(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rw_lock_reader_locker_free)))))));
}
pub fn glib_queueautoptr_cleanup_GRWLockReaderLocker(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_rw_lock_reader_locker_free)))))));
    }
}
pub fn glib_auto_cleanup_GCond(arg__ptr: [*c]GCond) callconv(.C) void {
    var _ptr = arg__ptr;
    g_cond_clear(_ptr);
}
pub const GTimer_autoptr = ?*GTimer;
pub const GTimer_listautoptr = [*c]GList;
pub const GTimer_slistautoptr = [*c]GSList;
pub const GTimer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTimer(arg__ptr: ?*GTimer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_timer_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GTimer(arg__ptr: [*c]?*GTimer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTimer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTimer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_timer_destroy)))))));
}
pub fn glib_slistautoptr_cleanup_GTimer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_timer_destroy)))))));
}
pub fn glib_queueautoptr_cleanup_GTimer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_timer_destroy)))))));
    }
}
pub const GTimeZone_autoptr = ?*GTimeZone;
pub const GTimeZone_listautoptr = [*c]GList;
pub const GTimeZone_slistautoptr = [*c]GSList;
pub const GTimeZone_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTimeZone(arg__ptr: ?*GTimeZone) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_time_zone_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GTimeZone(arg__ptr: [*c]?*GTimeZone) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTimeZone(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTimeZone(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_time_zone_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTimeZone(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_time_zone_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTimeZone(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_time_zone_unref)))))));
    }
}
pub const GTree_autoptr = ?*GTree;
pub const GTree_listautoptr = [*c]GList;
pub const GTree_slistautoptr = [*c]GSList;
pub const GTree_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTree(arg__ptr: ?*GTree) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_tree_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GTree(arg__ptr: [*c]?*GTree) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTree(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTree(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_tree_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTree(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_tree_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTree(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_tree_unref)))))));
    }
}
pub const GVariant_autoptr = ?*GVariant;
pub const GVariant_listautoptr = [*c]GList;
pub const GVariant_slistautoptr = [*c]GSList;
pub const GVariant_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariant(arg__ptr: ?*GVariant) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariant(arg__ptr: [*c]?*GVariant) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariant(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariant(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GVariant(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GVariant(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_unref)))))));
    }
}
pub const GVariantBuilder_autoptr = [*c]GVariantBuilder;
pub const GVariantBuilder_listautoptr = [*c]GList;
pub const GVariantBuilder_slistautoptr = [*c]GSList;
pub const GVariantBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantBuilder(arg__ptr: [*c]GVariantBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_builder_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantBuilder(arg__ptr: [*c][*c]GVariantBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantBuilder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantBuilder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_builder_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GVariantBuilder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_builder_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GVariantBuilder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_builder_unref)))))));
    }
}
pub fn glib_auto_cleanup_GVariantBuilder(arg__ptr: [*c]GVariantBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    g_variant_builder_clear(_ptr);
}
pub const GVariantIter_autoptr = [*c]GVariantIter;
pub const GVariantIter_listautoptr = [*c]GList;
pub const GVariantIter_slistautoptr = [*c]GSList;
pub const GVariantIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantIter(arg__ptr: [*c]GVariantIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_iter_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantIter(arg__ptr: [*c][*c]GVariantIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_iter_free)))))));
}
pub fn glib_slistautoptr_cleanup_GVariantIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_iter_free)))))));
}
pub fn glib_queueautoptr_cleanup_GVariantIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_iter_free)))))));
    }
}
pub const GVariantDict_autoptr = [*c]GVariantDict;
pub const GVariantDict_listautoptr = [*c]GList;
pub const GVariantDict_slistautoptr = [*c]GSList;
pub const GVariantDict_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantDict(arg__ptr: [*c]GVariantDict) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_dict_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantDict(arg__ptr: [*c][*c]GVariantDict) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantDict(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantDict(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_dict_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GVariantDict(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_dict_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GVariantDict(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_dict_unref)))))));
    }
}
pub fn glib_auto_cleanup_GVariantDict(arg__ptr: [*c]GVariantDict) callconv(.C) void {
    var _ptr = arg__ptr;
    g_variant_dict_clear(_ptr);
}
pub const GVariantType_autoptr = ?*GVariantType;
pub const GVariantType_listautoptr = [*c]GList;
pub const GVariantType_slistautoptr = [*c]GSList;
pub const GVariantType_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantType(arg__ptr: ?*GVariantType) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_variant_type_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GVariantType(arg__ptr: [*c]?*GVariantType) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVariantType(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVariantType(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_type_free)))))));
}
pub fn glib_slistautoptr_cleanup_GVariantType(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_type_free)))))));
}
pub fn glib_queueautoptr_cleanup_GVariantType(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_variant_type_free)))))));
    }
}
pub fn glib_auto_cleanup_GStrv(arg__ptr: [*c]GStrv) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr.* != @as(GStrv, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        g_strfreev(_ptr.*);
    }
}
pub const GRefString_autoptr = [*c]GRefString;
pub const GRefString_listautoptr = [*c]GList;
pub const GRefString_slistautoptr = [*c]GSList;
pub const GRefString_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRefString(arg__ptr: [*c]GRefString) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_ref_string_release(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GRefString(arg__ptr: [*c][*c]GRefString) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRefString(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRefString(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_ref_string_release)))))));
}
pub fn glib_slistautoptr_cleanup_GRefString(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_ref_string_release)))))));
}
pub fn glib_queueautoptr_cleanup_GRefString(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_ref_string_release)))))));
    }
}
pub const GUri_autoptr = ?*GUri;
pub const GUri_listautoptr = [*c]GList;
pub const GUri_slistautoptr = [*c]GSList;
pub const GUri_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GUri(arg__ptr: ?*GUri) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_uri_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GUri(arg__ptr: [*c]?*GUri) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GUri(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GUri(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_uri_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GUri(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_uri_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GUri(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_uri_unref)))))));
    }
}
pub const GPathBuf_autoptr = [*c]GPathBuf;
pub const GPathBuf_listautoptr = [*c]GList;
pub const GPathBuf_slistautoptr = [*c]GSList;
pub const GPathBuf_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPathBuf(arg__ptr: [*c]GPathBuf) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_path_buf_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GPathBuf(arg__ptr: [*c][*c]GPathBuf) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPathBuf(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPathBuf(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_path_buf_free)))))));
}
pub fn glib_slistautoptr_cleanup_GPathBuf(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_path_buf_free)))))));
}
pub fn glib_queueautoptr_cleanup_GPathBuf(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_path_buf_free)))))));
    }
}
pub fn glib_auto_cleanup_GPathBuf(arg__ptr: [*c]GPathBuf) callconv(.C) void {
    var _ptr = arg__ptr;
    g_path_buf_clear(_ptr);
}
pub const GTK_CSS_PARSER_ERROR_FAILED: c_int = 0;
pub const GTK_CSS_PARSER_ERROR_SYNTAX: c_int = 1;
pub const GTK_CSS_PARSER_ERROR_IMPORT: c_int = 2;
pub const GTK_CSS_PARSER_ERROR_NAME: c_int = 3;
pub const GTK_CSS_PARSER_ERROR_UNKNOWN_VALUE: c_int = 4;
pub const GtkCssParserError = c_uint;
pub const GTK_CSS_PARSER_WARNING_DEPRECATED: c_int = 0;
pub const GTK_CSS_PARSER_WARNING_SYNTAX: c_int = 1;
pub const GTK_CSS_PARSER_WARNING_UNIMPLEMENTED: c_int = 2;
pub const GtkCssParserWarning = c_uint;
pub const GType = gsize;
const union_unnamed_43 = extern union {
    v_int: gint,
    v_uint: guint,
    v_long: glong,
    v_ulong: gulong,
    v_int64: gint64,
    v_uint64: guint64,
    v_float: gfloat,
    v_double: gdouble,
    v_pointer: gpointer,
};
pub const struct__GValue = extern struct {
    g_type: GType,
    data: [2]union_unnamed_43,
};
pub const GValue = struct__GValue;
pub const union__GTypeCValue = opaque {};
pub const GTypeCValue = union__GTypeCValue;
pub const struct__GTypePlugin = opaque {};
pub const GTypePlugin = struct__GTypePlugin;
pub const struct__GTypeClass = extern struct {
    g_type: GType,
};
pub const GTypeClass = struct__GTypeClass;
pub const struct__GTypeInterface = extern struct {
    g_type: GType,
    g_instance_type: GType,
};
pub const GTypeInterface = struct__GTypeInterface;
pub const struct__GTypeInstance = extern struct {
    g_class: [*c]GTypeClass,
};
pub const GTypeInstance = struct__GTypeInstance;
pub const GBaseInitFunc = ?*const fn (gpointer) callconv(.C) void;
pub const GBaseFinalizeFunc = ?*const fn (gpointer) callconv(.C) void;
pub const GClassInitFunc = ?*const fn (gpointer, gpointer) callconv(.C) void;
pub const GClassFinalizeFunc = ?*const fn (gpointer, gpointer) callconv(.C) void;
pub const GInstanceInitFunc = ?*const fn ([*c]GTypeInstance, gpointer) callconv(.C) void;
pub const GTypeValueInitFunc = ?*const fn ([*c]GValue) callconv(.C) void;
pub const GTypeValueFreeFunc = ?*const fn ([*c]GValue) callconv(.C) void;
pub const GTypeValueCopyFunc = ?*const fn ([*c]const GValue, [*c]GValue) callconv(.C) void;
pub const GTypeValuePeekPointerFunc = ?*const fn ([*c]const GValue) callconv(.C) gpointer;
pub const GTypeValueCollectFunc = ?*const fn ([*c]GValue, guint, ?*GTypeCValue, guint) callconv(.C) [*c]gchar;
pub const GTypeValueLCopyFunc = ?*const fn ([*c]const GValue, guint, ?*GTypeCValue, guint) callconv(.C) [*c]gchar;
pub const struct__GTypeValueTable = extern struct {
    value_init: GTypeValueInitFunc,
    value_free: GTypeValueFreeFunc,
    value_copy: GTypeValueCopyFunc,
    value_peek_pointer: GTypeValuePeekPointerFunc,
    collect_format: [*c]const gchar,
    collect_value: GTypeValueCollectFunc,
    lcopy_format: [*c]const gchar,
    lcopy_value: GTypeValueLCopyFunc,
};
pub const GTypeValueTable = struct__GTypeValueTable;
pub const struct__GTypeInfo = extern struct {
    class_size: guint16,
    base_init: GBaseInitFunc,
    base_finalize: GBaseFinalizeFunc,
    class_init: GClassInitFunc,
    class_finalize: GClassFinalizeFunc,
    class_data: gconstpointer,
    instance_size: guint16,
    n_preallocs: guint16,
    instance_init: GInstanceInitFunc,
    value_table: [*c]const GTypeValueTable,
};
pub const GTypeInfo = struct__GTypeInfo;
pub const struct__GTypeFundamentalInfo = extern struct {
    type_flags: GTypeFundamentalFlags,
};
pub const GTypeFundamentalInfo = struct__GTypeFundamentalInfo;
pub const GInterfaceInitFunc = ?*const fn (gpointer, gpointer) callconv(.C) void;
pub const GInterfaceFinalizeFunc = ?*const fn (gpointer, gpointer) callconv(.C) void;
pub const struct__GInterfaceInfo = extern struct {
    interface_init: GInterfaceInitFunc,
    interface_finalize: GInterfaceFinalizeFunc,
    interface_data: gpointer,
};
pub const GInterfaceInfo = struct__GInterfaceInfo;
pub const struct__GTypeQuery = extern struct {
    type: GType,
    type_name: [*c]const gchar,
    class_size: guint,
    instance_size: guint,
};
pub const GTypeQuery = struct__GTypeQuery;
pub const G_TYPE_DEBUG_NONE: c_int = 0;
pub const G_TYPE_DEBUG_OBJECTS: c_int = 1;
pub const G_TYPE_DEBUG_SIGNALS: c_int = 2;
pub const G_TYPE_DEBUG_INSTANCE_COUNT: c_int = 4;
pub const G_TYPE_DEBUG_MASK: c_int = 7;
pub const GTypeDebugFlags = c_uint;
pub extern fn g_type_init() void;
pub extern fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags) void;
pub extern fn g_type_name(@"type": GType) [*c]const gchar;
pub extern fn g_type_qname(@"type": GType) GQuark;
pub extern fn g_type_from_name(name: [*c]const gchar) GType;
pub extern fn g_type_parent(@"type": GType) GType;
pub extern fn g_type_depth(@"type": GType) guint;
pub extern fn g_type_next_base(leaf_type: GType, root_type: GType) GType;
pub extern fn g_type_is_a(@"type": GType, is_a_type: GType) gboolean;
pub extern fn g_type_class_ref(@"type": GType) gpointer;
pub extern fn g_type_class_peek(@"type": GType) gpointer;
pub extern fn g_type_class_peek_static(@"type": GType) gpointer;
pub extern fn g_type_class_unref(g_class: gpointer) void;
pub extern fn g_type_class_peek_parent(g_class: gpointer) gpointer;
pub extern fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) gpointer;
pub extern fn g_type_interface_peek_parent(g_iface: gpointer) gpointer;
pub extern fn g_type_default_interface_ref(g_type: GType) gpointer;
pub extern fn g_type_default_interface_peek(g_type: GType) gpointer;
pub extern fn g_type_default_interface_unref(g_iface: gpointer) void;
pub extern fn g_type_children(@"type": GType, n_children: [*c]guint) [*c]GType;
pub extern fn g_type_interfaces(@"type": GType, n_interfaces: [*c]guint) [*c]GType;
pub extern fn g_type_set_qdata(@"type": GType, quark: GQuark, data: gpointer) void;
pub extern fn g_type_get_qdata(@"type": GType, quark: GQuark) gpointer;
pub extern fn g_type_query(@"type": GType, query: [*c]GTypeQuery) void;
pub extern fn g_type_get_instance_count(@"type": GType) c_int;
pub const GTypeClassCacheFunc = ?*const fn (gpointer, [*c]GTypeClass) callconv(.C) gboolean;
pub const GTypeInterfaceCheckFunc = ?*const fn (gpointer, gpointer) callconv(.C) void;
pub const G_TYPE_FLAG_CLASSED: c_int = 1;
pub const G_TYPE_FLAG_INSTANTIATABLE: c_int = 2;
pub const G_TYPE_FLAG_DERIVABLE: c_int = 4;
pub const G_TYPE_FLAG_DEEP_DERIVABLE: c_int = 8;
pub const GTypeFundamentalFlags = c_uint;
pub const G_TYPE_FLAG_NONE: c_int = 0;
pub const G_TYPE_FLAG_ABSTRACT: c_int = 16;
pub const G_TYPE_FLAG_VALUE_ABSTRACT: c_int = 32;
pub const G_TYPE_FLAG_FINAL: c_int = 64;
pub const G_TYPE_FLAG_DEPRECATED: c_int = 128;
pub const GTypeFlags = c_uint;
pub extern fn g_type_register_static(parent_type: GType, type_name: [*c]const gchar, info: [*c]const GTypeInfo, flags: GTypeFlags) GType;
pub extern fn g_type_register_static_simple(parent_type: GType, type_name: [*c]const gchar, class_size: guint, class_init: GClassInitFunc, instance_size: guint, instance_init: GInstanceInitFunc, flags: GTypeFlags) GType;
pub extern fn g_type_register_dynamic(parent_type: GType, type_name: [*c]const gchar, plugin: ?*GTypePlugin, flags: GTypeFlags) GType;
pub extern fn g_type_register_fundamental(type_id: GType, type_name: [*c]const gchar, info: [*c]const GTypeInfo, finfo: [*c]const GTypeFundamentalInfo, flags: GTypeFlags) GType;
pub extern fn g_type_add_interface_static(instance_type: GType, interface_type: GType, info: [*c]const GInterfaceInfo) void;
pub extern fn g_type_add_interface_dynamic(instance_type: GType, interface_type: GType, plugin: ?*GTypePlugin) void;
pub extern fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType) void;
pub extern fn g_type_interface_prerequisites(interface_type: GType, n_prerequisites: [*c]guint) [*c]GType;
pub extern fn g_type_interface_instantiatable_prerequisite(interface_type: GType) GType;
pub extern fn g_type_class_add_private(g_class: gpointer, private_size: gsize) void;
pub extern fn g_type_add_instance_private(class_type: GType, private_size: gsize) gint;
pub extern fn g_type_instance_get_private(instance: [*c]GTypeInstance, private_type: GType) gpointer;
pub extern fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: [*c]gint) void;
pub extern fn g_type_add_class_private(class_type: GType, private_size: gsize) void;
pub extern fn g_type_class_get_private(klass: [*c]GTypeClass, private_type: GType) gpointer;
pub extern fn g_type_class_get_instance_private_offset(g_class: gpointer) gint;
pub extern fn g_type_ensure(@"type": GType) void;
pub extern fn g_type_get_type_registration_serial() guint;
pub extern fn g_type_get_plugin(@"type": GType) ?*GTypePlugin;
pub extern fn g_type_interface_get_plugin(instance_type: GType, interface_type: GType) ?*GTypePlugin;
pub extern fn g_type_fundamental_next() GType;
pub extern fn g_type_fundamental(type_id: GType) GType;
pub extern fn g_type_create_instance(@"type": GType) [*c]GTypeInstance;
pub extern fn g_type_free_instance(instance: [*c]GTypeInstance) void;
pub extern fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc) void;
pub extern fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc) void;
pub extern fn g_type_class_unref_uncached(g_class: gpointer) void;
pub extern fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc) void;
pub extern fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc) void;
pub extern fn g_type_value_table_peek(@"type": GType) [*c]GTypeValueTable;
pub extern fn g_type_check_instance(instance: [*c]GTypeInstance) gboolean;
pub extern fn g_type_check_instance_cast(instance: [*c]GTypeInstance, iface_type: GType) [*c]GTypeInstance;
pub extern fn g_type_check_instance_is_a(instance: [*c]GTypeInstance, iface_type: GType) gboolean;
pub extern fn g_type_check_instance_is_fundamentally_a(instance: [*c]GTypeInstance, fundamental_type: GType) gboolean;
pub extern fn g_type_check_class_cast(g_class: [*c]GTypeClass, is_a_type: GType) [*c]GTypeClass;
pub extern fn g_type_check_class_is_a(g_class: [*c]GTypeClass, is_a_type: GType) gboolean;
pub extern fn g_type_check_is_value_type(@"type": GType) gboolean;
pub extern fn g_type_check_value(value: [*c]const GValue) gboolean;
pub extern fn g_type_check_value_holds(value: [*c]const GValue, @"type": GType) gboolean;
pub extern fn g_type_test_flags(@"type": GType, flags: guint) gboolean;
pub extern fn g_type_name_from_instance(instance: [*c]GTypeInstance) [*c]const gchar;
pub extern fn g_type_name_from_class(g_class: [*c]GTypeClass) [*c]const gchar;
pub const GValueTransform = ?*const fn ([*c]const GValue, [*c]GValue) callconv(.C) void;
pub extern fn g_value_init(value: [*c]GValue, g_type: GType) [*c]GValue;
pub extern fn g_value_copy(src_value: [*c]const GValue, dest_value: [*c]GValue) void;
pub extern fn g_value_reset(value: [*c]GValue) [*c]GValue;
pub extern fn g_value_unset(value: [*c]GValue) void;
pub extern fn g_value_set_instance(value: [*c]GValue, instance: gpointer) void;
pub extern fn g_value_init_from_instance(value: [*c]GValue, instance: gpointer) void;
pub extern fn g_value_fits_pointer(value: [*c]const GValue) gboolean;
pub extern fn g_value_peek_pointer(value: [*c]const GValue) gpointer;
pub extern fn g_value_type_compatible(src_type: GType, dest_type: GType) gboolean;
pub extern fn g_value_type_transformable(src_type: GType, dest_type: GType) gboolean;
pub extern fn g_value_transform(src_value: [*c]const GValue, dest_value: [*c]GValue) gboolean;
pub extern fn g_value_register_transform_func(src_type: GType, dest_type: GType, transform_func: GValueTransform) void;
pub const G_PARAM_READABLE: c_int = 1;
pub const G_PARAM_WRITABLE: c_int = 2;
pub const G_PARAM_READWRITE: c_int = 3;
pub const G_PARAM_CONSTRUCT: c_int = 4;
pub const G_PARAM_CONSTRUCT_ONLY: c_int = 8;
pub const G_PARAM_LAX_VALIDATION: c_int = 16;
pub const G_PARAM_STATIC_NAME: c_int = 32;
pub const G_PARAM_PRIVATE: c_int = 32;
pub const G_PARAM_STATIC_NICK: c_int = 64;
pub const G_PARAM_STATIC_BLURB: c_int = 128;
pub const G_PARAM_EXPLICIT_NOTIFY: c_int = 1073741824;
pub const G_PARAM_DEPRECATED: c_int = -2147483648;
pub const GParamFlags = c_int;
pub const struct__GParamSpec = extern struct {
    g_type_instance: GTypeInstance,
    name: [*c]const gchar,
    flags: GParamFlags,
    value_type: GType,
    owner_type: GType,
    _nick: [*c]gchar,
    _blurb: [*c]gchar,
    qdata: ?*GData,
    ref_count: guint,
    param_id: guint,
};
pub const GParamSpec = struct__GParamSpec;
pub const struct__GParamSpecClass = extern struct {
    g_type_class: GTypeClass,
    value_type: GType,
    finalize: ?*const fn ([*c]GParamSpec) callconv(.C) void,
    value_set_default: ?*const fn ([*c]GParamSpec, [*c]GValue) callconv(.C) void,
    value_validate: ?*const fn ([*c]GParamSpec, [*c]GValue) callconv(.C) gboolean,
    values_cmp: ?*const fn ([*c]GParamSpec, [*c]const GValue, [*c]const GValue) callconv(.C) gint,
    value_is_valid: ?*const fn ([*c]GParamSpec, [*c]const GValue) callconv(.C) gboolean,
    dummy: [3]gpointer,
};
pub const GParamSpecClass = struct__GParamSpecClass;
pub const struct__GParameter = extern struct {
    name: [*c]const gchar,
    value: GValue,
};
pub const GParameter = struct__GParameter;
pub const struct__GParamSpecPool = opaque {};
pub const GParamSpecPool = struct__GParamSpecPool;
pub extern fn g_param_spec_ref(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_unref(pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_sink(pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_ref_sink(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_get_qdata(pspec: [*c]GParamSpec, quark: GQuark) gpointer;
pub extern fn g_param_spec_set_qdata(pspec: [*c]GParamSpec, quark: GQuark, data: gpointer) void;
pub extern fn g_param_spec_set_qdata_full(pspec: [*c]GParamSpec, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_param_spec_steal_qdata(pspec: [*c]GParamSpec, quark: GQuark) gpointer;
pub extern fn g_param_spec_get_redirect_target(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_value_set_default(pspec: [*c]GParamSpec, value: [*c]GValue) void;
pub extern fn g_param_value_defaults(pspec: [*c]GParamSpec, value: [*c]const GValue) gboolean;
pub extern fn g_param_value_validate(pspec: [*c]GParamSpec, value: [*c]GValue) gboolean;
pub extern fn g_param_value_is_valid(pspec: [*c]GParamSpec, value: [*c]const GValue) gboolean;
pub extern fn g_param_value_convert(pspec: [*c]GParamSpec, src_value: [*c]const GValue, dest_value: [*c]GValue, strict_validation: gboolean) gboolean;
pub extern fn g_param_values_cmp(pspec: [*c]GParamSpec, value1: [*c]const GValue, value2: [*c]const GValue) gint;
pub extern fn g_param_spec_get_name(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_param_spec_get_nick(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_param_spec_get_blurb(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_value_set_param(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_value_get_param(value: [*c]const GValue) [*c]GParamSpec;
pub extern fn g_value_dup_param(value: [*c]const GValue) [*c]GParamSpec;
pub extern fn g_value_take_param(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_value_set_param_take_ownership(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_param_spec_get_default_value(pspec: [*c]GParamSpec) [*c]const GValue;
pub extern fn g_param_spec_get_name_quark(pspec: [*c]GParamSpec) GQuark;
pub const struct__GParamSpecTypeInfo = extern struct {
    instance_size: guint16,
    n_preallocs: guint16,
    instance_init: ?*const fn ([*c]GParamSpec) callconv(.C) void,
    value_type: GType,
    finalize: ?*const fn ([*c]GParamSpec) callconv(.C) void,
    value_set_default: ?*const fn ([*c]GParamSpec, [*c]GValue) callconv(.C) void,
    value_validate: ?*const fn ([*c]GParamSpec, [*c]GValue) callconv(.C) gboolean,
    values_cmp: ?*const fn ([*c]GParamSpec, [*c]const GValue, [*c]const GValue) callconv(.C) gint,
};
pub const GParamSpecTypeInfo = struct__GParamSpecTypeInfo;
pub extern fn g_param_type_register_static(name: [*c]const gchar, pspec_info: [*c]const GParamSpecTypeInfo) GType;
pub extern fn g_param_spec_is_valid_name(name: [*c]const gchar) gboolean;
pub extern fn _g_param_type_register_static_constant(name: [*c]const gchar, pspec_info: [*c]const GParamSpecTypeInfo, opt_type: GType) GType;
pub extern fn g_param_spec_internal(param_type: GType, name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags: GParamFlags) gpointer;
pub extern fn g_param_spec_pool_new(type_prefixing: gboolean) ?*GParamSpecPool;
pub extern fn g_param_spec_pool_insert(pool: ?*GParamSpecPool, pspec: [*c]GParamSpec, owner_type: GType) void;
pub extern fn g_param_spec_pool_remove(pool: ?*GParamSpecPool, pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_pool_lookup(pool: ?*GParamSpecPool, param_name: [*c]const gchar, owner_type: GType, walk_ancestors: gboolean) [*c]GParamSpec;
pub extern fn g_param_spec_pool_list_owned(pool: ?*GParamSpecPool, owner_type: GType) [*c]GList;
pub extern fn g_param_spec_pool_list(pool: ?*GParamSpecPool, owner_type: GType, n_pspecs_p: [*c]guint) [*c][*c]GParamSpec; // /usr/include/glib-2.0/gobject/gclosure.h:184:9: warning: struct demoted to opaque type - has bitfield
pub const struct__GClosure = opaque {};
pub const GClosure = struct__GClosure;
pub const GClosureNotify = ?*const fn (gpointer, ?*GClosure) callconv(.C) void;
pub const struct__GClosureNotifyData = extern struct {
    data: gpointer,
    notify: GClosureNotify,
};
pub const GClosureNotifyData = struct__GClosureNotifyData;
pub const GCallback = ?*const fn () callconv(.C) void;
pub const GClosureMarshal = ?*const fn (?*GClosure, [*c]GValue, guint, [*c]const GValue, gpointer, gpointer) callconv(.C) void;
pub const GVaClosureMarshal = ?*const fn (?*GClosure, [*c]GValue, gpointer, [*c]struct___va_list_tag, gpointer, c_int, [*c]GType) callconv(.C) void;
pub const struct__GCClosure = extern struct {
    closure: GClosure,
    callback: gpointer,
};
pub const GCClosure = struct__GCClosure;
pub extern fn g_cclosure_new(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) ?*GClosure;
pub extern fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) ?*GClosure;
pub extern fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) ?*GClosure;
pub extern fn g_closure_ref(closure: ?*GClosure) ?*GClosure;
pub extern fn g_closure_sink(closure: ?*GClosure) void;
pub extern fn g_closure_unref(closure: ?*GClosure) void;
pub extern fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) ?*GClosure;
pub extern fn g_closure_add_finalize_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_remove_finalize_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_add_invalidate_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_remove_invalidate_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_add_marshal_guards(closure: ?*GClosure, pre_marshal_data: gpointer, pre_marshal_notify: GClosureNotify, post_marshal_data: gpointer, post_marshal_notify: GClosureNotify) void;
pub extern fn g_closure_set_marshal(closure: ?*GClosure, marshal: GClosureMarshal) void;
pub extern fn g_closure_set_meta_marshal(closure: ?*GClosure, marshal_data: gpointer, meta_marshal: GClosureMarshal) void;
pub extern fn g_closure_invalidate(closure: ?*GClosure) void;
pub extern fn g_closure_invoke(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer) void;
pub extern fn g_cclosure_marshal_generic(closure: ?*GClosure, return_gvalue: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_generic_va(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args_list: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__VOID(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__VOIDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__BOOLEAN(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__BOOLEANv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__CHAR(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__CHARv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UCHAR(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UCHARv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__INT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__INTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UINT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UINTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__LONG(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__LONGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__ULONG(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__ULONGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__ENUM(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__ENUMv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__FLAGS(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__FLAGSv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__FLOAT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__FLOATv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__DOUBLE(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__DOUBLEv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__STRING(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__STRINGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__PARAM(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__PARAMv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__BOXED(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__BOXEDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__OBJECT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__OBJECTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__VARIANT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__VARIANTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UINT_POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: [*c]struct___va_list_tag, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub const struct__GSignalQuery = extern struct {
    signal_id: guint,
    signal_name: [*c]const gchar,
    itype: GType,
    signal_flags: GSignalFlags,
    return_type: GType,
    n_params: guint,
    param_types: [*c]const GType,
};
pub const GSignalQuery = struct__GSignalQuery;
pub const struct__GSignalInvocationHint = extern struct {
    signal_id: guint,
    detail: GQuark,
    run_type: GSignalFlags,
};
pub const GSignalInvocationHint = struct__GSignalInvocationHint;
pub const GSignalCMarshaller = GClosureMarshal;
pub const GSignalCVaMarshaller = GVaClosureMarshal;
pub const GSignalEmissionHook = ?*const fn ([*c]GSignalInvocationHint, guint, [*c]const GValue, gpointer) callconv(.C) gboolean;
pub const GSignalAccumulator = ?*const fn ([*c]GSignalInvocationHint, [*c]GValue, [*c]const GValue, gpointer) callconv(.C) gboolean;
pub const G_SIGNAL_RUN_FIRST: c_int = 1;
pub const G_SIGNAL_RUN_LAST: c_int = 2;
pub const G_SIGNAL_RUN_CLEANUP: c_int = 4;
pub const G_SIGNAL_NO_RECURSE: c_int = 8;
pub const G_SIGNAL_DETAILED: c_int = 16;
pub const G_SIGNAL_ACTION: c_int = 32;
pub const G_SIGNAL_NO_HOOKS: c_int = 64;
pub const G_SIGNAL_MUST_COLLECT: c_int = 128;
pub const G_SIGNAL_DEPRECATED: c_int = 256;
pub const G_SIGNAL_ACCUMULATOR_FIRST_RUN: c_int = 131072;
pub const GSignalFlags = c_uint;
pub const G_CONNECT_DEFAULT: c_int = 0;
pub const G_CONNECT_AFTER: c_int = 1;
pub const G_CONNECT_SWAPPED: c_int = 2;
pub const GConnectFlags = c_uint;
pub const G_SIGNAL_MATCH_ID: c_int = 1;
pub const G_SIGNAL_MATCH_DETAIL: c_int = 2;
pub const G_SIGNAL_MATCH_CLOSURE: c_int = 4;
pub const G_SIGNAL_MATCH_FUNC: c_int = 8;
pub const G_SIGNAL_MATCH_DATA: c_int = 16;
pub const G_SIGNAL_MATCH_UNBLOCKED: c_int = 32;
pub const GSignalMatchType = c_uint;
pub extern fn g_signal_newv(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: ?*GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, param_types: [*c]GType) guint;
pub extern fn g_signal_new_valist(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: ?*GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, args: [*c]struct___va_list_tag) guint;
pub extern fn g_signal_new(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_offset: guint, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) guint;
pub extern fn g_signal_new_class_handler(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_handler: GCallback, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) guint;
pub extern fn g_signal_set_va_marshaller(signal_id: guint, instance_type: GType, va_marshaller: GSignalCVaMarshaller) void;
pub extern fn g_signal_emitv(instance_and_params: [*c]const GValue, signal_id: guint, detail: GQuark, return_value: [*c]GValue) void;
pub extern fn g_signal_emit_valist(instance: gpointer, signal_id: guint, detail: GQuark, var_args: [*c]struct___va_list_tag) void;
pub extern fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...) void;
pub extern fn g_signal_emit_by_name(instance: gpointer, detailed_signal: [*c]const gchar, ...) void;
pub extern fn g_signal_lookup(name: [*c]const gchar, itype: GType) guint;
pub extern fn g_signal_name(signal_id: guint) [*c]const gchar;
pub extern fn g_signal_query(signal_id: guint, query: [*c]GSignalQuery) void;
pub extern fn g_signal_list_ids(itype: GType, n_ids: [*c]guint) [*c]guint;
pub extern fn g_signal_is_valid_name(name: [*c]const gchar) gboolean;
pub extern fn g_signal_parse_name(detailed_signal: [*c]const gchar, itype: GType, signal_id_p: [*c]guint, detail_p: [*c]GQuark, force_detail_quark: gboolean) gboolean;
pub extern fn g_signal_get_invocation_hint(instance: gpointer) [*c]GSignalInvocationHint;
pub extern fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark) void;
pub extern fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: [*c]const gchar) void;
pub extern fn g_signal_add_emission_hook(signal_id: guint, detail: GQuark, hook_func: GSignalEmissionHook, hook_data: gpointer, data_destroy: GDestroyNotify) gulong;
pub extern fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong) void;
pub extern fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint, detail: GQuark, may_be_blocked: gboolean) gboolean;
pub extern fn g_signal_connect_closure_by_id(instance: gpointer, signal_id: guint, detail: GQuark, closure: ?*GClosure, after: gboolean) gulong;
pub extern fn g_signal_connect_closure(instance: gpointer, detailed_signal: [*c]const gchar, closure: ?*GClosure, after: gboolean) gulong;
pub extern fn g_signal_connect_data(instance: gpointer, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer, destroy_data: GClosureNotify, connect_flags: GConnectFlags) gulong;
pub extern fn g_signal_handler_block(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) gboolean;
pub extern fn g_signal_handler_find(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) gulong;
pub extern fn g_signal_handlers_block_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_signal_handlers_unblock_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_signal_handlers_disconnect_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_clear_signal_handler(handler_id_ptr: [*c]gulong, instance: gpointer) void;
pub extern fn g_signal_override_class_closure(signal_id: guint, instance_type: GType, class_closure: ?*GClosure) void;
pub extern fn g_signal_override_class_handler(signal_name: [*c]const gchar, instance_type: GType, class_handler: GCallback) void;
pub extern fn g_signal_chain_from_overridden(instance_and_params: [*c]const GValue, return_value: [*c]GValue) void;
pub extern fn g_signal_chain_from_overridden_handler(instance: gpointer, ...) void;
pub extern fn g_signal_accumulator_true_handled(ihint: [*c]GSignalInvocationHint, return_accu: [*c]GValue, handler_return: [*c]const GValue, dummy: gpointer) gboolean;
pub extern fn g_signal_accumulator_first_wins(ihint: [*c]GSignalInvocationHint, return_accu: [*c]GValue, handler_return: [*c]const GValue, dummy: gpointer) gboolean;
pub extern fn g_signal_handlers_destroy(instance: gpointer) void;
pub extern fn _g_signals_destroy(itype: GType) void;
pub extern fn g_date_get_type() GType;
pub extern fn g_strv_get_type() GType;
pub extern fn g_gstring_get_type() GType;
pub extern fn g_hash_table_get_type() GType;
pub extern fn g_array_get_type() GType;
pub extern fn g_byte_array_get_type() GType;
pub extern fn g_ptr_array_get_type() GType;
pub extern fn g_bytes_get_type() GType;
pub extern fn g_variant_type_get_gtype() GType;
pub extern fn g_regex_get_type() GType;
pub extern fn g_match_info_get_type() GType;
pub extern fn g_error_get_type() GType;
pub extern fn g_date_time_get_type() GType;
pub extern fn g_time_zone_get_type() GType;
pub extern fn g_io_channel_get_type() GType;
pub extern fn g_io_condition_get_type() GType;
pub extern fn g_variant_builder_get_type() GType;
pub extern fn g_variant_dict_get_type() GType;
pub extern fn g_key_file_get_type() GType;
pub extern fn g_main_loop_get_type() GType;
pub extern fn g_main_context_get_type() GType;
pub extern fn g_source_get_type() GType;
pub extern fn g_pollfd_get_type() GType;
pub extern fn g_thread_get_type() GType;
pub extern fn g_checksum_get_type() GType;
pub extern fn g_markup_parse_context_get_type() GType;
pub extern fn g_mapped_file_get_type() GType;
pub extern fn g_option_group_get_type() GType;
pub extern fn g_uri_get_type() GType;
pub extern fn g_tree_get_type() GType;
pub extern fn g_pattern_spec_get_type() GType;
pub extern fn g_bookmark_file_get_type() GType;
pub extern fn g_variant_get_gtype() GType;
pub const GBoxedCopyFunc = ?*const fn (gpointer) callconv(.C) gpointer;
pub const GBoxedFreeFunc = ?*const fn (gpointer) callconv(.C) void;
pub extern fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) gpointer;
pub extern fn g_boxed_free(boxed_type: GType, boxed: gpointer) void;
pub extern fn g_value_set_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_set_static_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_take_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_set_boxed_take_ownership(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_get_boxed(value: [*c]const GValue) gpointer;
pub extern fn g_value_dup_boxed(value: [*c]const GValue) gpointer;
pub extern fn g_boxed_type_register_static(name: [*c]const gchar, boxed_copy: GBoxedCopyFunc, boxed_free: GBoxedFreeFunc) GType;
pub extern fn g_closure_get_type() GType;
pub extern fn g_value_get_type() GType;
pub const struct__GObject = extern struct {
    g_type_instance: GTypeInstance,
    ref_count: guint,
    qdata: ?*GData,
};
pub const GObject = struct__GObject;
pub const struct__GObjectConstructParam = extern struct {
    pspec: [*c]GParamSpec,
    value: [*c]GValue,
};
pub const GObjectConstructParam = struct__GObjectConstructParam;
pub const struct__GObjectClass = extern struct {
    g_type_class: GTypeClass,
    construct_properties: [*c]GSList,
    constructor: ?*const fn (GType, guint, [*c]GObjectConstructParam) callconv(.C) [*c]GObject,
    set_property: ?*const fn ([*c]GObject, guint, [*c]const GValue, [*c]GParamSpec) callconv(.C) void,
    get_property: ?*const fn ([*c]GObject, guint, [*c]GValue, [*c]GParamSpec) callconv(.C) void,
    dispose: ?*const fn ([*c]GObject) callconv(.C) void,
    finalize: ?*const fn ([*c]GObject) callconv(.C) void,
    dispatch_properties_changed: ?*const fn ([*c]GObject, guint, [*c][*c]GParamSpec) callconv(.C) void,
    notify: ?*const fn ([*c]GObject, [*c]GParamSpec) callconv(.C) void,
    constructed: ?*const fn ([*c]GObject) callconv(.C) void,
    flags: gsize,
    n_construct_properties: gsize,
    pspecs: gpointer,
    n_pspecs: gsize,
    pdummy: [3]gpointer,
};
pub const GObjectClass = struct__GObjectClass;
pub const GInitiallyUnowned = struct__GObject;
pub const GInitiallyUnownedClass = struct__GObjectClass;
pub const GObjectGetPropertyFunc = ?*const fn ([*c]GObject, guint, [*c]GValue, [*c]GParamSpec) callconv(.C) void;
pub const GObjectSetPropertyFunc = ?*const fn ([*c]GObject, guint, [*c]const GValue, [*c]GParamSpec) callconv(.C) void;
pub const GObjectFinalizeFunc = ?*const fn ([*c]GObject) callconv(.C) void;
pub const GWeakNotify = ?*const fn (gpointer, [*c]GObject) callconv(.C) void;
pub extern fn g_initially_unowned_get_type() GType;
pub extern fn g_object_class_install_property(oclass: [*c]GObjectClass, property_id: guint, pspec: [*c]GParamSpec) void;
pub extern fn g_object_class_find_property(oclass: [*c]GObjectClass, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn g_object_class_list_properties(oclass: [*c]GObjectClass, n_properties: [*c]guint) [*c][*c]GParamSpec;
pub extern fn g_object_class_override_property(oclass: [*c]GObjectClass, property_id: guint, name: [*c]const gchar) void;
pub extern fn g_object_class_install_properties(oclass: [*c]GObjectClass, n_pspecs: guint, pspecs: [*c][*c]GParamSpec) void;
pub extern fn g_object_interface_install_property(g_iface: gpointer, pspec: [*c]GParamSpec) void;
pub extern fn g_object_interface_find_property(g_iface: gpointer, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn g_object_interface_list_properties(g_iface: gpointer, n_properties_p: [*c]guint) [*c][*c]GParamSpec;
pub extern fn g_object_get_type() GType;
pub extern fn g_object_new(object_type: GType, first_property_name: [*c]const gchar, ...) gpointer;
pub extern fn g_object_new_with_properties(object_type: GType, n_properties: guint, names: [*c][*c]const u8, values: [*c]const GValue) [*c]GObject;
pub extern fn g_object_newv(object_type: GType, n_parameters: guint, parameters: [*c]GParameter) gpointer;
pub extern fn g_object_new_valist(object_type: GType, first_property_name: [*c]const gchar, var_args: [*c]struct___va_list_tag) [*c]GObject;
pub extern fn g_object_set(object: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_object_get(object: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_object_connect(object: gpointer, signal_spec: [*c]const gchar, ...) gpointer;
pub extern fn g_object_disconnect(object: gpointer, signal_spec: [*c]const gchar, ...) void;
pub extern fn g_object_setv(object: [*c]GObject, n_properties: guint, names: [*c][*c]const gchar, values: [*c]const GValue) void;
pub extern fn g_object_set_valist(object: [*c]GObject, first_property_name: [*c]const gchar, var_args: [*c]struct___va_list_tag) void;
pub extern fn g_object_getv(object: [*c]GObject, n_properties: guint, names: [*c][*c]const gchar, values: [*c]GValue) void;
pub extern fn g_object_get_valist(object: [*c]GObject, first_property_name: [*c]const gchar, var_args: [*c]struct___va_list_tag) void;
pub extern fn g_object_set_property(object: [*c]GObject, property_name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn g_object_get_property(object: [*c]GObject, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn g_object_freeze_notify(object: [*c]GObject) void;
pub extern fn g_object_notify(object: [*c]GObject, property_name: [*c]const gchar) void;
pub extern fn g_object_notify_by_pspec(object: [*c]GObject, pspec: [*c]GParamSpec) void;
pub extern fn g_object_thaw_notify(object: [*c]GObject) void;
pub extern fn g_object_is_floating(object: gpointer) gboolean;
pub extern fn g_object_ref_sink(object: gpointer) gpointer;
pub extern fn g_object_take_ref(object: gpointer) gpointer;
pub extern fn g_object_ref(object: gpointer) gpointer;
pub extern fn g_object_unref(object: gpointer) void;
pub extern fn g_object_weak_ref(object: [*c]GObject, notify: GWeakNotify, data: gpointer) void;
pub extern fn g_object_weak_unref(object: [*c]GObject, notify: GWeakNotify, data: gpointer) void;
pub extern fn g_object_add_weak_pointer(object: [*c]GObject, weak_pointer_location: [*c]gpointer) void;
pub extern fn g_object_remove_weak_pointer(object: [*c]GObject, weak_pointer_location: [*c]gpointer) void;
pub const GToggleNotify = ?*const fn (gpointer, [*c]GObject, gboolean) callconv(.C) void;
pub extern fn g_object_add_toggle_ref(object: [*c]GObject, notify: GToggleNotify, data: gpointer) void;
pub extern fn g_object_remove_toggle_ref(object: [*c]GObject, notify: GToggleNotify, data: gpointer) void;
pub extern fn g_object_get_qdata(object: [*c]GObject, quark: GQuark) gpointer;
pub extern fn g_object_set_qdata(object: [*c]GObject, quark: GQuark, data: gpointer) void;
pub extern fn g_object_set_qdata_full(object: [*c]GObject, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_object_steal_qdata(object: [*c]GObject, quark: GQuark) gpointer;
pub extern fn g_object_dup_qdata(object: [*c]GObject, quark: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_object_replace_qdata(object: [*c]GObject, quark: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_object_get_data(object: [*c]GObject, key: [*c]const gchar) gpointer;
pub extern fn g_object_set_data(object: [*c]GObject, key: [*c]const gchar, data: gpointer) void;
pub extern fn g_object_set_data_full(object: [*c]GObject, key: [*c]const gchar, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_object_steal_data(object: [*c]GObject, key: [*c]const gchar) gpointer;
pub extern fn g_object_dup_data(object: [*c]GObject, key: [*c]const gchar, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_object_replace_data(object: [*c]GObject, key: [*c]const gchar, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_object_watch_closure(object: [*c]GObject, closure: ?*GClosure) void;
pub extern fn g_cclosure_new_object(callback_func: GCallback, object: [*c]GObject) ?*GClosure;
pub extern fn g_cclosure_new_object_swap(callback_func: GCallback, object: [*c]GObject) ?*GClosure;
pub extern fn g_closure_new_object(sizeof_closure: guint, object: [*c]GObject) ?*GClosure;
pub extern fn g_value_set_object(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_value_get_object(value: [*c]const GValue) gpointer;
pub extern fn g_value_dup_object(value: [*c]const GValue) gpointer;
pub extern fn g_signal_connect_object(instance: gpointer, detailed_signal: [*c]const gchar, c_handler: GCallback, gobject: gpointer, connect_flags: GConnectFlags) gulong;
pub extern fn g_object_force_floating(object: [*c]GObject) void;
pub extern fn g_object_run_dispose(object: [*c]GObject) void;
pub extern fn g_value_take_object(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_value_set_object_take_ownership(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_object_compat_control(what: gsize, data: gpointer) gsize;
pub extern fn g_clear_object(object_ptr: [*c][*c]GObject) void;
pub fn g_set_object(arg_object_ptr: [*c][*c]GObject, arg_new_object: [*c]GObject) callconv(.C) gboolean {
    var object_ptr = arg_object_ptr;
    var new_object = arg_new_object;
    var old_object: [*c]GObject = object_ptr.*;
    if (old_object == new_object) return @as(c_int, 0);
    if (new_object != @as([*c]GObject, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        _ = @as(@TypeOf(new_object), @ptrCast(@alignCast(g_object_ref(@as(gpointer, @ptrCast(new_object))))));
    }
    object_ptr.* = new_object;
    if (old_object != @as([*c]GObject, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        g_object_unref(@as(gpointer, @ptrCast(old_object)));
    }
    return @intFromBool(!(@as(c_int, 0) != 0));
}
pub fn g_assert_finalize_object(arg_object: [*c]GObject) callconv(.C) void {
    var object = arg_object;
    var weak_pointer: gpointer = @as(gpointer, @ptrCast(object));
    while (true) {
        if (g_type_check_instance_is_fundamentally_a(@as([*c]GTypeInstance, @ptrCast(@alignCast(weak_pointer))), @as(GType, @bitCast(@as(c_long, @as(c_int, 20) << @intCast(@as(c_int, 2)))))) != 0) {} else {
            g_assertion_message(@as([*c]gchar, @ptrFromInt(@as(c_int, 0))), "/usr/include/glib-2.0/gobject/gobject.h", @as(c_int, 819), "g_assert_finalize_object", "'G_IS_OBJECT (weak_pointer)' should be TRUE");
        }
        if (!false) break;
    }
    g_object_add_weak_pointer(object, &weak_pointer);
    g_object_unref(weak_pointer);
    while (true) {
        if (weak_pointer == @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {} else {
            g_assertion_message(@as([*c]gchar, @ptrFromInt(@as(c_int, 0))), "/usr/include/glib-2.0/gobject/gobject.h", @as(c_int, 822), "g_assert_finalize_object", "'weak_pointer' should be NULL");
        }
        if (!false) break;
    }
}
pub fn g_clear_weak_pointer(arg_weak_pointer_location: [*c]gpointer) callconv(.C) void {
    var weak_pointer_location = arg_weak_pointer_location;
    var object: [*c]GObject = @as([*c]GObject, @ptrCast(@alignCast(weak_pointer_location.*)));
    if (object != @as([*c]GObject, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        g_object_remove_weak_pointer(object, weak_pointer_location);
        weak_pointer_location.* = @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)));
    }
}
pub fn g_set_weak_pointer(arg_weak_pointer_location: [*c]gpointer, arg_new_object: [*c]GObject) callconv(.C) gboolean {
    var weak_pointer_location = arg_weak_pointer_location;
    var new_object = arg_new_object;
    var old_object: [*c]GObject = @as([*c]GObject, @ptrCast(@alignCast(weak_pointer_location.*)));
    if (old_object == new_object) return @as(c_int, 0);
    if (old_object != @as([*c]GObject, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        g_object_remove_weak_pointer(old_object, weak_pointer_location);
    }
    weak_pointer_location.* = @as(gpointer, @ptrCast(new_object));
    if (new_object != @as([*c]GObject, @ptrCast(@alignCast(@as(?*anyopaque, @ptrFromInt(@as(c_int, 0))))))) {
        g_object_add_weak_pointer(new_object, weak_pointer_location);
    }
    return @intFromBool(!(@as(c_int, 0) != 0));
}
const union_unnamed_44 = extern union {
    p: gpointer,
};
pub const GWeakRef = extern struct {
    priv: union_unnamed_44,
};
pub extern fn g_weak_ref_init(weak_ref: [*c]GWeakRef, object: gpointer) void;
pub extern fn g_weak_ref_clear(weak_ref: [*c]GWeakRef) void;
pub extern fn g_weak_ref_get(weak_ref: [*c]GWeakRef) gpointer;
pub extern fn g_weak_ref_set(weak_ref: [*c]GWeakRef, object: gpointer) void;
pub const struct__GBinding = opaque {};
pub const GBinding = struct__GBinding;
pub const GBindingTransformFunc = ?*const fn (?*GBinding, [*c]const GValue, [*c]GValue, gpointer) callconv(.C) gboolean;
pub const G_BINDING_DEFAULT: c_int = 0;
pub const G_BINDING_BIDIRECTIONAL: c_int = 1;
pub const G_BINDING_SYNC_CREATE: c_int = 2;
pub const G_BINDING_INVERT_BOOLEAN: c_int = 4;
pub const GBindingFlags = c_uint;
pub extern fn g_binding_flags_get_type() GType;
pub extern fn g_binding_get_type() GType;
pub extern fn g_binding_get_flags(binding: ?*GBinding) GBindingFlags;
pub extern fn g_binding_get_source(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_dup_source(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_get_target(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_dup_target(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_get_source_property(binding: ?*GBinding) [*c]const gchar;
pub extern fn g_binding_get_target_property(binding: ?*GBinding) [*c]const gchar;
pub extern fn g_binding_unbind(binding: ?*GBinding) void;
pub extern fn g_object_bind_property(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags) ?*GBinding;
pub extern fn g_object_bind_property_full(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: GBindingTransformFunc, transform_from: GBindingTransformFunc, user_data: gpointer, notify: GDestroyNotify) ?*GBinding;
pub extern fn g_object_bind_property_with_closures(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: ?*GClosure, transform_from: ?*GClosure) ?*GBinding;
pub const struct__GBindingGroup = opaque {};
pub const GBindingGroup = struct__GBindingGroup;
pub extern fn g_binding_group_get_type() GType;
pub extern fn g_binding_group_new() ?*GBindingGroup;
pub extern fn g_binding_group_dup_source(self: ?*GBindingGroup) gpointer;
pub extern fn g_binding_group_set_source(self: ?*GBindingGroup, source: gpointer) void;
pub extern fn g_binding_group_bind(self: ?*GBindingGroup, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags) void;
pub extern fn g_binding_group_bind_full(self: ?*GBindingGroup, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: GBindingTransformFunc, transform_from: GBindingTransformFunc, user_data: gpointer, user_data_destroy: GDestroyNotify) void;
pub extern fn g_binding_group_bind_with_closures(self: ?*GBindingGroup, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: ?*GClosure, transform_from: ?*GClosure) void;
pub const struct__GEnumValue = extern struct {
    value: gint,
    value_name: [*c]const gchar,
    value_nick: [*c]const gchar,
};
pub const GEnumValue = struct__GEnumValue;
pub const struct__GEnumClass = extern struct {
    g_type_class: GTypeClass,
    minimum: gint,
    maximum: gint,
    n_values: guint,
    values: [*c]GEnumValue,
};
pub const GEnumClass = struct__GEnumClass;
pub const struct__GFlagsValue = extern struct {
    value: guint,
    value_name: [*c]const gchar,
    value_nick: [*c]const gchar,
};
pub const GFlagsValue = struct__GFlagsValue;
pub const struct__GFlagsClass = extern struct {
    g_type_class: GTypeClass,
    mask: guint,
    n_values: guint,
    values: [*c]GFlagsValue,
};
pub const GFlagsClass = struct__GFlagsClass;
pub extern fn g_enum_get_value(enum_class: [*c]GEnumClass, value: gint) [*c]GEnumValue;
pub extern fn g_enum_get_value_by_name(enum_class: [*c]GEnumClass, name: [*c]const gchar) [*c]GEnumValue;
pub extern fn g_enum_get_value_by_nick(enum_class: [*c]GEnumClass, nick: [*c]const gchar) [*c]GEnumValue;
pub extern fn g_flags_get_first_value(flags_class: [*c]GFlagsClass, value: guint) [*c]GFlagsValue;
pub extern fn g_flags_get_value_by_name(flags_class: [*c]GFlagsClass, name: [*c]const gchar) [*c]GFlagsValue;
pub extern fn g_flags_get_value_by_nick(flags_class: [*c]GFlagsClass, nick: [*c]const gchar) [*c]GFlagsValue;
pub extern fn g_enum_to_string(g_enum_type: GType, value: gint) [*c]gchar;
pub extern fn g_flags_to_string(flags_type: GType, value: guint) [*c]gchar;
pub extern fn g_value_set_enum(value: [*c]GValue, v_enum: gint) void;
pub extern fn g_value_get_enum(value: [*c]const GValue) gint;
pub extern fn g_value_set_flags(value: [*c]GValue, v_flags: guint) void;
pub extern fn g_value_get_flags(value: [*c]const GValue) guint;
pub extern fn g_enum_register_static(name: [*c]const gchar, const_static_values: [*c]const GEnumValue) GType;
pub extern fn g_flags_register_static(name: [*c]const gchar, const_static_values: [*c]const GFlagsValue) GType;
pub extern fn g_enum_complete_type_info(g_enum_type: GType, info: [*c]GTypeInfo, const_values: [*c]const GEnumValue) void;
pub extern fn g_flags_complete_type_info(g_flags_type: GType, info: [*c]GTypeInfo, const_values: [*c]const GFlagsValue) void;
pub extern fn g_unicode_type_get_type() GType;
pub extern fn g_unicode_break_type_get_type() GType;
pub extern fn g_unicode_script_get_type() GType;
pub extern fn g_normalize_mode_get_type() GType;
pub const struct__GParamSpecChar = extern struct {
    parent_instance: GParamSpec,
    minimum: gint8,
    maximum: gint8,
    default_value: gint8,
};
pub const GParamSpecChar = struct__GParamSpecChar;
pub const struct__GParamSpecUChar = extern struct {
    parent_instance: GParamSpec,
    minimum: guint8,
    maximum: guint8,
    default_value: guint8,
};
pub const GParamSpecUChar = struct__GParamSpecUChar;
pub const struct__GParamSpecBoolean = extern struct {
    parent_instance: GParamSpec,
    default_value: gboolean,
};
pub const GParamSpecBoolean = struct__GParamSpecBoolean;
pub const struct__GParamSpecInt = extern struct {
    parent_instance: GParamSpec,
    minimum: gint,
    maximum: gint,
    default_value: gint,
};
pub const GParamSpecInt = struct__GParamSpecInt;
pub const struct__GParamSpecUInt = extern struct {
    parent_instance: GParamSpec,
    minimum: guint,
    maximum: guint,
    default_value: guint,
};
pub const GParamSpecUInt = struct__GParamSpecUInt;
pub const struct__GParamSpecLong = extern struct {
    parent_instance: GParamSpec,
    minimum: glong,
    maximum: glong,
    default_value: glong,
};
pub const GParamSpecLong = struct__GParamSpecLong;
pub const struct__GParamSpecULong = extern struct {
    parent_instance: GParamSpec,
    minimum: gulong,
    maximum: gulong,
    default_value: gulong,
};
pub const GParamSpecULong = struct__GParamSpecULong;
pub const struct__GParamSpecInt64 = extern struct {
    parent_instance: GParamSpec,
    minimum: gint64,
    maximum: gint64,
    default_value: gint64,
};
pub const GParamSpecInt64 = struct__GParamSpecInt64;
pub const struct__GParamSpecUInt64 = extern struct {
    parent_instance: GParamSpec,
    minimum: guint64,
    maximum: guint64,
    default_value: guint64,
};
pub const GParamSpecUInt64 = struct__GParamSpecUInt64;
pub const struct__GParamSpecUnichar = extern struct {
    parent_instance: GParamSpec,
    default_value: gunichar,
};
pub const GParamSpecUnichar = struct__GParamSpecUnichar;
pub const struct__GParamSpecEnum = extern struct {
    parent_instance: GParamSpec,
    enum_class: [*c]GEnumClass,
    default_value: gint,
};
pub const GParamSpecEnum = struct__GParamSpecEnum;
pub const struct__GParamSpecFlags = extern struct {
    parent_instance: GParamSpec,
    flags_class: [*c]GFlagsClass,
    default_value: guint,
};
pub const GParamSpecFlags = struct__GParamSpecFlags;
pub const struct__GParamSpecFloat = extern struct {
    parent_instance: GParamSpec,
    minimum: gfloat,
    maximum: gfloat,
    default_value: gfloat,
    epsilon: gfloat,
};
pub const GParamSpecFloat = struct__GParamSpecFloat;
pub const struct__GParamSpecDouble = extern struct {
    parent_instance: GParamSpec,
    minimum: gdouble,
    maximum: gdouble,
    default_value: gdouble,
    epsilon: gdouble,
};
pub const GParamSpecDouble = struct__GParamSpecDouble; // /usr/include/glib-2.0/gobject/gparamspecs.h:867:17: warning: struct demoted to opaque type - has bitfield
pub const struct__GParamSpecString = opaque {};
pub const GParamSpecString = struct__GParamSpecString;
pub const struct__GParamSpecParam = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecParam = struct__GParamSpecParam;
pub const struct__GParamSpecBoxed = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecBoxed = struct__GParamSpecBoxed;
pub const struct__GParamSpecPointer = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecPointer = struct__GParamSpecPointer;
pub const struct__GParamSpecValueArray = extern struct {
    parent_instance: GParamSpec,
    element_spec: [*c]GParamSpec,
    fixed_n_elements: guint,
};
pub const GParamSpecValueArray = struct__GParamSpecValueArray;
pub const struct__GParamSpecObject = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecObject = struct__GParamSpecObject;
pub const struct__GParamSpecOverride = extern struct {
    parent_instance: GParamSpec,
    overridden: [*c]GParamSpec,
};
pub const GParamSpecOverride = struct__GParamSpecOverride;
pub const struct__GParamSpecGType = extern struct {
    parent_instance: GParamSpec,
    is_a_type: GType,
};
pub const GParamSpecGType = struct__GParamSpecGType;
pub const struct__GParamSpecVariant = extern struct {
    parent_instance: GParamSpec,
    type: ?*GVariantType,
    default_value: ?*GVariant,
    padding: [4]gpointer,
};
pub const GParamSpecVariant = struct__GParamSpecVariant;
pub extern fn g_param_spec_char(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint8, maximum: gint8, default_value: gint8, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uchar(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint8, maximum: guint8, default_value: guint8, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_boolean(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: gboolean, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_int(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint, maximum: gint, default_value: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uint(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint, maximum: guint, default_value: guint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_long(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: glong, maximum: glong, default_value: glong, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_ulong(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gulong, maximum: gulong, default_value: gulong, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_int64(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint64, maximum: gint64, default_value: gint64, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uint64(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint64, maximum: guint64, default_value: guint64, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_unichar(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: gunichar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_enum(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, enum_type: GType, default_value: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_flags(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags_type: GType, default_value: guint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_float(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gfloat, maximum: gfloat, default_value: gfloat, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_double(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gdouble, maximum: gdouble, default_value: gdouble, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_string(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: [*c]const gchar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_param(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, param_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_boxed(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, boxed_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_pointer(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_value_array(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, element_spec: [*c]GParamSpec, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_object(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, object_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_override(name: [*c]const gchar, overridden: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_gtype(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, is_a_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_variant(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, @"type": ?*const GVariantType, default_value: ?*GVariant, flags: GParamFlags) [*c]GParamSpec;
pub extern var g_param_spec_types: [*c]GType;
pub const struct__GSignalGroup = opaque {};
pub const GSignalGroup = struct__GSignalGroup;
pub extern fn g_signal_group_get_type() GType;
pub extern fn g_signal_group_new(target_type: GType) ?*GSignalGroup;
pub extern fn g_signal_group_set_target(self: ?*GSignalGroup, target: gpointer) void;
pub extern fn g_signal_group_dup_target(self: ?*GSignalGroup) gpointer;
pub extern fn g_signal_group_block(self: ?*GSignalGroup) void;
pub extern fn g_signal_group_unblock(self: ?*GSignalGroup) void;
pub extern fn g_signal_group_connect_closure(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, closure: ?*GClosure, after: gboolean) void;
pub extern fn g_signal_group_connect_object(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, object: gpointer, flags: GConnectFlags) void;
pub extern fn g_signal_group_connect_data(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer, notify: GClosureNotify, flags: GConnectFlags) void;
pub extern fn g_signal_group_connect(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer) void;
pub extern fn g_signal_group_connect_after(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer) void;
pub extern fn g_signal_group_connect_swapped(self: ?*GSignalGroup, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer) void;
pub extern fn g_source_set_closure(source: [*c]GSource, closure: ?*GClosure) void;
pub extern fn g_source_set_dummy_callback(source: [*c]GSource) void;
pub const struct__GTypeModule = extern struct {
    parent_instance: GObject,
    use_count: guint,
    type_infos: [*c]GSList,
    interface_infos: [*c]GSList,
    name: [*c]gchar,
};
pub const GTypeModule = struct__GTypeModule;
pub const struct__GTypeModuleClass = extern struct {
    parent_class: GObjectClass,
    load: ?*const fn ([*c]GTypeModule) callconv(.C) gboolean,
    unload: ?*const fn ([*c]GTypeModule) callconv(.C) void,
    reserved1: ?*const fn () callconv(.C) void,
    reserved2: ?*const fn () callconv(.C) void,
    reserved3: ?*const fn () callconv(.C) void,
    reserved4: ?*const fn () callconv(.C) void,
};
pub const GTypeModuleClass = struct__GTypeModuleClass;
pub const GTypeModule_autoptr = [*c]GTypeModule;
pub const GTypeModule_listautoptr = [*c]GList;
pub const GTypeModule_slistautoptr = [*c]GSList;
pub const GTypeModule_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTypeModule(arg__ptr: [*c]GTypeModule) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTypeModule(arg__ptr: [*c][*c]GTypeModule) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTypeModule(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTypeModule(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTypeModule(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTypeModule(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn g_type_module_get_type() GType;
pub extern fn g_type_module_use(module: [*c]GTypeModule) gboolean;
pub extern fn g_type_module_unuse(module: [*c]GTypeModule) void;
pub extern fn g_type_module_set_name(module: [*c]GTypeModule, name: [*c]const gchar) void;
pub extern fn g_type_module_register_type(module: [*c]GTypeModule, parent_type: GType, type_name: [*c]const gchar, type_info: [*c]const GTypeInfo, flags: GTypeFlags) GType;
pub extern fn g_type_module_add_interface(module: [*c]GTypeModule, instance_type: GType, interface_type: GType, interface_info: [*c]const GInterfaceInfo) void;
pub extern fn g_type_module_register_enum(module: [*c]GTypeModule, name: [*c]const gchar, const_static_values: [*c]const GEnumValue) GType;
pub extern fn g_type_module_register_flags(module: [*c]GTypeModule, name: [*c]const gchar, const_static_values: [*c]const GFlagsValue) GType;
pub const GTypePluginUse = ?*const fn (?*GTypePlugin) callconv(.C) void;
pub const GTypePluginUnuse = ?*const fn (?*GTypePlugin) callconv(.C) void;
pub const GTypePluginCompleteTypeInfo = ?*const fn (?*GTypePlugin, GType, [*c]GTypeInfo, [*c]GTypeValueTable) callconv(.C) void;
pub const GTypePluginCompleteInterfaceInfo = ?*const fn (?*GTypePlugin, GType, GType, [*c]GInterfaceInfo) callconv(.C) void;
pub const struct__GTypePluginClass = extern struct {
    base_iface: GTypeInterface,
    use_plugin: GTypePluginUse,
    unuse_plugin: GTypePluginUnuse,
    complete_type_info: GTypePluginCompleteTypeInfo,
    complete_interface_info: GTypePluginCompleteInterfaceInfo,
};
pub const GTypePluginClass = struct__GTypePluginClass;
pub extern fn g_type_plugin_get_type() GType;
pub extern fn g_type_plugin_use(plugin: ?*GTypePlugin) void;
pub extern fn g_type_plugin_unuse(plugin: ?*GTypePlugin) void;
pub extern fn g_type_plugin_complete_type_info(plugin: ?*GTypePlugin, g_type: GType, info: [*c]GTypeInfo, value_table: [*c]GTypeValueTable) void;
pub extern fn g_type_plugin_complete_interface_info(plugin: ?*GTypePlugin, instance_type: GType, interface_type: GType, info: [*c]GInterfaceInfo) void;
pub const struct__GValueArray = extern struct {
    n_values: guint,
    values: [*c]GValue,
    n_prealloced: guint,
};
pub const GValueArray = struct__GValueArray;
pub extern fn g_value_array_get_type() GType;
pub extern fn g_value_array_get_nth(value_array: [*c]GValueArray, index_: guint) [*c]GValue;
pub extern fn g_value_array_new(n_prealloced: guint) [*c]GValueArray;
pub extern fn g_value_array_free(value_array: [*c]GValueArray) void;
pub extern fn g_value_array_copy(value_array: [*c]const GValueArray) [*c]GValueArray;
pub extern fn g_value_array_prepend(value_array: [*c]GValueArray, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_append(value_array: [*c]GValueArray, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_insert(value_array: [*c]GValueArray, index_: guint, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_remove(value_array: [*c]GValueArray, index_: guint) [*c]GValueArray;
pub extern fn g_value_array_sort(value_array: [*c]GValueArray, compare_func: GCompareFunc) [*c]GValueArray;
pub extern fn g_value_array_sort_with_data(value_array: [*c]GValueArray, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GValueArray;
pub extern fn g_value_set_char(value: [*c]GValue, v_char: gchar) void;
pub extern fn g_value_get_char(value: [*c]const GValue) gchar;
pub extern fn g_value_set_schar(value: [*c]GValue, v_char: gint8) void;
pub extern fn g_value_get_schar(value: [*c]const GValue) gint8;
pub extern fn g_value_set_uchar(value: [*c]GValue, v_uchar: guchar) void;
pub extern fn g_value_get_uchar(value: [*c]const GValue) guchar;
pub extern fn g_value_set_boolean(value: [*c]GValue, v_boolean: gboolean) void;
pub extern fn g_value_get_boolean(value: [*c]const GValue) gboolean;
pub extern fn g_value_set_int(value: [*c]GValue, v_int: gint) void;
pub extern fn g_value_get_int(value: [*c]const GValue) gint;
pub extern fn g_value_set_uint(value: [*c]GValue, v_uint: guint) void;
pub extern fn g_value_get_uint(value: [*c]const GValue) guint;
pub extern fn g_value_set_long(value: [*c]GValue, v_long: glong) void;
pub extern fn g_value_get_long(value: [*c]const GValue) glong;
pub extern fn g_value_set_ulong(value: [*c]GValue, v_ulong: gulong) void;
pub extern fn g_value_get_ulong(value: [*c]const GValue) gulong;
pub extern fn g_value_set_int64(value: [*c]GValue, v_int64: gint64) void;
pub extern fn g_value_get_int64(value: [*c]const GValue) gint64;
pub extern fn g_value_set_uint64(value: [*c]GValue, v_uint64: guint64) void;
pub extern fn g_value_get_uint64(value: [*c]const GValue) guint64;
pub extern fn g_value_set_float(value: [*c]GValue, v_float: gfloat) void;
pub extern fn g_value_get_float(value: [*c]const GValue) gfloat;
pub extern fn g_value_set_double(value: [*c]GValue, v_double: gdouble) void;
pub extern fn g_value_get_double(value: [*c]const GValue) gdouble;
pub extern fn g_value_set_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_set_static_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_set_interned_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_get_string(value: [*c]const GValue) [*c]const gchar;
pub extern fn g_value_dup_string(value: [*c]const GValue) [*c]gchar;
pub extern fn g_value_set_pointer(value: [*c]GValue, v_pointer: gpointer) void;
pub extern fn g_value_get_pointer(value: [*c]const GValue) gpointer;
pub extern fn g_gtype_get_type() GType;
pub extern fn g_value_set_gtype(value: [*c]GValue, v_gtype: GType) void;
pub extern fn g_value_get_gtype(value: [*c]const GValue) GType;
pub extern fn g_value_set_variant(value: [*c]GValue, variant: ?*GVariant) void;
pub extern fn g_value_take_variant(value: [*c]GValue, variant: ?*GVariant) void;
pub extern fn g_value_get_variant(value: [*c]const GValue) ?*GVariant;
pub extern fn g_value_dup_variant(value: [*c]const GValue) ?*GVariant;
pub extern fn g_pointer_type_register_static(name: [*c]const gchar) GType;
pub extern fn g_strdup_value_contents(value: [*c]const GValue) [*c]gchar;
pub extern fn g_value_take_string(value: [*c]GValue, v_string: [*c]gchar) void;
pub extern fn g_value_set_string_take_ownership(value: [*c]GValue, v_string: [*c]gchar) void;
pub const gchararray = [*c]gchar;
pub const GClosure_autoptr = ?*GClosure;
pub const GClosure_listautoptr = [*c]GList;
pub const GClosure_slistautoptr = [*c]GSList;
pub const GClosure_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GClosure(arg__ptr: ?*GClosure) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_closure_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GClosure(arg__ptr: [*c]?*GClosure) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GClosure(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GClosure(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_closure_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GClosure(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_closure_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GClosure(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_closure_unref)))))));
    }
}
pub const GEnumClass_autoptr = [*c]GEnumClass;
pub const GEnumClass_listautoptr = [*c]GList;
pub const GEnumClass_slistautoptr = [*c]GSList;
pub const GEnumClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEnumClass(arg__ptr: [*c]GEnumClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GEnumClass(arg__ptr: [*c][*c]GEnumClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GEnumClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GEnumClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GEnumClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GEnumClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub const GFlagsClass_autoptr = [*c]GFlagsClass;
pub const GFlagsClass_listautoptr = [*c]GList;
pub const GFlagsClass_slistautoptr = [*c]GSList;
pub const GFlagsClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFlagsClass(arg__ptr: [*c]GFlagsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFlagsClass(arg__ptr: [*c][*c]GFlagsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFlagsClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFlagsClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFlagsClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFlagsClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub const GObject_autoptr = [*c]GObject;
pub const GObject_listautoptr = [*c]GList;
pub const GObject_slistautoptr = [*c]GSList;
pub const GObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GObject(arg__ptr: [*c]GObject) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GObject(arg__ptr: [*c][*c]GObject) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GObject(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GObject(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GObject(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GObject(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GInitiallyUnowned_autoptr = [*c]GInitiallyUnowned;
pub const GInitiallyUnowned_listautoptr = [*c]GList;
pub const GInitiallyUnowned_slistautoptr = [*c]GSList;
pub const GInitiallyUnowned_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInitiallyUnowned(arg__ptr: [*c]GInitiallyUnowned) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GInitiallyUnowned(arg__ptr: [*c][*c]GInitiallyUnowned) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInitiallyUnowned(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInitiallyUnowned(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GInitiallyUnowned(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GInitiallyUnowned(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GParamSpec_autoptr = [*c]GParamSpec;
pub const GParamSpec_listautoptr = [*c]GList;
pub const GParamSpec_slistautoptr = [*c]GSList;
pub const GParamSpec_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GParamSpec(arg__ptr: [*c]GParamSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_param_spec_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GParamSpec(arg__ptr: [*c][*c]GParamSpec) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GParamSpec(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GParamSpec(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_param_spec_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GParamSpec(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_param_spec_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GParamSpec(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_param_spec_unref)))))));
    }
}
pub const GTypeClass_autoptr = [*c]GTypeClass;
pub const GTypeClass_listautoptr = [*c]GList;
pub const GTypeClass_slistautoptr = [*c]GSList;
pub const GTypeClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTypeClass(arg__ptr: [*c]GTypeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTypeClass(arg__ptr: [*c][*c]GTypeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTypeClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTypeClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTypeClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTypeClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn glib_auto_cleanup_GValue(arg__ptr: [*c]GValue) callconv(.C) void {
    var _ptr = arg__ptr;
    g_value_unset(_ptr);
}
pub extern fn gtk_css_parser_error_get_type() GType;
pub extern fn gtk_css_parser_warning_get_type() GType;
pub extern fn gtk_css_parser_error_quark() GQuark;
pub extern fn gtk_css_parser_warning_quark() GQuark;
pub const struct__GtkCssLocation = extern struct {
    bytes: gsize,
    chars: gsize,
    lines: gsize,
    line_bytes: gsize,
    line_chars: gsize,
};
pub const GtkCssLocation = struct__GtkCssLocation;
pub const G_APP_INFO_CREATE_NONE: c_int = 0;
pub const G_APP_INFO_CREATE_NEEDS_TERMINAL: c_int = 1;
pub const G_APP_INFO_CREATE_SUPPORTS_URIS: c_int = 2;
pub const G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: c_int = 4;
pub const GAppInfoCreateFlags = c_uint;
pub const G_CONVERTER_NO_FLAGS: c_int = 0;
pub const G_CONVERTER_INPUT_AT_END: c_int = 1;
pub const G_CONVERTER_FLUSH: c_int = 2;
pub const GConverterFlags = c_uint;
pub const G_CONVERTER_ERROR: c_int = 0;
pub const G_CONVERTER_CONVERTED: c_int = 1;
pub const G_CONVERTER_FINISHED: c_int = 2;
pub const G_CONVERTER_FLUSHED: c_int = 3;
pub const GConverterResult = c_uint;
pub const G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: c_int = 0;
pub const G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: c_int = 1;
pub const G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: c_int = 2;
pub const GDataStreamByteOrder = c_uint;
pub const G_DATA_STREAM_NEWLINE_TYPE_LF: c_int = 0;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR: c_int = 1;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR_LF: c_int = 2;
pub const G_DATA_STREAM_NEWLINE_TYPE_ANY: c_int = 3;
pub const GDataStreamNewlineType = c_uint;
pub const G_FILE_ATTRIBUTE_TYPE_INVALID: c_int = 0;
pub const G_FILE_ATTRIBUTE_TYPE_STRING: c_int = 1;
pub const G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: c_int = 2;
pub const G_FILE_ATTRIBUTE_TYPE_BOOLEAN: c_int = 3;
pub const G_FILE_ATTRIBUTE_TYPE_UINT32: c_int = 4;
pub const G_FILE_ATTRIBUTE_TYPE_INT32: c_int = 5;
pub const G_FILE_ATTRIBUTE_TYPE_UINT64: c_int = 6;
pub const G_FILE_ATTRIBUTE_TYPE_INT64: c_int = 7;
pub const G_FILE_ATTRIBUTE_TYPE_OBJECT: c_int = 8;
pub const G_FILE_ATTRIBUTE_TYPE_STRINGV: c_int = 9;
pub const GFileAttributeType = c_uint;
pub const G_FILE_ATTRIBUTE_INFO_NONE: c_int = 0;
pub const G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: c_int = 1;
pub const G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: c_int = 2;
pub const GFileAttributeInfoFlags = c_uint;
pub const G_FILE_ATTRIBUTE_STATUS_UNSET: c_int = 0;
pub const G_FILE_ATTRIBUTE_STATUS_SET: c_int = 1;
pub const G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: c_int = 2;
pub const GFileAttributeStatus = c_uint;
pub const G_FILE_QUERY_INFO_NONE: c_int = 0;
pub const G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: c_int = 1;
pub const GFileQueryInfoFlags = c_uint;
pub const G_FILE_CREATE_NONE: c_int = 0;
pub const G_FILE_CREATE_PRIVATE: c_int = 1;
pub const G_FILE_CREATE_REPLACE_DESTINATION: c_int = 2;
pub const GFileCreateFlags = c_uint;
pub const G_FILE_MEASURE_NONE: c_int = 0;
pub const G_FILE_MEASURE_REPORT_ANY_ERROR: c_int = 2;
pub const G_FILE_MEASURE_APPARENT_SIZE: c_int = 4;
pub const G_FILE_MEASURE_NO_XDEV: c_int = 8;
pub const GFileMeasureFlags = c_uint;
pub const G_MOUNT_MOUNT_NONE: c_int = 0;
pub const GMountMountFlags = c_uint;
pub const G_MOUNT_UNMOUNT_NONE: c_int = 0;
pub const G_MOUNT_UNMOUNT_FORCE: c_int = 1;
pub const GMountUnmountFlags = c_uint;
pub const G_DRIVE_START_NONE: c_int = 0;
pub const GDriveStartFlags = c_uint;
pub const G_DRIVE_START_STOP_TYPE_UNKNOWN: c_int = 0;
pub const G_DRIVE_START_STOP_TYPE_SHUTDOWN: c_int = 1;
pub const G_DRIVE_START_STOP_TYPE_NETWORK: c_int = 2;
pub const G_DRIVE_START_STOP_TYPE_MULTIDISK: c_int = 3;
pub const G_DRIVE_START_STOP_TYPE_PASSWORD: c_int = 4;
pub const GDriveStartStopType = c_uint;
pub const G_FILE_COPY_NONE: c_int = 0;
pub const G_FILE_COPY_OVERWRITE: c_int = 1;
pub const G_FILE_COPY_BACKUP: c_int = 2;
pub const G_FILE_COPY_NOFOLLOW_SYMLINKS: c_int = 4;
pub const G_FILE_COPY_ALL_METADATA: c_int = 8;
pub const G_FILE_COPY_NO_FALLBACK_FOR_MOVE: c_int = 16;
pub const G_FILE_COPY_TARGET_DEFAULT_PERMS: c_int = 32;
pub const GFileCopyFlags = c_uint;
pub const G_FILE_MONITOR_NONE: c_int = 0;
pub const G_FILE_MONITOR_WATCH_MOUNTS: c_int = 1;
pub const G_FILE_MONITOR_SEND_MOVED: c_int = 2;
pub const G_FILE_MONITOR_WATCH_HARD_LINKS: c_int = 4;
pub const G_FILE_MONITOR_WATCH_MOVES: c_int = 8;
pub const GFileMonitorFlags = c_uint;
pub const G_FILE_TYPE_UNKNOWN: c_int = 0;
pub const G_FILE_TYPE_REGULAR: c_int = 1;
pub const G_FILE_TYPE_DIRECTORY: c_int = 2;
pub const G_FILE_TYPE_SYMBOLIC_LINK: c_int = 3;
pub const G_FILE_TYPE_SPECIAL: c_int = 4;
pub const G_FILE_TYPE_SHORTCUT: c_int = 5;
pub const G_FILE_TYPE_MOUNTABLE: c_int = 6;
pub const GFileType = c_uint;
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: c_int = 0;
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: c_int = 1;
pub const G_FILESYSTEM_PREVIEW_TYPE_NEVER: c_int = 2;
pub const GFilesystemPreviewType = c_uint;
pub const G_FILE_MONITOR_EVENT_CHANGED: c_int = 0;
pub const G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: c_int = 1;
pub const G_FILE_MONITOR_EVENT_DELETED: c_int = 2;
pub const G_FILE_MONITOR_EVENT_CREATED: c_int = 3;
pub const G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: c_int = 4;
pub const G_FILE_MONITOR_EVENT_PRE_UNMOUNT: c_int = 5;
pub const G_FILE_MONITOR_EVENT_UNMOUNTED: c_int = 6;
pub const G_FILE_MONITOR_EVENT_MOVED: c_int = 7;
pub const G_FILE_MONITOR_EVENT_RENAMED: c_int = 8;
pub const G_FILE_MONITOR_EVENT_MOVED_IN: c_int = 9;
pub const G_FILE_MONITOR_EVENT_MOVED_OUT: c_int = 10;
pub const GFileMonitorEvent = c_uint;
pub const G_IO_ERROR_FAILED: c_int = 0;
pub const G_IO_ERROR_NOT_FOUND: c_int = 1;
pub const G_IO_ERROR_EXISTS: c_int = 2;
pub const G_IO_ERROR_IS_DIRECTORY: c_int = 3;
pub const G_IO_ERROR_NOT_DIRECTORY: c_int = 4;
pub const G_IO_ERROR_NOT_EMPTY: c_int = 5;
pub const G_IO_ERROR_NOT_REGULAR_FILE: c_int = 6;
pub const G_IO_ERROR_NOT_SYMBOLIC_LINK: c_int = 7;
pub const G_IO_ERROR_NOT_MOUNTABLE_FILE: c_int = 8;
pub const G_IO_ERROR_FILENAME_TOO_LONG: c_int = 9;
pub const G_IO_ERROR_INVALID_FILENAME: c_int = 10;
pub const G_IO_ERROR_TOO_MANY_LINKS: c_int = 11;
pub const G_IO_ERROR_NO_SPACE: c_int = 12;
pub const G_IO_ERROR_INVALID_ARGUMENT: c_int = 13;
pub const G_IO_ERROR_PERMISSION_DENIED: c_int = 14;
pub const G_IO_ERROR_NOT_SUPPORTED: c_int = 15;
pub const G_IO_ERROR_NOT_MOUNTED: c_int = 16;
pub const G_IO_ERROR_ALREADY_MOUNTED: c_int = 17;
pub const G_IO_ERROR_CLOSED: c_int = 18;
pub const G_IO_ERROR_CANCELLED: c_int = 19;
pub const G_IO_ERROR_PENDING: c_int = 20;
pub const G_IO_ERROR_READ_ONLY: c_int = 21;
pub const G_IO_ERROR_CANT_CREATE_BACKUP: c_int = 22;
pub const G_IO_ERROR_WRONG_ETAG: c_int = 23;
pub const G_IO_ERROR_TIMED_OUT: c_int = 24;
pub const G_IO_ERROR_WOULD_RECURSE: c_int = 25;
pub const G_IO_ERROR_BUSY: c_int = 26;
pub const G_IO_ERROR_WOULD_BLOCK: c_int = 27;
pub const G_IO_ERROR_HOST_NOT_FOUND: c_int = 28;
pub const G_IO_ERROR_WOULD_MERGE: c_int = 29;
pub const G_IO_ERROR_FAILED_HANDLED: c_int = 30;
pub const G_IO_ERROR_TOO_MANY_OPEN_FILES: c_int = 31;
pub const G_IO_ERROR_NOT_INITIALIZED: c_int = 32;
pub const G_IO_ERROR_ADDRESS_IN_USE: c_int = 33;
pub const G_IO_ERROR_PARTIAL_INPUT: c_int = 34;
pub const G_IO_ERROR_INVALID_DATA: c_int = 35;
pub const G_IO_ERROR_DBUS_ERROR: c_int = 36;
pub const G_IO_ERROR_HOST_UNREACHABLE: c_int = 37;
pub const G_IO_ERROR_NETWORK_UNREACHABLE: c_int = 38;
pub const G_IO_ERROR_CONNECTION_REFUSED: c_int = 39;
pub const G_IO_ERROR_PROXY_FAILED: c_int = 40;
pub const G_IO_ERROR_PROXY_AUTH_FAILED: c_int = 41;
pub const G_IO_ERROR_PROXY_NEED_AUTH: c_int = 42;
pub const G_IO_ERROR_PROXY_NOT_ALLOWED: c_int = 43;
pub const G_IO_ERROR_BROKEN_PIPE: c_int = 44;
pub const G_IO_ERROR_CONNECTION_CLOSED: c_int = 44;
pub const G_IO_ERROR_NOT_CONNECTED: c_int = 45;
pub const G_IO_ERROR_MESSAGE_TOO_LARGE: c_int = 46;
pub const G_IO_ERROR_NO_SUCH_DEVICE: c_int = 47;
pub const GIOErrorEnum = c_uint;
pub const G_ASK_PASSWORD_NEED_PASSWORD: c_int = 1;
pub const G_ASK_PASSWORD_NEED_USERNAME: c_int = 2;
pub const G_ASK_PASSWORD_NEED_DOMAIN: c_int = 4;
pub const G_ASK_PASSWORD_SAVING_SUPPORTED: c_int = 8;
pub const G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: c_int = 16;
pub const G_ASK_PASSWORD_TCRYPT: c_int = 32;
pub const GAskPasswordFlags = c_uint;
pub const G_PASSWORD_SAVE_NEVER: c_int = 0;
pub const G_PASSWORD_SAVE_FOR_SESSION: c_int = 1;
pub const G_PASSWORD_SAVE_PERMANENTLY: c_int = 2;
pub const GPasswordSave = c_uint;
pub const G_MOUNT_OPERATION_HANDLED: c_int = 0;
pub const G_MOUNT_OPERATION_ABORTED: c_int = 1;
pub const G_MOUNT_OPERATION_UNHANDLED: c_int = 2;
pub const GMountOperationResult = c_uint;
pub const G_OUTPUT_STREAM_SPLICE_NONE: c_int = 0;
pub const G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: c_int = 1;
pub const G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: c_int = 2;
pub const GOutputStreamSpliceFlags = c_uint;
pub const G_IO_STREAM_SPLICE_NONE: c_int = 0;
pub const G_IO_STREAM_SPLICE_CLOSE_STREAM1: c_int = 1;
pub const G_IO_STREAM_SPLICE_CLOSE_STREAM2: c_int = 2;
pub const G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: c_int = 4;
pub const GIOStreamSpliceFlags = c_uint;
pub const G_EMBLEM_ORIGIN_UNKNOWN: c_int = 0;
pub const G_EMBLEM_ORIGIN_DEVICE: c_int = 1;
pub const G_EMBLEM_ORIGIN_LIVEMETADATA: c_int = 2;
pub const G_EMBLEM_ORIGIN_TAG: c_int = 3;
pub const GEmblemOrigin = c_uint;
pub const G_RESOLVER_ERROR_NOT_FOUND: c_int = 0;
pub const G_RESOLVER_ERROR_TEMPORARY_FAILURE: c_int = 1;
pub const G_RESOLVER_ERROR_INTERNAL: c_int = 2;
pub const GResolverError = c_uint;
pub const G_RESOLVER_RECORD_SRV: c_int = 1;
pub const G_RESOLVER_RECORD_MX: c_int = 2;
pub const G_RESOLVER_RECORD_TXT: c_int = 3;
pub const G_RESOLVER_RECORD_SOA: c_int = 4;
pub const G_RESOLVER_RECORD_NS: c_int = 5;
pub const GResolverRecordType = c_uint;
pub const G_RESOURCE_ERROR_NOT_FOUND: c_int = 0;
pub const G_RESOURCE_ERROR_INTERNAL: c_int = 1;
pub const GResourceError = c_uint;
pub const G_RESOURCE_FLAGS_NONE: c_int = 0;
pub const G_RESOURCE_FLAGS_COMPRESSED: c_int = 1;
pub const GResourceFlags = c_uint;
pub const G_RESOURCE_LOOKUP_FLAGS_NONE: c_int = 0;
pub const GResourceLookupFlags = c_uint;
pub const G_SOCKET_FAMILY_INVALID: c_int = 0;
pub const G_SOCKET_FAMILY_UNIX: c_int = 1;
pub const G_SOCKET_FAMILY_IPV4: c_int = 2;
pub const G_SOCKET_FAMILY_IPV6: c_int = 10;
pub const GSocketFamily = c_uint;
pub const G_SOCKET_TYPE_INVALID: c_int = 0;
pub const G_SOCKET_TYPE_STREAM: c_int = 1;
pub const G_SOCKET_TYPE_DATAGRAM: c_int = 2;
pub const G_SOCKET_TYPE_SEQPACKET: c_int = 3;
pub const GSocketType = c_uint;
pub const G_SOCKET_MSG_NONE: c_int = 0;
pub const G_SOCKET_MSG_OOB: c_int = 1;
pub const G_SOCKET_MSG_PEEK: c_int = 2;
pub const G_SOCKET_MSG_DONTROUTE: c_int = 4;
pub const GSocketMsgFlags = c_uint;
pub const G_SOCKET_PROTOCOL_UNKNOWN: c_int = -1;
pub const G_SOCKET_PROTOCOL_DEFAULT: c_int = 0;
pub const G_SOCKET_PROTOCOL_TCP: c_int = 6;
pub const G_SOCKET_PROTOCOL_UDP: c_int = 17;
pub const G_SOCKET_PROTOCOL_SCTP: c_int = 132;
pub const GSocketProtocol = c_int;
pub const G_ZLIB_COMPRESSOR_FORMAT_ZLIB: c_int = 0;
pub const G_ZLIB_COMPRESSOR_FORMAT_GZIP: c_int = 1;
pub const G_ZLIB_COMPRESSOR_FORMAT_RAW: c_int = 2;
pub const GZlibCompressorFormat = c_uint;
pub const G_UNIX_SOCKET_ADDRESS_INVALID: c_int = 0;
pub const G_UNIX_SOCKET_ADDRESS_ANONYMOUS: c_int = 1;
pub const G_UNIX_SOCKET_ADDRESS_PATH: c_int = 2;
pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT: c_int = 3;
pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: c_int = 4;
pub const GUnixSocketAddressType = c_uint;
pub const G_BUS_TYPE_STARTER: c_int = -1;
pub const G_BUS_TYPE_NONE: c_int = 0;
pub const G_BUS_TYPE_SYSTEM: c_int = 1;
pub const G_BUS_TYPE_SESSION: c_int = 2;
pub const GBusType = c_int;
pub const G_BUS_NAME_OWNER_FLAGS_NONE: c_int = 0;
pub const G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: c_int = 1;
pub const G_BUS_NAME_OWNER_FLAGS_REPLACE: c_int = 2;
pub const G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: c_int = 4;
pub const GBusNameOwnerFlags = c_uint;
pub const G_BUS_NAME_WATCHER_FLAGS_NONE: c_int = 0;
pub const G_BUS_NAME_WATCHER_FLAGS_AUTO_START: c_int = 1;
pub const GBusNameWatcherFlags = c_uint;
pub const G_DBUS_PROXY_FLAGS_NONE: c_int = 0;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: c_int = 1;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: c_int = 2;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: c_int = 4;
pub const G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: c_int = 8;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: c_int = 16;
pub const G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: c_int = 32;
pub const GDBusProxyFlags = c_uint;
pub const G_DBUS_ERROR_FAILED: c_int = 0;
pub const G_DBUS_ERROR_NO_MEMORY: c_int = 1;
pub const G_DBUS_ERROR_SERVICE_UNKNOWN: c_int = 2;
pub const G_DBUS_ERROR_NAME_HAS_NO_OWNER: c_int = 3;
pub const G_DBUS_ERROR_NO_REPLY: c_int = 4;
pub const G_DBUS_ERROR_IO_ERROR: c_int = 5;
pub const G_DBUS_ERROR_BAD_ADDRESS: c_int = 6;
pub const G_DBUS_ERROR_NOT_SUPPORTED: c_int = 7;
pub const G_DBUS_ERROR_LIMITS_EXCEEDED: c_int = 8;
pub const G_DBUS_ERROR_ACCESS_DENIED: c_int = 9;
pub const G_DBUS_ERROR_AUTH_FAILED: c_int = 10;
pub const G_DBUS_ERROR_NO_SERVER: c_int = 11;
pub const G_DBUS_ERROR_TIMEOUT: c_int = 12;
pub const G_DBUS_ERROR_NO_NETWORK: c_int = 13;
pub const G_DBUS_ERROR_ADDRESS_IN_USE: c_int = 14;
pub const G_DBUS_ERROR_DISCONNECTED: c_int = 15;
pub const G_DBUS_ERROR_INVALID_ARGS: c_int = 16;
pub const G_DBUS_ERROR_FILE_NOT_FOUND: c_int = 17;
pub const G_DBUS_ERROR_FILE_EXISTS: c_int = 18;
pub const G_DBUS_ERROR_UNKNOWN_METHOD: c_int = 19;
pub const G_DBUS_ERROR_TIMED_OUT: c_int = 20;
pub const G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: c_int = 21;
pub const G_DBUS_ERROR_MATCH_RULE_INVALID: c_int = 22;
pub const G_DBUS_ERROR_SPAWN_EXEC_FAILED: c_int = 23;
pub const G_DBUS_ERROR_SPAWN_FORK_FAILED: c_int = 24;
pub const G_DBUS_ERROR_SPAWN_CHILD_EXITED: c_int = 25;
pub const G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: c_int = 26;
pub const G_DBUS_ERROR_SPAWN_FAILED: c_int = 27;
pub const G_DBUS_ERROR_SPAWN_SETUP_FAILED: c_int = 28;
pub const G_DBUS_ERROR_SPAWN_CONFIG_INVALID: c_int = 29;
pub const G_DBUS_ERROR_SPAWN_SERVICE_INVALID: c_int = 30;
pub const G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: c_int = 31;
pub const G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: c_int = 32;
pub const G_DBUS_ERROR_SPAWN_FILE_INVALID: c_int = 33;
pub const G_DBUS_ERROR_SPAWN_NO_MEMORY: c_int = 34;
pub const G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: c_int = 35;
pub const G_DBUS_ERROR_INVALID_SIGNATURE: c_int = 36;
pub const G_DBUS_ERROR_INVALID_FILE_CONTENT: c_int = 37;
pub const G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: c_int = 38;
pub const G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: c_int = 39;
pub const G_DBUS_ERROR_OBJECT_PATH_IN_USE: c_int = 40;
pub const G_DBUS_ERROR_UNKNOWN_OBJECT: c_int = 41;
pub const G_DBUS_ERROR_UNKNOWN_INTERFACE: c_int = 42;
pub const G_DBUS_ERROR_UNKNOWN_PROPERTY: c_int = 43;
pub const G_DBUS_ERROR_PROPERTY_READ_ONLY: c_int = 44;
pub const GDBusError = c_uint;
pub const G_DBUS_CONNECTION_FLAGS_NONE: c_int = 0;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: c_int = 1;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: c_int = 2;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: c_int = 4;
pub const G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: c_int = 8;
pub const G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: c_int = 16;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: c_int = 32;
pub const G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: c_int = 64;
pub const GDBusConnectionFlags = c_uint;
pub const G_DBUS_CAPABILITY_FLAGS_NONE: c_int = 0;
pub const G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: c_int = 1;
pub const GDBusCapabilityFlags = c_uint;
pub const G_DBUS_CALL_FLAGS_NONE: c_int = 0;
pub const G_DBUS_CALL_FLAGS_NO_AUTO_START: c_int = 1;
pub const G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: c_int = 2;
pub const GDBusCallFlags = c_uint;
pub const G_DBUS_MESSAGE_TYPE_INVALID: c_int = 0;
pub const G_DBUS_MESSAGE_TYPE_METHOD_CALL: c_int = 1;
pub const G_DBUS_MESSAGE_TYPE_METHOD_RETURN: c_int = 2;
pub const G_DBUS_MESSAGE_TYPE_ERROR: c_int = 3;
pub const G_DBUS_MESSAGE_TYPE_SIGNAL: c_int = 4;
pub const GDBusMessageType = c_uint;
pub const G_DBUS_MESSAGE_FLAGS_NONE: c_int = 0;
pub const G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: c_int = 1;
pub const G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: c_int = 2;
pub const G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: c_int = 4;
pub const GDBusMessageFlags = c_uint;
pub const G_DBUS_MESSAGE_HEADER_FIELD_INVALID: c_int = 0;
pub const G_DBUS_MESSAGE_HEADER_FIELD_PATH: c_int = 1;
pub const G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: c_int = 2;
pub const G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: c_int = 3;
pub const G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: c_int = 4;
pub const G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: c_int = 5;
pub const G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: c_int = 6;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SENDER: c_int = 7;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: c_int = 8;
pub const G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: c_int = 9;
pub const GDBusMessageHeaderField = c_uint;
pub const G_DBUS_PROPERTY_INFO_FLAGS_NONE: c_int = 0;
pub const G_DBUS_PROPERTY_INFO_FLAGS_READABLE: c_int = 1;
pub const G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: c_int = 2;
pub const GDBusPropertyInfoFlags = c_uint;
pub const G_DBUS_SUBTREE_FLAGS_NONE: c_int = 0;
pub const G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: c_int = 1;
pub const GDBusSubtreeFlags = c_uint;
pub const G_DBUS_SERVER_FLAGS_NONE: c_int = 0;
pub const G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: c_int = 1;
pub const G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: c_int = 2;
pub const G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: c_int = 4;
pub const GDBusServerFlags = c_uint;
pub const G_DBUS_SIGNAL_FLAGS_NONE: c_int = 0;
pub const G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: c_int = 1;
pub const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: c_int = 2;
pub const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: c_int = 4;
pub const GDBusSignalFlags = c_uint;
pub const G_DBUS_SEND_MESSAGE_FLAGS_NONE: c_int = 0;
pub const G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: c_int = 1;
pub const GDBusSendMessageFlags = c_uint;
pub const G_CREDENTIALS_TYPE_INVALID: c_int = 0;
pub const G_CREDENTIALS_TYPE_LINUX_UCRED: c_int = 1;
pub const G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: c_int = 2;
pub const G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: c_int = 3;
pub const G_CREDENTIALS_TYPE_SOLARIS_UCRED: c_int = 4;
pub const G_CREDENTIALS_TYPE_NETBSD_UNPCBID: c_int = 5;
pub const G_CREDENTIALS_TYPE_APPLE_XUCRED: c_int = 6;
pub const G_CREDENTIALS_TYPE_WIN32_PID: c_int = 7;
pub const GCredentialsType = c_uint;
pub const G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: c_int = 66;
pub const G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: c_int = 108;
pub const GDBusMessageByteOrder = c_uint;
pub const G_APPLICATION_FLAGS_NONE: c_int = 0;
pub const G_APPLICATION_DEFAULT_FLAGS: c_int = 0;
pub const G_APPLICATION_IS_SERVICE: c_int = 1;
pub const G_APPLICATION_IS_LAUNCHER: c_int = 2;
pub const G_APPLICATION_HANDLES_OPEN: c_int = 4;
pub const G_APPLICATION_HANDLES_COMMAND_LINE: c_int = 8;
pub const G_APPLICATION_SEND_ENVIRONMENT: c_int = 16;
pub const G_APPLICATION_NON_UNIQUE: c_int = 32;
pub const G_APPLICATION_CAN_OVERRIDE_APP_ID: c_int = 64;
pub const G_APPLICATION_ALLOW_REPLACEMENT: c_int = 128;
pub const G_APPLICATION_REPLACE: c_int = 256;
pub const GApplicationFlags = c_uint;
pub const G_TLS_ERROR_UNAVAILABLE: c_int = 0;
pub const G_TLS_ERROR_MISC: c_int = 1;
pub const G_TLS_ERROR_BAD_CERTIFICATE: c_int = 2;
pub const G_TLS_ERROR_NOT_TLS: c_int = 3;
pub const G_TLS_ERROR_HANDSHAKE: c_int = 4;
pub const G_TLS_ERROR_CERTIFICATE_REQUIRED: c_int = 5;
pub const G_TLS_ERROR_EOF: c_int = 6;
pub const G_TLS_ERROR_INAPPROPRIATE_FALLBACK: c_int = 7;
pub const G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: c_int = 8;
pub const GTlsError = c_uint;
pub const G_TLS_CERTIFICATE_NO_FLAGS: c_int = 0;
pub const G_TLS_CERTIFICATE_UNKNOWN_CA: c_int = 1;
pub const G_TLS_CERTIFICATE_BAD_IDENTITY: c_int = 2;
pub const G_TLS_CERTIFICATE_NOT_ACTIVATED: c_int = 4;
pub const G_TLS_CERTIFICATE_EXPIRED: c_int = 8;
pub const G_TLS_CERTIFICATE_REVOKED: c_int = 16;
pub const G_TLS_CERTIFICATE_INSECURE: c_int = 32;
pub const G_TLS_CERTIFICATE_GENERIC_ERROR: c_int = 64;
pub const G_TLS_CERTIFICATE_VALIDATE_ALL: c_int = 127;
pub const GTlsCertificateFlags = c_uint;
pub const G_TLS_AUTHENTICATION_NONE: c_int = 0;
pub const G_TLS_AUTHENTICATION_REQUESTED: c_int = 1;
pub const G_TLS_AUTHENTICATION_REQUIRED: c_int = 2;
pub const GTlsAuthenticationMode = c_uint;
pub const G_TLS_CHANNEL_BINDING_TLS_UNIQUE: c_int = 0;
pub const G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT: c_int = 1;
pub const G_TLS_CHANNEL_BINDING_TLS_EXPORTER: c_int = 2;
pub const GTlsChannelBindingType = c_uint;
pub const G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED: c_int = 0;
pub const G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE: c_int = 1;
pub const G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE: c_int = 2;
pub const G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED: c_int = 3;
pub const G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR: c_int = 4;
pub const GTlsChannelBindingError = c_uint;
pub const G_TLS_REHANDSHAKE_NEVER: c_int = 0;
pub const G_TLS_REHANDSHAKE_SAFELY: c_int = 1;
pub const G_TLS_REHANDSHAKE_UNSAFELY: c_int = 2;
pub const GTlsRehandshakeMode = c_uint;
pub const G_TLS_PASSWORD_NONE: c_int = 0;
pub const G_TLS_PASSWORD_RETRY: c_int = 2;
pub const G_TLS_PASSWORD_MANY_TRIES: c_int = 4;
pub const G_TLS_PASSWORD_FINAL_TRY: c_int = 8;
pub const G_TLS_PASSWORD_PKCS11_USER: c_int = 16;
pub const G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: c_int = 32;
pub const G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: c_int = 64;
pub const enum__GTlsPasswordFlags = c_uint;
pub const GTlsPasswordFlags = enum__GTlsPasswordFlags;
pub const G_TLS_INTERACTION_UNHANDLED: c_int = 0;
pub const G_TLS_INTERACTION_HANDLED: c_int = 1;
pub const G_TLS_INTERACTION_FAILED: c_int = 2;
pub const GTlsInteractionResult = c_uint;
pub const G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: c_int = 0;
pub const G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: c_int = 1;
pub const GDBusInterfaceSkeletonFlags = c_uint;
pub const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: c_int = 0;
pub const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: c_int = 1;
pub const GDBusObjectManagerClientFlags = c_uint;
pub const G_TLS_DATABASE_VERIFY_NONE: c_int = 0;
pub const GTlsDatabaseVerifyFlags = c_uint;
pub const G_TLS_DATABASE_LOOKUP_NONE: c_int = 0;
pub const G_TLS_DATABASE_LOOKUP_KEYPAIR: c_int = 1;
pub const GTlsDatabaseLookupFlags = c_uint;
pub const G_TLS_CERTIFICATE_REQUEST_NONE: c_int = 0;
pub const GTlsCertificateRequestFlags = c_uint;
pub const G_TLS_PROTOCOL_VERSION_UNKNOWN: c_int = 0;
pub const G_TLS_PROTOCOL_VERSION_SSL_3_0: c_int = 1;
pub const G_TLS_PROTOCOL_VERSION_TLS_1_0: c_int = 2;
pub const G_TLS_PROTOCOL_VERSION_TLS_1_1: c_int = 3;
pub const G_TLS_PROTOCOL_VERSION_TLS_1_2: c_int = 4;
pub const G_TLS_PROTOCOL_VERSION_TLS_1_3: c_int = 5;
pub const G_TLS_PROTOCOL_VERSION_DTLS_1_0: c_int = 201;
pub const G_TLS_PROTOCOL_VERSION_DTLS_1_2: c_int = 202;
pub const GTlsProtocolVersion = c_uint;
pub const G_IO_MODULE_SCOPE_NONE: c_int = 0;
pub const G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: c_int = 1;
pub const GIOModuleScopeFlags = c_uint;
pub const G_SOCKET_CLIENT_RESOLVING: c_int = 0;
pub const G_SOCKET_CLIENT_RESOLVED: c_int = 1;
pub const G_SOCKET_CLIENT_CONNECTING: c_int = 2;
pub const G_SOCKET_CLIENT_CONNECTED: c_int = 3;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATING: c_int = 4;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATED: c_int = 5;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKING: c_int = 6;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKED: c_int = 7;
pub const G_SOCKET_CLIENT_COMPLETE: c_int = 8;
pub const GSocketClientEvent = c_uint;
pub const G_SOCKET_LISTENER_BINDING: c_int = 0;
pub const G_SOCKET_LISTENER_BOUND: c_int = 1;
pub const G_SOCKET_LISTENER_LISTENING: c_int = 2;
pub const G_SOCKET_LISTENER_LISTENED: c_int = 3;
pub const GSocketListenerEvent = c_uint;
pub const G_TEST_DBUS_NONE: c_int = 0;
pub const GTestDBusFlags = c_uint;
pub const G_SUBPROCESS_FLAGS_NONE: c_int = 0;
pub const G_SUBPROCESS_FLAGS_STDIN_PIPE: c_int = 1;
pub const G_SUBPROCESS_FLAGS_STDIN_INHERIT: c_int = 2;
pub const G_SUBPROCESS_FLAGS_STDOUT_PIPE: c_int = 4;
pub const G_SUBPROCESS_FLAGS_STDOUT_SILENCE: c_int = 8;
pub const G_SUBPROCESS_FLAGS_STDERR_PIPE: c_int = 16;
pub const G_SUBPROCESS_FLAGS_STDERR_SILENCE: c_int = 32;
pub const G_SUBPROCESS_FLAGS_STDERR_MERGE: c_int = 64;
pub const G_SUBPROCESS_FLAGS_INHERIT_FDS: c_int = 128;
pub const G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: c_int = 256;
pub const GSubprocessFlags = c_uint;
pub const G_NOTIFICATION_PRIORITY_NORMAL: c_int = 0;
pub const G_NOTIFICATION_PRIORITY_LOW: c_int = 1;
pub const G_NOTIFICATION_PRIORITY_HIGH: c_int = 2;
pub const G_NOTIFICATION_PRIORITY_URGENT: c_int = 3;
pub const GNotificationPriority = c_uint;
pub const G_NETWORK_CONNECTIVITY_LOCAL: c_int = 1;
pub const G_NETWORK_CONNECTIVITY_LIMITED: c_int = 2;
pub const G_NETWORK_CONNECTIVITY_PORTAL: c_int = 3;
pub const G_NETWORK_CONNECTIVITY_FULL: c_int = 4;
pub const GNetworkConnectivity = c_uint;
pub const G_POLLABLE_RETURN_FAILED: c_int = 0;
pub const G_POLLABLE_RETURN_OK: c_int = 1;
pub const G_POLLABLE_RETURN_WOULD_BLOCK: c_int = -27;
pub const GPollableReturn = c_int;
pub const G_MEMORY_MONITOR_WARNING_LEVEL_LOW: c_int = 50;
pub const G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM: c_int = 100;
pub const G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL: c_int = 255;
pub const GMemoryMonitorWarningLevel = c_uint;
pub const struct__GAppLaunchContextPrivate = opaque {};
pub const GAppLaunchContextPrivate = struct__GAppLaunchContextPrivate;
pub const struct__GAppLaunchContext = extern struct {
    parent_instance: GObject,
    priv: ?*GAppLaunchContextPrivate,
};
pub const GAppLaunchContext = struct__GAppLaunchContext;
pub const struct__GAppInfo = opaque {};
pub const GAppInfo = struct__GAppInfo;
pub const struct__GAsyncResult = opaque {};
pub const GAsyncResult = struct__GAsyncResult;
pub const struct__GAsyncInitable = opaque {};
pub const GAsyncInitable = struct__GAsyncInitable;
pub const struct__GInputStreamPrivate = opaque {};
pub const GInputStreamPrivate = struct__GInputStreamPrivate;
pub const struct__GInputStream = extern struct {
    parent_instance: GObject,
    priv: ?*GInputStreamPrivate,
};
pub const GInputStream = struct__GInputStream;
pub const struct__GFilterInputStream = extern struct {
    parent_instance: GInputStream,
    base_stream: [*c]GInputStream,
};
pub const GFilterInputStream = struct__GFilterInputStream;
pub const struct__GBufferedInputStreamPrivate = opaque {};
pub const GBufferedInputStreamPrivate = struct__GBufferedInputStreamPrivate;
pub const struct__GBufferedInputStream = extern struct {
    parent_instance: GFilterInputStream,
    priv: ?*GBufferedInputStreamPrivate,
};
pub const GBufferedInputStream = struct__GBufferedInputStream;
pub const struct__GOutputStreamPrivate = opaque {};
pub const GOutputStreamPrivate = struct__GOutputStreamPrivate;
pub const struct__GOutputStream = extern struct {
    parent_instance: GObject,
    priv: ?*GOutputStreamPrivate,
};
pub const GOutputStream = struct__GOutputStream;
pub const struct__GFilterOutputStream = extern struct {
    parent_instance: GOutputStream,
    base_stream: [*c]GOutputStream,
};
pub const GFilterOutputStream = struct__GFilterOutputStream;
pub const struct__GBufferedOutputStreamPrivate = opaque {};
pub const GBufferedOutputStreamPrivate = struct__GBufferedOutputStreamPrivate;
pub const struct__GBufferedOutputStream = extern struct {
    parent_instance: GFilterOutputStream,
    priv: ?*GBufferedOutputStreamPrivate,
};
pub const GBufferedOutputStream = struct__GBufferedOutputStream;
pub const struct__GCancellablePrivate = opaque {};
pub const GCancellablePrivate = struct__GCancellablePrivate;
pub const struct__GCancellable = extern struct {
    parent_instance: GObject,
    priv: ?*GCancellablePrivate,
};
pub const GCancellable = struct__GCancellable;
pub const struct__GCharsetConverter = opaque {};
pub const GCharsetConverter = struct__GCharsetConverter;
pub const struct__GConverter = opaque {};
pub const GConverter = struct__GConverter;
pub const struct__GConverterInputStreamPrivate = opaque {};
pub const GConverterInputStreamPrivate = struct__GConverterInputStreamPrivate;
pub const struct__GConverterInputStream = extern struct {
    parent_instance: GFilterInputStream,
    priv: ?*GConverterInputStreamPrivate,
};
pub const GConverterInputStream = struct__GConverterInputStream;
pub const struct__GConverterOutputStreamPrivate = opaque {};
pub const GConverterOutputStreamPrivate = struct__GConverterOutputStreamPrivate;
pub const struct__GConverterOutputStream = extern struct {
    parent_instance: GFilterOutputStream,
    priv: ?*GConverterOutputStreamPrivate,
};
pub const GConverterOutputStream = struct__GConverterOutputStream;
pub const struct__GDatagramBased = opaque {};
pub const GDatagramBased = struct__GDatagramBased;
pub const struct__GDataInputStreamPrivate = opaque {};
pub const GDataInputStreamPrivate = struct__GDataInputStreamPrivate;
pub const struct__GDataInputStream = extern struct {
    parent_instance: GBufferedInputStream,
    priv: ?*GDataInputStreamPrivate,
};
pub const GDataInputStream = struct__GDataInputStream;
pub const struct__GSimplePermission = opaque {};
pub const GSimplePermission = struct__GSimplePermission;
pub const struct__GZlibCompressor = opaque {};
pub const GZlibCompressor = struct__GZlibCompressor;
pub const struct__GZlibDecompressor = opaque {};
pub const GZlibDecompressor = struct__GZlibDecompressor;
pub const struct__GSimpleActionGroupPrivate = opaque {};
pub const GSimpleActionGroupPrivate = struct__GSimpleActionGroupPrivate;
pub const struct__GSimpleActionGroup = extern struct {
    parent_instance: GObject,
    priv: ?*GSimpleActionGroupPrivate,
};
pub const GSimpleActionGroup = struct__GSimpleActionGroup;
pub const struct__GRemoteActionGroup = opaque {};
pub const GRemoteActionGroup = struct__GRemoteActionGroup;
pub const struct__GDBusActionGroup = opaque {};
pub const GDBusActionGroup = struct__GDBusActionGroup;
pub const struct__GActionMap = opaque {};
pub const GActionMap = struct__GActionMap;
pub const struct__GActionGroup = opaque {};
pub const GActionGroup = struct__GActionGroup;
pub const struct__GPropertyAction = opaque {};
pub const GPropertyAction = struct__GPropertyAction;
pub const struct__GSimpleAction = opaque {};
pub const GSimpleAction = struct__GSimpleAction;
pub const struct__GAction = opaque {};
pub const GAction = struct__GAction;
pub const struct__GApplicationPrivate = opaque {};
pub const GApplicationPrivate = struct__GApplicationPrivate;
pub const struct__GApplication = extern struct {
    parent_instance: GObject,
    priv: ?*GApplicationPrivate,
};
pub const GApplication = struct__GApplication;
pub const struct__GApplicationCommandLinePrivate = opaque {};
pub const GApplicationCommandLinePrivate = struct__GApplicationCommandLinePrivate;
pub const struct__GApplicationCommandLine = extern struct {
    parent_instance: GObject,
    priv: ?*GApplicationCommandLinePrivate,
};
pub const GApplicationCommandLine = struct__GApplicationCommandLine;
pub const struct__GSettingsBackend = opaque {};
pub const GSettingsBackend = struct__GSettingsBackend;
pub const struct__GSettingsPrivate = opaque {};
pub const GSettingsPrivate = struct__GSettingsPrivate;
pub const struct__GSettings = extern struct {
    parent_instance: GObject,
    priv: ?*GSettingsPrivate,
};
pub const GSettings = struct__GSettings;
pub const struct__GPermissionPrivate = opaque {};
pub const GPermissionPrivate = struct__GPermissionPrivate;
pub const struct__GPermission = extern struct {
    parent_instance: GObject,
    priv: ?*GPermissionPrivate,
};
pub const GPermission = struct__GPermission;
pub const struct__GMenuModelPrivate = opaque {};
pub const GMenuModelPrivate = struct__GMenuModelPrivate;
pub const struct__GMenuModel = extern struct {
    parent_instance: GObject,
    priv: ?*GMenuModelPrivate,
};
pub const GMenuModel = struct__GMenuModel;
pub const struct__GNotification = opaque {};
pub const GNotification = struct__GNotification;
pub const struct__GDrive = opaque {};
pub const GDrive = struct__GDrive;
pub const struct__GFileEnumeratorPrivate = opaque {};
pub const GFileEnumeratorPrivate = struct__GFileEnumeratorPrivate;
pub const struct__GFileEnumerator = extern struct {
    parent_instance: GObject,
    priv: ?*GFileEnumeratorPrivate,
};
pub const GFileEnumerator = struct__GFileEnumerator;
pub const struct__GFileMonitorPrivate = opaque {};
pub const GFileMonitorPrivate = struct__GFileMonitorPrivate;
pub const struct__GFileMonitor = extern struct {
    parent_instance: GObject,
    priv: ?*GFileMonitorPrivate,
};
pub const GFileMonitor = struct__GFileMonitor;
pub const struct__GFile = opaque {};
pub const GFile = struct__GFile;
pub const struct__GFileInfo = opaque {};
pub const GFileInfo = struct__GFileInfo;
pub const struct__GFileAttributeMatcher = opaque {};
pub const GFileAttributeMatcher = struct__GFileAttributeMatcher;
pub const struct__GFileAttributeInfo = extern struct {
    name: [*c]u8,
    type: GFileAttributeType,
    flags: GFileAttributeInfoFlags,
};
pub const GFileAttributeInfo = struct__GFileAttributeInfo;
pub const struct__GFileAttributeInfoList = extern struct {
    infos: [*c]GFileAttributeInfo,
    n_infos: c_int,
};
pub const GFileAttributeInfoList = struct__GFileAttributeInfoList;
pub const struct__GFileDescriptorBased = opaque {};
pub const GFileDescriptorBased = struct__GFileDescriptorBased;
pub const struct__GFileInputStreamPrivate = opaque {};
pub const GFileInputStreamPrivate = struct__GFileInputStreamPrivate;
pub const struct__GFileInputStream = extern struct {
    parent_instance: GInputStream,
    priv: ?*GFileInputStreamPrivate,
};
pub const GFileInputStream = struct__GFileInputStream;
pub const struct__GFileOutputStreamPrivate = opaque {};
pub const GFileOutputStreamPrivate = struct__GFileOutputStreamPrivate;
pub const struct__GFileOutputStream = extern struct {
    parent_instance: GOutputStream,
    priv: ?*GFileOutputStreamPrivate,
};
pub const GFileOutputStream = struct__GFileOutputStream;
pub const struct__GIOStreamPrivate = opaque {};
pub const GIOStreamPrivate = struct__GIOStreamPrivate;
pub const struct__GIOStream = extern struct {
    parent_instance: GObject,
    priv: ?*GIOStreamPrivate,
};
pub const GIOStream = struct__GIOStream;
pub const struct__GFileIOStreamPrivate = opaque {};
pub const GFileIOStreamPrivate = struct__GFileIOStreamPrivate;
pub const struct__GFileIOStream = extern struct {
    parent_instance: GIOStream,
    priv: ?*GFileIOStreamPrivate,
};
pub const GFileIOStream = struct__GFileIOStream;
pub const struct__GFileIcon = opaque {};
pub const GFileIcon = struct__GFileIcon;
pub const struct__GFilenameCompleter = opaque {};
pub const GFilenameCompleter = struct__GFilenameCompleter;
pub const struct__GIcon = opaque {};
pub const GIcon = struct__GIcon;
pub const struct__GInetAddressPrivate = opaque {};
pub const GInetAddressPrivate = struct__GInetAddressPrivate;
pub const struct__GInetAddress = extern struct {
    parent_instance: GObject,
    priv: ?*GInetAddressPrivate,
};
pub const GInetAddress = struct__GInetAddress;
pub const struct__GInetAddressMaskPrivate = opaque {};
pub const GInetAddressMaskPrivate = struct__GInetAddressMaskPrivate;
pub const struct__GInetAddressMask = extern struct {
    parent_instance: GObject,
    priv: ?*GInetAddressMaskPrivate,
};
pub const GInetAddressMask = struct__GInetAddressMask;
pub const struct__GSocketAddress = extern struct {
    parent_instance: GObject,
};
pub const GSocketAddress = struct__GSocketAddress;
pub const struct__GInetSocketAddressPrivate = opaque {};
pub const GInetSocketAddressPrivate = struct__GInetSocketAddressPrivate;
pub const struct__GInetSocketAddress = extern struct {
    parent_instance: GSocketAddress,
    priv: ?*GInetSocketAddressPrivate,
};
pub const GInetSocketAddress = struct__GInetSocketAddress;
pub const struct__GNativeSocketAddressPrivate = opaque {};
pub const GNativeSocketAddressPrivate = struct__GNativeSocketAddressPrivate;
pub const struct__GNativeSocketAddress = extern struct {
    parent_instance: GSocketAddress,
    priv: ?*GNativeSocketAddressPrivate,
};
pub const GNativeSocketAddress = struct__GNativeSocketAddress;
pub const struct__GInitable = opaque {};
pub const GInitable = struct__GInitable;
pub const struct__GIOModule = opaque {};
pub const GIOModule = struct__GIOModule;
pub const struct__GIOExtensionPoint = opaque {};
pub const GIOExtensionPoint = struct__GIOExtensionPoint;
pub const struct__GIOExtension = opaque {};
pub const GIOExtension = struct__GIOExtension;
pub const struct__GIOSchedulerJob = opaque {};
pub const GIOSchedulerJob = struct__GIOSchedulerJob;
pub const struct__GIOStreamAdapter = opaque {};
pub const GIOStreamAdapter = struct__GIOStreamAdapter;
pub const struct__GLoadableIcon = opaque {};
pub const GLoadableIcon = struct__GLoadableIcon;
pub const struct__GBytesIcon = opaque {};
pub const GBytesIcon = struct__GBytesIcon;
pub const struct__GMemoryInputStreamPrivate = opaque {};
pub const GMemoryInputStreamPrivate = struct__GMemoryInputStreamPrivate;
pub const struct__GMemoryInputStream = extern struct {
    parent_instance: GInputStream,
    priv: ?*GMemoryInputStreamPrivate,
};
pub const GMemoryInputStream = struct__GMemoryInputStream;
pub const struct__GMemoryOutputStreamPrivate = opaque {};
pub const GMemoryOutputStreamPrivate = struct__GMemoryOutputStreamPrivate;
pub const struct__GMemoryOutputStream = extern struct {
    parent_instance: GOutputStream,
    priv: ?*GMemoryOutputStreamPrivate,
};
pub const GMemoryOutputStream = struct__GMemoryOutputStream;
pub const struct__GMount = opaque {};
pub const GMount = struct__GMount;
pub const struct__GMountOperationPrivate = opaque {};
pub const GMountOperationPrivate = struct__GMountOperationPrivate;
pub const struct__GMountOperation = extern struct {
    parent_instance: GObject,
    priv: ?*GMountOperationPrivate,
};
pub const GMountOperation = struct__GMountOperation;
pub const struct__GNetworkAddressPrivate = opaque {};
pub const GNetworkAddressPrivate = struct__GNetworkAddressPrivate;
pub const struct__GNetworkAddress = extern struct {
    parent_instance: GObject,
    priv: ?*GNetworkAddressPrivate,
};
pub const GNetworkAddress = struct__GNetworkAddress;
pub const struct__GNetworkMonitor = opaque {};
pub const GNetworkMonitor = struct__GNetworkMonitor;
pub const struct__GNetworkServicePrivate = opaque {};
pub const GNetworkServicePrivate = struct__GNetworkServicePrivate;
pub const struct__GNetworkService = extern struct {
    parent_instance: GObject,
    priv: ?*GNetworkServicePrivate,
};
pub const GNetworkService = struct__GNetworkService;
pub const struct__GSimpleIOStream = opaque {};
pub const GSimpleIOStream = struct__GSimpleIOStream;
pub const struct__GPollableInputStream = opaque {};
pub const GPollableInputStream = struct__GPollableInputStream;
pub const struct__GPollableOutputStream = opaque {};
pub const GPollableOutputStream = struct__GPollableOutputStream;
pub const struct__GResolverPrivate = opaque {};
pub const GResolverPrivate = struct__GResolverPrivate;
pub const struct__GResolver = extern struct {
    parent_instance: GObject,
    priv: ?*GResolverPrivate,
};
pub const GResolver = struct__GResolver;
pub const struct__GResource = opaque {};
pub const GResource = struct__GResource;
pub const struct__GSeekable = opaque {};
pub const GSeekable = struct__GSeekable;
pub const struct__GSimpleAsyncResult = opaque {};
pub const GSimpleAsyncResult = struct__GSimpleAsyncResult;
pub const struct__GSocketPrivate = opaque {};
pub const GSocketPrivate = struct__GSocketPrivate;
pub const struct__GSocket = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketPrivate,
};
pub const GSocket = struct__GSocket;
pub const struct__GSocketControlMessagePrivate = opaque {};
pub const GSocketControlMessagePrivate = struct__GSocketControlMessagePrivate;
pub const struct__GSocketControlMessage = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketControlMessagePrivate,
};
pub const GSocketControlMessage = struct__GSocketControlMessage;
pub const struct__GSocketClientPrivate = opaque {};
pub const GSocketClientPrivate = struct__GSocketClientPrivate;
pub const struct__GSocketClient = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketClientPrivate,
};
pub const GSocketClient = struct__GSocketClient;
pub const struct__GSocketConnectionPrivate = opaque {};
pub const GSocketConnectionPrivate = struct__GSocketConnectionPrivate;
pub const struct__GSocketConnection = extern struct {
    parent_instance: GIOStream,
    priv: ?*GSocketConnectionPrivate,
};
pub const GSocketConnection = struct__GSocketConnection;
pub const struct__GSocketListenerPrivate = opaque {};
pub const GSocketListenerPrivate = struct__GSocketListenerPrivate;
pub const struct__GSocketListener = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketListenerPrivate,
};
pub const GSocketListener = struct__GSocketListener;
pub const struct__GSocketServicePrivate = opaque {};
pub const GSocketServicePrivate = struct__GSocketServicePrivate;
pub const struct__GSocketService = extern struct {
    parent_instance: GSocketListener,
    priv: ?*GSocketServicePrivate,
};
pub const GSocketService = struct__GSocketService;
pub const struct__GSocketAddressEnumerator = extern struct {
    parent_instance: GObject,
};
pub const GSocketAddressEnumerator = struct__GSocketAddressEnumerator;
pub const struct__GSocketConnectable = opaque {};
pub const GSocketConnectable = struct__GSocketConnectable;
pub const struct__GSrvTarget = opaque {};
pub const GSrvTarget = struct__GSrvTarget;
pub const struct__GTask = opaque {};
pub const GTask = struct__GTask;
pub const struct__GTcpConnectionPrivate = opaque {};
pub const GTcpConnectionPrivate = struct__GTcpConnectionPrivate;
pub const struct__GTcpConnection = extern struct {
    parent_instance: GSocketConnection,
    priv: ?*GTcpConnectionPrivate,
};
pub const GTcpConnection = struct__GTcpConnection;
pub const struct__GTcpWrapperConnectionPrivate = opaque {};
pub const GTcpWrapperConnectionPrivate = struct__GTcpWrapperConnectionPrivate;
pub const struct__GTcpWrapperConnection = extern struct {
    parent_instance: GTcpConnection,
    priv: ?*GTcpWrapperConnectionPrivate,
};
pub const GTcpWrapperConnection = struct__GTcpWrapperConnection;
pub const struct__GThreadedSocketServicePrivate = opaque {};
pub const GThreadedSocketServicePrivate = struct__GThreadedSocketServicePrivate;
pub const struct__GThreadedSocketService = extern struct {
    parent_instance: GSocketService,
    priv: ?*GThreadedSocketServicePrivate,
};
pub const GThreadedSocketService = struct__GThreadedSocketService;
pub const struct__GDtlsConnection = opaque {};
pub const GDtlsConnection = struct__GDtlsConnection;
pub const struct__GDtlsClientConnection = opaque {};
pub const GDtlsClientConnection = struct__GDtlsClientConnection;
pub const struct__GDtlsServerConnection = opaque {};
pub const GDtlsServerConnection = struct__GDtlsServerConnection;
pub const struct__GThemedIcon = opaque {};
pub const GThemedIcon = struct__GThemedIcon;
pub const struct__GTlsCertificatePrivate = opaque {};
pub const GTlsCertificatePrivate = struct__GTlsCertificatePrivate;
pub const struct__GTlsCertificate = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsCertificatePrivate,
};
pub const GTlsCertificate = struct__GTlsCertificate;
pub const struct__GTlsClientConnection = opaque {};
pub const GTlsClientConnection = struct__GTlsClientConnection;
pub const struct__GTlsConnectionPrivate = opaque {};
pub const GTlsConnectionPrivate = struct__GTlsConnectionPrivate;
pub const struct__GTlsConnection = extern struct {
    parent_instance: GIOStream,
    priv: ?*GTlsConnectionPrivate,
};
pub const GTlsConnection = struct__GTlsConnection;
pub const struct__GTlsDatabasePrivate = opaque {};
pub const GTlsDatabasePrivate = struct__GTlsDatabasePrivate;
pub const struct__GTlsDatabase = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsDatabasePrivate,
};
pub const GTlsDatabase = struct__GTlsDatabase;
pub const struct__GTlsFileDatabase = opaque {};
pub const GTlsFileDatabase = struct__GTlsFileDatabase;
pub const struct__GTlsInteractionPrivate = opaque {};
pub const GTlsInteractionPrivate = struct__GTlsInteractionPrivate;
pub const struct__GTlsInteraction = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsInteractionPrivate,
};
pub const GTlsInteraction = struct__GTlsInteraction;
pub const struct__GTlsPasswordPrivate = opaque {};
pub const GTlsPasswordPrivate = struct__GTlsPasswordPrivate;
pub const struct__GTlsPassword = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsPasswordPrivate,
};
pub const GTlsPassword = struct__GTlsPassword;
pub const struct__GTlsServerConnection = opaque {};
pub const GTlsServerConnection = struct__GTlsServerConnection;
pub const struct__GVfs = extern struct {
    parent_instance: GObject,
};
pub const GVfs = struct__GVfs;
pub const struct__GProxyResolver = opaque {};
pub const GProxyResolver = struct__GProxyResolver;
pub const struct__GProxy = opaque {};
pub const GProxy = struct__GProxy;
pub const struct__GProxyAddressPrivate = opaque {};
pub const GProxyAddressPrivate = struct__GProxyAddressPrivate;
pub const struct__GProxyAddress = extern struct {
    parent_instance: GInetSocketAddress,
    priv: ?*GProxyAddressPrivate,
};
pub const GProxyAddress = struct__GProxyAddress;
pub const struct__GProxyAddressEnumeratorPrivate = opaque {};
pub const GProxyAddressEnumeratorPrivate = struct__GProxyAddressEnumeratorPrivate;
pub const struct__GProxyAddressEnumerator = extern struct {
    parent_instance: GSocketAddressEnumerator,
    priv: ?*GProxyAddressEnumeratorPrivate,
};
pub const GProxyAddressEnumerator = struct__GProxyAddressEnumerator;
pub const struct__GVolume = opaque {};
pub const GVolume = struct__GVolume;
pub const struct__GVolumeMonitor = extern struct {
    parent_instance: GObject,
    priv: gpointer,
};
pub const GVolumeMonitor = struct__GVolumeMonitor;
pub const GAsyncReadyCallback = ?*const fn ([*c]GObject, ?*GAsyncResult, gpointer) callconv(.C) void;
pub const GFileProgressCallback = ?*const fn (goffset, goffset, gpointer) callconv(.C) void;
pub const GFileReadMoreCallback = ?*const fn ([*c]const u8, goffset, gpointer) callconv(.C) gboolean;
pub const GFileMeasureProgressCallback = ?*const fn (gboolean, guint64, guint64, guint64, gpointer) callconv(.C) void;
pub const GIOSchedulerJobFunc = ?*const fn (?*GIOSchedulerJob, [*c]GCancellable, gpointer) callconv(.C) gboolean;
pub const GSimpleAsyncThreadFunc = ?*const fn (?*GSimpleAsyncResult, [*c]GObject, [*c]GCancellable) callconv(.C) void;
pub const GSocketSourceFunc = ?*const fn ([*c]GSocket, GIOCondition, gpointer) callconv(.C) gboolean;
pub const GDatagramBasedSourceFunc = ?*const fn (?*GDatagramBased, GIOCondition, gpointer) callconv(.C) gboolean;
pub const struct__GInputVector = extern struct {
    buffer: gpointer,
    size: gsize,
};
pub const GInputVector = struct__GInputVector;
pub const struct__GInputMessage = extern struct {
    address: [*c][*c]GSocketAddress,
    vectors: [*c]GInputVector,
    num_vectors: guint,
    bytes_received: gsize,
    flags: gint,
    control_messages: [*c][*c][*c]GSocketControlMessage,
    num_control_messages: [*c]guint,
};
pub const GInputMessage = struct__GInputMessage;
pub const struct__GOutputVector = extern struct {
    buffer: gconstpointer,
    size: gsize,
};
pub const GOutputVector = struct__GOutputVector;
pub const struct__GOutputMessage = extern struct {
    address: [*c]GSocketAddress,
    vectors: [*c]GOutputVector,
    num_vectors: guint,
    bytes_sent: guint,
    control_messages: [*c][*c]GSocketControlMessage,
    num_control_messages: guint,
};
pub const GOutputMessage = struct__GOutputMessage;
pub const struct__GCredentials = opaque {};
pub const GCredentials = struct__GCredentials;
pub const struct__GUnixCredentialsMessagePrivate = opaque {};
pub const GUnixCredentialsMessagePrivate = struct__GUnixCredentialsMessagePrivate;
pub const struct__GUnixCredentialsMessage = extern struct {
    parent_instance: GSocketControlMessage,
    priv: ?*GUnixCredentialsMessagePrivate,
};
pub const GUnixCredentialsMessage = struct__GUnixCredentialsMessage;
pub const struct__GUnixFDListPrivate = opaque {};
pub const GUnixFDListPrivate = struct__GUnixFDListPrivate;
pub const struct__GUnixFDList = extern struct {
    parent_instance: GObject,
    priv: ?*GUnixFDListPrivate,
};
pub const GUnixFDList = struct__GUnixFDList;
pub const struct__GDBusMessage = opaque {};
pub const GDBusMessage = struct__GDBusMessage;
pub const struct__GDBusConnection = opaque {};
pub const GDBusConnection = struct__GDBusConnection;
pub const struct__GDBusProxyPrivate = opaque {};
pub const GDBusProxyPrivate = struct__GDBusProxyPrivate;
pub const struct__GDBusProxy = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusProxyPrivate,
};
pub const GDBusProxy = struct__GDBusProxy;
pub const struct__GDBusMethodInvocation = opaque {};
pub const GDBusMethodInvocation = struct__GDBusMethodInvocation;
pub const struct__GDBusServer = opaque {};
pub const GDBusServer = struct__GDBusServer;
pub const struct__GDBusAuthObserver = opaque {};
pub const GDBusAuthObserver = struct__GDBusAuthObserver;
pub const struct__GDBusErrorEntry = extern struct {
    error_code: gint,
    dbus_error_name: [*c]const gchar,
};
pub const GDBusErrorEntry = struct__GDBusErrorEntry;
pub const GDBusInterfaceMethodCallFunc = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, ?*GVariant, ?*GDBusMethodInvocation, gpointer) callconv(.C) void;
pub const GDBusInterfaceGetPropertyFunc = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c][*c]GError, gpointer) callconv(.C) ?*GVariant;
pub const GDBusInterfaceSetPropertyFunc = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, ?*GVariant, [*c][*c]GError, gpointer) callconv(.C) gboolean;
pub const struct__GDBusInterfaceVTable = extern struct {
    method_call: GDBusInterfaceMethodCallFunc,
    get_property: GDBusInterfaceGetPropertyFunc,
    set_property: GDBusInterfaceSetPropertyFunc,
    padding: [8]gpointer,
};
pub const GDBusInterfaceVTable = struct__GDBusInterfaceVTable;
pub const GDBusSubtreeEnumerateFunc = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, gpointer) callconv(.C) [*c][*c]gchar;
pub const struct__GDBusAnnotationInfo = extern struct {
    ref_count: gint,
    key: [*c]gchar,
    value: [*c]gchar,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GDBusAnnotationInfo = struct__GDBusAnnotationInfo;
pub const struct__GDBusArgInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    signature: [*c]gchar,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GDBusArgInfo = struct__GDBusArgInfo;
pub const struct__GDBusMethodInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    in_args: [*c][*c]GDBusArgInfo,
    out_args: [*c][*c]GDBusArgInfo,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GDBusMethodInfo = struct__GDBusMethodInfo;
pub const struct__GDBusSignalInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    args: [*c][*c]GDBusArgInfo,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GDBusSignalInfo = struct__GDBusSignalInfo;
pub const struct__GDBusPropertyInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    signature: [*c]gchar,
    flags: GDBusPropertyInfoFlags,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GDBusPropertyInfo = struct__GDBusPropertyInfo;
pub const struct__GDBusInterfaceInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    methods: [*c][*c]GDBusMethodInfo,
    signals: [*c][*c]GDBusSignalInfo,
    properties: [*c][*c]GDBusPropertyInfo,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GDBusInterfaceInfo = struct__GDBusInterfaceInfo;
pub const GDBusSubtreeIntrospectFunc = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, gpointer) callconv(.C) [*c][*c]GDBusInterfaceInfo;
pub const GDBusSubtreeDispatchFunc = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]gpointer, gpointer) callconv(.C) [*c]const GDBusInterfaceVTable;
pub const struct__GDBusSubtreeVTable = extern struct {
    enumerate: GDBusSubtreeEnumerateFunc,
    introspect: GDBusSubtreeIntrospectFunc,
    dispatch: GDBusSubtreeDispatchFunc,
    padding: [8]gpointer,
};
pub const GDBusSubtreeVTable = struct__GDBusSubtreeVTable;
pub const GDBusNodeInfo = struct__GDBusNodeInfo;
pub const struct__GDBusNodeInfo = extern struct {
    ref_count: gint,
    path: [*c]gchar,
    interfaces: [*c][*c]GDBusInterfaceInfo,
    nodes: [*c][*c]GDBusNodeInfo,
    annotations: [*c][*c]GDBusAnnotationInfo,
};
pub const GCancellableSourceFunc = ?*const fn ([*c]GCancellable, gpointer) callconv(.C) gboolean;
pub const GPollableSourceFunc = ?*const fn ([*c]GObject, gpointer) callconv(.C) gboolean;
pub const struct__GDBusInterface = opaque {};
pub const GDBusInterface = struct__GDBusInterface;
pub const struct__GDBusInterfaceSkeletonPrivate = opaque {};
pub const GDBusInterfaceSkeletonPrivate = struct__GDBusInterfaceSkeletonPrivate;
pub const struct__GDBusInterfaceSkeleton = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusInterfaceSkeletonPrivate,
};
pub const GDBusInterfaceSkeleton = struct__GDBusInterfaceSkeleton;
pub const struct__GDBusObject = opaque {};
pub const GDBusObject = struct__GDBusObject;
pub const struct__GDBusObjectSkeletonPrivate = opaque {};
pub const GDBusObjectSkeletonPrivate = struct__GDBusObjectSkeletonPrivate;
pub const struct__GDBusObjectSkeleton = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectSkeletonPrivate,
};
pub const GDBusObjectSkeleton = struct__GDBusObjectSkeleton;
pub const struct__GDBusObjectProxyPrivate = opaque {};
pub const GDBusObjectProxyPrivate = struct__GDBusObjectProxyPrivate;
pub const struct__GDBusObjectProxy = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectProxyPrivate,
};
pub const GDBusObjectProxy = struct__GDBusObjectProxy;
pub const struct__GDBusObjectManager = opaque {};
pub const GDBusObjectManager = struct__GDBusObjectManager;
pub const struct__GDBusObjectManagerClientPrivate = opaque {};
pub const GDBusObjectManagerClientPrivate = struct__GDBusObjectManagerClientPrivate;
pub const struct__GDBusObjectManagerClient = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectManagerClientPrivate,
};
pub const GDBusObjectManagerClient = struct__GDBusObjectManagerClient;
pub const struct__GDBusObjectManagerServerPrivate = opaque {};
pub const GDBusObjectManagerServerPrivate = struct__GDBusObjectManagerServerPrivate;
pub const struct__GDBusObjectManagerServer = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectManagerServerPrivate,
};
pub const GDBusObjectManagerServer = struct__GDBusObjectManagerServer;
pub const GDBusProxyTypeFunc = ?*const fn ([*c]GDBusObjectManagerClient, [*c]const gchar, [*c]const gchar, gpointer) callconv(.C) GType;
pub const struct__GTestDBus = opaque {};
pub const GTestDBus = struct__GTestDBus;
pub const struct__GSubprocess = opaque {};
pub const GSubprocess = struct__GSubprocess;
pub const struct__GSubprocessLauncher = opaque {};
pub const GSubprocessLauncher = struct__GSubprocessLauncher;
pub const struct__GActionInterface = extern struct {
    g_iface: GTypeInterface,
    get_name: ?*const fn (?*GAction) callconv(.C) [*c]const gchar,
    get_parameter_type: ?*const fn (?*GAction) callconv(.C) ?*const GVariantType,
    get_state_type: ?*const fn (?*GAction) callconv(.C) ?*const GVariantType,
    get_state_hint: ?*const fn (?*GAction) callconv(.C) ?*GVariant,
    get_enabled: ?*const fn (?*GAction) callconv(.C) gboolean,
    get_state: ?*const fn (?*GAction) callconv(.C) ?*GVariant,
    change_state: ?*const fn (?*GAction, ?*GVariant) callconv(.C) void,
    activate: ?*const fn (?*GAction, ?*GVariant) callconv(.C) void,
};
pub const GActionInterface = struct__GActionInterface;
pub extern fn g_action_get_type() GType;
pub extern fn g_action_get_name(action: ?*GAction) [*c]const gchar;
pub extern fn g_action_get_parameter_type(action: ?*GAction) ?*const GVariantType;
pub extern fn g_action_get_state_type(action: ?*GAction) ?*const GVariantType;
pub extern fn g_action_get_state_hint(action: ?*GAction) ?*GVariant;
pub extern fn g_action_get_enabled(action: ?*GAction) gboolean;
pub extern fn g_action_get_state(action: ?*GAction) ?*GVariant;
pub extern fn g_action_change_state(action: ?*GAction, value: ?*GVariant) void;
pub extern fn g_action_activate(action: ?*GAction, parameter: ?*GVariant) void;
pub extern fn g_action_name_is_valid(action_name: [*c]const gchar) gboolean;
pub extern fn g_action_parse_detailed_name(detailed_name: [*c]const gchar, action_name: [*c][*c]gchar, target_value: [*c]?*GVariant, @"error": [*c][*c]GError) gboolean;
pub extern fn g_action_print_detailed_name(action_name: [*c]const gchar, target_value: ?*GVariant) [*c]gchar;
pub const struct__GActionGroupInterface = extern struct {
    g_iface: GTypeInterface,
    has_action: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) gboolean,
    list_actions: ?*const fn (?*GActionGroup) callconv(.C) [*c][*c]gchar,
    get_action_enabled: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) gboolean,
    get_action_parameter_type: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) ?*const GVariantType,
    get_action_state_type: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) ?*const GVariantType,
    get_action_state_hint: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) ?*GVariant,
    get_action_state: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) ?*GVariant,
    change_action_state: ?*const fn (?*GActionGroup, [*c]const gchar, ?*GVariant) callconv(.C) void,
    activate_action: ?*const fn (?*GActionGroup, [*c]const gchar, ?*GVariant) callconv(.C) void,
    action_added: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) void,
    action_removed: ?*const fn (?*GActionGroup, [*c]const gchar) callconv(.C) void,
    action_enabled_changed: ?*const fn (?*GActionGroup, [*c]const gchar, gboolean) callconv(.C) void,
    action_state_changed: ?*const fn (?*GActionGroup, [*c]const gchar, ?*GVariant) callconv(.C) void,
    query_action: ?*const fn (?*GActionGroup, [*c]const gchar, [*c]gboolean, [*c]?*const GVariantType, [*c]?*const GVariantType, [*c]?*GVariant, [*c]?*GVariant) callconv(.C) gboolean,
};
pub const GActionGroupInterface = struct__GActionGroupInterface;
pub extern fn g_action_group_get_type() GType;
pub extern fn g_action_group_has_action(action_group: ?*GActionGroup, action_name: [*c]const gchar) gboolean;
pub extern fn g_action_group_list_actions(action_group: ?*GActionGroup) [*c][*c]gchar;
pub extern fn g_action_group_get_action_parameter_type(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*const GVariantType;
pub extern fn g_action_group_get_action_state_type(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*const GVariantType;
pub extern fn g_action_group_get_action_state_hint(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*GVariant;
pub extern fn g_action_group_get_action_enabled(action_group: ?*GActionGroup, action_name: [*c]const gchar) gboolean;
pub extern fn g_action_group_get_action_state(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*GVariant;
pub extern fn g_action_group_change_action_state(action_group: ?*GActionGroup, action_name: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_action_group_activate_action(action_group: ?*GActionGroup, action_name: [*c]const gchar, parameter: ?*GVariant) void;
pub extern fn g_action_group_action_added(action_group: ?*GActionGroup, action_name: [*c]const gchar) void;
pub extern fn g_action_group_action_removed(action_group: ?*GActionGroup, action_name: [*c]const gchar) void;
pub extern fn g_action_group_action_enabled_changed(action_group: ?*GActionGroup, action_name: [*c]const gchar, enabled: gboolean) void;
pub extern fn g_action_group_action_state_changed(action_group: ?*GActionGroup, action_name: [*c]const gchar, state: ?*GVariant) void;
pub extern fn g_action_group_query_action(action_group: ?*GActionGroup, action_name: [*c]const gchar, enabled: [*c]gboolean, parameter_type: [*c]?*const GVariantType, state_type: [*c]?*const GVariantType, state_hint: [*c]?*GVariant, state: [*c]?*GVariant) gboolean;
pub extern fn g_dbus_connection_export_action_group(connection: ?*GDBusConnection, object_path: [*c]const gchar, action_group: ?*GActionGroup, @"error": [*c][*c]GError) guint;
pub extern fn g_dbus_connection_unexport_action_group(connection: ?*GDBusConnection, export_id: guint) void;
pub const struct__GActionMapInterface = extern struct {
    g_iface: GTypeInterface,
    lookup_action: ?*const fn (?*GActionMap, [*c]const gchar) callconv(.C) ?*GAction,
    add_action: ?*const fn (?*GActionMap, ?*GAction) callconv(.C) void,
    remove_action: ?*const fn (?*GActionMap, [*c]const gchar) callconv(.C) void,
};
pub const GActionMapInterface = struct__GActionMapInterface;
pub const struct__GActionEntry = extern struct {
    name: [*c]const gchar,
    activate: ?*const fn (?*GSimpleAction, ?*GVariant, gpointer) callconv(.C) void,
    parameter_type: [*c]const gchar,
    state: [*c]const gchar,
    change_state: ?*const fn (?*GSimpleAction, ?*GVariant, gpointer) callconv(.C) void,
    padding: [3]gsize,
};
pub const GActionEntry = struct__GActionEntry;
pub extern fn g_action_map_get_type() GType;
pub extern fn g_action_map_lookup_action(action_map: ?*GActionMap, action_name: [*c]const gchar) ?*GAction;
pub extern fn g_action_map_add_action(action_map: ?*GActionMap, action: ?*GAction) void;
pub extern fn g_action_map_remove_action(action_map: ?*GActionMap, action_name: [*c]const gchar) void;
pub extern fn g_action_map_add_action_entries(action_map: ?*GActionMap, entries: [*c]const GActionEntry, n_entries: gint, user_data: gpointer) void;
pub extern fn g_action_map_remove_action_entries(action_map: ?*GActionMap, entries: [*c]const GActionEntry, n_entries: gint) void;
pub const struct__GAppLaunchContextClass = extern struct {
    parent_class: GObjectClass,
    get_display: ?*const fn ([*c]GAppLaunchContext, ?*GAppInfo, [*c]GList) callconv(.C) [*c]u8,
    get_startup_notify_id: ?*const fn ([*c]GAppLaunchContext, ?*GAppInfo, [*c]GList) callconv(.C) [*c]u8,
    launch_failed: ?*const fn ([*c]GAppLaunchContext, [*c]const u8) callconv(.C) void,
    launched: ?*const fn ([*c]GAppLaunchContext, ?*GAppInfo, ?*GVariant) callconv(.C) void,
    launch_started: ?*const fn ([*c]GAppLaunchContext, ?*GAppInfo, ?*GVariant) callconv(.C) void,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
};
pub const GAppLaunchContextClass = struct__GAppLaunchContextClass;
pub const struct__GAppInfoIface = extern struct {
    g_iface: GTypeInterface,
    dup: ?*const fn (?*GAppInfo) callconv(.C) ?*GAppInfo,
    equal: ?*const fn (?*GAppInfo, ?*GAppInfo) callconv(.C) gboolean,
    get_id: ?*const fn (?*GAppInfo) callconv(.C) [*c]const u8,
    get_name: ?*const fn (?*GAppInfo) callconv(.C) [*c]const u8,
    get_description: ?*const fn (?*GAppInfo) callconv(.C) [*c]const u8,
    get_executable: ?*const fn (?*GAppInfo) callconv(.C) [*c]const u8,
    get_icon: ?*const fn (?*GAppInfo) callconv(.C) ?*GIcon,
    launch: ?*const fn (?*GAppInfo, [*c]GList, [*c]GAppLaunchContext, [*c][*c]GError) callconv(.C) gboolean,
    supports_uris: ?*const fn (?*GAppInfo) callconv(.C) gboolean,
    supports_files: ?*const fn (?*GAppInfo) callconv(.C) gboolean,
    launch_uris: ?*const fn (?*GAppInfo, [*c]GList, [*c]GAppLaunchContext, [*c][*c]GError) callconv(.C) gboolean,
    should_show: ?*const fn (?*GAppInfo) callconv(.C) gboolean,
    set_as_default_for_type: ?*const fn (?*GAppInfo, [*c]const u8, [*c][*c]GError) callconv(.C) gboolean,
    set_as_default_for_extension: ?*const fn (?*GAppInfo, [*c]const u8, [*c][*c]GError) callconv(.C) gboolean,
    add_supports_type: ?*const fn (?*GAppInfo, [*c]const u8, [*c][*c]GError) callconv(.C) gboolean,
    can_remove_supports_type: ?*const fn (?*GAppInfo) callconv(.C) gboolean,
    remove_supports_type: ?*const fn (?*GAppInfo, [*c]const u8, [*c][*c]GError) callconv(.C) gboolean,
    can_delete: ?*const fn (?*GAppInfo) callconv(.C) gboolean,
    do_delete: ?*const fn (?*GAppInfo) callconv(.C) gboolean,
    get_commandline: ?*const fn (?*GAppInfo) callconv(.C) [*c]const u8,
    get_display_name: ?*const fn (?*GAppInfo) callconv(.C) [*c]const u8,
    set_as_last_used_for_type: ?*const fn (?*GAppInfo, [*c]const u8, [*c][*c]GError) callconv(.C) gboolean,
    get_supported_types: ?*const fn (?*GAppInfo) callconv(.C) [*c][*c]const u8,
    launch_uris_async: ?*const fn (?*GAppInfo, [*c]GList, [*c]GAppLaunchContext, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    launch_uris_finish: ?*const fn (?*GAppInfo, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GAppInfoIface = struct__GAppInfoIface;
pub extern fn g_app_info_get_type() GType;
pub extern fn g_app_info_create_from_commandline(commandline: [*c]const u8, application_name: [*c]const u8, flags: GAppInfoCreateFlags, @"error": [*c][*c]GError) ?*GAppInfo;
pub extern fn g_app_info_dup(appinfo: ?*GAppInfo) ?*GAppInfo;
pub extern fn g_app_info_equal(appinfo1: ?*GAppInfo, appinfo2: ?*GAppInfo) gboolean;
pub extern fn g_app_info_get_id(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_name(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_display_name(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_description(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_executable(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_commandline(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_icon(appinfo: ?*GAppInfo) ?*GIcon;
pub extern fn g_app_info_launch(appinfo: ?*GAppInfo, files: [*c]GList, context: [*c]GAppLaunchContext, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_supports_uris(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_supports_files(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_launch_uris(appinfo: ?*GAppInfo, uris: [*c]GList, context: [*c]GAppLaunchContext, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_launch_uris_async(appinfo: ?*GAppInfo, uris: [*c]GList, context: [*c]GAppLaunchContext, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_app_info_launch_uris_finish(appinfo: ?*GAppInfo, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_should_show(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_set_as_default_for_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_set_as_default_for_extension(appinfo: ?*GAppInfo, extension: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_add_supports_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_can_remove_supports_type(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_remove_supports_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_get_supported_types(appinfo: ?*GAppInfo) [*c][*c]const u8;
pub extern fn g_app_info_can_delete(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_delete(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_set_as_last_used_for_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_get_all() [*c]GList;
pub extern fn g_app_info_get_all_for_type(content_type: [*c]const u8) [*c]GList;
pub extern fn g_app_info_get_recommended_for_type(content_type: [*c]const gchar) [*c]GList;
pub extern fn g_app_info_get_fallback_for_type(content_type: [*c]const gchar) [*c]GList;
pub extern fn g_app_info_reset_type_associations(content_type: [*c]const u8) void;
pub extern fn g_app_info_get_default_for_type(content_type: [*c]const u8, must_support_uris: gboolean) ?*GAppInfo;
pub extern fn g_app_info_get_default_for_type_async(content_type: [*c]const u8, must_support_uris: gboolean, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_app_info_get_default_for_type_finish(result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GAppInfo;
pub extern fn g_app_info_get_default_for_uri_scheme(uri_scheme: [*c]const u8) ?*GAppInfo;
pub extern fn g_app_info_get_default_for_uri_scheme_async(uri_scheme: [*c]const u8, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_app_info_get_default_for_uri_scheme_finish(result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GAppInfo;
pub extern fn g_app_info_launch_default_for_uri(uri: [*c]const u8, context: [*c]GAppLaunchContext, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_info_launch_default_for_uri_async(uri: [*c]const u8, context: [*c]GAppLaunchContext, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_app_info_launch_default_for_uri_finish(result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_app_launch_context_get_type() GType;
pub extern fn g_app_launch_context_new() [*c]GAppLaunchContext;
pub extern fn g_app_launch_context_setenv(context: [*c]GAppLaunchContext, variable: [*c]const u8, value: [*c]const u8) void;
pub extern fn g_app_launch_context_unsetenv(context: [*c]GAppLaunchContext, variable: [*c]const u8) void;
pub extern fn g_app_launch_context_get_environment(context: [*c]GAppLaunchContext) [*c][*c]u8;
pub extern fn g_app_launch_context_get_display(context: [*c]GAppLaunchContext, info: ?*GAppInfo, files: [*c]GList) [*c]u8;
pub extern fn g_app_launch_context_get_startup_notify_id(context: [*c]GAppLaunchContext, info: ?*GAppInfo, files: [*c]GList) [*c]u8;
pub extern fn g_app_launch_context_launch_failed(context: [*c]GAppLaunchContext, startup_notify_id: [*c]const u8) void;
pub const struct__GAppInfoMonitor = opaque {};
pub const GAppInfoMonitor = struct__GAppInfoMonitor;
pub extern fn g_app_info_monitor_get_type() GType;
pub extern fn g_app_info_monitor_get() ?*GAppInfoMonitor;
pub const struct__GApplicationClass = extern struct {
    parent_class: GObjectClass,
    startup: ?*const fn ([*c]GApplication) callconv(.C) void,
    activate: ?*const fn ([*c]GApplication) callconv(.C) void,
    open: ?*const fn ([*c]GApplication, [*c]?*GFile, gint, [*c]const gchar) callconv(.C) void,
    command_line: ?*const fn ([*c]GApplication, [*c]GApplicationCommandLine) callconv(.C) c_int,
    local_command_line: ?*const fn ([*c]GApplication, [*c][*c][*c]gchar, [*c]c_int) callconv(.C) gboolean,
    before_emit: ?*const fn ([*c]GApplication, ?*GVariant) callconv(.C) void,
    after_emit: ?*const fn ([*c]GApplication, ?*GVariant) callconv(.C) void,
    add_platform_data: ?*const fn ([*c]GApplication, [*c]GVariantBuilder) callconv(.C) void,
    quit_mainloop: ?*const fn ([*c]GApplication) callconv(.C) void,
    run_mainloop: ?*const fn ([*c]GApplication) callconv(.C) void,
    shutdown: ?*const fn ([*c]GApplication) callconv(.C) void,
    dbus_register: ?*const fn ([*c]GApplication, ?*GDBusConnection, [*c]const gchar, [*c][*c]GError) callconv(.C) gboolean,
    dbus_unregister: ?*const fn ([*c]GApplication, ?*GDBusConnection, [*c]const gchar) callconv(.C) void,
    handle_local_options: ?*const fn ([*c]GApplication, [*c]GVariantDict) callconv(.C) gint,
    name_lost: ?*const fn ([*c]GApplication) callconv(.C) gboolean,
    padding: [7]gpointer,
};
pub const GApplicationClass = struct__GApplicationClass;
pub extern fn g_application_get_type() GType;
pub extern fn g_application_id_is_valid(application_id: [*c]const gchar) gboolean;
pub extern fn g_application_new(application_id: [*c]const gchar, flags: GApplicationFlags) [*c]GApplication;
pub extern fn g_application_get_application_id(application: [*c]GApplication) [*c]const gchar;
pub extern fn g_application_set_application_id(application: [*c]GApplication, application_id: [*c]const gchar) void;
pub extern fn g_application_get_dbus_connection(application: [*c]GApplication) ?*GDBusConnection;
pub extern fn g_application_get_dbus_object_path(application: [*c]GApplication) [*c]const gchar;
pub extern fn g_application_get_inactivity_timeout(application: [*c]GApplication) guint;
pub extern fn g_application_set_inactivity_timeout(application: [*c]GApplication, inactivity_timeout: guint) void;
pub extern fn g_application_get_flags(application: [*c]GApplication) GApplicationFlags;
pub extern fn g_application_set_flags(application: [*c]GApplication, flags: GApplicationFlags) void;
pub extern fn g_application_get_resource_base_path(application: [*c]GApplication) [*c]const gchar;
pub extern fn g_application_set_resource_base_path(application: [*c]GApplication, resource_path: [*c]const gchar) void;
pub extern fn g_application_set_action_group(application: [*c]GApplication, action_group: ?*GActionGroup) void;
pub extern fn g_application_add_main_option_entries(application: [*c]GApplication, entries: [*c]const GOptionEntry) void;
pub extern fn g_application_add_main_option(application: [*c]GApplication, long_name: [*c]const u8, short_name: u8, flags: GOptionFlags, arg: GOptionArg, description: [*c]const u8, arg_description: [*c]const u8) void;
pub extern fn g_application_add_option_group(application: [*c]GApplication, group: ?*GOptionGroup) void;
pub extern fn g_application_set_option_context_parameter_string(application: [*c]GApplication, parameter_string: [*c]const gchar) void;
pub extern fn g_application_set_option_context_summary(application: [*c]GApplication, summary: [*c]const gchar) void;
pub extern fn g_application_set_option_context_description(application: [*c]GApplication, description: [*c]const gchar) void;
pub extern fn g_application_get_is_registered(application: [*c]GApplication) gboolean;
pub extern fn g_application_get_is_remote(application: [*c]GApplication) gboolean;
pub extern fn g_application_register(application: [*c]GApplication, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_application_hold(application: [*c]GApplication) void;
pub extern fn g_application_release(application: [*c]GApplication) void;
pub extern fn g_application_activate(application: [*c]GApplication) void;
pub extern fn g_application_open(application: [*c]GApplication, files: [*c]?*GFile, n_files: gint, hint: [*c]const gchar) void;
pub extern fn g_application_run(application: [*c]GApplication, argc: c_int, argv: [*c][*c]u8) c_int;
pub extern fn g_application_quit(application: [*c]GApplication) void;
pub extern fn g_application_get_default() [*c]GApplication;
pub extern fn g_application_set_default(application: [*c]GApplication) void;
pub extern fn g_application_mark_busy(application: [*c]GApplication) void;
pub extern fn g_application_unmark_busy(application: [*c]GApplication) void;
pub extern fn g_application_get_is_busy(application: [*c]GApplication) gboolean;
pub extern fn g_application_send_notification(application: [*c]GApplication, id: [*c]const gchar, notification: ?*GNotification) void;
pub extern fn g_application_withdraw_notification(application: [*c]GApplication, id: [*c]const gchar) void;
pub extern fn g_application_bind_busy_property(application: [*c]GApplication, object: gpointer, property: [*c]const gchar) void;
pub extern fn g_application_unbind_busy_property(application: [*c]GApplication, object: gpointer, property: [*c]const gchar) void;
pub const struct__GApplicationCommandLineClass = extern struct {
    parent_class: GObjectClass,
    print_literal: ?*const fn ([*c]GApplicationCommandLine, [*c]const gchar) callconv(.C) void,
    printerr_literal: ?*const fn ([*c]GApplicationCommandLine, [*c]const gchar) callconv(.C) void,
    get_stdin: ?*const fn ([*c]GApplicationCommandLine) callconv(.C) [*c]GInputStream,
    padding: [11]gpointer,
};
pub const GApplicationCommandLineClass = struct__GApplicationCommandLineClass;
pub extern fn g_application_command_line_get_type() GType;
pub extern fn g_application_command_line_get_arguments(cmdline: [*c]GApplicationCommandLine, argc: [*c]c_int) [*c][*c]gchar;
pub extern fn g_application_command_line_get_options_dict(cmdline: [*c]GApplicationCommandLine) [*c]GVariantDict;
pub extern fn g_application_command_line_get_stdin(cmdline: [*c]GApplicationCommandLine) [*c]GInputStream;
pub extern fn g_application_command_line_get_environ(cmdline: [*c]GApplicationCommandLine) [*c]const [*c]const gchar;
pub extern fn g_application_command_line_getenv(cmdline: [*c]GApplicationCommandLine, name: [*c]const gchar) [*c]const gchar;
pub extern fn g_application_command_line_get_cwd(cmdline: [*c]GApplicationCommandLine) [*c]const gchar;
pub extern fn g_application_command_line_get_is_remote(cmdline: [*c]GApplicationCommandLine) gboolean;
pub extern fn g_application_command_line_print(cmdline: [*c]GApplicationCommandLine, format: [*c]const gchar, ...) void;
pub extern fn g_application_command_line_printerr(cmdline: [*c]GApplicationCommandLine, format: [*c]const gchar, ...) void;
pub extern fn g_application_command_line_get_exit_status(cmdline: [*c]GApplicationCommandLine) c_int;
pub extern fn g_application_command_line_set_exit_status(cmdline: [*c]GApplicationCommandLine, exit_status: c_int) void;
pub extern fn g_application_command_line_get_platform_data(cmdline: [*c]GApplicationCommandLine) ?*GVariant;
pub extern fn g_application_command_line_create_file_for_arg(cmdline: [*c]GApplicationCommandLine, arg: [*c]const gchar) ?*GFile;
pub const struct__GInitableIface = extern struct {
    g_iface: GTypeInterface,
    init: ?*const fn (?*GInitable, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GInitableIface = struct__GInitableIface;
pub extern fn g_initable_get_type() GType;
pub extern fn g_initable_init(initable: ?*GInitable, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_initable_new(object_type: GType, cancellable: [*c]GCancellable, @"error": [*c][*c]GError, first_property_name: [*c]const gchar, ...) gpointer;
pub extern fn g_initable_newv(object_type: GType, n_parameters: guint, parameters: [*c]GParameter, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gpointer;
pub extern fn g_initable_new_valist(object_type: GType, first_property_name: [*c]const gchar, var_args: [*c]struct___va_list_tag, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GObject;
pub const struct__GAsyncInitableIface = extern struct {
    g_iface: GTypeInterface,
    init_async: ?*const fn (?*GAsyncInitable, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    init_finish: ?*const fn (?*GAsyncInitable, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GAsyncInitableIface = struct__GAsyncInitableIface;
pub extern fn g_async_initable_get_type() GType;
pub extern fn g_async_initable_init_async(initable: ?*GAsyncInitable, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_async_initable_init_finish(initable: ?*GAsyncInitable, res: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_async_initable_new_async(object_type: GType, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_async_initable_newv_async(object_type: GType, n_parameters: guint, parameters: [*c]GParameter, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_async_initable_new_valist_async(object_type: GType, first_property_name: [*c]const gchar, var_args: [*c]struct___va_list_tag, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_async_initable_new_finish(initable: ?*GAsyncInitable, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GObject;
pub const struct__GAsyncResultIface = extern struct {
    g_iface: GTypeInterface,
    get_user_data: ?*const fn (?*GAsyncResult) callconv(.C) gpointer,
    get_source_object: ?*const fn (?*GAsyncResult) callconv(.C) [*c]GObject,
    is_tagged: ?*const fn (?*GAsyncResult, gpointer) callconv(.C) gboolean,
};
pub const GAsyncResultIface = struct__GAsyncResultIface;
pub extern fn g_async_result_get_type() GType;
pub extern fn g_async_result_get_user_data(res: ?*GAsyncResult) gpointer;
pub extern fn g_async_result_get_source_object(res: ?*GAsyncResult) [*c]GObject;
pub extern fn g_async_result_legacy_propagate_error(res: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_async_result_is_tagged(res: ?*GAsyncResult, source_tag: gpointer) gboolean;
pub const struct__GInputStreamClass = extern struct {
    parent_class: GObjectClass,
    read_fn: ?*const fn ([*c]GInputStream, ?*anyopaque, gsize, [*c]GCancellable, [*c][*c]GError) callconv(.C) gssize,
    skip: ?*const fn ([*c]GInputStream, gsize, [*c]GCancellable, [*c][*c]GError) callconv(.C) gssize,
    close_fn: ?*const fn ([*c]GInputStream, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    read_async: ?*const fn ([*c]GInputStream, ?*anyopaque, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    read_finish: ?*const fn ([*c]GInputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gssize,
    skip_async: ?*const fn ([*c]GInputStream, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    skip_finish: ?*const fn ([*c]GInputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gssize,
    close_async: ?*const fn ([*c]GInputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    close_finish: ?*const fn ([*c]GInputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GInputStreamClass = struct__GInputStreamClass;
pub extern fn g_input_stream_get_type() GType;
pub extern fn g_input_stream_read(stream: [*c]GInputStream, buffer: ?*anyopaque, count: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_input_stream_read_all(stream: [*c]GInputStream, buffer: ?*anyopaque, count: gsize, bytes_read: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_input_stream_read_bytes(stream: [*c]GInputStream, count: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_input_stream_skip(stream: [*c]GInputStream, count: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_input_stream_close(stream: [*c]GInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_input_stream_read_async(stream: [*c]GInputStream, buffer: ?*anyopaque, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_read_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gssize;
pub extern fn g_input_stream_read_all_async(stream: [*c]GInputStream, buffer: ?*anyopaque, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_read_all_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, bytes_read: [*c]gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_input_stream_read_bytes_async(stream: [*c]GInputStream, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_read_bytes_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_input_stream_skip_async(stream: [*c]GInputStream, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_skip_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gssize;
pub extern fn g_input_stream_close_async(stream: [*c]GInputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_close_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_input_stream_is_closed(stream: [*c]GInputStream) gboolean;
pub extern fn g_input_stream_has_pending(stream: [*c]GInputStream) gboolean;
pub extern fn g_input_stream_set_pending(stream: [*c]GInputStream, @"error": [*c][*c]GError) gboolean;
pub extern fn g_input_stream_clear_pending(stream: [*c]GInputStream) void;
pub const struct__GFilterInputStreamClass = extern struct {
    parent_class: GInputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
};
pub const GFilterInputStreamClass = struct__GFilterInputStreamClass;
pub extern fn g_filter_input_stream_get_type() GType;
pub extern fn g_filter_input_stream_get_base_stream(stream: [*c]GFilterInputStream) [*c]GInputStream;
pub extern fn g_filter_input_stream_get_close_base_stream(stream: [*c]GFilterInputStream) gboolean;
pub extern fn g_filter_input_stream_set_close_base_stream(stream: [*c]GFilterInputStream, close_base: gboolean) void;
pub const struct__GBufferedInputStreamClass = extern struct {
    parent_class: GFilterInputStreamClass,
    fill: ?*const fn ([*c]GBufferedInputStream, gssize, [*c]GCancellable, [*c][*c]GError) callconv(.C) gssize,
    fill_async: ?*const fn ([*c]GBufferedInputStream, gssize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    fill_finish: ?*const fn ([*c]GBufferedInputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gssize,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GBufferedInputStreamClass = struct__GBufferedInputStreamClass;
pub extern fn g_buffered_input_stream_get_type() GType;
pub extern fn g_buffered_input_stream_new(base_stream: [*c]GInputStream) [*c]GInputStream;
pub extern fn g_buffered_input_stream_new_sized(base_stream: [*c]GInputStream, size: gsize) [*c]GInputStream;
pub extern fn g_buffered_input_stream_get_buffer_size(stream: [*c]GBufferedInputStream) gsize;
pub extern fn g_buffered_input_stream_set_buffer_size(stream: [*c]GBufferedInputStream, size: gsize) void;
pub extern fn g_buffered_input_stream_get_available(stream: [*c]GBufferedInputStream) gsize;
pub extern fn g_buffered_input_stream_peek(stream: [*c]GBufferedInputStream, buffer: ?*anyopaque, offset: gsize, count: gsize) gsize;
pub extern fn g_buffered_input_stream_peek_buffer(stream: [*c]GBufferedInputStream, count: [*c]gsize) ?*const anyopaque;
pub extern fn g_buffered_input_stream_fill(stream: [*c]GBufferedInputStream, count: gssize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_buffered_input_stream_fill_async(stream: [*c]GBufferedInputStream, count: gssize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_buffered_input_stream_fill_finish(stream: [*c]GBufferedInputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gssize;
pub extern fn g_buffered_input_stream_read_byte(stream: [*c]GBufferedInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) c_int;
pub const struct__GOutputStreamClass = extern struct {
    parent_class: GObjectClass,
    write_fn: ?*const fn ([*c]GOutputStream, ?*const anyopaque, gsize, [*c]GCancellable, [*c][*c]GError) callconv(.C) gssize,
    splice: ?*const fn ([*c]GOutputStream, [*c]GInputStream, GOutputStreamSpliceFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) gssize,
    flush: ?*const fn ([*c]GOutputStream, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    close_fn: ?*const fn ([*c]GOutputStream, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    write_async: ?*const fn ([*c]GOutputStream, ?*const anyopaque, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    write_finish: ?*const fn ([*c]GOutputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gssize,
    splice_async: ?*const fn ([*c]GOutputStream, [*c]GInputStream, GOutputStreamSpliceFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    splice_finish: ?*const fn ([*c]GOutputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gssize,
    flush_async: ?*const fn ([*c]GOutputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    flush_finish: ?*const fn ([*c]GOutputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    close_async: ?*const fn ([*c]GOutputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    close_finish: ?*const fn ([*c]GOutputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    writev_fn: ?*const fn ([*c]GOutputStream, [*c]const GOutputVector, gsize, [*c]gsize, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    writev_async: ?*const fn ([*c]GOutputStream, [*c]const GOutputVector, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    writev_finish: ?*const fn ([*c]GOutputStream, ?*GAsyncResult, [*c]gsize, [*c][*c]GError) callconv(.C) gboolean,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
    _g_reserved7: ?*const fn () callconv(.C) void,
    _g_reserved8: ?*const fn () callconv(.C) void,
};
pub const GOutputStreamClass = struct__GOutputStreamClass;
pub extern fn g_output_stream_get_type() GType;
pub extern fn g_output_stream_write(stream: [*c]GOutputStream, buffer: ?*const anyopaque, count: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_output_stream_write_all(stream: [*c]GOutputStream, buffer: ?*const anyopaque, count: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_writev(stream: [*c]GOutputStream, vectors: [*c]const GOutputVector, n_vectors: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_writev_all(stream: [*c]GOutputStream, vectors: [*c]GOutputVector, n_vectors: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_printf(stream: [*c]GOutputStream, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError, format: [*c]const gchar, ...) gboolean;
pub extern fn g_output_stream_vprintf(stream: [*c]GOutputStream, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError, format: [*c]const gchar, args: [*c]struct___va_list_tag) gboolean;
pub extern fn g_output_stream_write_bytes(stream: [*c]GOutputStream, bytes: ?*GBytes, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_output_stream_splice(stream: [*c]GOutputStream, source: [*c]GInputStream, flags: GOutputStreamSpliceFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_output_stream_flush(stream: [*c]GOutputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_close(stream: [*c]GOutputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_write_async(stream: [*c]GOutputStream, buffer: ?*const anyopaque, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_write_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gssize;
pub extern fn g_output_stream_write_all_async(stream: [*c]GOutputStream, buffer: ?*const anyopaque, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_write_all_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, bytes_written: [*c]gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_writev_async(stream: [*c]GOutputStream, vectors: [*c]const GOutputVector, n_vectors: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_writev_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, bytes_written: [*c]gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_writev_all_async(stream: [*c]GOutputStream, vectors: [*c]GOutputVector, n_vectors: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_writev_all_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, bytes_written: [*c]gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_write_bytes_async(stream: [*c]GOutputStream, bytes: ?*GBytes, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_write_bytes_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gssize;
pub extern fn g_output_stream_splice_async(stream: [*c]GOutputStream, source: [*c]GInputStream, flags: GOutputStreamSpliceFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_splice_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gssize;
pub extern fn g_output_stream_flush_async(stream: [*c]GOutputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_flush_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_close_async(stream: [*c]GOutputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_close_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_is_closed(stream: [*c]GOutputStream) gboolean;
pub extern fn g_output_stream_is_closing(stream: [*c]GOutputStream) gboolean;
pub extern fn g_output_stream_has_pending(stream: [*c]GOutputStream) gboolean;
pub extern fn g_output_stream_set_pending(stream: [*c]GOutputStream, @"error": [*c][*c]GError) gboolean;
pub extern fn g_output_stream_clear_pending(stream: [*c]GOutputStream) void;
pub const struct__GFilterOutputStreamClass = extern struct {
    parent_class: GOutputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
};
pub const GFilterOutputStreamClass = struct__GFilterOutputStreamClass;
pub extern fn g_filter_output_stream_get_type() GType;
pub extern fn g_filter_output_stream_get_base_stream(stream: [*c]GFilterOutputStream) [*c]GOutputStream;
pub extern fn g_filter_output_stream_get_close_base_stream(stream: [*c]GFilterOutputStream) gboolean;
pub extern fn g_filter_output_stream_set_close_base_stream(stream: [*c]GFilterOutputStream, close_base: gboolean) void;
pub const struct__GBufferedOutputStreamClass = extern struct {
    parent_class: GFilterOutputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
};
pub const GBufferedOutputStreamClass = struct__GBufferedOutputStreamClass;
pub extern fn g_buffered_output_stream_get_type() GType;
pub extern fn g_buffered_output_stream_new(base_stream: [*c]GOutputStream) [*c]GOutputStream;
pub extern fn g_buffered_output_stream_new_sized(base_stream: [*c]GOutputStream, size: gsize) [*c]GOutputStream;
pub extern fn g_buffered_output_stream_get_buffer_size(stream: [*c]GBufferedOutputStream) gsize;
pub extern fn g_buffered_output_stream_set_buffer_size(stream: [*c]GBufferedOutputStream, size: gsize) void;
pub extern fn g_buffered_output_stream_get_auto_grow(stream: [*c]GBufferedOutputStream) gboolean;
pub extern fn g_buffered_output_stream_set_auto_grow(stream: [*c]GBufferedOutputStream, auto_grow: gboolean) void;
pub extern fn g_bytes_icon_get_type() GType;
pub extern fn g_bytes_icon_new(bytes: ?*GBytes) ?*GIcon;
pub extern fn g_bytes_icon_get_bytes(icon: ?*GBytesIcon) ?*GBytes;
pub const struct__GCancellableClass = extern struct {
    parent_class: GObjectClass,
    cancelled: ?*const fn ([*c]GCancellable) callconv(.C) void,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GCancellableClass = struct__GCancellableClass;
pub extern fn g_cancellable_get_type() GType;
pub extern fn g_cancellable_new() [*c]GCancellable;
pub extern fn g_cancellable_is_cancelled(cancellable: [*c]GCancellable) gboolean;
pub extern fn g_cancellable_set_error_if_cancelled(cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_cancellable_get_fd(cancellable: [*c]GCancellable) c_int;
pub extern fn g_cancellable_make_pollfd(cancellable: [*c]GCancellable, pollfd: [*c]GPollFD) gboolean;
pub extern fn g_cancellable_release_fd(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_source_new(cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_cancellable_get_current() [*c]GCancellable;
pub extern fn g_cancellable_push_current(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_pop_current(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_reset(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_connect(cancellable: [*c]GCancellable, callback: GCallback, data: gpointer, data_destroy_func: GDestroyNotify) gulong;
pub extern fn g_cancellable_disconnect(cancellable: [*c]GCancellable, handler_id: gulong) void;
pub extern fn g_cancellable_cancel(cancellable: [*c]GCancellable) void;
pub const struct__GConverterIface = extern struct {
    g_iface: GTypeInterface,
    convert: ?*const fn (?*GConverter, ?*const anyopaque, gsize, ?*anyopaque, gsize, GConverterFlags, [*c]gsize, [*c]gsize, [*c][*c]GError) callconv(.C) GConverterResult,
    reset: ?*const fn (?*GConverter) callconv(.C) void,
};
pub const GConverterIface = struct__GConverterIface;
pub extern fn g_converter_get_type() GType;
pub extern fn g_converter_convert(converter: ?*GConverter, inbuf: ?*const anyopaque, inbuf_size: gsize, outbuf: ?*anyopaque, outbuf_size: gsize, flags: GConverterFlags, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c][*c]GError) GConverterResult;
pub extern fn g_converter_reset(converter: ?*GConverter) void;
pub const struct__GCharsetConverterClass = extern struct {
    parent_class: GObjectClass,
};
pub const GCharsetConverterClass = struct__GCharsetConverterClass;
pub extern fn g_charset_converter_get_type() GType;
pub extern fn g_charset_converter_new(to_charset: [*c]const gchar, from_charset: [*c]const gchar, @"error": [*c][*c]GError) ?*GCharsetConverter;
pub extern fn g_charset_converter_set_use_fallback(converter: ?*GCharsetConverter, use_fallback: gboolean) void;
pub extern fn g_charset_converter_get_use_fallback(converter: ?*GCharsetConverter) gboolean;
pub extern fn g_charset_converter_get_num_fallbacks(converter: ?*GCharsetConverter) guint;
pub extern fn g_content_type_equals(type1: [*c]const gchar, type2: [*c]const gchar) gboolean;
pub extern fn g_content_type_is_a(@"type": [*c]const gchar, supertype: [*c]const gchar) gboolean;
pub extern fn g_content_type_is_mime_type(@"type": [*c]const gchar, mime_type: [*c]const gchar) gboolean;
pub extern fn g_content_type_is_unknown(@"type": [*c]const gchar) gboolean;
pub extern fn g_content_type_get_description(@"type": [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_get_mime_type(@"type": [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_get_icon(@"type": [*c]const gchar) ?*GIcon;
pub extern fn g_content_type_get_symbolic_icon(@"type": [*c]const gchar) ?*GIcon;
pub extern fn g_content_type_get_generic_icon_name(@"type": [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_can_be_executable(@"type": [*c]const gchar) gboolean;
pub extern fn g_content_type_from_mime_type(mime_type: [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_guess(filename: [*c]const gchar, data: [*c]const guchar, data_size: gsize, result_uncertain: [*c]gboolean) [*c]gchar;
pub extern fn g_content_type_guess_for_tree(root: ?*GFile) [*c][*c]gchar;
pub extern fn g_content_types_get_registered() [*c]GList;
pub extern fn g_content_type_get_mime_dirs() [*c]const [*c]const gchar;
pub extern fn g_content_type_set_mime_dirs(dirs: [*c]const [*c]const gchar) void;
pub const struct__GConverterInputStreamClass = extern struct {
    parent_class: GFilterInputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GConverterInputStreamClass = struct__GConverterInputStreamClass;
pub extern fn g_converter_input_stream_get_type() GType;
pub extern fn g_converter_input_stream_new(base_stream: [*c]GInputStream, converter: ?*GConverter) [*c]GInputStream;
pub extern fn g_converter_input_stream_get_converter(converter_stream: [*c]GConverterInputStream) ?*GConverter;
pub const struct__GConverterOutputStreamClass = extern struct {
    parent_class: GFilterOutputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GConverterOutputStreamClass = struct__GConverterOutputStreamClass;
pub extern fn g_converter_output_stream_get_type() GType;
pub extern fn g_converter_output_stream_new(base_stream: [*c]GOutputStream, converter: ?*GConverter) [*c]GOutputStream;
pub extern fn g_converter_output_stream_get_converter(converter_stream: [*c]GConverterOutputStream) ?*GConverter;
pub const useconds_t = __useconds_t;
pub const socklen_t = __socklen_t;
pub extern fn access(__name: [*c]const u8, __type: c_int) c_int;
pub extern fn faccessat(__fd: c_int, __file: [*c]const u8, __type: c_int, __flag: c_int) c_int;
pub extern fn lseek(__fd: c_int, __offset: __off_t, __whence: c_int) __off_t;
pub extern fn close(__fd: c_int) c_int;
pub extern fn closefrom(__lowfd: c_int) void;
pub extern fn read(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize) isize;
pub extern fn write(__fd: c_int, __buf: ?*const anyopaque, __n: usize) isize;
pub extern fn pread(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize, __offset: __off_t) isize;
pub extern fn pwrite(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __offset: __off_t) isize;
pub extern fn pipe(__pipedes: [*c]c_int) c_int;
pub extern fn alarm(__seconds: c_uint) c_uint;
pub extern fn sleep(__seconds: c_uint) c_uint;
pub extern fn ualarm(__value: __useconds_t, __interval: __useconds_t) __useconds_t;
pub extern fn usleep(__useconds: __useconds_t) c_int;
pub extern fn pause() c_int;
pub extern fn chown(__file: [*c]const u8, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn fchown(__fd: c_int, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn lchown(__file: [*c]const u8, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn fchownat(__fd: c_int, __file: [*c]const u8, __owner: __uid_t, __group: __gid_t, __flag: c_int) c_int;
pub extern fn chdir(__path: [*c]const u8) c_int;
pub extern fn fchdir(__fd: c_int) c_int;
pub extern fn getcwd(__buf: [*c]u8, __size: usize) [*c]u8;
pub extern fn getwd(__buf: [*c]u8) [*c]u8;
pub extern fn dup(__fd: c_int) c_int;
pub extern fn dup2(__fd: c_int, __fd2: c_int) c_int;
pub extern var __environ: [*c][*c]u8;
pub extern fn execve(__path: [*c]const u8, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn fexecve(__fd: c_int, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn execv(__path: [*c]const u8, __argv: [*c]const [*c]u8) c_int;
pub extern fn execle(__path: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execl(__path: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execvp(__file: [*c]const u8, __argv: [*c]const [*c]u8) c_int;
pub extern fn execlp(__file: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn nice(__inc: c_int) c_int;
pub extern fn _exit(__status: c_int) noreturn;
pub const _PC_LINK_MAX: c_int = 0;
pub const _PC_MAX_CANON: c_int = 1;
pub const _PC_MAX_INPUT: c_int = 2;
pub const _PC_NAME_MAX: c_int = 3;
pub const _PC_PATH_MAX: c_int = 4;
pub const _PC_PIPE_BUF: c_int = 5;
pub const _PC_CHOWN_RESTRICTED: c_int = 6;
pub const _PC_NO_TRUNC: c_int = 7;
pub const _PC_VDISABLE: c_int = 8;
pub const _PC_SYNC_IO: c_int = 9;
pub const _PC_ASYNC_IO: c_int = 10;
pub const _PC_PRIO_IO: c_int = 11;
pub const _PC_SOCK_MAXBUF: c_int = 12;
pub const _PC_FILESIZEBITS: c_int = 13;
pub const _PC_REC_INCR_XFER_SIZE: c_int = 14;
pub const _PC_REC_MAX_XFER_SIZE: c_int = 15;
pub const _PC_REC_MIN_XFER_SIZE: c_int = 16;
pub const _PC_REC_XFER_ALIGN: c_int = 17;
pub const _PC_ALLOC_SIZE_MIN: c_int = 18;
pub const _PC_SYMLINK_MAX: c_int = 19;
pub const _PC_2_SYMLINKS: c_int = 20;
const enum_unnamed_45 = c_uint;
pub const _SC_ARG_MAX: c_int = 0;
pub const _SC_CHILD_MAX: c_int = 1;
pub const _SC_CLK_TCK: c_int = 2;
pub const _SC_NGROUPS_MAX: c_int = 3;
pub const _SC_OPEN_MAX: c_int = 4;
pub const _SC_STREAM_MAX: c_int = 5;
pub const _SC_TZNAME_MAX: c_int = 6;
pub const _SC_JOB_CONTROL: c_int = 7;
pub const _SC_SAVED_IDS: c_int = 8;
pub const _SC_REALTIME_SIGNALS: c_int = 9;
pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
pub const _SC_TIMERS: c_int = 11;
pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
pub const _SC_PRIORITIZED_IO: c_int = 13;
pub const _SC_SYNCHRONIZED_IO: c_int = 14;
pub const _SC_FSYNC: c_int = 15;
pub const _SC_MAPPED_FILES: c_int = 16;
pub const _SC_MEMLOCK: c_int = 17;
pub const _SC_MEMLOCK_RANGE: c_int = 18;
pub const _SC_MEMORY_PROTECTION: c_int = 19;
pub const _SC_MESSAGE_PASSING: c_int = 20;
pub const _SC_SEMAPHORES: c_int = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
pub const _SC_AIO_LISTIO_MAX: c_int = 23;
pub const _SC_AIO_MAX: c_int = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
pub const _SC_DELAYTIMER_MAX: c_int = 26;
pub const _SC_MQ_OPEN_MAX: c_int = 27;
pub const _SC_MQ_PRIO_MAX: c_int = 28;
pub const _SC_VERSION: c_int = 29;
pub const _SC_PAGESIZE: c_int = 30;
pub const _SC_RTSIG_MAX: c_int = 31;
pub const _SC_SEM_NSEMS_MAX: c_int = 32;
pub const _SC_SEM_VALUE_MAX: c_int = 33;
pub const _SC_SIGQUEUE_MAX: c_int = 34;
pub const _SC_TIMER_MAX: c_int = 35;
pub const _SC_BC_BASE_MAX: c_int = 36;
pub const _SC_BC_DIM_MAX: c_int = 37;
pub const _SC_BC_SCALE_MAX: c_int = 38;
pub const _SC_BC_STRING_MAX: c_int = 39;
pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
pub const _SC_EQUIV_CLASS_MAX: c_int = 41;
pub const _SC_EXPR_NEST_MAX: c_int = 42;
pub const _SC_LINE_MAX: c_int = 43;
pub const _SC_RE_DUP_MAX: c_int = 44;
pub const _SC_CHARCLASS_NAME_MAX: c_int = 45;
pub const _SC_2_VERSION: c_int = 46;
pub const _SC_2_C_BIND: c_int = 47;
pub const _SC_2_C_DEV: c_int = 48;
pub const _SC_2_FORT_DEV: c_int = 49;
pub const _SC_2_FORT_RUN: c_int = 50;
pub const _SC_2_SW_DEV: c_int = 51;
pub const _SC_2_LOCALEDEF: c_int = 52;
pub const _SC_PII: c_int = 53;
pub const _SC_PII_XTI: c_int = 54;
pub const _SC_PII_SOCKET: c_int = 55;
pub const _SC_PII_INTERNET: c_int = 56;
pub const _SC_PII_OSI: c_int = 57;
pub const _SC_POLL: c_int = 58;
pub const _SC_SELECT: c_int = 59;
pub const _SC_UIO_MAXIOV: c_int = 60;
pub const _SC_IOV_MAX: c_int = 60;
pub const _SC_PII_INTERNET_STREAM: c_int = 61;
pub const _SC_PII_INTERNET_DGRAM: c_int = 62;
pub const _SC_PII_OSI_COTS: c_int = 63;
pub const _SC_PII_OSI_CLTS: c_int = 64;
pub const _SC_PII_OSI_M: c_int = 65;
pub const _SC_T_IOV_MAX: c_int = 66;
pub const _SC_THREADS: c_int = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
pub const _SC_LOGIN_NAME_MAX: c_int = 71;
pub const _SC_TTY_NAME_MAX: c_int = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
pub const _SC_THREAD_KEYS_MAX: c_int = 74;
pub const _SC_THREAD_STACK_MIN: c_int = 75;
pub const _SC_THREAD_THREADS_MAX: c_int = 76;
pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
pub const _SC_NPROCESSORS_CONF: c_int = 83;
pub const _SC_NPROCESSORS_ONLN: c_int = 84;
pub const _SC_PHYS_PAGES: c_int = 85;
pub const _SC_AVPHYS_PAGES: c_int = 86;
pub const _SC_ATEXIT_MAX: c_int = 87;
pub const _SC_PASS_MAX: c_int = 88;
pub const _SC_XOPEN_VERSION: c_int = 89;
pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
pub const _SC_XOPEN_UNIX: c_int = 91;
pub const _SC_XOPEN_CRYPT: c_int = 92;
pub const _SC_XOPEN_ENH_I18N: c_int = 93;
pub const _SC_XOPEN_SHM: c_int = 94;
pub const _SC_2_CHAR_TERM: c_int = 95;
pub const _SC_2_C_VERSION: c_int = 96;
pub const _SC_2_UPE: c_int = 97;
pub const _SC_XOPEN_XPG2: c_int = 98;
pub const _SC_XOPEN_XPG3: c_int = 99;
pub const _SC_XOPEN_XPG4: c_int = 100;
pub const _SC_CHAR_BIT: c_int = 101;
pub const _SC_CHAR_MAX: c_int = 102;
pub const _SC_CHAR_MIN: c_int = 103;
pub const _SC_INT_MAX: c_int = 104;
pub const _SC_INT_MIN: c_int = 105;
pub const _SC_LONG_BIT: c_int = 106;
pub const _SC_WORD_BIT: c_int = 107;
pub const _SC_MB_LEN_MAX: c_int = 108;
pub const _SC_NZERO: c_int = 109;
pub const _SC_SSIZE_MAX: c_int = 110;
pub const _SC_SCHAR_MAX: c_int = 111;
pub const _SC_SCHAR_MIN: c_int = 112;
pub const _SC_SHRT_MAX: c_int = 113;
pub const _SC_SHRT_MIN: c_int = 114;
pub const _SC_UCHAR_MAX: c_int = 115;
pub const _SC_UINT_MAX: c_int = 116;
pub const _SC_ULONG_MAX: c_int = 117;
pub const _SC_USHRT_MAX: c_int = 118;
pub const _SC_NL_ARGMAX: c_int = 119;
pub const _SC_NL_LANGMAX: c_int = 120;
pub const _SC_NL_MSGMAX: c_int = 121;
pub const _SC_NL_NMAX: c_int = 122;
pub const _SC_NL_SETMAX: c_int = 123;
pub const _SC_NL_TEXTMAX: c_int = 124;
pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
pub const _SC_XBS5_LP64_OFF64: c_int = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
pub const _SC_XOPEN_LEGACY: c_int = 129;
pub const _SC_XOPEN_REALTIME: c_int = 130;
pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
pub const _SC_ADVISORY_INFO: c_int = 132;
pub const _SC_BARRIERS: c_int = 133;
pub const _SC_BASE: c_int = 134;
pub const _SC_C_LANG_SUPPORT: c_int = 135;
pub const _SC_C_LANG_SUPPORT_R: c_int = 136;
pub const _SC_CLOCK_SELECTION: c_int = 137;
pub const _SC_CPUTIME: c_int = 138;
pub const _SC_THREAD_CPUTIME: c_int = 139;
pub const _SC_DEVICE_IO: c_int = 140;
pub const _SC_DEVICE_SPECIFIC: c_int = 141;
pub const _SC_DEVICE_SPECIFIC_R: c_int = 142;
pub const _SC_FD_MGMT: c_int = 143;
pub const _SC_FIFO: c_int = 144;
pub const _SC_PIPE: c_int = 145;
pub const _SC_FILE_ATTRIBUTES: c_int = 146;
pub const _SC_FILE_LOCKING: c_int = 147;
pub const _SC_FILE_SYSTEM: c_int = 148;
pub const _SC_MONOTONIC_CLOCK: c_int = 149;
pub const _SC_MULTI_PROCESS: c_int = 150;
pub const _SC_SINGLE_PROCESS: c_int = 151;
pub const _SC_NETWORKING: c_int = 152;
pub const _SC_READER_WRITER_LOCKS: c_int = 153;
pub const _SC_SPIN_LOCKS: c_int = 154;
pub const _SC_REGEXP: c_int = 155;
pub const _SC_REGEX_VERSION: c_int = 156;
pub const _SC_SHELL: c_int = 157;
pub const _SC_SIGNALS: c_int = 158;
pub const _SC_SPAWN: c_int = 159;
pub const _SC_SPORADIC_SERVER: c_int = 160;
pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
pub const _SC_SYSTEM_DATABASE: c_int = 162;
pub const _SC_SYSTEM_DATABASE_R: c_int = 163;
pub const _SC_TIMEOUTS: c_int = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
pub const _SC_USER_GROUPS: c_int = 166;
pub const _SC_USER_GROUPS_R: c_int = 167;
pub const _SC_2_PBS: c_int = 168;
pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
pub const _SC_2_PBS_LOCATE: c_int = 170;
pub const _SC_2_PBS_MESSAGE: c_int = 171;
pub const _SC_2_PBS_TRACK: c_int = 172;
pub const _SC_SYMLOOP_MAX: c_int = 173;
pub const _SC_STREAMS: c_int = 174;
pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
pub const _SC_V6_ILP32_OFF32: c_int = 176;
pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
pub const _SC_V6_LP64_OFF64: c_int = 178;
pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
pub const _SC_HOST_NAME_MAX: c_int = 180;
pub const _SC_TRACE: c_int = 181;
pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
pub const _SC_TRACE_INHERIT: c_int = 183;
pub const _SC_TRACE_LOG: c_int = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: c_int = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: c_int = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: c_int = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: c_int = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: c_int = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: c_int = 190;
pub const _SC_LEVEL2_CACHE_SIZE: c_int = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: c_int = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: c_int = 193;
pub const _SC_LEVEL3_CACHE_SIZE: c_int = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: c_int = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: c_int = 196;
pub const _SC_LEVEL4_CACHE_SIZE: c_int = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: c_int = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: c_int = 199;
pub const _SC_IPV6: c_int = 235;
pub const _SC_RAW_SOCKETS: c_int = 236;
pub const _SC_V7_ILP32_OFF32: c_int = 237;
pub const _SC_V7_ILP32_OFFBIG: c_int = 238;
pub const _SC_V7_LP64_OFF64: c_int = 239;
pub const _SC_V7_LPBIG_OFFBIG: c_int = 240;
pub const _SC_SS_REPL_MAX: c_int = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: c_int = 242;
pub const _SC_TRACE_NAME_MAX: c_int = 243;
pub const _SC_TRACE_SYS_MAX: c_int = 244;
pub const _SC_TRACE_USER_EVENT_MAX: c_int = 245;
pub const _SC_XOPEN_STREAMS: c_int = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: c_int = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: c_int = 248;
pub const _SC_MINSIGSTKSZ: c_int = 249;
pub const _SC_SIGSTKSZ: c_int = 250;
const enum_unnamed_46 = c_uint;
pub const _CS_PATH: c_int = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: c_int = 1;
pub const _CS_GNU_LIBC_VERSION: c_int = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: c_int = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: c_int = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: c_int = 5;
pub const _CS_LFS_CFLAGS: c_int = 1000;
pub const _CS_LFS_LDFLAGS: c_int = 1001;
pub const _CS_LFS_LIBS: c_int = 1002;
pub const _CS_LFS_LINTFLAGS: c_int = 1003;
pub const _CS_LFS64_CFLAGS: c_int = 1004;
pub const _CS_LFS64_LDFLAGS: c_int = 1005;
pub const _CS_LFS64_LIBS: c_int = 1006;
pub const _CS_LFS64_LINTFLAGS: c_int = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: c_int = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: c_int = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: c_int = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: c_int = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: c_int = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: c_int = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: c_int = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: c_int = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: c_int = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: c_int = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: c_int = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: c_int = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: c_int = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: c_int = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: c_int = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: c_int = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: c_int = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: c_int = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: c_int = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: c_int = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: c_int = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: c_int = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: c_int = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: c_int = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: c_int = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: c_int = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: c_int = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: c_int = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: c_int = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: c_int = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: c_int = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: c_int = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: c_int = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: c_int = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: c_int = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: c_int = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: c_int = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: c_int = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: c_int = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: c_int = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: c_int = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: c_int = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: c_int = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: c_int = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: c_int = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: c_int = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: c_int = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: c_int = 1147;
pub const _CS_V6_ENV: c_int = 1148;
pub const _CS_V7_ENV: c_int = 1149;
const enum_unnamed_47 = c_uint;
pub extern fn pathconf(__path: [*c]const u8, __name: c_int) c_long;
pub extern fn fpathconf(__fd: c_int, __name: c_int) c_long;
pub extern fn sysconf(__name: c_int) c_long;
pub extern fn confstr(__name: c_int, __buf: [*c]u8, __len: usize) usize;
pub extern fn getpid() __pid_t;
pub extern fn getppid() __pid_t;
pub extern fn getpgrp() __pid_t;
pub extern fn __getpgid(__pid: __pid_t) __pid_t;
pub extern fn getpgid(__pid: __pid_t) __pid_t;
pub extern fn setpgid(__pid: __pid_t, __pgid: __pid_t) c_int;
pub extern fn setpgrp() c_int;
pub extern fn setsid() __pid_t;
pub extern fn getsid(__pid: __pid_t) __pid_t;
pub extern fn getuid() __uid_t;
pub extern fn geteuid() __uid_t;
pub extern fn getgid() __gid_t;
pub extern fn getegid() __gid_t;
pub extern fn getgroups(__size: c_int, __list: [*c]__gid_t) c_int;
pub extern fn setuid(__uid: __uid_t) c_int;
pub extern fn setreuid(__ruid: __uid_t, __euid: __uid_t) c_int;
pub extern fn seteuid(__uid: __uid_t) c_int;
pub extern fn setgid(__gid: __gid_t) c_int;
pub extern fn setregid(__rgid: __gid_t, __egid: __gid_t) c_int;
pub extern fn setegid(__gid: __gid_t) c_int;
pub extern fn fork() __pid_t;
pub extern fn vfork() c_int;
pub extern fn ttyname(__fd: c_int) [*c]u8;
pub extern fn ttyname_r(__fd: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn isatty(__fd: c_int) c_int;
pub extern fn ttyslot() c_int;
pub extern fn link(__from: [*c]const u8, __to: [*c]const u8) c_int;
pub extern fn linkat(__fromfd: c_int, __from: [*c]const u8, __tofd: c_int, __to: [*c]const u8, __flags: c_int) c_int;
pub extern fn symlink(__from: [*c]const u8, __to: [*c]const u8) c_int;
pub extern fn readlink(noalias __path: [*c]const u8, noalias __buf: [*c]u8, __len: usize) isize;
pub extern fn symlinkat(__from: [*c]const u8, __tofd: c_int, __to: [*c]const u8) c_int;
pub extern fn readlinkat(__fd: c_int, noalias __path: [*c]const u8, noalias __buf: [*c]u8, __len: usize) isize;
pub extern fn unlink(__name: [*c]const u8) c_int;
pub extern fn unlinkat(__fd: c_int, __name: [*c]const u8, __flag: c_int) c_int;
pub extern fn rmdir(__path: [*c]const u8) c_int;
pub extern fn tcgetpgrp(__fd: c_int) __pid_t;
pub extern fn tcsetpgrp(__fd: c_int, __pgrp_id: __pid_t) c_int;
pub extern fn getlogin() [*c]u8;
pub extern fn getlogin_r(__name: [*c]u8, __name_len: usize) c_int;
pub extern fn setlogin(__name: [*c]const u8) c_int;
pub extern var optarg: [*c]u8;
pub extern var optind: c_int;
pub extern var opterr: c_int;
pub extern var optopt: c_int;
pub extern fn getopt(___argc: c_int, ___argv: [*c]const [*c]u8, __shortopts: [*c]const u8) c_int;
pub extern fn gethostname(__name: [*c]u8, __len: usize) c_int;
pub extern fn sethostname(__name: [*c]const u8, __len: usize) c_int;
pub extern fn sethostid(__id: c_long) c_int;
pub extern fn getdomainname(__name: [*c]u8, __len: usize) c_int;
pub extern fn setdomainname(__name: [*c]const u8, __len: usize) c_int;
pub extern fn vhangup() c_int;
pub extern fn revoke(__file: [*c]const u8) c_int;
pub extern fn profil(__sample_buffer: [*c]c_ushort, __size: usize, __offset: usize, __scale: c_uint) c_int;
pub extern fn acct(__name: [*c]const u8) c_int;
pub extern fn getusershell() [*c]u8;
pub extern fn endusershell() void;
pub extern fn setusershell() void;
pub extern fn daemon(__nochdir: c_int, __noclose: c_int) c_int;
pub extern fn chroot(__path: [*c]const u8) c_int;
pub extern fn getpass(__prompt: [*c]const u8) [*c]u8;
pub extern fn fsync(__fd: c_int) c_int;
pub extern fn gethostid() c_long;
pub extern fn sync() void;
pub extern fn getpagesize() c_int;
pub extern fn getdtablesize() c_int;
pub extern fn truncate(__file: [*c]const u8, __length: __off_t) c_int;
pub extern fn ftruncate(__fd: c_int, __length: __off_t) c_int;
pub extern fn brk(__addr: ?*anyopaque) c_int;
pub extern fn sbrk(__delta: isize) ?*anyopaque;
pub extern fn syscall(__sysno: c_long, ...) c_long;
pub extern fn lockf(__fd: c_int, __cmd: c_int, __len: __off_t) c_int;
pub extern fn fdatasync(__fildes: c_int) c_int;
pub extern fn crypt(__key: [*c]const u8, __salt: [*c]const u8) [*c]u8;
pub extern fn getentropy(__buffer: ?*anyopaque, __length: usize) c_int;
pub const struct__GCredentialsClass = opaque {};
pub const GCredentialsClass = struct__GCredentialsClass;
pub extern fn g_credentials_get_type() GType;
pub extern fn g_credentials_new() ?*GCredentials;
pub extern fn g_credentials_to_string(credentials: ?*GCredentials) [*c]gchar;
pub extern fn g_credentials_get_native(credentials: ?*GCredentials, native_type: GCredentialsType) gpointer;
pub extern fn g_credentials_set_native(credentials: ?*GCredentials, native_type: GCredentialsType, native: gpointer) void;
pub extern fn g_credentials_is_same_user(credentials: ?*GCredentials, other_credentials: ?*GCredentials, @"error": [*c][*c]GError) gboolean;
pub extern fn g_credentials_get_unix_pid(credentials: ?*GCredentials, @"error": [*c][*c]GError) pid_t;
pub extern fn g_credentials_get_unix_user(credentials: ?*GCredentials, @"error": [*c][*c]GError) uid_t;
pub extern fn g_credentials_set_unix_user(credentials: ?*GCredentials, uid: uid_t, @"error": [*c][*c]GError) gboolean;
pub const struct__GDatagramBasedInterface = extern struct {
    g_iface: GTypeInterface,
    receive_messages: ?*const fn (?*GDatagramBased, [*c]GInputMessage, guint, gint, gint64, [*c]GCancellable, [*c][*c]GError) callconv(.C) gint,
    send_messages: ?*const fn (?*GDatagramBased, [*c]GOutputMessage, guint, gint, gint64, [*c]GCancellable, [*c][*c]GError) callconv(.C) gint,
    create_source: ?*const fn (?*GDatagramBased, GIOCondition, [*c]GCancellable) callconv(.C) [*c]GSource,
    condition_check: ?*const fn (?*GDatagramBased, GIOCondition) callconv(.C) GIOCondition,
    condition_wait: ?*const fn (?*GDatagramBased, GIOCondition, gint64, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GDatagramBasedInterface = struct__GDatagramBasedInterface;
pub extern fn g_datagram_based_get_type() GType;
pub extern fn g_datagram_based_receive_messages(datagram_based: ?*GDatagramBased, messages: [*c]GInputMessage, num_messages: guint, flags: gint, timeout: gint64, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint;
pub extern fn g_datagram_based_send_messages(datagram_based: ?*GDatagramBased, messages: [*c]GOutputMessage, num_messages: guint, flags: gint, timeout: gint64, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint;
pub extern fn g_datagram_based_create_source(datagram_based: ?*GDatagramBased, condition: GIOCondition, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_datagram_based_condition_check(datagram_based: ?*GDatagramBased, condition: GIOCondition) GIOCondition;
pub extern fn g_datagram_based_condition_wait(datagram_based: ?*GDatagramBased, condition: GIOCondition, timeout: gint64, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub const struct__GDataInputStreamClass = extern struct {
    parent_class: GBufferedInputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GDataInputStreamClass = struct__GDataInputStreamClass;
pub extern fn g_data_input_stream_get_type() GType;
pub extern fn g_data_input_stream_new(base_stream: [*c]GInputStream) [*c]GDataInputStream;
pub extern fn g_data_input_stream_set_byte_order(stream: [*c]GDataInputStream, order: GDataStreamByteOrder) void;
pub extern fn g_data_input_stream_get_byte_order(stream: [*c]GDataInputStream) GDataStreamByteOrder;
pub extern fn g_data_input_stream_set_newline_type(stream: [*c]GDataInputStream, @"type": GDataStreamNewlineType) void;
pub extern fn g_data_input_stream_get_newline_type(stream: [*c]GDataInputStream) GDataStreamNewlineType;
pub extern fn g_data_input_stream_read_byte(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) guchar;
pub extern fn g_data_input_stream_read_int16(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint16;
pub extern fn g_data_input_stream_read_uint16(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) guint16;
pub extern fn g_data_input_stream_read_int32(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint32;
pub extern fn g_data_input_stream_read_uint32(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) guint32;
pub extern fn g_data_input_stream_read_int64(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint64;
pub extern fn g_data_input_stream_read_uint64(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) guint64;
pub extern fn g_data_input_stream_read_line(stream: [*c]GDataInputStream, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_line_utf8(stream: [*c]GDataInputStream, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_line_async(stream: [*c]GDataInputStream, io_priority: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_data_input_stream_read_line_finish(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_line_finish_utf8(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_until(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_until_async(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, io_priority: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_data_input_stream_read_until_finish(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_upto(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, stop_chars_len: gssize, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_data_input_stream_read_upto_async(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, stop_chars_len: gssize, io_priority: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_data_input_stream_read_upto_finish(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c][*c]GError) [*c]u8;
pub const struct__GDataOutputStreamPrivate = opaque {};
pub const GDataOutputStreamPrivate = struct__GDataOutputStreamPrivate;
pub const struct__GDataOutputStream = extern struct {
    parent_instance: GFilterOutputStream,
    priv: ?*GDataOutputStreamPrivate,
};
pub const GDataOutputStream = struct__GDataOutputStream;
pub const struct__GDataOutputStreamClass = extern struct {
    parent_class: GFilterOutputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GDataOutputStreamClass = struct__GDataOutputStreamClass;
pub extern fn g_data_output_stream_get_type() GType;
pub extern fn g_data_output_stream_new(base_stream: [*c]GOutputStream) [*c]GDataOutputStream;
pub extern fn g_data_output_stream_set_byte_order(stream: [*c]GDataOutputStream, order: GDataStreamByteOrder) void;
pub extern fn g_data_output_stream_get_byte_order(stream: [*c]GDataOutputStream) GDataStreamByteOrder;
pub extern fn g_data_output_stream_put_byte(stream: [*c]GDataOutputStream, data: guchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_int16(stream: [*c]GDataOutputStream, data: gint16, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_uint16(stream: [*c]GDataOutputStream, data: guint16, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_int32(stream: [*c]GDataOutputStream, data: gint32, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_uint32(stream: [*c]GDataOutputStream, data: guint32, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_int64(stream: [*c]GDataOutputStream, data: gint64, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_uint64(stream: [*c]GDataOutputStream, data: guint64, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_data_output_stream_put_string(stream: [*c]GDataOutputStream, str: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_action_group_get_type() GType;
pub extern fn g_dbus_action_group_get(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar) ?*GDBusActionGroup;
pub extern fn g_dbus_address_escape_value(string: [*c]const gchar) [*c]gchar;
pub extern fn g_dbus_is_address(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_supported_address(string: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_address_get_stream(address: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_address_get_stream_finish(res: ?*GAsyncResult, out_guid: [*c][*c]gchar, @"error": [*c][*c]GError) [*c]GIOStream;
pub extern fn g_dbus_address_get_stream_sync(address: [*c]const gchar, out_guid: [*c][*c]gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GIOStream;
pub extern fn g_dbus_address_get_for_bus_sync(bus_type: GBusType, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_dbus_auth_observer_get_type() GType;
pub extern fn g_dbus_auth_observer_new() ?*GDBusAuthObserver;
pub extern fn g_dbus_auth_observer_authorize_authenticated_peer(observer: ?*GDBusAuthObserver, stream: [*c]GIOStream, credentials: ?*GCredentials) gboolean;
pub extern fn g_dbus_auth_observer_allow_mechanism(observer: ?*GDBusAuthObserver, mechanism: [*c]const gchar) gboolean;
pub extern fn g_dbus_connection_get_type() GType;
pub extern fn g_bus_get(bus_type: GBusType, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_bus_get_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GDBusConnection;
pub extern fn g_bus_get_sync(bus_type: GBusType, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusConnection;
pub extern fn g_dbus_connection_new(stream: [*c]GIOStream, guid: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_new_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GDBusConnection;
pub extern fn g_dbus_connection_new_sync(stream: [*c]GIOStream, guid: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusConnection;
pub extern fn g_dbus_connection_new_for_address(address: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_new_for_address_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GDBusConnection;
pub extern fn g_dbus_connection_new_for_address_sync(address: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusConnection;
pub extern fn g_dbus_connection_start_message_processing(connection: ?*GDBusConnection) void;
pub extern fn g_dbus_connection_is_closed(connection: ?*GDBusConnection) gboolean;
pub extern fn g_dbus_connection_get_stream(connection: ?*GDBusConnection) [*c]GIOStream;
pub extern fn g_dbus_connection_get_guid(connection: ?*GDBusConnection) [*c]const gchar;
pub extern fn g_dbus_connection_get_unique_name(connection: ?*GDBusConnection) [*c]const gchar;
pub extern fn g_dbus_connection_get_peer_credentials(connection: ?*GDBusConnection) ?*GCredentials;
pub extern fn g_dbus_connection_get_last_serial(connection: ?*GDBusConnection) guint32;
pub extern fn g_dbus_connection_get_exit_on_close(connection: ?*GDBusConnection) gboolean;
pub extern fn g_dbus_connection_set_exit_on_close(connection: ?*GDBusConnection, exit_on_close: gboolean) void;
pub extern fn g_dbus_connection_get_capabilities(connection: ?*GDBusConnection) GDBusCapabilityFlags;
pub extern fn g_dbus_connection_get_flags(connection: ?*GDBusConnection) GDBusConnectionFlags;
pub extern fn g_dbus_connection_close(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_close_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_connection_close_sync(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_connection_flush(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_flush_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_connection_flush_sync(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_connection_send_message(connection: ?*GDBusConnection, message: ?*GDBusMessage, flags: GDBusSendMessageFlags, out_serial: [*c]volatile guint32, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_connection_send_message_with_reply(connection: ?*GDBusConnection, message: ?*GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: gint, out_serial: [*c]volatile guint32, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_send_message_with_reply_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GDBusMessage;
pub extern fn g_dbus_connection_send_message_with_reply_sync(connection: ?*GDBusConnection, message: ?*GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: gint, out_serial: [*c]volatile guint32, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusMessage;
pub extern fn g_dbus_connection_emit_signal(connection: ?*GDBusConnection, destination_bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, signal_name: [*c]const gchar, parameters: ?*GVariant, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_connection_call(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_call_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_connection_call_sync(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_connection_call_with_unix_fd_list(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, fd_list: [*c]GUnixFDList, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_call_with_unix_fd_list_finish(connection: ?*GDBusConnection, out_fd_list: [*c][*c]GUnixFDList, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_connection_call_with_unix_fd_list_sync(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, fd_list: [*c]GUnixFDList, out_fd_list: [*c][*c]GUnixFDList, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_connection_register_object(connection: ?*GDBusConnection, object_path: [*c]const gchar, interface_info: [*c]GDBusInterfaceInfo, vtable: [*c]const GDBusInterfaceVTable, user_data: gpointer, user_data_free_func: GDestroyNotify, @"error": [*c][*c]GError) guint;
pub extern fn g_dbus_connection_register_object_with_closures(connection: ?*GDBusConnection, object_path: [*c]const gchar, interface_info: [*c]GDBusInterfaceInfo, method_call_closure: ?*GClosure, get_property_closure: ?*GClosure, set_property_closure: ?*GClosure, @"error": [*c][*c]GError) guint;
pub extern fn g_dbus_connection_unregister_object(connection: ?*GDBusConnection, registration_id: guint) gboolean;
pub extern fn g_dbus_connection_register_subtree(connection: ?*GDBusConnection, object_path: [*c]const gchar, vtable: [*c]const GDBusSubtreeVTable, flags: GDBusSubtreeFlags, user_data: gpointer, user_data_free_func: GDestroyNotify, @"error": [*c][*c]GError) guint;
pub extern fn g_dbus_connection_unregister_subtree(connection: ?*GDBusConnection, registration_id: guint) gboolean;
pub const GDBusSignalCallback = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, ?*GVariant, gpointer) callconv(.C) void;
pub extern fn g_dbus_connection_signal_subscribe(connection: ?*GDBusConnection, sender: [*c]const gchar, interface_name: [*c]const gchar, member: [*c]const gchar, object_path: [*c]const gchar, arg0: [*c]const gchar, flags: GDBusSignalFlags, callback: GDBusSignalCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_dbus_connection_signal_unsubscribe(connection: ?*GDBusConnection, subscription_id: guint) void;
pub const GDBusMessageFilterFunction = ?*const fn (?*GDBusConnection, ?*GDBusMessage, gboolean, gpointer) callconv(.C) ?*GDBusMessage;
pub extern fn g_dbus_connection_add_filter(connection: ?*GDBusConnection, filter_function: GDBusMessageFilterFunction, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_dbus_connection_remove_filter(connection: ?*GDBusConnection, filter_id: guint) void;
pub extern fn g_dbus_error_quark() GQuark;
pub extern fn g_dbus_error_is_remote_error(@"error": [*c]const GError) gboolean;
pub extern fn g_dbus_error_get_remote_error(@"error": [*c]const GError) [*c]gchar;
pub extern fn g_dbus_error_strip_remote_error(@"error": [*c]GError) gboolean;
pub extern fn g_dbus_error_register_error(error_domain: GQuark, error_code: gint, dbus_error_name: [*c]const gchar) gboolean;
pub extern fn g_dbus_error_unregister_error(error_domain: GQuark, error_code: gint, dbus_error_name: [*c]const gchar) gboolean;
pub extern fn g_dbus_error_register_error_domain(error_domain_quark_name: [*c]const gchar, quark_volatile: [*c]volatile gsize, entries: [*c]const GDBusErrorEntry, num_entries: guint) void;
pub extern fn g_dbus_error_new_for_dbus_error(dbus_error_name: [*c]const gchar, dbus_error_message: [*c]const gchar) [*c]GError;
pub extern fn g_dbus_error_set_dbus_error(@"error": [*c][*c]GError, dbus_error_name: [*c]const gchar, dbus_error_message: [*c]const gchar, format: [*c]const gchar, ...) void;
pub extern fn g_dbus_error_set_dbus_error_valist(@"error": [*c][*c]GError, dbus_error_name: [*c]const gchar, dbus_error_message: [*c]const gchar, format: [*c]const gchar, var_args: [*c]struct___va_list_tag) void;
pub extern fn g_dbus_error_encode_gerror(@"error": [*c]const GError) [*c]gchar;
pub const struct__GDBusInterfaceIface = extern struct {
    parent_iface: GTypeInterface,
    get_info: ?*const fn (?*GDBusInterface) callconv(.C) [*c]GDBusInterfaceInfo,
    get_object: ?*const fn (?*GDBusInterface) callconv(.C) ?*GDBusObject,
    set_object: ?*const fn (?*GDBusInterface, ?*GDBusObject) callconv(.C) void,
    dup_object: ?*const fn (?*GDBusInterface) callconv(.C) ?*GDBusObject,
};
pub const GDBusInterfaceIface = struct__GDBusInterfaceIface;
pub extern fn g_dbus_interface_get_type() GType;
pub extern fn g_dbus_interface_get_info(interface_: ?*GDBusInterface) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_interface_get_object(interface_: ?*GDBusInterface) ?*GDBusObject;
pub extern fn g_dbus_interface_set_object(interface_: ?*GDBusInterface, object: ?*GDBusObject) void;
pub extern fn g_dbus_interface_dup_object(interface_: ?*GDBusInterface) ?*GDBusObject;
pub const struct__GDBusInterfaceSkeletonClass = extern struct {
    parent_class: GObjectClass,
    get_info: ?*const fn ([*c]GDBusInterfaceSkeleton) callconv(.C) [*c]GDBusInterfaceInfo,
    get_vtable: ?*const fn ([*c]GDBusInterfaceSkeleton) callconv(.C) [*c]GDBusInterfaceVTable,
    get_properties: ?*const fn ([*c]GDBusInterfaceSkeleton) callconv(.C) ?*GVariant,
    flush: ?*const fn ([*c]GDBusInterfaceSkeleton) callconv(.C) void,
    vfunc_padding: [8]gpointer,
    g_authorize_method: ?*const fn ([*c]GDBusInterfaceSkeleton, ?*GDBusMethodInvocation) callconv(.C) gboolean,
    signal_padding: [8]gpointer,
};
pub const GDBusInterfaceSkeletonClass = struct__GDBusInterfaceSkeletonClass;
pub extern fn g_dbus_interface_skeleton_get_type() GType;
pub extern fn g_dbus_interface_skeleton_get_flags(interface_: [*c]GDBusInterfaceSkeleton) GDBusInterfaceSkeletonFlags;
pub extern fn g_dbus_interface_skeleton_set_flags(interface_: [*c]GDBusInterfaceSkeleton, flags: GDBusInterfaceSkeletonFlags) void;
pub extern fn g_dbus_interface_skeleton_get_info(interface_: [*c]GDBusInterfaceSkeleton) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_interface_skeleton_get_vtable(interface_: [*c]GDBusInterfaceSkeleton) [*c]GDBusInterfaceVTable;
pub extern fn g_dbus_interface_skeleton_get_properties(interface_: [*c]GDBusInterfaceSkeleton) ?*GVariant;
pub extern fn g_dbus_interface_skeleton_flush(interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_interface_skeleton_export(interface_: [*c]GDBusInterfaceSkeleton, connection: ?*GDBusConnection, object_path: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_interface_skeleton_unexport(interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_interface_skeleton_unexport_from_connection(interface_: [*c]GDBusInterfaceSkeleton, connection: ?*GDBusConnection) void;
pub extern fn g_dbus_interface_skeleton_get_connection(interface_: [*c]GDBusInterfaceSkeleton) ?*GDBusConnection;
pub extern fn g_dbus_interface_skeleton_get_connections(interface_: [*c]GDBusInterfaceSkeleton) [*c]GList;
pub extern fn g_dbus_interface_skeleton_has_connection(interface_: [*c]GDBusInterfaceSkeleton, connection: ?*GDBusConnection) gboolean;
pub extern fn g_dbus_interface_skeleton_get_object_path(interface_: [*c]GDBusInterfaceSkeleton) [*c]const gchar;
pub extern fn g_dbus_annotation_info_lookup(annotations: [*c][*c]GDBusAnnotationInfo, name: [*c]const gchar) [*c]const gchar;
pub extern fn g_dbus_interface_info_lookup_method(info: [*c]GDBusInterfaceInfo, name: [*c]const gchar) [*c]GDBusMethodInfo;
pub extern fn g_dbus_interface_info_lookup_signal(info: [*c]GDBusInterfaceInfo, name: [*c]const gchar) [*c]GDBusSignalInfo;
pub extern fn g_dbus_interface_info_lookup_property(info: [*c]GDBusInterfaceInfo, name: [*c]const gchar) [*c]GDBusPropertyInfo;
pub extern fn g_dbus_interface_info_cache_build(info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_interface_info_cache_release(info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_interface_info_generate_xml(info: [*c]GDBusInterfaceInfo, indent: guint, string_builder: [*c]GString) void;
pub extern fn g_dbus_node_info_new_for_xml(xml_data: [*c]const gchar, @"error": [*c][*c]GError) [*c]GDBusNodeInfo;
pub extern fn g_dbus_node_info_lookup_interface(info: [*c]GDBusNodeInfo, name: [*c]const gchar) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_node_info_generate_xml(info: [*c]GDBusNodeInfo, indent: guint, string_builder: [*c]GString) void;
pub extern fn g_dbus_node_info_ref(info: [*c]GDBusNodeInfo) [*c]GDBusNodeInfo;
pub extern fn g_dbus_interface_info_ref(info: [*c]GDBusInterfaceInfo) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_method_info_ref(info: [*c]GDBusMethodInfo) [*c]GDBusMethodInfo;
pub extern fn g_dbus_signal_info_ref(info: [*c]GDBusSignalInfo) [*c]GDBusSignalInfo;
pub extern fn g_dbus_property_info_ref(info: [*c]GDBusPropertyInfo) [*c]GDBusPropertyInfo;
pub extern fn g_dbus_arg_info_ref(info: [*c]GDBusArgInfo) [*c]GDBusArgInfo;
pub extern fn g_dbus_annotation_info_ref(info: [*c]GDBusAnnotationInfo) [*c]GDBusAnnotationInfo;
pub extern fn g_dbus_node_info_unref(info: [*c]GDBusNodeInfo) void;
pub extern fn g_dbus_interface_info_unref(info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_method_info_unref(info: [*c]GDBusMethodInfo) void;
pub extern fn g_dbus_signal_info_unref(info: [*c]GDBusSignalInfo) void;
pub extern fn g_dbus_property_info_unref(info: [*c]GDBusPropertyInfo) void;
pub extern fn g_dbus_arg_info_unref(info: [*c]GDBusArgInfo) void;
pub extern fn g_dbus_annotation_info_unref(info: [*c]GDBusAnnotationInfo) void;
pub extern fn g_dbus_node_info_get_type() GType;
pub extern fn g_dbus_interface_info_get_type() GType;
pub extern fn g_dbus_method_info_get_type() GType;
pub extern fn g_dbus_signal_info_get_type() GType;
pub extern fn g_dbus_property_info_get_type() GType;
pub extern fn g_dbus_arg_info_get_type() GType;
pub extern fn g_dbus_annotation_info_get_type() GType;
pub const struct__GDBusMenuModel = opaque {};
pub const GDBusMenuModel = struct__GDBusMenuModel;
pub extern fn g_dbus_menu_model_get_type() GType;
pub extern fn g_dbus_menu_model_get(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar) ?*GDBusMenuModel;
pub extern fn g_dbus_message_get_type() GType;
pub extern fn g_dbus_message_new() ?*GDBusMessage;
pub extern fn g_dbus_message_new_signal(path: [*c]const gchar, interface_: [*c]const gchar, signal: [*c]const gchar) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_call(name: [*c]const gchar, path: [*c]const gchar, interface_: [*c]const gchar, method: [*c]const gchar) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_reply(method_call_message: ?*GDBusMessage) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_error(method_call_message: ?*GDBusMessage, error_name: [*c]const gchar, error_message_format: [*c]const gchar, ...) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_error_valist(method_call_message: ?*GDBusMessage, error_name: [*c]const gchar, error_message_format: [*c]const gchar, var_args: [*c]struct___va_list_tag) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_error_literal(method_call_message: ?*GDBusMessage, error_name: [*c]const gchar, error_message: [*c]const gchar) ?*GDBusMessage;
pub extern fn g_dbus_message_print(message: ?*GDBusMessage, indent: guint) [*c]gchar;
pub extern fn g_dbus_message_get_locked(message: ?*GDBusMessage) gboolean;
pub extern fn g_dbus_message_lock(message: ?*GDBusMessage) void;
pub extern fn g_dbus_message_copy(message: ?*GDBusMessage, @"error": [*c][*c]GError) ?*GDBusMessage;
pub extern fn g_dbus_message_get_byte_order(message: ?*GDBusMessage) GDBusMessageByteOrder;
pub extern fn g_dbus_message_set_byte_order(message: ?*GDBusMessage, byte_order: GDBusMessageByteOrder) void;
pub extern fn g_dbus_message_get_message_type(message: ?*GDBusMessage) GDBusMessageType;
pub extern fn g_dbus_message_set_message_type(message: ?*GDBusMessage, @"type": GDBusMessageType) void;
pub extern fn g_dbus_message_get_flags(message: ?*GDBusMessage) GDBusMessageFlags;
pub extern fn g_dbus_message_set_flags(message: ?*GDBusMessage, flags: GDBusMessageFlags) void;
pub extern fn g_dbus_message_get_serial(message: ?*GDBusMessage) guint32;
pub extern fn g_dbus_message_set_serial(message: ?*GDBusMessage, serial: guint32) void;
pub extern fn g_dbus_message_get_header(message: ?*GDBusMessage, header_field: GDBusMessageHeaderField) ?*GVariant;
pub extern fn g_dbus_message_set_header(message: ?*GDBusMessage, header_field: GDBusMessageHeaderField, value: ?*GVariant) void;
pub extern fn g_dbus_message_get_header_fields(message: ?*GDBusMessage) [*c]guchar;
pub extern fn g_dbus_message_get_body(message: ?*GDBusMessage) ?*GVariant;
pub extern fn g_dbus_message_set_body(message: ?*GDBusMessage, body: ?*GVariant) void;
pub extern fn g_dbus_message_get_unix_fd_list(message: ?*GDBusMessage) [*c]GUnixFDList;
pub extern fn g_dbus_message_set_unix_fd_list(message: ?*GDBusMessage, fd_list: [*c]GUnixFDList) void;
pub extern fn g_dbus_message_get_reply_serial(message: ?*GDBusMessage) guint32;
pub extern fn g_dbus_message_set_reply_serial(message: ?*GDBusMessage, value: guint32) void;
pub extern fn g_dbus_message_get_interface(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_interface(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_member(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_member(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_path(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_path(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_sender(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_sender(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_destination(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_destination(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_error_name(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_error_name(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_signature(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_signature(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_num_unix_fds(message: ?*GDBusMessage) guint32;
pub extern fn g_dbus_message_set_num_unix_fds(message: ?*GDBusMessage, value: guint32) void;
pub extern fn g_dbus_message_get_arg0(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_new_from_blob(blob: [*c]guchar, blob_len: gsize, capabilities: GDBusCapabilityFlags, @"error": [*c][*c]GError) ?*GDBusMessage;
pub extern fn g_dbus_message_bytes_needed(blob: [*c]guchar, blob_len: gsize, @"error": [*c][*c]GError) gssize;
pub extern fn g_dbus_message_to_blob(message: ?*GDBusMessage, out_size: [*c]gsize, capabilities: GDBusCapabilityFlags, @"error": [*c][*c]GError) [*c]guchar;
pub extern fn g_dbus_message_to_gerror(message: ?*GDBusMessage, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dbus_method_invocation_get_type() GType;
pub extern fn g_dbus_method_invocation_get_sender(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_object_path(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_interface_name(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_method_name(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_method_info(invocation: ?*GDBusMethodInvocation) [*c]const GDBusMethodInfo;
pub extern fn g_dbus_method_invocation_get_property_info(invocation: ?*GDBusMethodInvocation) [*c]const GDBusPropertyInfo;
pub extern fn g_dbus_method_invocation_get_connection(invocation: ?*GDBusMethodInvocation) ?*GDBusConnection;
pub extern fn g_dbus_method_invocation_get_message(invocation: ?*GDBusMethodInvocation) ?*GDBusMessage;
pub extern fn g_dbus_method_invocation_get_parameters(invocation: ?*GDBusMethodInvocation) ?*GVariant;
pub extern fn g_dbus_method_invocation_get_user_data(invocation: ?*GDBusMethodInvocation) gpointer;
pub extern fn g_dbus_method_invocation_return_value(invocation: ?*GDBusMethodInvocation, parameters: ?*GVariant) void;
pub extern fn g_dbus_method_invocation_return_value_with_unix_fd_list(invocation: ?*GDBusMethodInvocation, parameters: ?*GVariant, fd_list: [*c]GUnixFDList) void;
pub extern fn g_dbus_method_invocation_return_error(invocation: ?*GDBusMethodInvocation, domain: GQuark, code: gint, format: [*c]const gchar, ...) void;
pub extern fn g_dbus_method_invocation_return_error_valist(invocation: ?*GDBusMethodInvocation, domain: GQuark, code: gint, format: [*c]const gchar, var_args: [*c]struct___va_list_tag) void;
pub extern fn g_dbus_method_invocation_return_error_literal(invocation: ?*GDBusMethodInvocation, domain: GQuark, code: gint, message: [*c]const gchar) void;
pub extern fn g_dbus_method_invocation_return_gerror(invocation: ?*GDBusMethodInvocation, @"error": [*c]const GError) void;
pub extern fn g_dbus_method_invocation_take_error(invocation: ?*GDBusMethodInvocation, @"error": [*c]GError) void;
pub extern fn g_dbus_method_invocation_return_dbus_error(invocation: ?*GDBusMethodInvocation, error_name: [*c]const gchar, error_message: [*c]const gchar) void;
pub const GBusAcquiredCallback = ?*const fn (?*GDBusConnection, [*c]const gchar, gpointer) callconv(.C) void;
pub const GBusNameAcquiredCallback = ?*const fn (?*GDBusConnection, [*c]const gchar, gpointer) callconv(.C) void;
pub const GBusNameLostCallback = ?*const fn (?*GDBusConnection, [*c]const gchar, gpointer) callconv(.C) void;
pub extern fn g_bus_own_name(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameOwnerFlags, bus_acquired_handler: GBusAcquiredCallback, name_acquired_handler: GBusNameAcquiredCallback, name_lost_handler: GBusNameLostCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_own_name_on_connection(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameOwnerFlags, name_acquired_handler: GBusNameAcquiredCallback, name_lost_handler: GBusNameLostCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_own_name_with_closures(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameOwnerFlags, bus_acquired_closure: ?*GClosure, name_acquired_closure: ?*GClosure, name_lost_closure: ?*GClosure) guint;
pub extern fn g_bus_own_name_on_connection_with_closures(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameOwnerFlags, name_acquired_closure: ?*GClosure, name_lost_closure: ?*GClosure) guint;
pub extern fn g_bus_unown_name(owner_id: guint) void;
pub const GBusNameAppearedCallback = ?*const fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, gpointer) callconv(.C) void;
pub const GBusNameVanishedCallback = ?*const fn (?*GDBusConnection, [*c]const gchar, gpointer) callconv(.C) void;
pub extern fn g_bus_watch_name(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_handler: GBusNameAppearedCallback, name_vanished_handler: GBusNameVanishedCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_watch_name_on_connection(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_handler: GBusNameAppearedCallback, name_vanished_handler: GBusNameVanishedCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_watch_name_with_closures(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_closure: ?*GClosure, name_vanished_closure: ?*GClosure) guint;
pub extern fn g_bus_watch_name_on_connection_with_closures(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_closure: ?*GClosure, name_vanished_closure: ?*GClosure) guint;
pub extern fn g_bus_unwatch_name(watcher_id: guint) void;
pub const struct__GDBusObjectIface = extern struct {
    parent_iface: GTypeInterface,
    get_object_path: ?*const fn (?*GDBusObject) callconv(.C) [*c]const gchar,
    get_interfaces: ?*const fn (?*GDBusObject) callconv(.C) [*c]GList,
    get_interface: ?*const fn (?*GDBusObject, [*c]const gchar) callconv(.C) ?*GDBusInterface,
    interface_added: ?*const fn (?*GDBusObject, ?*GDBusInterface) callconv(.C) void,
    interface_removed: ?*const fn (?*GDBusObject, ?*GDBusInterface) callconv(.C) void,
};
pub const GDBusObjectIface = struct__GDBusObjectIface;
pub extern fn g_dbus_object_get_type() GType;
pub extern fn g_dbus_object_get_object_path(object: ?*GDBusObject) [*c]const gchar;
pub extern fn g_dbus_object_get_interfaces(object: ?*GDBusObject) [*c]GList;
pub extern fn g_dbus_object_get_interface(object: ?*GDBusObject, interface_name: [*c]const gchar) ?*GDBusInterface;
pub const struct__GDBusObjectManagerIface = extern struct {
    parent_iface: GTypeInterface,
    get_object_path: ?*const fn (?*GDBusObjectManager) callconv(.C) [*c]const gchar,
    get_objects: ?*const fn (?*GDBusObjectManager) callconv(.C) [*c]GList,
    get_object: ?*const fn (?*GDBusObjectManager, [*c]const gchar) callconv(.C) ?*GDBusObject,
    get_interface: ?*const fn (?*GDBusObjectManager, [*c]const gchar, [*c]const gchar) callconv(.C) ?*GDBusInterface,
    object_added: ?*const fn (?*GDBusObjectManager, ?*GDBusObject) callconv(.C) void,
    object_removed: ?*const fn (?*GDBusObjectManager, ?*GDBusObject) callconv(.C) void,
    interface_added: ?*const fn (?*GDBusObjectManager, ?*GDBusObject, ?*GDBusInterface) callconv(.C) void,
    interface_removed: ?*const fn (?*GDBusObjectManager, ?*GDBusObject, ?*GDBusInterface) callconv(.C) void,
};
pub const GDBusObjectManagerIface = struct__GDBusObjectManagerIface;
pub extern fn g_dbus_object_manager_get_type() GType;
pub extern fn g_dbus_object_manager_get_object_path(manager: ?*GDBusObjectManager) [*c]const gchar;
pub extern fn g_dbus_object_manager_get_objects(manager: ?*GDBusObjectManager) [*c]GList;
pub extern fn g_dbus_object_manager_get_object(manager: ?*GDBusObjectManager, object_path: [*c]const gchar) ?*GDBusObject;
pub extern fn g_dbus_object_manager_get_interface(manager: ?*GDBusObjectManager, object_path: [*c]const gchar, interface_name: [*c]const gchar) ?*GDBusInterface;
pub const struct__GDBusObjectManagerClientClass = extern struct {
    parent_class: GObjectClass,
    interface_proxy_signal: ?*const fn ([*c]GDBusObjectManagerClient, [*c]GDBusObjectProxy, [*c]GDBusProxy, [*c]const gchar, [*c]const gchar, ?*GVariant) callconv(.C) void,
    interface_proxy_properties_changed: ?*const fn ([*c]GDBusObjectManagerClient, [*c]GDBusObjectProxy, [*c]GDBusProxy, ?*GVariant, [*c]const [*c]const gchar) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GDBusObjectManagerClientClass = struct__GDBusObjectManagerClientClass;
pub extern fn g_dbus_object_manager_client_get_type() GType;
pub extern fn g_dbus_object_manager_client_new(connection: ?*GDBusConnection, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_object_manager_client_new_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_new_sync(connection: ?*GDBusConnection, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_new_for_bus(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_object_manager_client_new_for_bus_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_new_for_bus_sync(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_get_connection(manager: [*c]GDBusObjectManagerClient) ?*GDBusConnection;
pub extern fn g_dbus_object_manager_client_get_flags(manager: [*c]GDBusObjectManagerClient) GDBusObjectManagerClientFlags;
pub extern fn g_dbus_object_manager_client_get_name(manager: [*c]GDBusObjectManagerClient) [*c]const gchar;
pub extern fn g_dbus_object_manager_client_get_name_owner(manager: [*c]GDBusObjectManagerClient) [*c]gchar;
pub const struct__GDBusObjectManagerServerClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GDBusObjectManagerServerClass = struct__GDBusObjectManagerServerClass;
pub extern fn g_dbus_object_manager_server_get_type() GType;
pub extern fn g_dbus_object_manager_server_new(object_path: [*c]const gchar) [*c]GDBusObjectManagerServer;
pub extern fn g_dbus_object_manager_server_get_connection(manager: [*c]GDBusObjectManagerServer) ?*GDBusConnection;
pub extern fn g_dbus_object_manager_server_set_connection(manager: [*c]GDBusObjectManagerServer, connection: ?*GDBusConnection) void;
pub extern fn g_dbus_object_manager_server_export(manager: [*c]GDBusObjectManagerServer, object: [*c]GDBusObjectSkeleton) void;
pub extern fn g_dbus_object_manager_server_export_uniquely(manager: [*c]GDBusObjectManagerServer, object: [*c]GDBusObjectSkeleton) void;
pub extern fn g_dbus_object_manager_server_is_exported(manager: [*c]GDBusObjectManagerServer, object: [*c]GDBusObjectSkeleton) gboolean;
pub extern fn g_dbus_object_manager_server_unexport(manager: [*c]GDBusObjectManagerServer, object_path: [*c]const gchar) gboolean;
pub const struct__GDBusObjectProxyClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GDBusObjectProxyClass = struct__GDBusObjectProxyClass;
pub extern fn g_dbus_object_proxy_get_type() GType;
pub extern fn g_dbus_object_proxy_new(connection: ?*GDBusConnection, object_path: [*c]const gchar) [*c]GDBusObjectProxy;
pub extern fn g_dbus_object_proxy_get_connection(proxy: [*c]GDBusObjectProxy) ?*GDBusConnection;
pub const struct__GDBusObjectSkeletonClass = extern struct {
    parent_class: GObjectClass,
    authorize_method: ?*const fn ([*c]GDBusObjectSkeleton, [*c]GDBusInterfaceSkeleton, ?*GDBusMethodInvocation) callconv(.C) gboolean,
    padding: [8]gpointer,
};
pub const GDBusObjectSkeletonClass = struct__GDBusObjectSkeletonClass;
pub extern fn g_dbus_object_skeleton_get_type() GType;
pub extern fn g_dbus_object_skeleton_new(object_path: [*c]const gchar) [*c]GDBusObjectSkeleton;
pub extern fn g_dbus_object_skeleton_flush(object: [*c]GDBusObjectSkeleton) void;
pub extern fn g_dbus_object_skeleton_add_interface(object: [*c]GDBusObjectSkeleton, interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_object_skeleton_remove_interface(object: [*c]GDBusObjectSkeleton, interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_object_skeleton_remove_interface_by_name(object: [*c]GDBusObjectSkeleton, interface_name: [*c]const gchar) void;
pub extern fn g_dbus_object_skeleton_set_object_path(object: [*c]GDBusObjectSkeleton, object_path: [*c]const gchar) void;
pub const struct__GDBusProxyClass = extern struct {
    parent_class: GObjectClass,
    g_properties_changed: ?*const fn ([*c]GDBusProxy, ?*GVariant, [*c]const [*c]const gchar) callconv(.C) void,
    g_signal: ?*const fn ([*c]GDBusProxy, [*c]const gchar, [*c]const gchar, ?*GVariant) callconv(.C) void,
    padding: [32]gpointer,
};
pub const GDBusProxyClass = struct__GDBusProxyClass;
pub extern fn g_dbus_proxy_get_type() GType;
pub extern fn g_dbus_proxy_new(connection: ?*GDBusConnection, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_new_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_new_sync(connection: ?*GDBusConnection, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_new_for_bus(bus_type: GBusType, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_new_for_bus_finish(res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_new_for_bus_sync(bus_type: GBusType, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_get_connection(proxy: [*c]GDBusProxy) ?*GDBusConnection;
pub extern fn g_dbus_proxy_get_flags(proxy: [*c]GDBusProxy) GDBusProxyFlags;
pub extern fn g_dbus_proxy_get_name(proxy: [*c]GDBusProxy) [*c]const gchar;
pub extern fn g_dbus_proxy_get_name_owner(proxy: [*c]GDBusProxy) [*c]gchar;
pub extern fn g_dbus_proxy_get_object_path(proxy: [*c]GDBusProxy) [*c]const gchar;
pub extern fn g_dbus_proxy_get_interface_name(proxy: [*c]GDBusProxy) [*c]const gchar;
pub extern fn g_dbus_proxy_get_default_timeout(proxy: [*c]GDBusProxy) gint;
pub extern fn g_dbus_proxy_set_default_timeout(proxy: [*c]GDBusProxy, timeout_msec: gint) void;
pub extern fn g_dbus_proxy_get_interface_info(proxy: [*c]GDBusProxy) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_proxy_set_interface_info(proxy: [*c]GDBusProxy, info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_proxy_get_cached_property(proxy: [*c]GDBusProxy, property_name: [*c]const gchar) ?*GVariant;
pub extern fn g_dbus_proxy_set_cached_property(proxy: [*c]GDBusProxy, property_name: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_dbus_proxy_get_cached_property_names(proxy: [*c]GDBusProxy) [*c][*c]gchar;
pub extern fn g_dbus_proxy_call(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_call_finish(proxy: [*c]GDBusProxy, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_proxy_call_sync(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_proxy_call_with_unix_fd_list(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, fd_list: [*c]GUnixFDList, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_call_with_unix_fd_list_finish(proxy: [*c]GDBusProxy, out_fd_list: [*c][*c]GUnixFDList, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_proxy_call_with_unix_fd_list_sync(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, fd_list: [*c]GUnixFDList, out_fd_list: [*c][*c]GUnixFDList, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GVariant;
pub extern fn g_dbus_server_get_type() GType;
pub extern fn g_dbus_server_new_sync(address: [*c]const gchar, flags: GDBusServerFlags, guid: [*c]const gchar, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GDBusServer;
pub extern fn g_dbus_server_get_client_address(server: ?*GDBusServer) [*c]const gchar;
pub extern fn g_dbus_server_get_guid(server: ?*GDBusServer) [*c]const gchar;
pub extern fn g_dbus_server_get_flags(server: ?*GDBusServer) GDBusServerFlags;
pub extern fn g_dbus_server_start(server: ?*GDBusServer) void;
pub extern fn g_dbus_server_stop(server: ?*GDBusServer) void;
pub extern fn g_dbus_server_is_active(server: ?*GDBusServer) gboolean;
pub extern fn g_dbus_is_guid(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_generate_guid() [*c]gchar;
pub extern fn g_dbus_is_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_unique_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_member_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_interface_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_error_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_gvariant_to_gvalue(value: ?*GVariant, out_gvalue: [*c]GValue) void;
pub extern fn g_dbus_gvalue_to_gvariant(gvalue: [*c]const GValue, @"type": ?*const GVariantType) ?*GVariant;
pub extern fn g_dbus_escape_object_path_bytestring(bytes: [*c]const guint8) [*c]gchar;
pub extern fn g_dbus_escape_object_path(s: [*c]const gchar) [*c]gchar;
pub extern fn g_dbus_unescape_object_path(s: [*c]const gchar) [*c]guint8;
pub extern fn g_debug_controller_get_type() GType;
pub const struct__GDebugController = opaque {};
pub const GDebugController = struct__GDebugController;
pub const struct__GDebugControllerInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GDebugControllerInterface = struct__GDebugControllerInterface;
pub const GDebugController_autoptr = ?*GDebugController;
pub const GDebugController_listautoptr = [*c]GList;
pub const GDebugController_slistautoptr = [*c]GSList;
pub const GDebugController_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDebugController(arg__ptr: ?*GDebugController) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GDebugController(arg__ptr: [*c]?*GDebugController) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDebugController(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDebugController(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GDebugController(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GDebugController(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn g_debug_controller(arg_ptr: gpointer) callconv(.C) ?*GDebugController {
    var ptr = arg_ptr;
    return @as(?*GDebugController, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), g_debug_controller_get_type())))));
}
pub fn g_IS_debug_controller(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_debug_controller_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn g_debug_controller_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GDebugControllerInterface {
    var ptr = arg_ptr;
    return @as([*c]GDebugControllerInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), g_debug_controller_get_type()))));
}
pub extern fn g_debug_controller_get_debug_enabled(self: ?*GDebugController) gboolean;
pub extern fn g_debug_controller_set_debug_enabled(self: ?*GDebugController, debug_enabled: gboolean) void;
pub extern fn g_debug_controller_dbus_get_type() GType;
pub const struct__GDebugControllerDBus = extern struct {
    parent_instance: GObject,
};
pub const GDebugControllerDBus = struct__GDebugControllerDBus;
pub const struct__GDebugControllerDBusClass = extern struct {
    parent_class: GObjectClass,
    authorize: ?*const fn ([*c]GDebugControllerDBus, ?*GDBusMethodInvocation) callconv(.C) gboolean,
    padding: [12]gpointer,
};
pub const GDebugControllerDBusClass = struct__GDebugControllerDBusClass;
pub const GDebugControllerDBus_autoptr = [*c]GDebugControllerDBus;
pub const GDebugControllerDBus_listautoptr = [*c]GList;
pub const GDebugControllerDBus_slistautoptr = [*c]GSList;
pub const GDebugControllerDBus_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDebugControllerDBus(arg__ptr: [*c]GDebugControllerDBus) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GDebugControllerDBus(arg__ptr: [*c][*c]GDebugControllerDBus) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDebugControllerDBus(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDebugControllerDBus(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GDebugControllerDBus(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GDebugControllerDBus(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GDebugControllerDBusClass_autoptr = [*c]GDebugControllerDBusClass;
pub const GDebugControllerDBusClass_listautoptr = [*c]GList;
pub const GDebugControllerDBusClass_slistautoptr = [*c]GSList;
pub const GDebugControllerDBusClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDebugControllerDBusClass(arg__ptr: [*c]GDebugControllerDBusClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDebugControllerDBusClass(arg__ptr: [*c][*c]GDebugControllerDBusClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDebugControllerDBusClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDebugControllerDBusClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDebugControllerDBusClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDebugControllerDBusClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn G_DEBUG_CONTROLLER_DBUS(arg_ptr: gpointer) callconv(.C) [*c]GDebugControllerDBus {
    var ptr = arg_ptr;
    return @as([*c]GDebugControllerDBus, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), g_debug_controller_dbus_get_type()))))));
}
pub fn G_DEBUG_CONTROLLER_DBUS_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GDebugControllerDBusClass {
    var ptr = arg_ptr;
    return @as([*c]GDebugControllerDBusClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), g_debug_controller_dbus_get_type()))))));
}
pub fn G_IS_DEBUG_CONTROLLER_DBUS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_debug_controller_dbus_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn G_IS_DEBUG_CONTROLLER_DBUS_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_debug_controller_dbus_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn G_DEBUG_CONTROLLER_DBUS_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GDebugControllerDBusClass {
    var ptr = arg_ptr;
    return @as([*c]GDebugControllerDBusClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn g_debug_controller_dbus_new(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GDebugControllerDBus;
pub extern fn g_debug_controller_dbus_stop(self: [*c]GDebugControllerDBus) void;
pub const struct__GDriveIface = extern struct {
    g_iface: GTypeInterface,
    changed: ?*const fn (?*GDrive) callconv(.C) void,
    disconnected: ?*const fn (?*GDrive) callconv(.C) void,
    eject_button: ?*const fn (?*GDrive) callconv(.C) void,
    get_name: ?*const fn (?*GDrive) callconv(.C) [*c]u8,
    get_icon: ?*const fn (?*GDrive) callconv(.C) ?*GIcon,
    has_volumes: ?*const fn (?*GDrive) callconv(.C) gboolean,
    get_volumes: ?*const fn (?*GDrive) callconv(.C) [*c]GList,
    is_media_removable: ?*const fn (?*GDrive) callconv(.C) gboolean,
    has_media: ?*const fn (?*GDrive) callconv(.C) gboolean,
    is_media_check_automatic: ?*const fn (?*GDrive) callconv(.C) gboolean,
    can_eject: ?*const fn (?*GDrive) callconv(.C) gboolean,
    can_poll_for_media: ?*const fn (?*GDrive) callconv(.C) gboolean,
    eject: ?*const fn (?*GDrive, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_finish: ?*const fn (?*GDrive, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    poll_for_media: ?*const fn (?*GDrive, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    poll_for_media_finish: ?*const fn (?*GDrive, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_identifier: ?*const fn (?*GDrive, [*c]const u8) callconv(.C) [*c]u8,
    enumerate_identifiers: ?*const fn (?*GDrive) callconv(.C) [*c][*c]u8,
    get_start_stop_type: ?*const fn (?*GDrive) callconv(.C) GDriveStartStopType,
    can_start: ?*const fn (?*GDrive) callconv(.C) gboolean,
    can_start_degraded: ?*const fn (?*GDrive) callconv(.C) gboolean,
    start: ?*const fn (?*GDrive, GDriveStartFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    start_finish: ?*const fn (?*GDrive, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    can_stop: ?*const fn (?*GDrive) callconv(.C) gboolean,
    stop: ?*const fn (?*GDrive, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    stop_finish: ?*const fn (?*GDrive, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    stop_button: ?*const fn (?*GDrive) callconv(.C) void,
    eject_with_operation: ?*const fn (?*GDrive, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_with_operation_finish: ?*const fn (?*GDrive, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_sort_key: ?*const fn (?*GDrive) callconv(.C) [*c]const gchar,
    get_symbolic_icon: ?*const fn (?*GDrive) callconv(.C) ?*GIcon,
    is_removable: ?*const fn (?*GDrive) callconv(.C) gboolean,
};
pub const GDriveIface = struct__GDriveIface;
pub extern fn g_drive_get_type() GType;
pub extern fn g_drive_get_name(drive: ?*GDrive) [*c]u8;
pub extern fn g_drive_get_icon(drive: ?*GDrive) ?*GIcon;
pub extern fn g_drive_get_symbolic_icon(drive: ?*GDrive) ?*GIcon;
pub extern fn g_drive_has_volumes(drive: ?*GDrive) gboolean;
pub extern fn g_drive_get_volumes(drive: ?*GDrive) [*c]GList;
pub extern fn g_drive_is_removable(drive: ?*GDrive) gboolean;
pub extern fn g_drive_is_media_removable(drive: ?*GDrive) gboolean;
pub extern fn g_drive_has_media(drive: ?*GDrive) gboolean;
pub extern fn g_drive_is_media_check_automatic(drive: ?*GDrive) gboolean;
pub extern fn g_drive_can_poll_for_media(drive: ?*GDrive) gboolean;
pub extern fn g_drive_can_eject(drive: ?*GDrive) gboolean;
pub extern fn g_drive_eject(drive: ?*GDrive, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_eject_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_drive_poll_for_media(drive: ?*GDrive, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_poll_for_media_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_drive_get_identifier(drive: ?*GDrive, kind: [*c]const u8) [*c]u8;
pub extern fn g_drive_enumerate_identifiers(drive: ?*GDrive) [*c][*c]u8;
pub extern fn g_drive_get_start_stop_type(drive: ?*GDrive) GDriveStartStopType;
pub extern fn g_drive_can_start(drive: ?*GDrive) gboolean;
pub extern fn g_drive_can_start_degraded(drive: ?*GDrive) gboolean;
pub extern fn g_drive_start(drive: ?*GDrive, flags: GDriveStartFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_start_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_drive_can_stop(drive: ?*GDrive) gboolean;
pub extern fn g_drive_stop(drive: ?*GDrive, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_stop_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_drive_eject_with_operation(drive: ?*GDrive, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_eject_with_operation_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_drive_get_sort_key(drive: ?*GDrive) [*c]const gchar;
pub const struct__GDtlsConnectionInterface = extern struct {
    g_iface: GTypeInterface,
    accept_certificate: ?*const fn (?*GDtlsConnection, [*c]GTlsCertificate, GTlsCertificateFlags) callconv(.C) gboolean,
    handshake: ?*const fn (?*GDtlsConnection, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    handshake_async: ?*const fn (?*GDtlsConnection, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    handshake_finish: ?*const fn (?*GDtlsConnection, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    shutdown: ?*const fn (?*GDtlsConnection, gboolean, gboolean, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    shutdown_async: ?*const fn (?*GDtlsConnection, gboolean, gboolean, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    shutdown_finish: ?*const fn (?*GDtlsConnection, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    set_advertised_protocols: ?*const fn (?*GDtlsConnection, [*c]const [*c]const gchar) callconv(.C) void,
    get_negotiated_protocol: ?*const fn (?*GDtlsConnection) callconv(.C) [*c]const gchar,
    get_binding_data: ?*const fn (?*GDtlsConnection, GTlsChannelBindingType, [*c]GByteArray, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GDtlsConnectionInterface = struct__GDtlsConnectionInterface;
pub extern fn g_dtls_connection_get_type() GType;
pub extern fn g_dtls_connection_set_database(conn: ?*GDtlsConnection, database: [*c]GTlsDatabase) void;
pub extern fn g_dtls_connection_get_database(conn: ?*GDtlsConnection) [*c]GTlsDatabase;
pub extern fn g_dtls_connection_set_certificate(conn: ?*GDtlsConnection, certificate: [*c]GTlsCertificate) void;
pub extern fn g_dtls_connection_get_certificate(conn: ?*GDtlsConnection) [*c]GTlsCertificate;
pub extern fn g_dtls_connection_set_interaction(conn: ?*GDtlsConnection, interaction: [*c]GTlsInteraction) void;
pub extern fn g_dtls_connection_get_interaction(conn: ?*GDtlsConnection) [*c]GTlsInteraction;
pub extern fn g_dtls_connection_get_peer_certificate(conn: ?*GDtlsConnection) [*c]GTlsCertificate;
pub extern fn g_dtls_connection_get_peer_certificate_errors(conn: ?*GDtlsConnection) GTlsCertificateFlags;
pub extern fn g_dtls_connection_set_require_close_notify(conn: ?*GDtlsConnection, require_close_notify: gboolean) void;
pub extern fn g_dtls_connection_get_require_close_notify(conn: ?*GDtlsConnection) gboolean;
pub extern fn g_dtls_connection_set_rehandshake_mode(conn: ?*GDtlsConnection, mode: GTlsRehandshakeMode) void;
pub extern fn g_dtls_connection_get_rehandshake_mode(conn: ?*GDtlsConnection) GTlsRehandshakeMode;
pub extern fn g_dtls_connection_handshake(conn: ?*GDtlsConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_handshake_async(conn: ?*GDtlsConnection, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dtls_connection_handshake_finish(conn: ?*GDtlsConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_shutdown(conn: ?*GDtlsConnection, shutdown_read: gboolean, shutdown_write: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_shutdown_async(conn: ?*GDtlsConnection, shutdown_read: gboolean, shutdown_write: gboolean, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dtls_connection_shutdown_finish(conn: ?*GDtlsConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_close(conn: ?*GDtlsConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_close_async(conn: ?*GDtlsConnection, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dtls_connection_close_finish(conn: ?*GDtlsConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_emit_accept_certificate(conn: ?*GDtlsConnection, peer_cert: [*c]GTlsCertificate, errors: GTlsCertificateFlags) gboolean;
pub extern fn g_dtls_connection_set_advertised_protocols(conn: ?*GDtlsConnection, protocols: [*c]const [*c]const gchar) void;
pub extern fn g_dtls_connection_get_negotiated_protocol(conn: ?*GDtlsConnection) [*c]const gchar;
pub extern fn g_dtls_connection_get_channel_binding_data(conn: ?*GDtlsConnection, @"type": GTlsChannelBindingType, data: [*c]GByteArray, @"error": [*c][*c]GError) gboolean;
pub extern fn g_dtls_connection_get_protocol_version(conn: ?*GDtlsConnection) GTlsProtocolVersion;
pub extern fn g_dtls_connection_get_ciphersuite_name(conn: ?*GDtlsConnection) [*c]gchar;
pub const struct__GDtlsClientConnectionInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GDtlsClientConnectionInterface = struct__GDtlsClientConnectionInterface;
pub extern fn g_dtls_client_connection_get_type() GType;
pub extern fn g_dtls_client_connection_new(base_socket: ?*GDatagramBased, server_identity: ?*GSocketConnectable, @"error": [*c][*c]GError) ?*GDatagramBased;
pub extern fn g_dtls_client_connection_get_validation_flags(conn: ?*GDtlsClientConnection) GTlsCertificateFlags;
pub extern fn g_dtls_client_connection_set_validation_flags(conn: ?*GDtlsClientConnection, flags: GTlsCertificateFlags) void;
pub extern fn g_dtls_client_connection_get_server_identity(conn: ?*GDtlsClientConnection) ?*GSocketConnectable;
pub extern fn g_dtls_client_connection_set_server_identity(conn: ?*GDtlsClientConnection, identity: ?*GSocketConnectable) void;
pub extern fn g_dtls_client_connection_get_accepted_cas(conn: ?*GDtlsClientConnection) [*c]GList;
pub const struct__GDtlsServerConnectionInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GDtlsServerConnectionInterface = struct__GDtlsServerConnectionInterface;
pub extern fn g_dtls_server_connection_get_type() GType;
pub extern fn g_dtls_server_connection_new(base_socket: ?*GDatagramBased, certificate: [*c]GTlsCertificate, @"error": [*c][*c]GError) ?*GDatagramBased;
pub const struct__GIconIface = extern struct {
    g_iface: GTypeInterface,
    hash: ?*const fn (?*GIcon) callconv(.C) guint,
    equal: ?*const fn (?*GIcon, ?*GIcon) callconv(.C) gboolean,
    to_tokens: ?*const fn (?*GIcon, [*c]GPtrArray, [*c]gint) callconv(.C) gboolean,
    from_tokens: ?*const fn ([*c][*c]gchar, gint, gint, [*c][*c]GError) callconv(.C) ?*GIcon,
    serialize: ?*const fn (?*GIcon) callconv(.C) ?*GVariant,
};
pub const GIconIface = struct__GIconIface;
pub extern fn g_icon_get_type() GType;
pub extern fn g_icon_hash(icon: gconstpointer) guint;
pub extern fn g_icon_equal(icon1: ?*GIcon, icon2: ?*GIcon) gboolean;
pub extern fn g_icon_to_string(icon: ?*GIcon) [*c]gchar;
pub extern fn g_icon_new_for_string(str: [*c]const gchar, @"error": [*c][*c]GError) ?*GIcon;
pub extern fn g_icon_serialize(icon: ?*GIcon) ?*GVariant;
pub extern fn g_icon_deserialize(value: ?*GVariant) ?*GIcon;
pub const struct__GEmblem = opaque {};
pub const GEmblem = struct__GEmblem;
pub const struct__GEmblemClass = opaque {};
pub const GEmblemClass = struct__GEmblemClass;
pub extern fn g_emblem_get_type() GType;
pub extern fn g_emblem_new(icon: ?*GIcon) ?*GEmblem;
pub extern fn g_emblem_new_with_origin(icon: ?*GIcon, origin: GEmblemOrigin) ?*GEmblem;
pub extern fn g_emblem_get_icon(emblem: ?*GEmblem) ?*GIcon;
pub extern fn g_emblem_get_origin(emblem: ?*GEmblem) GEmblemOrigin;
pub const struct__GEmblemedIconPrivate = opaque {};
pub const GEmblemedIconPrivate = struct__GEmblemedIconPrivate;
pub const struct__GEmblemedIcon = extern struct {
    parent_instance: GObject,
    priv: ?*GEmblemedIconPrivate,
};
pub const GEmblemedIcon = struct__GEmblemedIcon;
pub const struct__GEmblemedIconClass = extern struct {
    parent_class: GObjectClass,
};
pub const GEmblemedIconClass = struct__GEmblemedIconClass;
pub extern fn g_emblemed_icon_get_type() GType;
pub extern fn g_emblemed_icon_new(icon: ?*GIcon, emblem: ?*GEmblem) ?*GIcon;
pub extern fn g_emblemed_icon_get_icon(emblemed: [*c]GEmblemedIcon) ?*GIcon;
pub extern fn g_emblemed_icon_get_emblems(emblemed: [*c]GEmblemedIcon) [*c]GList;
pub extern fn g_emblemed_icon_add_emblem(emblemed: [*c]GEmblemedIcon, emblem: ?*GEmblem) void;
pub extern fn g_emblemed_icon_clear_emblems(emblemed: [*c]GEmblemedIcon) void;
pub const struct__GFileIface = extern struct {
    g_iface: GTypeInterface,
    dup: ?*const fn (?*GFile) callconv(.C) ?*GFile,
    hash: ?*const fn (?*GFile) callconv(.C) guint,
    equal: ?*const fn (?*GFile, ?*GFile) callconv(.C) gboolean,
    is_native: ?*const fn (?*GFile) callconv(.C) gboolean,
    has_uri_scheme: ?*const fn (?*GFile, [*c]const u8) callconv(.C) gboolean,
    get_uri_scheme: ?*const fn (?*GFile) callconv(.C) [*c]u8,
    get_basename: ?*const fn (?*GFile) callconv(.C) [*c]u8,
    get_path: ?*const fn (?*GFile) callconv(.C) [*c]u8,
    get_uri: ?*const fn (?*GFile) callconv(.C) [*c]u8,
    get_parse_name: ?*const fn (?*GFile) callconv(.C) [*c]u8,
    get_parent: ?*const fn (?*GFile) callconv(.C) ?*GFile,
    prefix_matches: ?*const fn (?*GFile, ?*GFile) callconv(.C) gboolean,
    get_relative_path: ?*const fn (?*GFile, ?*GFile) callconv(.C) [*c]u8,
    resolve_relative_path: ?*const fn (?*GFile, [*c]const u8) callconv(.C) ?*GFile,
    get_child_for_display_name: ?*const fn (?*GFile, [*c]const u8, [*c][*c]GError) callconv(.C) ?*GFile,
    enumerate_children: ?*const fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileEnumerator,
    enumerate_children_async: ?*const fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    enumerate_children_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileEnumerator,
    query_info: ?*const fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    query_info_async: ?*const fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    query_info_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    query_filesystem_info: ?*const fn (?*GFile, [*c]const u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    query_filesystem_info_async: ?*const fn (?*GFile, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    query_filesystem_info_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    find_enclosing_mount: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GMount,
    find_enclosing_mount_async: ?*const fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    find_enclosing_mount_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GMount,
    set_display_name: ?*const fn (?*GFile, [*c]const u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFile,
    set_display_name_async: ?*const fn (?*GFile, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    set_display_name_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFile,
    query_settable_attributes: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileAttributeInfoList,
    _query_settable_attributes_async: ?*const fn () callconv(.C) void,
    _query_settable_attributes_finish: ?*const fn () callconv(.C) void,
    query_writable_namespaces: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileAttributeInfoList,
    _query_writable_namespaces_async: ?*const fn () callconv(.C) void,
    _query_writable_namespaces_finish: ?*const fn () callconv(.C) void,
    set_attribute: ?*const fn (?*GFile, [*c]const u8, GFileAttributeType, gpointer, GFileQueryInfoFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    set_attributes_from_info: ?*const fn (?*GFile, ?*GFileInfo, GFileQueryInfoFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    set_attributes_async: ?*const fn (?*GFile, ?*GFileInfo, GFileQueryInfoFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    set_attributes_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c]?*GFileInfo, [*c][*c]GError) callconv(.C) gboolean,
    read_fn: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileInputStream,
    read_async: ?*const fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    read_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileInputStream,
    append_to: ?*const fn (?*GFile, GFileCreateFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileOutputStream,
    append_to_async: ?*const fn (?*GFile, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    append_to_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileOutputStream,
    create: ?*const fn (?*GFile, GFileCreateFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileOutputStream,
    create_async: ?*const fn (?*GFile, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    create_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileOutputStream,
    replace: ?*const fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileOutputStream,
    replace_async: ?*const fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    replace_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileOutputStream,
    delete_file: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    delete_file_async: ?*const fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    delete_file_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    trash: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    trash_async: ?*const fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    trash_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    make_directory: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    make_directory_async: ?*const fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    make_directory_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    make_symbolic_link: ?*const fn (?*GFile, [*c]const u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    make_symbolic_link_async: ?*const fn (?*GFile, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    make_symbolic_link_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    copy: ?*const fn (?*GFile, ?*GFile, GFileCopyFlags, [*c]GCancellable, GFileProgressCallback, gpointer, [*c][*c]GError) callconv(.C) gboolean,
    copy_async: ?*const fn (?*GFile, ?*GFile, GFileCopyFlags, c_int, [*c]GCancellable, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer) callconv(.C) void,
    copy_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    move: ?*const fn (?*GFile, ?*GFile, GFileCopyFlags, [*c]GCancellable, GFileProgressCallback, gpointer, [*c][*c]GError) callconv(.C) gboolean,
    move_async: ?*const fn (?*GFile, ?*GFile, GFileCopyFlags, c_int, [*c]GCancellable, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer) callconv(.C) void,
    move_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    mount_mountable: ?*const fn (?*GFile, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    mount_mountable_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFile,
    unmount_mountable: ?*const fn (?*GFile, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    unmount_mountable_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    eject_mountable: ?*const fn (?*GFile, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_mountable_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    mount_enclosing_volume: ?*const fn (?*GFile, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    mount_enclosing_volume_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    monitor_dir: ?*const fn (?*GFile, GFileMonitorFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileMonitor,
    monitor_file: ?*const fn (?*GFile, GFileMonitorFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileMonitor,
    open_readwrite: ?*const fn (?*GFile, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileIOStream,
    open_readwrite_async: ?*const fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    open_readwrite_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileIOStream,
    create_readwrite: ?*const fn (?*GFile, GFileCreateFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileIOStream,
    create_readwrite_async: ?*const fn (?*GFile, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    create_readwrite_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileIOStream,
    replace_readwrite: ?*const fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GFileIOStream,
    replace_readwrite_async: ?*const fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    replace_readwrite_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GFileIOStream,
    start_mountable: ?*const fn (?*GFile, GDriveStartFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    start_mountable_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    stop_mountable: ?*const fn (?*GFile, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    stop_mountable_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    supports_thread_contexts: gboolean,
    unmount_mountable_with_operation: ?*const fn (?*GFile, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    unmount_mountable_with_operation_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    eject_mountable_with_operation: ?*const fn (?*GFile, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_mountable_with_operation_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    poll_mountable: ?*const fn (?*GFile, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    poll_mountable_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    measure_disk_usage: ?*const fn (?*GFile, GFileMeasureFlags, [*c]GCancellable, GFileMeasureProgressCallback, gpointer, [*c]guint64, [*c]guint64, [*c]guint64, [*c][*c]GError) callconv(.C) gboolean,
    measure_disk_usage_async: ?*const fn (?*GFile, GFileMeasureFlags, gint, [*c]GCancellable, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer) callconv(.C) void,
    measure_disk_usage_finish: ?*const fn (?*GFile, ?*GAsyncResult, [*c]guint64, [*c]guint64, [*c]guint64, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GFileIface = struct__GFileIface;
pub extern fn g_file_get_type() GType;
pub extern fn g_file_new_for_path(path: [*c]const u8) ?*GFile;
pub extern fn g_file_new_for_uri(uri: [*c]const u8) ?*GFile;
pub extern fn g_file_new_for_commandline_arg(arg: [*c]const u8) ?*GFile;
pub extern fn g_file_new_for_commandline_arg_and_cwd(arg: [*c]const gchar, cwd: [*c]const gchar) ?*GFile;
pub extern fn g_file_new_tmp(tmpl: [*c]const u8, iostream: [*c][*c]GFileIOStream, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_new_tmp_async(tmpl: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_new_tmp_finish(result: ?*GAsyncResult, iostream: [*c][*c]GFileIOStream, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_new_tmp_dir_async(tmpl: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_new_tmp_dir_finish(result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_parse_name(parse_name: [*c]const u8) ?*GFile;
pub extern fn g_file_new_build_filename(first_element: [*c]const gchar, ...) ?*GFile;
pub extern fn g_file_new_build_filenamev(args: [*c]const [*c]const gchar) ?*GFile;
pub extern fn g_file_dup(file: ?*GFile) ?*GFile;
pub extern fn g_file_hash(file: gconstpointer) guint;
pub extern fn g_file_equal(file1: ?*GFile, file2: ?*GFile) gboolean;
pub extern fn g_file_get_basename(file: ?*GFile) [*c]u8;
pub extern fn g_file_get_path(file: ?*GFile) [*c]u8;
pub extern fn g_file_peek_path(file: ?*GFile) [*c]const u8;
pub extern fn g_file_get_uri(file: ?*GFile) [*c]u8;
pub extern fn g_file_get_parse_name(file: ?*GFile) [*c]u8;
pub extern fn g_file_get_parent(file: ?*GFile) ?*GFile;
pub extern fn g_file_has_parent(file: ?*GFile, parent: ?*GFile) gboolean;
pub extern fn g_file_get_child(file: ?*GFile, name: [*c]const u8) ?*GFile;
pub extern fn g_file_get_child_for_display_name(file: ?*GFile, display_name: [*c]const u8, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_has_prefix(file: ?*GFile, prefix: ?*GFile) gboolean;
pub extern fn g_file_get_relative_path(parent: ?*GFile, descendant: ?*GFile) [*c]u8;
pub extern fn g_file_resolve_relative_path(file: ?*GFile, relative_path: [*c]const u8) ?*GFile;
pub extern fn g_file_is_native(file: ?*GFile) gboolean;
pub extern fn g_file_has_uri_scheme(file: ?*GFile, uri_scheme: [*c]const u8) gboolean;
pub extern fn g_file_get_uri_scheme(file: ?*GFile) [*c]u8;
pub extern fn g_file_read(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileInputStream;
pub extern fn g_file_read_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_read_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileInputStream;
pub extern fn g_file_append_to(file: ?*GFile, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileOutputStream;
pub extern fn g_file_create(file: ?*GFile, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileOutputStream;
pub extern fn g_file_replace(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileOutputStream;
pub extern fn g_file_append_to_async(file: ?*GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_append_to_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileOutputStream;
pub extern fn g_file_create_async(file: ?*GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_create_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileOutputStream;
pub extern fn g_file_replace_async(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileOutputStream;
pub extern fn g_file_open_readwrite(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileIOStream;
pub extern fn g_file_open_readwrite_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_open_readwrite_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileIOStream;
pub extern fn g_file_create_readwrite(file: ?*GFile, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileIOStream;
pub extern fn g_file_create_readwrite_async(file: ?*GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_create_readwrite_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileIOStream;
pub extern fn g_file_replace_readwrite(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileIOStream;
pub extern fn g_file_replace_readwrite_async(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_readwrite_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileIOStream;
pub extern fn g_file_query_exists(file: ?*GFile, cancellable: [*c]GCancellable) gboolean;
pub extern fn g_file_query_file_type(file: ?*GFile, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable) GFileType;
pub extern fn g_file_query_info(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_query_info_async(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_query_info_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_query_filesystem_info(file: ?*GFile, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_query_filesystem_info_async(file: ?*GFile, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_query_filesystem_info_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_find_enclosing_mount(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GMount;
pub extern fn g_file_find_enclosing_mount_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_find_enclosing_mount_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GMount;
pub extern fn g_file_enumerate_children(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileEnumerator;
pub extern fn g_file_enumerate_children_async(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_enumerate_children_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GFileEnumerator;
pub extern fn g_file_set_display_name(file: ?*GFile, display_name: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_set_display_name_async(file: ?*GFile, display_name: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_set_display_name_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_delete(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_delete_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_delete_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_trash(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_trash_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_trash_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_copy(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_copy_async(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, io_priority: c_int, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_copy_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_move(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_move_async(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, io_priority: c_int, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_move_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_make_directory(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_make_directory_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_make_directory_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_make_directory_with_parents(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_make_symbolic_link(file: ?*GFile, symlink_value: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_make_symbolic_link_async(file: ?*GFile, symlink_value: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_make_symbolic_link_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_query_settable_attributes(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileAttributeInfoList;
pub extern fn g_file_query_writable_namespaces(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileAttributeInfoList;
pub extern fn g_file_set_attribute(file: ?*GFile, attribute: [*c]const u8, @"type": GFileAttributeType, value_p: gpointer, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attributes_from_info(file: ?*GFile, info: ?*GFileInfo, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attributes_async(file: ?*GFile, info: ?*GFileInfo, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_set_attributes_finish(file: ?*GFile, result: ?*GAsyncResult, info: [*c]?*GFileInfo, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attribute_string(file: ?*GFile, attribute: [*c]const u8, value: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attribute_byte_string(file: ?*GFile, attribute: [*c]const u8, value: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attribute_uint32(file: ?*GFile, attribute: [*c]const u8, value: guint32, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attribute_int32(file: ?*GFile, attribute: [*c]const u8, value: gint32, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attribute_uint64(file: ?*GFile, attribute: [*c]const u8, value: guint64, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_set_attribute_int64(file: ?*GFile, attribute: [*c]const u8, value: gint64, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_mount_enclosing_volume(location: ?*GFile, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_mount_enclosing_volume_finish(location: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_mount_mountable(file: ?*GFile, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_mount_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFile;
pub extern fn g_file_unmount_mountable(file: ?*GFile, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_unmount_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_unmount_mountable_with_operation(file: ?*GFile, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_unmount_mountable_with_operation_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_eject_mountable(file: ?*GFile, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_eject_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_eject_mountable_with_operation(file: ?*GFile, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_eject_mountable_with_operation_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_build_attribute_list_for_copy(file: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]u8;
pub extern fn g_file_copy_attributes(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_monitor_directory(file: ?*GFile, flags: GFileMonitorFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileMonitor;
pub extern fn g_file_monitor_file(file: ?*GFile, flags: GFileMonitorFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileMonitor;
pub extern fn g_file_monitor(file: ?*GFile, flags: GFileMonitorFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GFileMonitor;
pub extern fn g_file_measure_disk_usage(file: ?*GFile, flags: GFileMeasureFlags, cancellable: [*c]GCancellable, progress_callback: GFileMeasureProgressCallback, progress_data: gpointer, disk_usage: [*c]guint64, num_dirs: [*c]guint64, num_files: [*c]guint64, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_measure_disk_usage_async(file: ?*GFile, flags: GFileMeasureFlags, io_priority: gint, cancellable: [*c]GCancellable, progress_callback: GFileMeasureProgressCallback, progress_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_measure_disk_usage_finish(file: ?*GFile, result: ?*GAsyncResult, disk_usage: [*c]guint64, num_dirs: [*c]guint64, num_files: [*c]guint64, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_start_mountable(file: ?*GFile, flags: GDriveStartFlags, start_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_start_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_stop_mountable(file: ?*GFile, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_stop_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_poll_mountable(file: ?*GFile, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_poll_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_query_default_handler(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GAppInfo;
pub extern fn g_file_query_default_handler_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_query_default_handler_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GAppInfo;
pub extern fn g_file_load_contents(file: ?*GFile, cancellable: [*c]GCancellable, contents: [*c][*c]u8, length: [*c]gsize, etag_out: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_load_contents_async(file: ?*GFile, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_load_contents_finish(file: ?*GFile, res: ?*GAsyncResult, contents: [*c][*c]u8, length: [*c]gsize, etag_out: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_load_partial_contents_async(file: ?*GFile, cancellable: [*c]GCancellable, read_more_callback: GFileReadMoreCallback, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_load_partial_contents_finish(file: ?*GFile, res: ?*GAsyncResult, contents: [*c][*c]u8, length: [*c]gsize, etag_out: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_replace_contents(file: ?*GFile, contents: [*c]const u8, length: gsize, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, new_etag: [*c][*c]u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_replace_contents_async(file: ?*GFile, contents: [*c]const u8, length: gsize, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_contents_bytes_async(file: ?*GFile, contents: ?*GBytes, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_contents_finish(file: ?*GFile, res: ?*GAsyncResult, new_etag: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_supports_thread_contexts(file: ?*GFile) gboolean;
pub extern fn g_file_load_bytes(file: ?*GFile, cancellable: [*c]GCancellable, etag_out: [*c][*c]gchar, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_file_load_bytes_async(file: ?*GFile, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_load_bytes_finish(file: ?*GFile, result: ?*GAsyncResult, etag_out: [*c][*c]gchar, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_file_attribute_info_list_get_type() GType;
pub extern fn g_file_attribute_info_list_new() [*c]GFileAttributeInfoList;
pub extern fn g_file_attribute_info_list_ref(list: [*c]GFileAttributeInfoList) [*c]GFileAttributeInfoList;
pub extern fn g_file_attribute_info_list_unref(list: [*c]GFileAttributeInfoList) void;
pub extern fn g_file_attribute_info_list_dup(list: [*c]GFileAttributeInfoList) [*c]GFileAttributeInfoList;
pub extern fn g_file_attribute_info_list_lookup(list: [*c]GFileAttributeInfoList, name: [*c]const u8) [*c]const GFileAttributeInfo;
pub extern fn g_file_attribute_info_list_add(list: [*c]GFileAttributeInfoList, name: [*c]const u8, @"type": GFileAttributeType, flags: GFileAttributeInfoFlags) void;
pub const struct__GFileEnumeratorClass = extern struct {
    parent_class: GObjectClass,
    next_file: ?*const fn ([*c]GFileEnumerator, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    close_fn: ?*const fn ([*c]GFileEnumerator, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    next_files_async: ?*const fn ([*c]GFileEnumerator, c_int, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    next_files_finish: ?*const fn ([*c]GFileEnumerator, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GList,
    close_async: ?*const fn ([*c]GFileEnumerator, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    close_finish: ?*const fn ([*c]GFileEnumerator, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
    _g_reserved7: ?*const fn () callconv(.C) void,
};
pub const GFileEnumeratorClass = struct__GFileEnumeratorClass;
pub extern fn g_file_enumerator_get_type() GType;
pub extern fn g_file_enumerator_next_file(enumerator: [*c]GFileEnumerator, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_enumerator_close(enumerator: [*c]GFileEnumerator, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_enumerator_next_files_async(enumerator: [*c]GFileEnumerator, num_files: c_int, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_enumerator_next_files_finish(enumerator: [*c]GFileEnumerator, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_file_enumerator_close_async(enumerator: [*c]GFileEnumerator, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_enumerator_close_finish(enumerator: [*c]GFileEnumerator, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_file_enumerator_is_closed(enumerator: [*c]GFileEnumerator) gboolean;
pub extern fn g_file_enumerator_has_pending(enumerator: [*c]GFileEnumerator) gboolean;
pub extern fn g_file_enumerator_set_pending(enumerator: [*c]GFileEnumerator, pending: gboolean) void;
pub extern fn g_file_enumerator_get_container(enumerator: [*c]GFileEnumerator) ?*GFile;
pub extern fn g_file_enumerator_get_child(enumerator: [*c]GFileEnumerator, info: ?*GFileInfo) ?*GFile;
pub extern fn g_file_enumerator_iterate(direnum: [*c]GFileEnumerator, out_info: [*c]?*GFileInfo, out_child: [*c]?*GFile, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub const struct__GFileIconClass = opaque {};
pub const GFileIconClass = struct__GFileIconClass;
pub extern fn g_file_icon_get_type() GType;
pub extern fn g_file_icon_new(file: ?*GFile) ?*GIcon;
pub extern fn g_file_icon_get_file(icon: ?*GFileIcon) ?*GFile;
pub const struct__GFileInfoClass = opaque {};
pub const GFileInfoClass = struct__GFileInfoClass;
pub extern fn g_file_info_get_type() GType;
pub extern fn g_file_info_new() ?*GFileInfo;
pub extern fn g_file_info_dup(other: ?*GFileInfo) ?*GFileInfo;
pub extern fn g_file_info_copy_into(src_info: ?*GFileInfo, dest_info: ?*GFileInfo) void;
pub extern fn g_file_info_has_attribute(info: ?*GFileInfo, attribute: [*c]const u8) gboolean;
pub extern fn g_file_info_has_namespace(info: ?*GFileInfo, name_space: [*c]const u8) gboolean;
pub extern fn g_file_info_list_attributes(info: ?*GFileInfo, name_space: [*c]const u8) [*c][*c]u8;
pub extern fn g_file_info_get_attribute_data(info: ?*GFileInfo, attribute: [*c]const u8, @"type": [*c]GFileAttributeType, value_pp: [*c]gpointer, status: [*c]GFileAttributeStatus) gboolean;
pub extern fn g_file_info_get_attribute_type(info: ?*GFileInfo, attribute: [*c]const u8) GFileAttributeType;
pub extern fn g_file_info_remove_attribute(info: ?*GFileInfo, attribute: [*c]const u8) void;
pub extern fn g_file_info_get_attribute_status(info: ?*GFileInfo, attribute: [*c]const u8) GFileAttributeStatus;
pub extern fn g_file_info_set_attribute_status(info: ?*GFileInfo, attribute: [*c]const u8, status: GFileAttributeStatus) gboolean;
pub extern fn g_file_info_get_attribute_as_string(info: ?*GFileInfo, attribute: [*c]const u8) [*c]u8;
pub extern fn g_file_info_get_attribute_string(info: ?*GFileInfo, attribute: [*c]const u8) [*c]const u8;
pub extern fn g_file_info_get_attribute_byte_string(info: ?*GFileInfo, attribute: [*c]const u8) [*c]const u8;
pub extern fn g_file_info_get_attribute_boolean(info: ?*GFileInfo, attribute: [*c]const u8) gboolean;
pub extern fn g_file_info_get_attribute_uint32(info: ?*GFileInfo, attribute: [*c]const u8) guint32;
pub extern fn g_file_info_get_attribute_int32(info: ?*GFileInfo, attribute: [*c]const u8) gint32;
pub extern fn g_file_info_get_attribute_uint64(info: ?*GFileInfo, attribute: [*c]const u8) guint64;
pub extern fn g_file_info_get_attribute_int64(info: ?*GFileInfo, attribute: [*c]const u8) gint64;
pub extern fn g_file_info_get_attribute_object(info: ?*GFileInfo, attribute: [*c]const u8) [*c]GObject;
pub extern fn g_file_info_get_attribute_stringv(info: ?*GFileInfo, attribute: [*c]const u8) [*c][*c]u8;
pub extern fn g_file_info_get_attribute_file_path(info: ?*GFileInfo, attribute: [*c]const u8) [*c]const u8;
pub extern fn g_file_info_set_attribute(info: ?*GFileInfo, attribute: [*c]const u8, @"type": GFileAttributeType, value_p: gpointer) void;
pub extern fn g_file_info_set_attribute_string(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]const u8) void;
pub extern fn g_file_info_set_attribute_byte_string(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]const u8) void;
pub extern fn g_file_info_set_attribute_boolean(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: gboolean) void;
pub extern fn g_file_info_set_attribute_uint32(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: guint32) void;
pub extern fn g_file_info_set_attribute_int32(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: gint32) void;
pub extern fn g_file_info_set_attribute_uint64(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: guint64) void;
pub extern fn g_file_info_set_attribute_int64(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: gint64) void;
pub extern fn g_file_info_set_attribute_object(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]GObject) void;
pub extern fn g_file_info_set_attribute_stringv(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c][*c]u8) void;
pub extern fn g_file_info_set_attribute_file_path(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]const u8) void;
pub extern fn g_file_info_clear_status(info: ?*GFileInfo) void;
pub extern fn g_file_info_get_deletion_date(info: ?*GFileInfo) ?*GDateTime;
pub extern fn g_file_info_get_file_type(info: ?*GFileInfo) GFileType;
pub extern fn g_file_info_get_is_hidden(info: ?*GFileInfo) gboolean;
pub extern fn g_file_info_get_is_backup(info: ?*GFileInfo) gboolean;
pub extern fn g_file_info_get_is_symlink(info: ?*GFileInfo) gboolean;
pub extern fn g_file_info_get_name(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_display_name(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_edit_name(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_icon(info: ?*GFileInfo) ?*GIcon;
pub extern fn g_file_info_get_symbolic_icon(info: ?*GFileInfo) ?*GIcon;
pub extern fn g_file_info_get_content_type(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_size(info: ?*GFileInfo) goffset;
pub extern fn g_file_info_get_modification_time(info: ?*GFileInfo, result: [*c]GTimeVal) void;
pub extern fn g_file_info_get_modification_date_time(info: ?*GFileInfo) ?*GDateTime;
pub extern fn g_file_info_get_access_date_time(info: ?*GFileInfo) ?*GDateTime;
pub extern fn g_file_info_get_creation_date_time(info: ?*GFileInfo) ?*GDateTime;
pub extern fn g_file_info_get_symlink_target(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_etag(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_sort_order(info: ?*GFileInfo) gint32;
pub extern fn g_file_info_set_attribute_mask(info: ?*GFileInfo, mask: ?*GFileAttributeMatcher) void;
pub extern fn g_file_info_unset_attribute_mask(info: ?*GFileInfo) void;
pub extern fn g_file_info_set_file_type(info: ?*GFileInfo, @"type": GFileType) void;
pub extern fn g_file_info_set_is_hidden(info: ?*GFileInfo, is_hidden: gboolean) void;
pub extern fn g_file_info_set_is_symlink(info: ?*GFileInfo, is_symlink: gboolean) void;
pub extern fn g_file_info_set_name(info: ?*GFileInfo, name: [*c]const u8) void;
pub extern fn g_file_info_set_display_name(info: ?*GFileInfo, display_name: [*c]const u8) void;
pub extern fn g_file_info_set_edit_name(info: ?*GFileInfo, edit_name: [*c]const u8) void;
pub extern fn g_file_info_set_icon(info: ?*GFileInfo, icon: ?*GIcon) void;
pub extern fn g_file_info_set_symbolic_icon(info: ?*GFileInfo, icon: ?*GIcon) void;
pub extern fn g_file_info_set_content_type(info: ?*GFileInfo, content_type: [*c]const u8) void;
pub extern fn g_file_info_set_size(info: ?*GFileInfo, size: goffset) void;
pub extern fn g_file_info_set_modification_time(info: ?*GFileInfo, mtime: [*c]GTimeVal) void;
pub extern fn g_file_info_set_modification_date_time(info: ?*GFileInfo, mtime: ?*GDateTime) void;
pub extern fn g_file_info_set_access_date_time(info: ?*GFileInfo, atime: ?*GDateTime) void;
pub extern fn g_file_info_set_creation_date_time(info: ?*GFileInfo, creation_time: ?*GDateTime) void;
pub extern fn g_file_info_set_symlink_target(info: ?*GFileInfo, symlink_target: [*c]const u8) void;
pub extern fn g_file_info_set_sort_order(info: ?*GFileInfo, sort_order: gint32) void;
pub extern fn g_file_attribute_matcher_get_type() GType;
pub extern fn g_file_attribute_matcher_new(attributes: [*c]const u8) ?*GFileAttributeMatcher;
pub extern fn g_file_attribute_matcher_ref(matcher: ?*GFileAttributeMatcher) ?*GFileAttributeMatcher;
pub extern fn g_file_attribute_matcher_unref(matcher: ?*GFileAttributeMatcher) void;
pub extern fn g_file_attribute_matcher_subtract(matcher: ?*GFileAttributeMatcher, subtract: ?*GFileAttributeMatcher) ?*GFileAttributeMatcher;
pub extern fn g_file_attribute_matcher_matches(matcher: ?*GFileAttributeMatcher, attribute: [*c]const u8) gboolean;
pub extern fn g_file_attribute_matcher_matches_only(matcher: ?*GFileAttributeMatcher, attribute: [*c]const u8) gboolean;
pub extern fn g_file_attribute_matcher_enumerate_namespace(matcher: ?*GFileAttributeMatcher, ns: [*c]const u8) gboolean;
pub extern fn g_file_attribute_matcher_enumerate_next(matcher: ?*GFileAttributeMatcher) [*c]const u8;
pub extern fn g_file_attribute_matcher_to_string(matcher: ?*GFileAttributeMatcher) [*c]u8;
pub const struct__GFileInputStreamClass = extern struct {
    parent_class: GInputStreamClass,
    tell: ?*const fn ([*c]GFileInputStream) callconv(.C) goffset,
    can_seek: ?*const fn ([*c]GFileInputStream) callconv(.C) gboolean,
    seek: ?*const fn ([*c]GFileInputStream, goffset, GSeekType, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    query_info: ?*const fn ([*c]GFileInputStream, [*c]const u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    query_info_async: ?*const fn ([*c]GFileInputStream, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    query_info_finish: ?*const fn ([*c]GFileInputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GFileInputStreamClass = struct__GFileInputStreamClass;
pub extern fn g_file_input_stream_get_type() GType;
pub extern fn g_file_input_stream_query_info(stream: [*c]GFileInputStream, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_input_stream_query_info_async(stream: [*c]GFileInputStream, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_input_stream_query_info_finish(stream: [*c]GFileInputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_io_error_quark() GQuark;
pub extern fn g_io_error_from_errno(err_no: gint) GIOErrorEnum;
pub extern fn g_io_error_from_file_error(file_error: GFileError) GIOErrorEnum;
pub const struct__GIOStreamClass = extern struct {
    parent_class: GObjectClass,
    get_input_stream: ?*const fn ([*c]GIOStream) callconv(.C) [*c]GInputStream,
    get_output_stream: ?*const fn ([*c]GIOStream) callconv(.C) [*c]GOutputStream,
    close_fn: ?*const fn ([*c]GIOStream, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    close_async: ?*const fn ([*c]GIOStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    close_finish: ?*const fn ([*c]GIOStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
    _g_reserved7: ?*const fn () callconv(.C) void,
    _g_reserved8: ?*const fn () callconv(.C) void,
    _g_reserved9: ?*const fn () callconv(.C) void,
    _g_reserved10: ?*const fn () callconv(.C) void,
};
pub const GIOStreamClass = struct__GIOStreamClass;
pub extern fn g_io_stream_get_type() GType;
pub extern fn g_io_stream_get_input_stream(stream: [*c]GIOStream) [*c]GInputStream;
pub extern fn g_io_stream_get_output_stream(stream: [*c]GIOStream) [*c]GOutputStream;
pub extern fn g_io_stream_splice_async(stream1: [*c]GIOStream, stream2: [*c]GIOStream, flags: GIOStreamSpliceFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_io_stream_splice_finish(result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_io_stream_close(stream: [*c]GIOStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_io_stream_close_async(stream: [*c]GIOStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_io_stream_close_finish(stream: [*c]GIOStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_io_stream_is_closed(stream: [*c]GIOStream) gboolean;
pub extern fn g_io_stream_has_pending(stream: [*c]GIOStream) gboolean;
pub extern fn g_io_stream_set_pending(stream: [*c]GIOStream, @"error": [*c][*c]GError) gboolean;
pub extern fn g_io_stream_clear_pending(stream: [*c]GIOStream) void;
pub const struct__GFileIOStreamClass = extern struct {
    parent_class: GIOStreamClass,
    tell: ?*const fn ([*c]GFileIOStream) callconv(.C) goffset,
    can_seek: ?*const fn ([*c]GFileIOStream) callconv(.C) gboolean,
    seek: ?*const fn ([*c]GFileIOStream, goffset, GSeekType, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    can_truncate: ?*const fn ([*c]GFileIOStream) callconv(.C) gboolean,
    truncate_fn: ?*const fn ([*c]GFileIOStream, goffset, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    query_info: ?*const fn ([*c]GFileIOStream, [*c]const u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    query_info_async: ?*const fn ([*c]GFileIOStream, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    query_info_finish: ?*const fn ([*c]GFileIOStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    get_etag: ?*const fn ([*c]GFileIOStream) callconv(.C) [*c]u8,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GFileIOStreamClass = struct__GFileIOStreamClass;
pub extern fn g_file_io_stream_get_type() GType;
pub extern fn g_file_io_stream_query_info(stream: [*c]GFileIOStream, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_io_stream_query_info_async(stream: [*c]GFileIOStream, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_io_stream_query_info_finish(stream: [*c]GFileIOStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_io_stream_get_etag(stream: [*c]GFileIOStream) [*c]u8;
pub const struct__GFileMonitorClass = extern struct {
    parent_class: GObjectClass,
    changed: ?*const fn ([*c]GFileMonitor, ?*GFile, ?*GFile, GFileMonitorEvent) callconv(.C) void,
    cancel: ?*const fn ([*c]GFileMonitor) callconv(.C) gboolean,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GFileMonitorClass = struct__GFileMonitorClass;
pub extern fn g_file_monitor_get_type() GType;
pub extern fn g_file_monitor_cancel(monitor: [*c]GFileMonitor) gboolean;
pub extern fn g_file_monitor_is_cancelled(monitor: [*c]GFileMonitor) gboolean;
pub extern fn g_file_monitor_set_rate_limit(monitor: [*c]GFileMonitor, limit_msecs: gint) void;
pub extern fn g_file_monitor_emit_event(monitor: [*c]GFileMonitor, child: ?*GFile, other_file: ?*GFile, event_type: GFileMonitorEvent) void;
pub const struct__GFilenameCompleterClass = extern struct {
    parent_class: GObjectClass,
    got_completion_data: ?*const fn (?*GFilenameCompleter) callconv(.C) void,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
};
pub const GFilenameCompleterClass = struct__GFilenameCompleterClass;
pub extern fn g_filename_completer_get_type() GType;
pub extern fn g_filename_completer_new() ?*GFilenameCompleter;
pub extern fn g_filename_completer_get_completion_suffix(completer: ?*GFilenameCompleter, initial_text: [*c]const u8) [*c]u8;
pub extern fn g_filename_completer_get_completions(completer: ?*GFilenameCompleter, initial_text: [*c]const u8) [*c][*c]u8;
pub extern fn g_filename_completer_set_dirs_only(completer: ?*GFilenameCompleter, dirs_only: gboolean) void;
pub const struct__GFileOutputStreamClass = extern struct {
    parent_class: GOutputStreamClass,
    tell: ?*const fn ([*c]GFileOutputStream) callconv(.C) goffset,
    can_seek: ?*const fn ([*c]GFileOutputStream) callconv(.C) gboolean,
    seek: ?*const fn ([*c]GFileOutputStream, goffset, GSeekType, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    can_truncate: ?*const fn ([*c]GFileOutputStream) callconv(.C) gboolean,
    truncate_fn: ?*const fn ([*c]GFileOutputStream, goffset, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    query_info: ?*const fn ([*c]GFileOutputStream, [*c]const u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    query_info_async: ?*const fn ([*c]GFileOutputStream, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    query_info_finish: ?*const fn ([*c]GFileOutputStream, ?*GAsyncResult, [*c][*c]GError) callconv(.C) ?*GFileInfo,
    get_etag: ?*const fn ([*c]GFileOutputStream) callconv(.C) [*c]u8,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GFileOutputStreamClass = struct__GFileOutputStreamClass;
pub extern fn g_file_output_stream_get_type() GType;
pub extern fn g_file_output_stream_query_info(stream: [*c]GFileOutputStream, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_output_stream_query_info_async(stream: [*c]GFileOutputStream, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_output_stream_query_info_finish(stream: [*c]GFileOutputStream, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFileInfo;
pub extern fn g_file_output_stream_get_etag(stream: [*c]GFileOutputStream) [*c]u8;
pub const struct__GInetAddressClass = extern struct {
    parent_class: GObjectClass,
    to_string: ?*const fn ([*c]GInetAddress) callconv(.C) [*c]gchar,
    to_bytes: ?*const fn ([*c]GInetAddress) callconv(.C) [*c]const guint8,
};
pub const GInetAddressClass = struct__GInetAddressClass;
pub extern fn g_inet_address_get_type() GType;
pub extern fn g_inet_address_new_from_string(string: [*c]const gchar) [*c]GInetAddress;
pub extern fn g_inet_address_new_from_bytes(bytes: [*c]const guint8, family: GSocketFamily) [*c]GInetAddress;
pub extern fn g_inet_address_new_loopback(family: GSocketFamily) [*c]GInetAddress;
pub extern fn g_inet_address_new_any(family: GSocketFamily) [*c]GInetAddress;
pub extern fn g_inet_address_equal(address: [*c]GInetAddress, other_address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_to_string(address: [*c]GInetAddress) [*c]gchar;
pub extern fn g_inet_address_to_bytes(address: [*c]GInetAddress) [*c]const guint8;
pub extern fn g_inet_address_get_native_size(address: [*c]GInetAddress) gsize;
pub extern fn g_inet_address_get_family(address: [*c]GInetAddress) GSocketFamily;
pub extern fn g_inet_address_get_is_any(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_loopback(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_link_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_site_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_multicast(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_global(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_link_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_node_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_org_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_site_local(address: [*c]GInetAddress) gboolean;
pub const struct__GInetAddressMaskClass = extern struct {
    parent_class: GObjectClass,
};
pub const GInetAddressMaskClass = struct__GInetAddressMaskClass;
pub extern fn g_inet_address_mask_get_type() GType;
pub extern fn g_inet_address_mask_new(addr: [*c]GInetAddress, length: guint, @"error": [*c][*c]GError) [*c]GInetAddressMask;
pub extern fn g_inet_address_mask_new_from_string(mask_string: [*c]const gchar, @"error": [*c][*c]GError) [*c]GInetAddressMask;
pub extern fn g_inet_address_mask_to_string(mask: [*c]GInetAddressMask) [*c]gchar;
pub extern fn g_inet_address_mask_get_family(mask: [*c]GInetAddressMask) GSocketFamily;
pub extern fn g_inet_address_mask_get_address(mask: [*c]GInetAddressMask) [*c]GInetAddress;
pub extern fn g_inet_address_mask_get_length(mask: [*c]GInetAddressMask) guint;
pub extern fn g_inet_address_mask_matches(mask: [*c]GInetAddressMask, address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_mask_equal(mask: [*c]GInetAddressMask, mask2: [*c]GInetAddressMask) gboolean;
pub const struct__GSocketAddressClass = extern struct {
    parent_class: GObjectClass,
    get_family: ?*const fn ([*c]GSocketAddress) callconv(.C) GSocketFamily,
    get_native_size: ?*const fn ([*c]GSocketAddress) callconv(.C) gssize,
    to_native: ?*const fn ([*c]GSocketAddress, gpointer, gsize, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GSocketAddressClass = struct__GSocketAddressClass;
pub extern fn g_socket_address_get_type() GType;
pub extern fn g_socket_address_get_family(address: [*c]GSocketAddress) GSocketFamily;
pub extern fn g_socket_address_new_from_native(native: gpointer, len: gsize) [*c]GSocketAddress;
pub extern fn g_socket_address_to_native(address: [*c]GSocketAddress, dest: gpointer, destlen: gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_address_get_native_size(address: [*c]GSocketAddress) gssize;
pub const struct__GInetSocketAddressClass = extern struct {
    parent_class: GSocketAddressClass,
};
pub const GInetSocketAddressClass = struct__GInetSocketAddressClass;
pub extern fn g_inet_socket_address_get_type() GType;
pub extern fn g_inet_socket_address_new(address: [*c]GInetAddress, port: guint16) [*c]GSocketAddress;
pub extern fn g_inet_socket_address_new_from_string(address: [*c]const u8, port: guint) [*c]GSocketAddress;
pub extern fn g_inet_socket_address_get_address(address: [*c]GInetSocketAddress) [*c]GInetAddress;
pub extern fn g_inet_socket_address_get_port(address: [*c]GInetSocketAddress) guint16;
pub extern fn g_inet_socket_address_get_flowinfo(address: [*c]GInetSocketAddress) guint32;
pub extern fn g_inet_socket_address_get_scope_id(address: [*c]GInetSocketAddress) guint32;
pub extern fn g_app_info_create_flags_get_type() GType;
pub extern fn g_converter_flags_get_type() GType;
pub extern fn g_converter_result_get_type() GType;
pub extern fn g_data_stream_byte_order_get_type() GType;
pub extern fn g_data_stream_newline_type_get_type() GType;
pub extern fn g_file_attribute_type_get_type() GType;
pub extern fn g_file_attribute_info_flags_get_type() GType;
pub extern fn g_file_attribute_status_get_type() GType;
pub extern fn g_file_query_info_flags_get_type() GType;
pub extern fn g_file_create_flags_get_type() GType;
pub extern fn g_file_measure_flags_get_type() GType;
pub extern fn g_mount_mount_flags_get_type() GType;
pub extern fn g_mount_unmount_flags_get_type() GType;
pub extern fn g_drive_start_flags_get_type() GType;
pub extern fn g_drive_start_stop_type_get_type() GType;
pub extern fn g_file_copy_flags_get_type() GType;
pub extern fn g_file_monitor_flags_get_type() GType;
pub extern fn g_file_type_get_type() GType;
pub extern fn g_filesystem_preview_type_get_type() GType;
pub extern fn g_file_monitor_event_get_type() GType;
pub extern fn g_io_error_enum_get_type() GType;
pub extern fn g_ask_password_flags_get_type() GType;
pub extern fn g_password_save_get_type() GType;
pub extern fn g_mount_operation_result_get_type() GType;
pub extern fn g_output_stream_splice_flags_get_type() GType;
pub extern fn g_io_stream_splice_flags_get_type() GType;
pub extern fn g_emblem_origin_get_type() GType;
pub extern fn g_resolver_error_get_type() GType;
pub extern fn g_resolver_record_type_get_type() GType;
pub extern fn g_resource_error_get_type() GType;
pub extern fn g_resource_flags_get_type() GType;
pub extern fn g_resource_lookup_flags_get_type() GType;
pub extern fn g_socket_family_get_type() GType;
pub extern fn g_socket_type_get_type() GType;
pub extern fn g_socket_msg_flags_get_type() GType;
pub extern fn g_socket_protocol_get_type() GType;
pub extern fn g_zlib_compressor_format_get_type() GType;
pub extern fn g_unix_socket_address_type_get_type() GType;
pub extern fn g_bus_type_get_type() GType;
pub extern fn g_bus_name_owner_flags_get_type() GType;
pub extern fn g_bus_name_watcher_flags_get_type() GType;
pub extern fn g_dbus_proxy_flags_get_type() GType;
pub extern fn g_dbus_error_get_type() GType;
pub extern fn g_dbus_connection_flags_get_type() GType;
pub extern fn g_dbus_capability_flags_get_type() GType;
pub extern fn g_dbus_call_flags_get_type() GType;
pub extern fn g_dbus_message_type_get_type() GType;
pub extern fn g_dbus_message_flags_get_type() GType;
pub extern fn g_dbus_message_header_field_get_type() GType;
pub extern fn g_dbus_property_info_flags_get_type() GType;
pub extern fn g_dbus_subtree_flags_get_type() GType;
pub extern fn g_dbus_server_flags_get_type() GType;
pub extern fn g_dbus_signal_flags_get_type() GType;
pub extern fn g_dbus_send_message_flags_get_type() GType;
pub extern fn g_credentials_type_get_type() GType;
pub extern fn g_dbus_message_byte_order_get_type() GType;
pub extern fn g_application_flags_get_type() GType;
pub extern fn g_tls_error_get_type() GType;
pub extern fn g_tls_certificate_flags_get_type() GType;
pub extern fn g_tls_authentication_mode_get_type() GType;
pub extern fn g_tls_channel_binding_type_get_type() GType;
pub extern fn g_tls_channel_binding_error_get_type() GType;
pub extern fn g_tls_rehandshake_mode_get_type() GType;
pub extern fn g_tls_password_flags_get_type() GType;
pub extern fn g_tls_interaction_result_get_type() GType;
pub extern fn g_dbus_interface_skeleton_flags_get_type() GType;
pub extern fn g_dbus_object_manager_client_flags_get_type() GType;
pub extern fn g_tls_database_verify_flags_get_type() GType;
pub extern fn g_tls_database_lookup_flags_get_type() GType;
pub extern fn g_tls_certificate_request_flags_get_type() GType;
pub extern fn g_tls_protocol_version_get_type() GType;
pub extern fn g_io_module_scope_flags_get_type() GType;
pub extern fn g_socket_client_event_get_type() GType;
pub extern fn g_socket_listener_event_get_type() GType;
pub extern fn g_test_dbus_flags_get_type() GType;
pub extern fn g_subprocess_flags_get_type() GType;
pub extern fn g_notification_priority_get_type() GType;
pub extern fn g_network_connectivity_get_type() GType;
pub extern fn g_pollable_return_get_type() GType;
pub extern fn g_memory_monitor_warning_level_get_type() GType;
pub extern fn g_resolver_name_lookup_flags_get_type() GType;
pub extern fn g_settings_bind_flags_get_type() GType;
pub const G_MODULE_BIND_LAZY: c_int = 1;
pub const G_MODULE_BIND_LOCAL: c_int = 2;
pub const G_MODULE_BIND_MASK: c_int = 3;
pub const GModuleFlags = c_uint;
pub const struct__GModule = opaque {};
pub const GModule = struct__GModule;
pub const GModuleCheckInit = ?*const fn (?*GModule) callconv(.C) [*c]const gchar;
pub const GModuleUnload = ?*const fn (?*GModule) callconv(.C) void;
pub extern fn g_module_error_quark() GQuark;
pub const G_MODULE_ERROR_FAILED: c_int = 0;
pub const G_MODULE_ERROR_CHECK_FAILED: c_int = 1;
pub const GModuleError = c_uint;
pub extern fn g_module_supported() gboolean;
pub extern fn g_module_open(file_name: [*c]const gchar, flags: GModuleFlags) ?*GModule;
pub extern fn g_module_open_full(file_name: [*c]const gchar, flags: GModuleFlags, @"error": [*c][*c]GError) ?*GModule;
pub extern fn g_module_close(module: ?*GModule) gboolean;
pub extern fn g_module_make_resident(module: ?*GModule) void;
pub extern fn g_module_error() [*c]const gchar;
pub extern fn g_module_symbol(module: ?*GModule, symbol_name: [*c]const gchar, symbol: [*c]gpointer) gboolean;
pub extern fn g_module_name(module: ?*GModule) [*c]const gchar;
pub extern fn g_module_build_path(directory: [*c]const gchar, module_name: [*c]const gchar) [*c]gchar;
pub const struct__GIOModuleScope = opaque {};
pub const GIOModuleScope = struct__GIOModuleScope;
pub extern fn g_io_module_scope_new(flags: GIOModuleScopeFlags) ?*GIOModuleScope;
pub extern fn g_io_module_scope_free(scope: ?*GIOModuleScope) void;
pub extern fn g_io_module_scope_block(scope: ?*GIOModuleScope, basename: [*c]const gchar) void;
pub const struct__GIOModuleClass = opaque {};
pub const GIOModuleClass = struct__GIOModuleClass;
pub extern fn g_io_module_get_type() GType;
pub extern fn g_io_module_new(filename: [*c]const gchar) ?*GIOModule;
pub extern fn g_io_modules_scan_all_in_directory(dirname: [*c]const u8) void;
pub extern fn g_io_modules_load_all_in_directory(dirname: [*c]const gchar) [*c]GList;
pub extern fn g_io_modules_scan_all_in_directory_with_scope(dirname: [*c]const gchar, scope: ?*GIOModuleScope) void;
pub extern fn g_io_modules_load_all_in_directory_with_scope(dirname: [*c]const gchar, scope: ?*GIOModuleScope) [*c]GList;
pub extern fn g_io_extension_point_register(name: [*c]const u8) ?*GIOExtensionPoint;
pub extern fn g_io_extension_point_lookup(name: [*c]const u8) ?*GIOExtensionPoint;
pub extern fn g_io_extension_point_set_required_type(extension_point: ?*GIOExtensionPoint, @"type": GType) void;
pub extern fn g_io_extension_point_get_required_type(extension_point: ?*GIOExtensionPoint) GType;
pub extern fn g_io_extension_point_get_extensions(extension_point: ?*GIOExtensionPoint) [*c]GList;
pub extern fn g_io_extension_point_get_extension_by_name(extension_point: ?*GIOExtensionPoint, name: [*c]const u8) ?*GIOExtension;
pub extern fn g_io_extension_point_implement(extension_point_name: [*c]const u8, @"type": GType, extension_name: [*c]const u8, priority: gint) ?*GIOExtension;
pub extern fn g_io_extension_get_type(extension: ?*GIOExtension) GType;
pub extern fn g_io_extension_get_name(extension: ?*GIOExtension) [*c]const u8;
pub extern fn g_io_extension_get_priority(extension: ?*GIOExtension) gint;
pub extern fn g_io_extension_ref_class(extension: ?*GIOExtension) [*c]GTypeClass;
pub extern fn g_io_module_load(module: ?*GIOModule) void;
pub extern fn g_io_module_unload(module: ?*GIOModule) void;
pub extern fn g_io_module_query() [*c][*c]u8;
pub extern fn g_io_scheduler_push_job(job_func: GIOSchedulerJobFunc, user_data: gpointer, notify: GDestroyNotify, io_priority: gint, cancellable: [*c]GCancellable) void;
pub extern fn g_io_scheduler_cancel_all_jobs() void;
pub extern fn g_io_scheduler_job_send_to_mainloop(job: ?*GIOSchedulerJob, func: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) gboolean;
pub extern fn g_io_scheduler_job_send_to_mainloop_async(job: ?*GIOSchedulerJob, func: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_list_model_get_type() GType;
pub const struct__GListModel = opaque {};
pub const GListModel = struct__GListModel;
pub const struct__GListModelInterface = extern struct {
    g_iface: GTypeInterface,
    get_item_type: ?*const fn (?*GListModel) callconv(.C) GType,
    get_n_items: ?*const fn (?*GListModel) callconv(.C) guint,
    get_item: ?*const fn (?*GListModel, guint) callconv(.C) gpointer,
};
pub const GListModelInterface = struct__GListModelInterface;
pub const GListModel_autoptr = ?*GListModel;
pub const GListModel_listautoptr = [*c]GList;
pub const GListModel_slistautoptr = [*c]GSList;
pub const GListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GListModel(arg__ptr: ?*GListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GListModel(arg__ptr: [*c]?*GListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn G_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GListModel {
    var ptr = arg_ptr;
    return @as(?*GListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), g_list_model_get_type())))));
}
pub fn G_IS_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn G_LIST_MODEL_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GListModelInterface {
    var ptr = arg_ptr;
    return @as([*c]GListModelInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), g_list_model_get_type()))));
}
pub extern fn g_list_model_get_item_type(list: ?*GListModel) GType;
pub extern fn g_list_model_get_n_items(list: ?*GListModel) guint;
pub extern fn g_list_model_get_item(list: ?*GListModel, position: guint) gpointer;
pub extern fn g_list_model_get_object(list: ?*GListModel, position: guint) [*c]GObject;
pub extern fn g_list_model_items_changed(list: ?*GListModel, position: guint, removed: guint, added: guint) void;
pub extern fn g_list_store_get_type() GType;
pub const struct__GListStore = opaque {};
pub const GListStore = struct__GListStore;
pub const GListStoreClass = extern struct {
    parent_class: GObjectClass,
};
pub const GListStore_autoptr = ?*GListStore;
pub const GListStore_listautoptr = [*c]GList;
pub const GListStore_slistautoptr = [*c]GSList;
pub const GListStore_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GListStore(arg__ptr: ?*GListStore) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GListStore(arg__ptr: [*c]?*GListStore) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GListStore(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GListStore(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GListStore(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GListStore(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GListStoreClass_autoptr = [*c]GListStoreClass;
pub const GListStoreClass_listautoptr = [*c]GList;
pub const GListStoreClass_slistautoptr = [*c]GSList;
pub const GListStoreClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GListStoreClass(arg__ptr: [*c]GListStoreClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GListStoreClass(arg__ptr: [*c][*c]GListStoreClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GListStoreClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GListStoreClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GListStoreClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GListStoreClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn G_LIST_STORE(arg_ptr: gpointer) callconv(.C) ?*GListStore {
    var ptr = arg_ptr;
    return @as(?*GListStore, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), g_list_store_get_type())))));
}
pub fn G_IS_LIST_STORE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_list_store_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn g_list_store_new(item_type: GType) ?*GListStore;
pub extern fn g_list_store_insert(store: ?*GListStore, position: guint, item: gpointer) void;
pub extern fn g_list_store_insert_sorted(store: ?*GListStore, item: gpointer, compare_func: GCompareDataFunc, user_data: gpointer) guint;
pub extern fn g_list_store_sort(store: ?*GListStore, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_list_store_append(store: ?*GListStore, item: gpointer) void;
pub extern fn g_list_store_remove(store: ?*GListStore, position: guint) void;
pub extern fn g_list_store_remove_all(store: ?*GListStore) void;
pub extern fn g_list_store_splice(store: ?*GListStore, position: guint, n_removals: guint, additions: [*c]gpointer, n_additions: guint) void;
pub extern fn g_list_store_find(store: ?*GListStore, item: gpointer, position: [*c]guint) gboolean;
pub extern fn g_list_store_find_with_equal_func(store: ?*GListStore, item: gpointer, equal_func: GEqualFunc, position: [*c]guint) gboolean;
pub extern fn g_list_store_find_with_equal_func_full(store: ?*GListStore, item: gpointer, equal_func: GEqualFuncFull, user_data: gpointer, position: [*c]guint) gboolean;
pub const struct__GLoadableIconIface = extern struct {
    g_iface: GTypeInterface,
    load: ?*const fn (?*GLoadableIcon, c_int, [*c][*c]u8, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GInputStream,
    load_async: ?*const fn (?*GLoadableIcon, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    load_finish: ?*const fn (?*GLoadableIcon, ?*GAsyncResult, [*c][*c]u8, [*c][*c]GError) callconv(.C) [*c]GInputStream,
};
pub const GLoadableIconIface = struct__GLoadableIconIface;
pub extern fn g_loadable_icon_get_type() GType;
pub extern fn g_loadable_icon_load(icon: ?*GLoadableIcon, size: c_int, @"type": [*c][*c]u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GInputStream;
pub extern fn g_loadable_icon_load_async(icon: ?*GLoadableIcon, size: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_loadable_icon_load_finish(icon: ?*GLoadableIcon, res: ?*GAsyncResult, @"type": [*c][*c]u8, @"error": [*c][*c]GError) [*c]GInputStream;
pub const struct__GMemoryInputStreamClass = extern struct {
    parent_class: GInputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GMemoryInputStreamClass = struct__GMemoryInputStreamClass;
pub extern fn g_memory_input_stream_get_type() GType;
pub extern fn g_memory_input_stream_new() [*c]GInputStream;
pub extern fn g_memory_input_stream_new_from_data(data: ?*const anyopaque, len: gssize, destroy: GDestroyNotify) [*c]GInputStream;
pub extern fn g_memory_input_stream_new_from_bytes(bytes: ?*GBytes) [*c]GInputStream;
pub extern fn g_memory_input_stream_add_data(stream: [*c]GMemoryInputStream, data: ?*const anyopaque, len: gssize, destroy: GDestroyNotify) void;
pub extern fn g_memory_input_stream_add_bytes(stream: [*c]GMemoryInputStream, bytes: ?*GBytes) void;
pub extern fn g_memory_monitor_get_type() GType;
pub const struct__GMemoryMonitor = opaque {};
pub const GMemoryMonitor = struct__GMemoryMonitor;
pub const struct__GMemoryMonitorInterface = extern struct {
    g_iface: GTypeInterface,
    low_memory_warning: ?*const fn (?*GMemoryMonitor, GMemoryMonitorWarningLevel) callconv(.C) void,
};
pub const GMemoryMonitorInterface = struct__GMemoryMonitorInterface;
pub const GMemoryMonitor_autoptr = ?*GMemoryMonitor;
pub const GMemoryMonitor_listautoptr = [*c]GList;
pub const GMemoryMonitor_slistautoptr = [*c]GSList;
pub const GMemoryMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMemoryMonitor(arg__ptr: ?*GMemoryMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GMemoryMonitor(arg__ptr: [*c]?*GMemoryMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMemoryMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMemoryMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GMemoryMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GMemoryMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn g_memory_monitor(arg_ptr: gpointer) callconv(.C) ?*GMemoryMonitor {
    var ptr = arg_ptr;
    return @as(?*GMemoryMonitor, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), g_memory_monitor_get_type())))));
}
pub fn g_IS_memory_monitor(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_memory_monitor_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn g_memory_monitor_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GMemoryMonitorInterface {
    var ptr = arg_ptr;
    return @as([*c]GMemoryMonitorInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), g_memory_monitor_get_type()))));
}
pub extern fn g_memory_monitor_dup_default() ?*GMemoryMonitor;
pub const struct__GMemoryOutputStreamClass = extern struct {
    parent_class: GOutputStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GMemoryOutputStreamClass = struct__GMemoryOutputStreamClass;
pub const GReallocFunc = ?*const fn (gpointer, gsize) callconv(.C) gpointer;
pub extern fn g_memory_output_stream_get_type() GType;
pub extern fn g_memory_output_stream_new(data: gpointer, size: gsize, realloc_function: GReallocFunc, destroy_function: GDestroyNotify) [*c]GOutputStream;
pub extern fn g_memory_output_stream_new_resizable() [*c]GOutputStream;
pub extern fn g_memory_output_stream_get_data(ostream: [*c]GMemoryOutputStream) gpointer;
pub extern fn g_memory_output_stream_get_size(ostream: [*c]GMemoryOutputStream) gsize;
pub extern fn g_memory_output_stream_get_data_size(ostream: [*c]GMemoryOutputStream) gsize;
pub extern fn g_memory_output_stream_steal_data(ostream: [*c]GMemoryOutputStream) gpointer;
pub extern fn g_memory_output_stream_steal_as_bytes(ostream: [*c]GMemoryOutputStream) ?*GBytes;
pub const struct__GMenuAttributeIterPrivate = opaque {};
pub const GMenuAttributeIterPrivate = struct__GMenuAttributeIterPrivate;
pub const struct__GMenuAttributeIter = extern struct {
    parent_instance: GObject,
    priv: ?*GMenuAttributeIterPrivate,
};
pub const GMenuAttributeIter = struct__GMenuAttributeIter;
pub const struct__GMenuLinkIterPrivate = opaque {};
pub const GMenuLinkIterPrivate = struct__GMenuLinkIterPrivate;
pub const struct__GMenuLinkIter = extern struct {
    parent_instance: GObject,
    priv: ?*GMenuLinkIterPrivate,
};
pub const GMenuLinkIter = struct__GMenuLinkIter;
pub const struct__GMenuModelClass = extern struct {
    parent_class: GObjectClass,
    is_mutable: ?*const fn ([*c]GMenuModel) callconv(.C) gboolean,
    get_n_items: ?*const fn ([*c]GMenuModel) callconv(.C) gint,
    get_item_attributes: ?*const fn ([*c]GMenuModel, gint, [*c]?*GHashTable) callconv(.C) void,
    iterate_item_attributes: ?*const fn ([*c]GMenuModel, gint) callconv(.C) [*c]GMenuAttributeIter,
    get_item_attribute_value: ?*const fn ([*c]GMenuModel, gint, [*c]const gchar, ?*const GVariantType) callconv(.C) ?*GVariant,
    get_item_links: ?*const fn ([*c]GMenuModel, gint, [*c]?*GHashTable) callconv(.C) void,
    iterate_item_links: ?*const fn ([*c]GMenuModel, gint) callconv(.C) [*c]GMenuLinkIter,
    get_item_link: ?*const fn ([*c]GMenuModel, gint, [*c]const gchar) callconv(.C) [*c]GMenuModel,
};
pub const GMenuModelClass = struct__GMenuModelClass;
pub const struct__GMenuAttributeIterClass = extern struct {
    parent_class: GObjectClass,
    get_next: ?*const fn ([*c]GMenuAttributeIter, [*c][*c]const gchar, [*c]?*GVariant) callconv(.C) gboolean,
};
pub const GMenuAttributeIterClass = struct__GMenuAttributeIterClass;
pub const struct__GMenuLinkIterClass = extern struct {
    parent_class: GObjectClass,
    get_next: ?*const fn ([*c]GMenuLinkIter, [*c][*c]const gchar, [*c][*c]GMenuModel) callconv(.C) gboolean,
};
pub const GMenuLinkIterClass = struct__GMenuLinkIterClass;
pub extern fn g_menu_model_get_type() GType;
pub extern fn g_menu_model_is_mutable(model: [*c]GMenuModel) gboolean;
pub extern fn g_menu_model_get_n_items(model: [*c]GMenuModel) gint;
pub extern fn g_menu_model_iterate_item_attributes(model: [*c]GMenuModel, item_index: gint) [*c]GMenuAttributeIter;
pub extern fn g_menu_model_get_item_attribute_value(model: [*c]GMenuModel, item_index: gint, attribute: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_menu_model_get_item_attribute(model: [*c]GMenuModel, item_index: gint, attribute: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_menu_model_iterate_item_links(model: [*c]GMenuModel, item_index: gint) [*c]GMenuLinkIter;
pub extern fn g_menu_model_get_item_link(model: [*c]GMenuModel, item_index: gint, link: [*c]const gchar) [*c]GMenuModel;
pub extern fn g_menu_model_items_changed(model: [*c]GMenuModel, position: gint, removed: gint, added: gint) void;
pub extern fn g_menu_attribute_iter_get_type() GType;
pub extern fn g_menu_attribute_iter_get_next(iter: [*c]GMenuAttributeIter, out_name: [*c][*c]const gchar, value: [*c]?*GVariant) gboolean;
pub extern fn g_menu_attribute_iter_next(iter: [*c]GMenuAttributeIter) gboolean;
pub extern fn g_menu_attribute_iter_get_name(iter: [*c]GMenuAttributeIter) [*c]const gchar;
pub extern fn g_menu_attribute_iter_get_value(iter: [*c]GMenuAttributeIter) ?*GVariant;
pub extern fn g_menu_link_iter_get_type() GType;
pub extern fn g_menu_link_iter_get_next(iter: [*c]GMenuLinkIter, out_link: [*c][*c]const gchar, value: [*c][*c]GMenuModel) gboolean;
pub extern fn g_menu_link_iter_next(iter: [*c]GMenuLinkIter) gboolean;
pub extern fn g_menu_link_iter_get_name(iter: [*c]GMenuLinkIter) [*c]const gchar;
pub extern fn g_menu_link_iter_get_value(iter: [*c]GMenuLinkIter) [*c]GMenuModel;
pub const struct__GMenuItem = opaque {};
pub const GMenuItem = struct__GMenuItem;
pub const struct__GMenu = opaque {};
pub const GMenu = struct__GMenu;
pub extern fn g_menu_get_type() GType;
pub extern fn g_menu_new() ?*GMenu;
pub extern fn g_menu_freeze(menu: ?*GMenu) void;
pub extern fn g_menu_insert_item(menu: ?*GMenu, position: gint, item: ?*GMenuItem) void;
pub extern fn g_menu_prepend_item(menu: ?*GMenu, item: ?*GMenuItem) void;
pub extern fn g_menu_append_item(menu: ?*GMenu, item: ?*GMenuItem) void;
pub extern fn g_menu_remove(menu: ?*GMenu, position: gint) void;
pub extern fn g_menu_remove_all(menu: ?*GMenu) void;
pub extern fn g_menu_insert(menu: ?*GMenu, position: gint, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_prepend(menu: ?*GMenu, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_append(menu: ?*GMenu, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_insert_section(menu: ?*GMenu, position: gint, label: [*c]const gchar, section: [*c]GMenuModel) void;
pub extern fn g_menu_prepend_section(menu: ?*GMenu, label: [*c]const gchar, section: [*c]GMenuModel) void;
pub extern fn g_menu_append_section(menu: ?*GMenu, label: [*c]const gchar, section: [*c]GMenuModel) void;
pub extern fn g_menu_insert_submenu(menu: ?*GMenu, position: gint, label: [*c]const gchar, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_prepend_submenu(menu: ?*GMenu, label: [*c]const gchar, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_append_submenu(menu: ?*GMenu, label: [*c]const gchar, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_item_get_type() GType;
pub extern fn g_menu_item_new(label: [*c]const gchar, detailed_action: [*c]const gchar) ?*GMenuItem;
pub extern fn g_menu_item_new_from_model(model: [*c]GMenuModel, item_index: gint) ?*GMenuItem;
pub extern fn g_menu_item_new_submenu(label: [*c]const gchar, submenu: [*c]GMenuModel) ?*GMenuItem;
pub extern fn g_menu_item_new_section(label: [*c]const gchar, section: [*c]GMenuModel) ?*GMenuItem;
pub extern fn g_menu_item_get_attribute_value(menu_item: ?*GMenuItem, attribute: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_menu_item_get_attribute(menu_item: ?*GMenuItem, attribute: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_menu_item_get_link(menu_item: ?*GMenuItem, link: [*c]const gchar) [*c]GMenuModel;
pub extern fn g_menu_item_set_attribute_value(menu_item: ?*GMenuItem, attribute: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_menu_item_set_attribute(menu_item: ?*GMenuItem, attribute: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_menu_item_set_link(menu_item: ?*GMenuItem, link: [*c]const gchar, model: [*c]GMenuModel) void;
pub extern fn g_menu_item_set_label(menu_item: ?*GMenuItem, label: [*c]const gchar) void;
pub extern fn g_menu_item_set_submenu(menu_item: ?*GMenuItem, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_item_set_section(menu_item: ?*GMenuItem, section: [*c]GMenuModel) void;
pub extern fn g_menu_item_set_action_and_target_value(menu_item: ?*GMenuItem, action: [*c]const gchar, target_value: ?*GVariant) void;
pub extern fn g_menu_item_set_action_and_target(menu_item: ?*GMenuItem, action: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_menu_item_set_detailed_action(menu_item: ?*GMenuItem, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_item_set_icon(menu_item: ?*GMenuItem, icon: ?*GIcon) void;
pub extern fn g_dbus_connection_export_menu_model(connection: ?*GDBusConnection, object_path: [*c]const gchar, menu: [*c]GMenuModel, @"error": [*c][*c]GError) guint;
pub extern fn g_dbus_connection_unexport_menu_model(connection: ?*GDBusConnection, export_id: guint) void;
pub const struct__GMountIface = extern struct {
    g_iface: GTypeInterface,
    changed: ?*const fn (?*GMount) callconv(.C) void,
    unmounted: ?*const fn (?*GMount) callconv(.C) void,
    get_root: ?*const fn (?*GMount) callconv(.C) ?*GFile,
    get_name: ?*const fn (?*GMount) callconv(.C) [*c]u8,
    get_icon: ?*const fn (?*GMount) callconv(.C) ?*GIcon,
    get_uuid: ?*const fn (?*GMount) callconv(.C) [*c]u8,
    get_volume: ?*const fn (?*GMount) callconv(.C) ?*GVolume,
    get_drive: ?*const fn (?*GMount) callconv(.C) ?*GDrive,
    can_unmount: ?*const fn (?*GMount) callconv(.C) gboolean,
    can_eject: ?*const fn (?*GMount) callconv(.C) gboolean,
    unmount: ?*const fn (?*GMount, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    unmount_finish: ?*const fn (?*GMount, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    eject: ?*const fn (?*GMount, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_finish: ?*const fn (?*GMount, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    remount: ?*const fn (?*GMount, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    remount_finish: ?*const fn (?*GMount, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    guess_content_type: ?*const fn (?*GMount, gboolean, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    guess_content_type_finish: ?*const fn (?*GMount, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c][*c]gchar,
    guess_content_type_sync: ?*const fn (?*GMount, gboolean, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c][*c]gchar,
    pre_unmount: ?*const fn (?*GMount) callconv(.C) void,
    unmount_with_operation: ?*const fn (?*GMount, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    unmount_with_operation_finish: ?*const fn (?*GMount, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    eject_with_operation: ?*const fn (?*GMount, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_with_operation_finish: ?*const fn (?*GMount, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_default_location: ?*const fn (?*GMount) callconv(.C) ?*GFile,
    get_sort_key: ?*const fn (?*GMount) callconv(.C) [*c]const gchar,
    get_symbolic_icon: ?*const fn (?*GMount) callconv(.C) ?*GIcon,
};
pub const GMountIface = struct__GMountIface;
pub extern fn g_mount_get_type() GType;
pub extern fn g_mount_get_root(mount: ?*GMount) ?*GFile;
pub extern fn g_mount_get_default_location(mount: ?*GMount) ?*GFile;
pub extern fn g_mount_get_name(mount: ?*GMount) [*c]u8;
pub extern fn g_mount_get_icon(mount: ?*GMount) ?*GIcon;
pub extern fn g_mount_get_symbolic_icon(mount: ?*GMount) ?*GIcon;
pub extern fn g_mount_get_uuid(mount: ?*GMount) [*c]u8;
pub extern fn g_mount_get_volume(mount: ?*GMount) ?*GVolume;
pub extern fn g_mount_get_drive(mount: ?*GMount) ?*GDrive;
pub extern fn g_mount_can_unmount(mount: ?*GMount) gboolean;
pub extern fn g_mount_can_eject(mount: ?*GMount) gboolean;
pub extern fn g_mount_unmount(mount: ?*GMount, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_unmount_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_mount_eject(mount: ?*GMount, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_eject_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_mount_remount(mount: ?*GMount, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_remount_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_mount_guess_content_type(mount: ?*GMount, force_rescan: gboolean, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_guess_content_type_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_mount_guess_content_type_sync(mount: ?*GMount, force_rescan: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_mount_is_shadowed(mount: ?*GMount) gboolean;
pub extern fn g_mount_shadow(mount: ?*GMount) void;
pub extern fn g_mount_unshadow(mount: ?*GMount) void;
pub extern fn g_mount_unmount_with_operation(mount: ?*GMount, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_unmount_with_operation_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_mount_eject_with_operation(mount: ?*GMount, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_eject_with_operation_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_mount_get_sort_key(mount: ?*GMount) [*c]const gchar;
pub const struct__GMountOperationClass = extern struct {
    parent_class: GObjectClass,
    ask_password: ?*const fn ([*c]GMountOperation, [*c]const u8, [*c]const u8, [*c]const u8, GAskPasswordFlags) callconv(.C) void,
    ask_question: ?*const fn ([*c]GMountOperation, [*c]const u8, [*c][*c]const u8) callconv(.C) void,
    reply: ?*const fn ([*c]GMountOperation, GMountOperationResult) callconv(.C) void,
    aborted: ?*const fn ([*c]GMountOperation) callconv(.C) void,
    show_processes: ?*const fn ([*c]GMountOperation, [*c]const gchar, [*c]GArray, [*c][*c]const gchar) callconv(.C) void,
    show_unmount_progress: ?*const fn ([*c]GMountOperation, [*c]const gchar, gint64, gint64) callconv(.C) void,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
    _g_reserved7: ?*const fn () callconv(.C) void,
    _g_reserved8: ?*const fn () callconv(.C) void,
    _g_reserved9: ?*const fn () callconv(.C) void,
};
pub const GMountOperationClass = struct__GMountOperationClass;
pub extern fn g_mount_operation_get_type() GType;
pub extern fn g_mount_operation_new() [*c]GMountOperation;
pub extern fn g_mount_operation_get_username(op: [*c]GMountOperation) [*c]const u8;
pub extern fn g_mount_operation_set_username(op: [*c]GMountOperation, username: [*c]const u8) void;
pub extern fn g_mount_operation_get_password(op: [*c]GMountOperation) [*c]const u8;
pub extern fn g_mount_operation_set_password(op: [*c]GMountOperation, password: [*c]const u8) void;
pub extern fn g_mount_operation_get_anonymous(op: [*c]GMountOperation) gboolean;
pub extern fn g_mount_operation_set_anonymous(op: [*c]GMountOperation, anonymous: gboolean) void;
pub extern fn g_mount_operation_get_domain(op: [*c]GMountOperation) [*c]const u8;
pub extern fn g_mount_operation_set_domain(op: [*c]GMountOperation, domain: [*c]const u8) void;
pub extern fn g_mount_operation_get_password_save(op: [*c]GMountOperation) GPasswordSave;
pub extern fn g_mount_operation_set_password_save(op: [*c]GMountOperation, save: GPasswordSave) void;
pub extern fn g_mount_operation_get_choice(op: [*c]GMountOperation) c_int;
pub extern fn g_mount_operation_set_choice(op: [*c]GMountOperation, choice: c_int) void;
pub extern fn g_mount_operation_reply(op: [*c]GMountOperation, result: GMountOperationResult) void;
pub extern fn g_mount_operation_get_is_tcrypt_hidden_volume(op: [*c]GMountOperation) gboolean;
pub extern fn g_mount_operation_set_is_tcrypt_hidden_volume(op: [*c]GMountOperation, hidden_volume: gboolean) void;
pub extern fn g_mount_operation_get_is_tcrypt_system_volume(op: [*c]GMountOperation) gboolean;
pub extern fn g_mount_operation_set_is_tcrypt_system_volume(op: [*c]GMountOperation, system_volume: gboolean) void;
pub extern fn g_mount_operation_get_pim(op: [*c]GMountOperation) guint;
pub extern fn g_mount_operation_set_pim(op: [*c]GMountOperation, pim: guint) void;
pub const struct__GNativeSocketAddressClass = extern struct {
    parent_class: GSocketAddressClass,
};
pub const GNativeSocketAddressClass = struct__GNativeSocketAddressClass;
pub extern fn g_native_socket_address_get_type() GType;
pub extern fn g_native_socket_address_new(native: gpointer, len: gsize) [*c]GSocketAddress;
pub const struct__GVolumeMonitorClass = extern struct {
    parent_class: GObjectClass,
    volume_added: ?*const fn ([*c]GVolumeMonitor, ?*GVolume) callconv(.C) void,
    volume_removed: ?*const fn ([*c]GVolumeMonitor, ?*GVolume) callconv(.C) void,
    volume_changed: ?*const fn ([*c]GVolumeMonitor, ?*GVolume) callconv(.C) void,
    mount_added: ?*const fn ([*c]GVolumeMonitor, ?*GMount) callconv(.C) void,
    mount_removed: ?*const fn ([*c]GVolumeMonitor, ?*GMount) callconv(.C) void,
    mount_pre_unmount: ?*const fn ([*c]GVolumeMonitor, ?*GMount) callconv(.C) void,
    mount_changed: ?*const fn ([*c]GVolumeMonitor, ?*GMount) callconv(.C) void,
    drive_connected: ?*const fn ([*c]GVolumeMonitor, ?*GDrive) callconv(.C) void,
    drive_disconnected: ?*const fn ([*c]GVolumeMonitor, ?*GDrive) callconv(.C) void,
    drive_changed: ?*const fn ([*c]GVolumeMonitor, ?*GDrive) callconv(.C) void,
    is_supported: ?*const fn () callconv(.C) gboolean,
    get_connected_drives: ?*const fn ([*c]GVolumeMonitor) callconv(.C) [*c]GList,
    get_volumes: ?*const fn ([*c]GVolumeMonitor) callconv(.C) [*c]GList,
    get_mounts: ?*const fn ([*c]GVolumeMonitor) callconv(.C) [*c]GList,
    get_volume_for_uuid: ?*const fn ([*c]GVolumeMonitor, [*c]const u8) callconv(.C) ?*GVolume,
    get_mount_for_uuid: ?*const fn ([*c]GVolumeMonitor, [*c]const u8) callconv(.C) ?*GMount,
    adopt_orphan_mount: ?*const fn (?*GMount, [*c]GVolumeMonitor) callconv(.C) ?*GVolume,
    drive_eject_button: ?*const fn ([*c]GVolumeMonitor, ?*GDrive) callconv(.C) void,
    drive_stop_button: ?*const fn ([*c]GVolumeMonitor, ?*GDrive) callconv(.C) void,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
};
pub const GVolumeMonitorClass = struct__GVolumeMonitorClass;
pub extern fn g_volume_monitor_get_type() GType;
pub extern fn g_volume_monitor_get() [*c]GVolumeMonitor;
pub extern fn g_volume_monitor_get_connected_drives(volume_monitor: [*c]GVolumeMonitor) [*c]GList;
pub extern fn g_volume_monitor_get_volumes(volume_monitor: [*c]GVolumeMonitor) [*c]GList;
pub extern fn g_volume_monitor_get_mounts(volume_monitor: [*c]GVolumeMonitor) [*c]GList;
pub extern fn g_volume_monitor_get_volume_for_uuid(volume_monitor: [*c]GVolumeMonitor, uuid: [*c]const u8) ?*GVolume;
pub extern fn g_volume_monitor_get_mount_for_uuid(volume_monitor: [*c]GVolumeMonitor, uuid: [*c]const u8) ?*GMount;
pub extern fn g_volume_monitor_adopt_orphan_mount(mount: ?*GMount) ?*GVolume;
pub const struct__GNativeVolumeMonitor = extern struct {
    parent_instance: GVolumeMonitor,
};
pub const GNativeVolumeMonitor = struct__GNativeVolumeMonitor;
pub const struct__GNativeVolumeMonitorClass = extern struct {
    parent_class: GVolumeMonitorClass,
    get_mount_for_mount_path: ?*const fn ([*c]const u8, [*c]GCancellable) callconv(.C) ?*GMount,
};
pub const GNativeVolumeMonitorClass = struct__GNativeVolumeMonitorClass;
pub extern fn g_native_volume_monitor_get_type() GType;
pub const struct__GNetworkAddressClass = extern struct {
    parent_class: GObjectClass,
};
pub const GNetworkAddressClass = struct__GNetworkAddressClass;
pub extern fn g_network_address_get_type() GType;
pub extern fn g_network_address_new(hostname: [*c]const gchar, port: guint16) ?*GSocketConnectable;
pub extern fn g_network_address_new_loopback(port: guint16) ?*GSocketConnectable;
pub extern fn g_network_address_parse(host_and_port: [*c]const gchar, default_port: guint16, @"error": [*c][*c]GError) ?*GSocketConnectable;
pub extern fn g_network_address_parse_uri(uri: [*c]const gchar, default_port: guint16, @"error": [*c][*c]GError) ?*GSocketConnectable;
pub extern fn g_network_address_get_hostname(addr: [*c]GNetworkAddress) [*c]const gchar;
pub extern fn g_network_address_get_port(addr: [*c]GNetworkAddress) guint16;
pub extern fn g_network_address_get_scheme(addr: [*c]GNetworkAddress) [*c]const gchar;
pub const struct__GNetworkMonitorInterface = extern struct {
    g_iface: GTypeInterface,
    network_changed: ?*const fn (?*GNetworkMonitor, gboolean) callconv(.C) void,
    can_reach: ?*const fn (?*GNetworkMonitor, ?*GSocketConnectable, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    can_reach_async: ?*const fn (?*GNetworkMonitor, ?*GSocketConnectable, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    can_reach_finish: ?*const fn (?*GNetworkMonitor, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GNetworkMonitorInterface = struct__GNetworkMonitorInterface;
pub extern fn g_network_monitor_get_type() GType;
pub extern fn g_network_monitor_get_default() ?*GNetworkMonitor;
pub extern fn g_network_monitor_get_network_available(monitor: ?*GNetworkMonitor) gboolean;
pub extern fn g_network_monitor_get_network_metered(monitor: ?*GNetworkMonitor) gboolean;
pub extern fn g_network_monitor_get_connectivity(monitor: ?*GNetworkMonitor) GNetworkConnectivity;
pub extern fn g_network_monitor_can_reach(monitor: ?*GNetworkMonitor, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_network_monitor_can_reach_async(monitor: ?*GNetworkMonitor, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_network_monitor_can_reach_finish(monitor: ?*GNetworkMonitor, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub const struct__GNetworkServiceClass = extern struct {
    parent_class: GObjectClass,
};
pub const GNetworkServiceClass = struct__GNetworkServiceClass;
pub extern fn g_network_service_get_type() GType;
pub extern fn g_network_service_new(service: [*c]const gchar, protocol: [*c]const gchar, domain: [*c]const gchar) ?*GSocketConnectable;
pub extern fn g_network_service_get_service(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_get_protocol(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_get_domain(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_get_scheme(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_set_scheme(srv: [*c]GNetworkService, scheme: [*c]const gchar) void;
pub extern fn g_notification_get_type() GType;
pub extern fn g_notification_new(title: [*c]const gchar) ?*GNotification;
pub extern fn g_notification_set_title(notification: ?*GNotification, title: [*c]const gchar) void;
pub extern fn g_notification_set_body(notification: ?*GNotification, body: [*c]const gchar) void;
pub extern fn g_notification_set_icon(notification: ?*GNotification, icon: ?*GIcon) void;
pub extern fn g_notification_set_urgent(notification: ?*GNotification, urgent: gboolean) void;
pub extern fn g_notification_set_priority(notification: ?*GNotification, priority: GNotificationPriority) void;
pub extern fn g_notification_set_category(notification: ?*GNotification, category: [*c]const gchar) void;
pub extern fn g_notification_add_button(notification: ?*GNotification, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_notification_add_button_with_target(notification: ?*GNotification, label: [*c]const gchar, action: [*c]const gchar, target_format: [*c]const gchar, ...) void;
pub extern fn g_notification_add_button_with_target_value(notification: ?*GNotification, label: [*c]const gchar, action: [*c]const gchar, target: ?*GVariant) void;
pub extern fn g_notification_set_default_action(notification: ?*GNotification, detailed_action: [*c]const gchar) void;
pub extern fn g_notification_set_default_action_and_target(notification: ?*GNotification, action: [*c]const gchar, target_format: [*c]const gchar, ...) void;
pub extern fn g_notification_set_default_action_and_target_value(notification: ?*GNotification, action: [*c]const gchar, target: ?*GVariant) void;
pub const struct__GPermissionClass = extern struct {
    parent_class: GObjectClass,
    acquire: ?*const fn ([*c]GPermission, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    acquire_async: ?*const fn ([*c]GPermission, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    acquire_finish: ?*const fn ([*c]GPermission, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    release: ?*const fn ([*c]GPermission, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    release_async: ?*const fn ([*c]GPermission, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    release_finish: ?*const fn ([*c]GPermission, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    reserved: [16]gpointer,
};
pub const GPermissionClass = struct__GPermissionClass;
pub extern fn g_permission_get_type() GType;
pub extern fn g_permission_acquire(permission: [*c]GPermission, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_permission_acquire_async(permission: [*c]GPermission, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_permission_acquire_finish(permission: [*c]GPermission, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_permission_release(permission: [*c]GPermission, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_permission_release_async(permission: [*c]GPermission, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_permission_release_finish(permission: [*c]GPermission, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_permission_get_allowed(permission: [*c]GPermission) gboolean;
pub extern fn g_permission_get_can_acquire(permission: [*c]GPermission) gboolean;
pub extern fn g_permission_get_can_release(permission: [*c]GPermission) gboolean;
pub extern fn g_permission_impl_update(permission: [*c]GPermission, allowed: gboolean, can_acquire: gboolean, can_release: gboolean) void;
pub const struct__GPollableInputStreamInterface = extern struct {
    g_iface: GTypeInterface,
    can_poll: ?*const fn (?*GPollableInputStream) callconv(.C) gboolean,
    is_readable: ?*const fn (?*GPollableInputStream) callconv(.C) gboolean,
    create_source: ?*const fn (?*GPollableInputStream, [*c]GCancellable) callconv(.C) [*c]GSource,
    read_nonblocking: ?*const fn (?*GPollableInputStream, ?*anyopaque, gsize, [*c][*c]GError) callconv(.C) gssize,
};
pub const GPollableInputStreamInterface = struct__GPollableInputStreamInterface;
pub extern fn g_pollable_input_stream_get_type() GType;
pub extern fn g_pollable_input_stream_can_poll(stream: ?*GPollableInputStream) gboolean;
pub extern fn g_pollable_input_stream_is_readable(stream: ?*GPollableInputStream) gboolean;
pub extern fn g_pollable_input_stream_create_source(stream: ?*GPollableInputStream, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_pollable_input_stream_read_nonblocking(stream: ?*GPollableInputStream, buffer: ?*anyopaque, count: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub const struct__GPollableOutputStreamInterface = extern struct {
    g_iface: GTypeInterface,
    can_poll: ?*const fn (?*GPollableOutputStream) callconv(.C) gboolean,
    is_writable: ?*const fn (?*GPollableOutputStream) callconv(.C) gboolean,
    create_source: ?*const fn (?*GPollableOutputStream, [*c]GCancellable) callconv(.C) [*c]GSource,
    write_nonblocking: ?*const fn (?*GPollableOutputStream, ?*const anyopaque, gsize, [*c][*c]GError) callconv(.C) gssize,
    writev_nonblocking: ?*const fn (?*GPollableOutputStream, [*c]const GOutputVector, gsize, [*c]gsize, [*c][*c]GError) callconv(.C) GPollableReturn,
};
pub const GPollableOutputStreamInterface = struct__GPollableOutputStreamInterface;
pub extern fn g_pollable_output_stream_get_type() GType;
pub extern fn g_pollable_output_stream_can_poll(stream: ?*GPollableOutputStream) gboolean;
pub extern fn g_pollable_output_stream_is_writable(stream: ?*GPollableOutputStream) gboolean;
pub extern fn g_pollable_output_stream_create_source(stream: ?*GPollableOutputStream, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_pollable_output_stream_write_nonblocking(stream: ?*GPollableOutputStream, buffer: ?*const anyopaque, count: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_pollable_output_stream_writev_nonblocking(stream: ?*GPollableOutputStream, vectors: [*c]const GOutputVector, n_vectors: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GPollableReturn;
pub extern fn g_pollable_source_new(pollable_stream: [*c]GObject) [*c]GSource;
pub extern fn g_pollable_source_new_full(pollable_stream: gpointer, child_source: [*c]GSource, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_pollable_stream_read(stream: [*c]GInputStream, buffer: ?*anyopaque, count: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_pollable_stream_write(stream: [*c]GOutputStream, buffer: ?*const anyopaque, count: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_pollable_stream_write_all(stream: [*c]GOutputStream, buffer: ?*const anyopaque, count: gsize, blocking: gboolean, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_power_profile_monitor_get_type() GType;
pub const struct__GPowerProfileMonitor = opaque {};
pub const GPowerProfileMonitor = struct__GPowerProfileMonitor;
pub const struct__GPowerProfileMonitorInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GPowerProfileMonitorInterface = struct__GPowerProfileMonitorInterface;
pub const GPowerProfileMonitor_autoptr = ?*GPowerProfileMonitor;
pub const GPowerProfileMonitor_listautoptr = [*c]GList;
pub const GPowerProfileMonitor_slistautoptr = [*c]GSList;
pub const GPowerProfileMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPowerProfileMonitor(arg__ptr: ?*GPowerProfileMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GPowerProfileMonitor(arg__ptr: [*c]?*GPowerProfileMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPowerProfileMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPowerProfileMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GPowerProfileMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GPowerProfileMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn g_power_profile_monitor(arg_ptr: gpointer) callconv(.C) ?*GPowerProfileMonitor {
    var ptr = arg_ptr;
    return @as(?*GPowerProfileMonitor, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), g_power_profile_monitor_get_type())))));
}
pub fn g_IS_power_profile_monitor(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = g_power_profile_monitor_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn g_power_profile_monitor_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GPowerProfileMonitorInterface {
    var ptr = arg_ptr;
    return @as([*c]GPowerProfileMonitorInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), g_power_profile_monitor_get_type()))));
}
pub extern fn g_power_profile_monitor_dup_default() ?*GPowerProfileMonitor;
pub extern fn g_power_profile_monitor_get_power_saver_enabled(monitor: ?*GPowerProfileMonitor) gboolean;
pub extern fn g_property_action_get_type() GType;
pub extern fn g_property_action_new(name: [*c]const gchar, object: gpointer, property_name: [*c]const gchar) ?*GPropertyAction;
pub const struct__GProxyInterface = extern struct {
    g_iface: GTypeInterface,
    connect: ?*const fn (?*GProxy, [*c]GIOStream, [*c]GProxyAddress, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GIOStream,
    connect_async: ?*const fn (?*GProxy, [*c]GIOStream, [*c]GProxyAddress, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    connect_finish: ?*const fn (?*GProxy, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GIOStream,
    supports_hostname: ?*const fn (?*GProxy) callconv(.C) gboolean,
};
pub const GProxyInterface = struct__GProxyInterface;
pub extern fn g_proxy_get_type() GType;
pub extern fn g_proxy_get_default_for_protocol(protocol: [*c]const gchar) ?*GProxy;
pub extern fn g_proxy_connect(proxy: ?*GProxy, connection: [*c]GIOStream, proxy_address: [*c]GProxyAddress, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GIOStream;
pub extern fn g_proxy_connect_async(proxy: ?*GProxy, connection: [*c]GIOStream, proxy_address: [*c]GProxyAddress, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_proxy_connect_finish(proxy: ?*GProxy, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GIOStream;
pub extern fn g_proxy_supports_hostname(proxy: ?*GProxy) gboolean;
pub const struct__GProxyAddressClass = extern struct {
    parent_class: GInetSocketAddressClass,
};
pub const GProxyAddressClass = struct__GProxyAddressClass;
pub extern fn g_proxy_address_get_type() GType;
pub extern fn g_proxy_address_new(inetaddr: [*c]GInetAddress, port: guint16, protocol: [*c]const gchar, dest_hostname: [*c]const gchar, dest_port: guint16, username: [*c]const gchar, password: [*c]const gchar) [*c]GSocketAddress;
pub extern fn g_proxy_address_get_protocol(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_destination_protocol(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_destination_hostname(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_destination_port(proxy: [*c]GProxyAddress) guint16;
pub extern fn g_proxy_address_get_username(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_password(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_uri(proxy: [*c]GProxyAddress) [*c]const gchar;
pub const struct__GSocketAddressEnumeratorClass = extern struct {
    parent_class: GObjectClass,
    next: ?*const fn ([*c]GSocketAddressEnumerator, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GSocketAddress,
    next_async: ?*const fn ([*c]GSocketAddressEnumerator, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    next_finish: ?*const fn ([*c]GSocketAddressEnumerator, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GSocketAddress,
};
pub const GSocketAddressEnumeratorClass = struct__GSocketAddressEnumeratorClass;
pub extern fn g_socket_address_enumerator_get_type() GType;
pub extern fn g_socket_address_enumerator_next(enumerator: [*c]GSocketAddressEnumerator, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocketAddress;
pub extern fn g_socket_address_enumerator_next_async(enumerator: [*c]GSocketAddressEnumerator, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_address_enumerator_next_finish(enumerator: [*c]GSocketAddressEnumerator, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GSocketAddress;
pub const struct__GProxyAddressEnumeratorClass = extern struct {
    parent_class: GSocketAddressEnumeratorClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
    _g_reserved7: ?*const fn () callconv(.C) void,
};
pub const GProxyAddressEnumeratorClass = struct__GProxyAddressEnumeratorClass;
pub extern fn g_proxy_address_enumerator_get_type() GType;
pub const struct__GProxyResolverInterface = extern struct {
    g_iface: GTypeInterface,
    is_supported: ?*const fn (?*GProxyResolver) callconv(.C) gboolean,
    lookup: ?*const fn (?*GProxyResolver, [*c]const gchar, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c][*c]gchar,
    lookup_async: ?*const fn (?*GProxyResolver, [*c]const gchar, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_finish: ?*const fn (?*GProxyResolver, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c][*c]gchar,
};
pub const GProxyResolverInterface = struct__GProxyResolverInterface;
pub extern fn g_proxy_resolver_get_type() GType;
pub extern fn g_proxy_resolver_get_default() ?*GProxyResolver;
pub extern fn g_proxy_resolver_is_supported(resolver: ?*GProxyResolver) gboolean;
pub extern fn g_proxy_resolver_lookup(resolver: ?*GProxyResolver, uri: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c][*c]gchar;
pub extern fn g_proxy_resolver_lookup_async(resolver: ?*GProxyResolver, uri: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_proxy_resolver_lookup_finish(resolver: ?*GProxyResolver, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c][*c]gchar;
pub const struct__GRemoteActionGroupInterface = extern struct {
    g_iface: GTypeInterface,
    activate_action_full: ?*const fn (?*GRemoteActionGroup, [*c]const gchar, ?*GVariant, ?*GVariant) callconv(.C) void,
    change_action_state_full: ?*const fn (?*GRemoteActionGroup, [*c]const gchar, ?*GVariant, ?*GVariant) callconv(.C) void,
};
pub const GRemoteActionGroupInterface = struct__GRemoteActionGroupInterface;
pub extern fn g_remote_action_group_get_type() GType;
pub extern fn g_remote_action_group_activate_action_full(remote: ?*GRemoteActionGroup, action_name: [*c]const gchar, parameter: ?*GVariant, platform_data: ?*GVariant) void;
pub extern fn g_remote_action_group_change_action_state_full(remote: ?*GRemoteActionGroup, action_name: [*c]const gchar, value: ?*GVariant, platform_data: ?*GVariant) void;
pub const struct__GResolverClass = extern struct {
    parent_class: GObjectClass,
    reload: ?*const fn ([*c]GResolver) callconv(.C) void,
    lookup_by_name: ?*const fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_by_name_async: ?*const fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_by_name_finish: ?*const fn ([*c]GResolver, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_by_address: ?*const fn ([*c]GResolver, [*c]GInetAddress, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]gchar,
    lookup_by_address_async: ?*const fn ([*c]GResolver, [*c]GInetAddress, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_by_address_finish: ?*const fn ([*c]GResolver, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]gchar,
    lookup_service: ?*const fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_service_async: ?*const fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_service_finish: ?*const fn ([*c]GResolver, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_records: ?*const fn ([*c]GResolver, [*c]const gchar, GResolverRecordType, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_records_async: ?*const fn ([*c]GResolver, [*c]const gchar, GResolverRecordType, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_records_finish: ?*const fn ([*c]GResolver, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_by_name_with_flags_async: ?*const fn ([*c]GResolver, [*c]const gchar, GResolverNameLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_by_name_with_flags_finish: ?*const fn ([*c]GResolver, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_by_name_with_flags: ?*const fn ([*c]GResolver, [*c]const gchar, GResolverNameLookupFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GList,
};
pub const GResolverClass = struct__GResolverClass;
pub const G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: c_int = 0;
pub const G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY: c_int = 1;
pub const G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY: c_int = 2;
pub const GResolverNameLookupFlags = c_uint;
pub extern fn g_resolver_get_type() GType;
pub extern fn g_resolver_get_default() [*c]GResolver;
pub extern fn g_resolver_set_default(resolver: [*c]GResolver) void;
pub extern fn g_resolver_lookup_by_name(resolver: [*c]GResolver, hostname: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_lookup_by_name_async(resolver: [*c]GResolver, hostname: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_by_name_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_lookup_by_name_with_flags_async(resolver: [*c]GResolver, hostname: [*c]const gchar, flags: GResolverNameLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_by_name_with_flags_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_lookup_by_name_with_flags(resolver: [*c]GResolver, hostname: [*c]const gchar, flags: GResolverNameLookupFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_free_addresses(addresses: [*c]GList) void;
pub extern fn g_resolver_lookup_by_address(resolver: [*c]GResolver, address: [*c]GInetAddress, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_resolver_lookup_by_address_async(resolver: [*c]GResolver, address: [*c]GInetAddress, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_by_address_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]gchar;
pub extern fn g_resolver_lookup_service(resolver: [*c]GResolver, service: [*c]const gchar, protocol: [*c]const gchar, domain: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_lookup_service_async(resolver: [*c]GResolver, service: [*c]const gchar, protocol: [*c]const gchar, domain: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_service_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_lookup_records(resolver: [*c]GResolver, rrname: [*c]const gchar, record_type: GResolverRecordType, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_lookup_records_async(resolver: [*c]GResolver, rrname: [*c]const gchar, record_type: GResolverRecordType, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_records_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_resolver_free_targets(targets: [*c]GList) void;
pub extern fn g_resolver_get_timeout(resolver: [*c]GResolver) c_uint;
pub extern fn g_resolver_set_timeout(resolver: [*c]GResolver, timeout_ms: c_uint) void;
pub extern fn g_resolver_error_quark() GQuark;
pub extern fn g_resource_error_quark() GQuark;
pub const GStaticResource = struct__GStaticResource;
pub const struct__GStaticResource = extern struct {
    data: [*c]const guint8,
    data_len: gsize,
    resource: ?*GResource,
    next: [*c]GStaticResource,
    padding: gpointer,
};
pub extern fn g_resource_get_type() GType;
pub extern fn g_resource_new_from_data(data: ?*GBytes, @"error": [*c][*c]GError) ?*GResource;
pub extern fn g_resource_ref(resource: ?*GResource) ?*GResource;
pub extern fn g_resource_unref(resource: ?*GResource) void;
pub extern fn g_resource_load(filename: [*c]const gchar, @"error": [*c][*c]GError) ?*GResource;
pub extern fn g_resource_open_stream(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c][*c]GError) [*c]GInputStream;
pub extern fn g_resource_lookup_data(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_resource_enumerate_children(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c][*c]GError) [*c][*c]u8;
pub extern fn g_resource_get_info(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, size: [*c]gsize, flags: [*c]guint32, @"error": [*c][*c]GError) gboolean;
pub extern fn g_resources_register(resource: ?*GResource) void;
pub extern fn g_resources_unregister(resource: ?*GResource) void;
pub extern fn g_resources_open_stream(path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c][*c]GError) [*c]GInputStream;
pub extern fn g_resources_lookup_data(path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c][*c]GError) ?*GBytes;
pub extern fn g_resources_enumerate_children(path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c][*c]GError) [*c][*c]u8;
pub extern fn g_resources_get_info(path: [*c]const u8, lookup_flags: GResourceLookupFlags, size: [*c]gsize, flags: [*c]guint32, @"error": [*c][*c]GError) gboolean;
pub extern fn g_static_resource_init(static_resource: [*c]GStaticResource) void;
pub extern fn g_static_resource_fini(static_resource: [*c]GStaticResource) void;
pub extern fn g_static_resource_get_resource(static_resource: [*c]GStaticResource) ?*GResource;
pub const struct__GSeekableIface = extern struct {
    g_iface: GTypeInterface,
    tell: ?*const fn (?*GSeekable) callconv(.C) goffset,
    can_seek: ?*const fn (?*GSeekable) callconv(.C) gboolean,
    seek: ?*const fn (?*GSeekable, goffset, GSeekType, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    can_truncate: ?*const fn (?*GSeekable) callconv(.C) gboolean,
    truncate_fn: ?*const fn (?*GSeekable, goffset, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
};
pub const GSeekableIface = struct__GSeekableIface;
pub extern fn g_seekable_get_type() GType;
pub extern fn g_seekable_tell(seekable: ?*GSeekable) goffset;
pub extern fn g_seekable_can_seek(seekable: ?*GSeekable) gboolean;
pub extern fn g_seekable_seek(seekable: ?*GSeekable, offset: goffset, @"type": GSeekType, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_seekable_can_truncate(seekable: ?*GSeekable) gboolean;
pub extern fn g_seekable_truncate(seekable: ?*GSeekable, offset: goffset, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub const struct__GSettingsSchemaSource = opaque {};
pub const GSettingsSchemaSource = struct__GSettingsSchemaSource;
pub const struct__GSettingsSchema = opaque {};
pub const GSettingsSchema = struct__GSettingsSchema;
pub const struct__GSettingsSchemaKey = opaque {};
pub const GSettingsSchemaKey = struct__GSettingsSchemaKey;
pub extern fn g_settings_schema_source_get_type() GType;
pub extern fn g_settings_schema_source_get_default() ?*GSettingsSchemaSource;
pub extern fn g_settings_schema_source_ref(source: ?*GSettingsSchemaSource) ?*GSettingsSchemaSource;
pub extern fn g_settings_schema_source_unref(source: ?*GSettingsSchemaSource) void;
pub extern fn g_settings_schema_source_new_from_directory(directory: [*c]const gchar, parent: ?*GSettingsSchemaSource, trusted: gboolean, @"error": [*c][*c]GError) ?*GSettingsSchemaSource;
pub extern fn g_settings_schema_source_lookup(source: ?*GSettingsSchemaSource, schema_id: [*c]const gchar, recursive: gboolean) ?*GSettingsSchema;
pub extern fn g_settings_schema_source_list_schemas(source: ?*GSettingsSchemaSource, recursive: gboolean, non_relocatable: [*c][*c][*c]gchar, relocatable: [*c][*c][*c]gchar) void;
pub extern fn g_settings_schema_get_type() GType;
pub extern fn g_settings_schema_ref(schema: ?*GSettingsSchema) ?*GSettingsSchema;
pub extern fn g_settings_schema_unref(schema: ?*GSettingsSchema) void;
pub extern fn g_settings_schema_get_id(schema: ?*GSettingsSchema) [*c]const gchar;
pub extern fn g_settings_schema_get_path(schema: ?*GSettingsSchema) [*c]const gchar;
pub extern fn g_settings_schema_get_key(schema: ?*GSettingsSchema, name: [*c]const gchar) ?*GSettingsSchemaKey;
pub extern fn g_settings_schema_has_key(schema: ?*GSettingsSchema, name: [*c]const gchar) gboolean;
pub extern fn g_settings_schema_list_keys(schema: ?*GSettingsSchema) [*c][*c]gchar;
pub extern fn g_settings_schema_list_children(schema: ?*GSettingsSchema) [*c][*c]gchar;
pub extern fn g_settings_schema_key_get_type() GType;
pub extern fn g_settings_schema_key_ref(key: ?*GSettingsSchemaKey) ?*GSettingsSchemaKey;
pub extern fn g_settings_schema_key_unref(key: ?*GSettingsSchemaKey) void;
pub extern fn g_settings_schema_key_get_value_type(key: ?*GSettingsSchemaKey) ?*const GVariantType;
pub extern fn g_settings_schema_key_get_default_value(key: ?*GSettingsSchemaKey) ?*GVariant;
pub extern fn g_settings_schema_key_get_range(key: ?*GSettingsSchemaKey) ?*GVariant;
pub extern fn g_settings_schema_key_range_check(key: ?*GSettingsSchemaKey, value: ?*GVariant) gboolean;
pub extern fn g_settings_schema_key_get_name(key: ?*GSettingsSchemaKey) [*c]const gchar;
pub extern fn g_settings_schema_key_get_summary(key: ?*GSettingsSchemaKey) [*c]const gchar;
pub extern fn g_settings_schema_key_get_description(key: ?*GSettingsSchemaKey) [*c]const gchar;
pub const struct__GSettingsClass = extern struct {
    parent_class: GObjectClass,
    writable_changed: ?*const fn ([*c]GSettings, [*c]const gchar) callconv(.C) void,
    changed: ?*const fn ([*c]GSettings, [*c]const gchar) callconv(.C) void,
    writable_change_event: ?*const fn ([*c]GSettings, GQuark) callconv(.C) gboolean,
    change_event: ?*const fn ([*c]GSettings, [*c]const GQuark, gint) callconv(.C) gboolean,
    padding: [20]gpointer,
};
pub const GSettingsClass = struct__GSettingsClass;
pub extern fn g_settings_get_type() GType;
pub extern fn g_settings_list_schemas() [*c]const [*c]const gchar;
pub extern fn g_settings_list_relocatable_schemas() [*c]const [*c]const gchar;
pub extern fn g_settings_new(schema_id: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_new_with_path(schema_id: [*c]const gchar, path: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_new_with_backend(schema_id: [*c]const gchar, backend: ?*GSettingsBackend) [*c]GSettings;
pub extern fn g_settings_new_with_backend_and_path(schema_id: [*c]const gchar, backend: ?*GSettingsBackend, path: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_new_full(schema: ?*GSettingsSchema, backend: ?*GSettingsBackend, path: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_list_children(settings: [*c]GSettings) [*c][*c]gchar;
pub extern fn g_settings_list_keys(settings: [*c]GSettings) [*c][*c]gchar;
pub extern fn g_settings_get_range(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_range_check(settings: [*c]GSettings, key: [*c]const gchar, value: ?*GVariant) gboolean;
pub extern fn g_settings_set_value(settings: [*c]GSettings, key: [*c]const gchar, value: ?*GVariant) gboolean;
pub extern fn g_settings_get_value(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_get_user_value(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_get_default_value(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_set(settings: [*c]GSettings, key: [*c]const gchar, format: [*c]const gchar, ...) gboolean;
pub extern fn g_settings_get(settings: [*c]GSettings, key: [*c]const gchar, format: [*c]const gchar, ...) void;
pub extern fn g_settings_reset(settings: [*c]GSettings, key: [*c]const gchar) void;
pub extern fn g_settings_get_int(settings: [*c]GSettings, key: [*c]const gchar) gint;
pub extern fn g_settings_set_int(settings: [*c]GSettings, key: [*c]const gchar, value: gint) gboolean;
pub extern fn g_settings_get_int64(settings: [*c]GSettings, key: [*c]const gchar) gint64;
pub extern fn g_settings_set_int64(settings: [*c]GSettings, key: [*c]const gchar, value: gint64) gboolean;
pub extern fn g_settings_get_uint(settings: [*c]GSettings, key: [*c]const gchar) guint;
pub extern fn g_settings_set_uint(settings: [*c]GSettings, key: [*c]const gchar, value: guint) gboolean;
pub extern fn g_settings_get_uint64(settings: [*c]GSettings, key: [*c]const gchar) guint64;
pub extern fn g_settings_set_uint64(settings: [*c]GSettings, key: [*c]const gchar, value: guint64) gboolean;
pub extern fn g_settings_get_string(settings: [*c]GSettings, key: [*c]const gchar) [*c]gchar;
pub extern fn g_settings_set_string(settings: [*c]GSettings, key: [*c]const gchar, value: [*c]const gchar) gboolean;
pub extern fn g_settings_get_boolean(settings: [*c]GSettings, key: [*c]const gchar) gboolean;
pub extern fn g_settings_set_boolean(settings: [*c]GSettings, key: [*c]const gchar, value: gboolean) gboolean;
pub extern fn g_settings_get_double(settings: [*c]GSettings, key: [*c]const gchar) gdouble;
pub extern fn g_settings_set_double(settings: [*c]GSettings, key: [*c]const gchar, value: gdouble) gboolean;
pub extern fn g_settings_get_strv(settings: [*c]GSettings, key: [*c]const gchar) [*c][*c]gchar;
pub extern fn g_settings_set_strv(settings: [*c]GSettings, key: [*c]const gchar, value: [*c]const [*c]const gchar) gboolean;
pub extern fn g_settings_get_enum(settings: [*c]GSettings, key: [*c]const gchar) gint;
pub extern fn g_settings_set_enum(settings: [*c]GSettings, key: [*c]const gchar, value: gint) gboolean;
pub extern fn g_settings_get_flags(settings: [*c]GSettings, key: [*c]const gchar) guint;
pub extern fn g_settings_set_flags(settings: [*c]GSettings, key: [*c]const gchar, value: guint) gboolean;
pub extern fn g_settings_get_child(settings: [*c]GSettings, name: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_is_writable(settings: [*c]GSettings, name: [*c]const gchar) gboolean;
pub extern fn g_settings_delay(settings: [*c]GSettings) void;
pub extern fn g_settings_apply(settings: [*c]GSettings) void;
pub extern fn g_settings_revert(settings: [*c]GSettings) void;
pub extern fn g_settings_get_has_unapplied(settings: [*c]GSettings) gboolean;
pub extern fn g_settings_sync() void;
pub const GSettingsBindSetMapping = ?*const fn ([*c]const GValue, ?*const GVariantType, gpointer) callconv(.C) ?*GVariant;
pub const GSettingsBindGetMapping = ?*const fn ([*c]GValue, ?*GVariant, gpointer) callconv(.C) gboolean;
pub const GSettingsGetMapping = ?*const fn (?*GVariant, [*c]gpointer, gpointer) callconv(.C) gboolean;
pub const G_SETTINGS_BIND_DEFAULT: c_int = 0;
pub const G_SETTINGS_BIND_GET: c_int = 1;
pub const G_SETTINGS_BIND_SET: c_int = 2;
pub const G_SETTINGS_BIND_NO_SENSITIVITY: c_int = 4;
pub const G_SETTINGS_BIND_GET_NO_CHANGES: c_int = 8;
pub const G_SETTINGS_BIND_INVERT_BOOLEAN: c_int = 16;
pub const GSettingsBindFlags = c_uint;
pub extern fn g_settings_bind(settings: [*c]GSettings, key: [*c]const gchar, object: gpointer, property: [*c]const gchar, flags: GSettingsBindFlags) void;
pub extern fn g_settings_bind_with_mapping(settings: [*c]GSettings, key: [*c]const gchar, object: gpointer, property: [*c]const gchar, flags: GSettingsBindFlags, get_mapping: GSettingsBindGetMapping, set_mapping: GSettingsBindSetMapping, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_settings_bind_writable(settings: [*c]GSettings, key: [*c]const gchar, object: gpointer, property: [*c]const gchar, inverted: gboolean) void;
pub extern fn g_settings_unbind(object: gpointer, property: [*c]const gchar) void;
pub extern fn g_settings_create_action(settings: [*c]GSettings, key: [*c]const gchar) ?*GAction;
pub extern fn g_settings_get_mapped(settings: [*c]GSettings, key: [*c]const gchar, mapping: GSettingsGetMapping, user_data: gpointer) gpointer;
pub extern fn g_simple_action_get_type() GType;
pub extern fn g_simple_action_new(name: [*c]const gchar, parameter_type: ?*const GVariantType) ?*GSimpleAction;
pub extern fn g_simple_action_new_stateful(name: [*c]const gchar, parameter_type: ?*const GVariantType, state: ?*GVariant) ?*GSimpleAction;
pub extern fn g_simple_action_set_enabled(simple: ?*GSimpleAction, enabled: gboolean) void;
pub extern fn g_simple_action_set_state(simple: ?*GSimpleAction, value: ?*GVariant) void;
pub extern fn g_simple_action_set_state_hint(simple: ?*GSimpleAction, state_hint: ?*GVariant) void;
pub const struct__GSimpleActionGroupClass = extern struct {
    parent_class: GObjectClass,
    padding: [12]gpointer,
};
pub const GSimpleActionGroupClass = struct__GSimpleActionGroupClass;
pub extern fn g_simple_action_group_get_type() GType;
pub extern fn g_simple_action_group_new() [*c]GSimpleActionGroup;
pub extern fn g_simple_action_group_lookup(simple: [*c]GSimpleActionGroup, action_name: [*c]const gchar) ?*GAction;
pub extern fn g_simple_action_group_insert(simple: [*c]GSimpleActionGroup, action: ?*GAction) void;
pub extern fn g_simple_action_group_remove(simple: [*c]GSimpleActionGroup, action_name: [*c]const gchar) void;
pub extern fn g_simple_action_group_add_entries(simple: [*c]GSimpleActionGroup, entries: [*c]const GActionEntry, n_entries: gint, user_data: gpointer) void;
pub const struct__GSimpleAsyncResultClass = opaque {};
pub const GSimpleAsyncResultClass = struct__GSimpleAsyncResultClass;
pub extern fn g_simple_async_result_get_type() GType;
pub extern fn g_simple_async_result_new(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, source_tag: gpointer) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_new_error(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, domain: GQuark, code: gint, format: [*c]const u8, ...) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_new_from_error(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]const GError) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_new_take_error(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]GError) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_set_op_res_gpointer(simple: ?*GSimpleAsyncResult, op_res: gpointer, destroy_op_res: GDestroyNotify) void;
pub extern fn g_simple_async_result_get_op_res_gpointer(simple: ?*GSimpleAsyncResult) gpointer;
pub extern fn g_simple_async_result_set_op_res_gssize(simple: ?*GSimpleAsyncResult, op_res: gssize) void;
pub extern fn g_simple_async_result_get_op_res_gssize(simple: ?*GSimpleAsyncResult) gssize;
pub extern fn g_simple_async_result_set_op_res_gboolean(simple: ?*GSimpleAsyncResult, op_res: gboolean) void;
pub extern fn g_simple_async_result_get_op_res_gboolean(simple: ?*GSimpleAsyncResult) gboolean;
pub extern fn g_simple_async_result_set_check_cancellable(simple: ?*GSimpleAsyncResult, check_cancellable: [*c]GCancellable) void;
pub extern fn g_simple_async_result_get_source_tag(simple: ?*GSimpleAsyncResult) gpointer;
pub extern fn g_simple_async_result_set_handle_cancellation(simple: ?*GSimpleAsyncResult, handle_cancellation: gboolean) void;
pub extern fn g_simple_async_result_complete(simple: ?*GSimpleAsyncResult) void;
pub extern fn g_simple_async_result_complete_in_idle(simple: ?*GSimpleAsyncResult) void;
pub extern fn g_simple_async_result_run_in_thread(simple: ?*GSimpleAsyncResult, func: GSimpleAsyncThreadFunc, io_priority: c_int, cancellable: [*c]GCancellable) void;
pub extern fn g_simple_async_result_set_from_error(simple: ?*GSimpleAsyncResult, @"error": [*c]const GError) void;
pub extern fn g_simple_async_result_take_error(simple: ?*GSimpleAsyncResult, @"error": [*c]GError) void;
pub extern fn g_simple_async_result_propagate_error(simple: ?*GSimpleAsyncResult, dest: [*c][*c]GError) gboolean;
pub extern fn g_simple_async_result_set_error(simple: ?*GSimpleAsyncResult, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_simple_async_result_set_error_va(simple: ?*GSimpleAsyncResult, domain: GQuark, code: gint, format: [*c]const u8, args: [*c]struct___va_list_tag) void;
pub extern fn g_simple_async_result_is_valid(result: ?*GAsyncResult, source: [*c]GObject, source_tag: gpointer) gboolean;
pub extern fn g_simple_async_report_error_in_idle(object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_simple_async_report_gerror_in_idle(object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]const GError) void;
pub extern fn g_simple_async_report_take_gerror_in_idle(object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]GError) void;
pub extern fn g_simple_io_stream_get_type() GType;
pub extern fn g_simple_io_stream_new(input_stream: [*c]GInputStream, output_stream: [*c]GOutputStream) [*c]GIOStream;
pub extern fn g_simple_permission_get_type() GType;
pub extern fn g_simple_permission_new(allowed: gboolean) [*c]GPermission;
pub const struct__GSimpleProxyResolverPrivate = opaque {};
pub const GSimpleProxyResolverPrivate = struct__GSimpleProxyResolverPrivate;
pub const struct__GSimpleProxyResolver = extern struct {
    parent_instance: GObject,
    priv: ?*GSimpleProxyResolverPrivate,
};
pub const GSimpleProxyResolver = struct__GSimpleProxyResolver;
pub const struct__GSimpleProxyResolverClass = extern struct {
    parent_class: GObjectClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GSimpleProxyResolverClass = struct__GSimpleProxyResolverClass;
pub extern fn g_simple_proxy_resolver_get_type() GType;
pub extern fn g_simple_proxy_resolver_new(default_proxy: [*c]const gchar, ignore_hosts: [*c][*c]gchar) ?*GProxyResolver;
pub extern fn g_simple_proxy_resolver_set_default_proxy(resolver: [*c]GSimpleProxyResolver, default_proxy: [*c]const gchar) void;
pub extern fn g_simple_proxy_resolver_set_ignore_hosts(resolver: [*c]GSimpleProxyResolver, ignore_hosts: [*c][*c]gchar) void;
pub extern fn g_simple_proxy_resolver_set_uri_proxy(resolver: [*c]GSimpleProxyResolver, uri_scheme: [*c]const gchar, proxy: [*c]const gchar) void;
pub const struct__GSocketClass = extern struct {
    parent_class: GObjectClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
    _g_reserved7: ?*const fn () callconv(.C) void,
    _g_reserved8: ?*const fn () callconv(.C) void,
    _g_reserved9: ?*const fn () callconv(.C) void,
    _g_reserved10: ?*const fn () callconv(.C) void,
};
pub const GSocketClass = struct__GSocketClass;
pub extern fn g_socket_get_type() GType;
pub extern fn g_socket_new(family: GSocketFamily, @"type": GSocketType, protocol: GSocketProtocol, @"error": [*c][*c]GError) [*c]GSocket;
pub extern fn g_socket_new_from_fd(fd: gint, @"error": [*c][*c]GError) [*c]GSocket;
pub extern fn g_socket_get_fd(socket: [*c]GSocket) c_int;
pub extern fn g_socket_get_family(socket: [*c]GSocket) GSocketFamily;
pub extern fn g_socket_get_socket_type(socket: [*c]GSocket) GSocketType;
pub extern fn g_socket_get_protocol(socket: [*c]GSocket) GSocketProtocol;
pub extern fn g_socket_get_local_address(socket: [*c]GSocket, @"error": [*c][*c]GError) [*c]GSocketAddress;
pub extern fn g_socket_get_remote_address(socket: [*c]GSocket, @"error": [*c][*c]GError) [*c]GSocketAddress;
pub extern fn g_socket_set_blocking(socket: [*c]GSocket, blocking: gboolean) void;
pub extern fn g_socket_get_blocking(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_set_keepalive(socket: [*c]GSocket, keepalive: gboolean) void;
pub extern fn g_socket_get_keepalive(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_get_listen_backlog(socket: [*c]GSocket) gint;
pub extern fn g_socket_set_listen_backlog(socket: [*c]GSocket, backlog: gint) void;
pub extern fn g_socket_get_timeout(socket: [*c]GSocket) guint;
pub extern fn g_socket_set_timeout(socket: [*c]GSocket, timeout: guint) void;
pub extern fn g_socket_get_ttl(socket: [*c]GSocket) guint;
pub extern fn g_socket_set_ttl(socket: [*c]GSocket, ttl: guint) void;
pub extern fn g_socket_get_broadcast(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_set_broadcast(socket: [*c]GSocket, broadcast: gboolean) void;
pub extern fn g_socket_get_multicast_loopback(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_set_multicast_loopback(socket: [*c]GSocket, loopback: gboolean) void;
pub extern fn g_socket_get_multicast_ttl(socket: [*c]GSocket) guint;
pub extern fn g_socket_set_multicast_ttl(socket: [*c]GSocket, ttl: guint) void;
pub extern fn g_socket_is_connected(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_bind(socket: [*c]GSocket, address: [*c]GSocketAddress, allow_reuse: gboolean, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_join_multicast_group(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: gboolean, iface: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_leave_multicast_group(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: gboolean, iface: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_join_multicast_group_ssm(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: [*c]GInetAddress, iface: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_leave_multicast_group_ssm(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: [*c]GInetAddress, iface: [*c]const gchar, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_connect(socket: [*c]GSocket, address: [*c]GSocketAddress, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_check_connect_result(socket: [*c]GSocket, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_get_available_bytes(socket: [*c]GSocket) gssize;
pub extern fn g_socket_condition_check(socket: [*c]GSocket, condition: GIOCondition) GIOCondition;
pub extern fn g_socket_condition_wait(socket: [*c]GSocket, condition: GIOCondition, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_condition_timed_wait(socket: [*c]GSocket, condition: GIOCondition, timeout_us: gint64, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_accept(socket: [*c]GSocket, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocket;
pub extern fn g_socket_listen(socket: [*c]GSocket, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_receive(socket: [*c]GSocket, buffer: [*c]gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_receive_from(socket: [*c]GSocket, address: [*c][*c]GSocketAddress, buffer: [*c]gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_send(socket: [*c]GSocket, buffer: [*c]const gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_send_to(socket: [*c]GSocket, address: [*c]GSocketAddress, buffer: [*c]const gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_receive_message(socket: [*c]GSocket, address: [*c][*c]GSocketAddress, vectors: [*c]GInputVector, num_vectors: gint, messages: [*c][*c][*c]GSocketControlMessage, num_messages: [*c]gint, flags: [*c]gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_send_message(socket: [*c]GSocket, address: [*c]GSocketAddress, vectors: [*c]GOutputVector, num_vectors: gint, messages: [*c][*c]GSocketControlMessage, num_messages: gint, flags: gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_receive_messages(socket: [*c]GSocket, messages: [*c]GInputMessage, num_messages: guint, flags: gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint;
pub extern fn g_socket_send_messages(socket: [*c]GSocket, messages: [*c]GOutputMessage, num_messages: guint, flags: gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint;
pub extern fn g_socket_close(socket: [*c]GSocket, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_shutdown(socket: [*c]GSocket, shutdown_read: gboolean, shutdown_write: gboolean, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_is_closed(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_create_source(socket: [*c]GSocket, condition: GIOCondition, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_socket_speaks_ipv4(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_get_credentials(socket: [*c]GSocket, @"error": [*c][*c]GError) ?*GCredentials;
pub extern fn g_socket_receive_with_blocking(socket: [*c]GSocket, buffer: [*c]gchar, size: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_send_with_blocking(socket: [*c]GSocket, buffer: [*c]const gchar, size: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gssize;
pub extern fn g_socket_send_message_with_timeout(socket: [*c]GSocket, address: [*c]GSocketAddress, vectors: [*c]const GOutputVector, num_vectors: gint, messages: [*c][*c]GSocketControlMessage, num_messages: gint, flags: gint, timeout_us: gint64, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GPollableReturn;
pub extern fn g_socket_get_option(socket: [*c]GSocket, level: gint, optname: gint, value: [*c]gint, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_set_option(socket: [*c]GSocket, level: gint, optname: gint, value: gint, @"error": [*c][*c]GError) gboolean;
pub const struct__GSocketClientClass = extern struct {
    parent_class: GObjectClass,
    event: ?*const fn ([*c]GSocketClient, GSocketClientEvent, ?*GSocketConnectable, [*c]GIOStream) callconv(.C) void,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
};
pub const GSocketClientClass = struct__GSocketClientClass;
pub extern fn g_socket_client_get_type() GType;
pub extern fn g_socket_client_new() [*c]GSocketClient;
pub extern fn g_socket_client_get_family(client: [*c]GSocketClient) GSocketFamily;
pub extern fn g_socket_client_set_family(client: [*c]GSocketClient, family: GSocketFamily) void;
pub extern fn g_socket_client_get_socket_type(client: [*c]GSocketClient) GSocketType;
pub extern fn g_socket_client_set_socket_type(client: [*c]GSocketClient, @"type": GSocketType) void;
pub extern fn g_socket_client_get_protocol(client: [*c]GSocketClient) GSocketProtocol;
pub extern fn g_socket_client_set_protocol(client: [*c]GSocketClient, protocol: GSocketProtocol) void;
pub extern fn g_socket_client_get_local_address(client: [*c]GSocketClient) [*c]GSocketAddress;
pub extern fn g_socket_client_set_local_address(client: [*c]GSocketClient, address: [*c]GSocketAddress) void;
pub extern fn g_socket_client_get_timeout(client: [*c]GSocketClient) guint;
pub extern fn g_socket_client_set_timeout(client: [*c]GSocketClient, timeout: guint) void;
pub extern fn g_socket_client_get_enable_proxy(client: [*c]GSocketClient) gboolean;
pub extern fn g_socket_client_set_enable_proxy(client: [*c]GSocketClient, enable: gboolean) void;
pub extern fn g_socket_client_get_tls(client: [*c]GSocketClient) gboolean;
pub extern fn g_socket_client_set_tls(client: [*c]GSocketClient, tls: gboolean) void;
pub extern fn g_socket_client_get_tls_validation_flags(client: [*c]GSocketClient) GTlsCertificateFlags;
pub extern fn g_socket_client_set_tls_validation_flags(client: [*c]GSocketClient, flags: GTlsCertificateFlags) void;
pub extern fn g_socket_client_get_proxy_resolver(client: [*c]GSocketClient) ?*GProxyResolver;
pub extern fn g_socket_client_set_proxy_resolver(client: [*c]GSocketClient, proxy_resolver: ?*GProxyResolver) void;
pub extern fn g_socket_client_connect(client: [*c]GSocketClient, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_host(client: [*c]GSocketClient, host_and_port: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_service(client: [*c]GSocketClient, domain: [*c]const gchar, service: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_uri(client: [*c]GSocketClient, uri: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_async(client: [*c]GSocketClient, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_host_async(client: [*c]GSocketClient, host_and_port: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_to_host_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_service_async(client: [*c]GSocketClient, domain: [*c]const gchar, service: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_to_service_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_uri_async(client: [*c]GSocketClient, uri: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_to_uri_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_client_add_application_proxy(client: [*c]GSocketClient, protocol: [*c]const gchar) void;
pub const struct__GSocketConnectableIface = extern struct {
    g_iface: GTypeInterface,
    enumerate: ?*const fn (?*GSocketConnectable) callconv(.C) [*c]GSocketAddressEnumerator,
    proxy_enumerate: ?*const fn (?*GSocketConnectable) callconv(.C) [*c]GSocketAddressEnumerator,
    to_string: ?*const fn (?*GSocketConnectable) callconv(.C) [*c]gchar,
};
pub const GSocketConnectableIface = struct__GSocketConnectableIface;
pub extern fn g_socket_connectable_get_type() GType;
pub extern fn g_socket_connectable_enumerate(connectable: ?*GSocketConnectable) [*c]GSocketAddressEnumerator;
pub extern fn g_socket_connectable_proxy_enumerate(connectable: ?*GSocketConnectable) [*c]GSocketAddressEnumerator;
pub extern fn g_socket_connectable_to_string(connectable: ?*GSocketConnectable) [*c]gchar;
pub const struct__GSocketConnectionClass = extern struct {
    parent_class: GIOStreamClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
};
pub const GSocketConnectionClass = struct__GSocketConnectionClass;
pub extern fn g_socket_connection_get_type() GType;
pub extern fn g_socket_connection_is_connected(connection: [*c]GSocketConnection) gboolean;
pub extern fn g_socket_connection_connect(connection: [*c]GSocketConnection, address: [*c]GSocketAddress, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_connection_connect_async(connection: [*c]GSocketConnection, address: [*c]GSocketAddress, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_connection_connect_finish(connection: [*c]GSocketConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_connection_get_socket(connection: [*c]GSocketConnection) [*c]GSocket;
pub extern fn g_socket_connection_get_local_address(connection: [*c]GSocketConnection, @"error": [*c][*c]GError) [*c]GSocketAddress;
pub extern fn g_socket_connection_get_remote_address(connection: [*c]GSocketConnection, @"error": [*c][*c]GError) [*c]GSocketAddress;
pub extern fn g_socket_connection_factory_register_type(g_type: GType, family: GSocketFamily, @"type": GSocketType, protocol: gint) void;
pub extern fn g_socket_connection_factory_lookup_type(family: GSocketFamily, @"type": GSocketType, protocol_id: gint) GType;
pub extern fn g_socket_connection_factory_create_connection(socket: [*c]GSocket) [*c]GSocketConnection;
pub const struct__GSocketControlMessageClass = extern struct {
    parent_class: GObjectClass,
    get_size: ?*const fn ([*c]GSocketControlMessage) callconv(.C) gsize,
    get_level: ?*const fn ([*c]GSocketControlMessage) callconv(.C) c_int,
    get_type: ?*const fn ([*c]GSocketControlMessage) callconv(.C) c_int,
    serialize: ?*const fn ([*c]GSocketControlMessage, gpointer) callconv(.C) void,
    deserialize: ?*const fn (c_int, c_int, gsize, gpointer) callconv(.C) [*c]GSocketControlMessage,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GSocketControlMessageClass = struct__GSocketControlMessageClass;
pub extern fn g_socket_control_message_get_type() GType;
pub extern fn g_socket_control_message_get_size(message: [*c]GSocketControlMessage) gsize;
pub extern fn g_socket_control_message_get_level(message: [*c]GSocketControlMessage) c_int;
pub extern fn g_socket_control_message_get_msg_type(message: [*c]GSocketControlMessage) c_int;
pub extern fn g_socket_control_message_serialize(message: [*c]GSocketControlMessage, data: gpointer) void;
pub extern fn g_socket_control_message_deserialize(level: c_int, @"type": c_int, size: gsize, data: gpointer) [*c]GSocketControlMessage;
pub const struct__GSocketListenerClass = extern struct {
    parent_class: GObjectClass,
    changed: ?*const fn ([*c]GSocketListener) callconv(.C) void,
    event: ?*const fn ([*c]GSocketListener, GSocketListenerEvent, [*c]GSocket) callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
};
pub const GSocketListenerClass = struct__GSocketListenerClass;
pub extern fn g_socket_listener_get_type() GType;
pub extern fn g_socket_listener_new() [*c]GSocketListener;
pub extern fn g_socket_listener_set_backlog(listener: [*c]GSocketListener, listen_backlog: c_int) void;
pub extern fn g_socket_listener_add_socket(listener: [*c]GSocketListener, socket: [*c]GSocket, source_object: [*c]GObject, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_listener_add_address(listener: [*c]GSocketListener, address: [*c]GSocketAddress, @"type": GSocketType, protocol: GSocketProtocol, source_object: [*c]GObject, effective_address: [*c][*c]GSocketAddress, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_listener_add_inet_port(listener: [*c]GSocketListener, port: guint16, source_object: [*c]GObject, @"error": [*c][*c]GError) gboolean;
pub extern fn g_socket_listener_add_any_inet_port(listener: [*c]GSocketListener, source_object: [*c]GObject, @"error": [*c][*c]GError) guint16;
pub extern fn g_socket_listener_accept_socket(listener: [*c]GSocketListener, source_object: [*c][*c]GObject, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocket;
pub extern fn g_socket_listener_accept_socket_async(listener: [*c]GSocketListener, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_listener_accept_socket_finish(listener: [*c]GSocketListener, result: ?*GAsyncResult, source_object: [*c][*c]GObject, @"error": [*c][*c]GError) [*c]GSocket;
pub extern fn g_socket_listener_accept(listener: [*c]GSocketListener, source_object: [*c][*c]GObject, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_listener_accept_async(listener: [*c]GSocketListener, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_listener_accept_finish(listener: [*c]GSocketListener, result: ?*GAsyncResult, source_object: [*c][*c]GObject, @"error": [*c][*c]GError) [*c]GSocketConnection;
pub extern fn g_socket_listener_close(listener: [*c]GSocketListener) void;
pub const struct__GSocketServiceClass = extern struct {
    parent_class: GSocketListenerClass,
    incoming: ?*const fn ([*c]GSocketService, [*c]GSocketConnection, [*c]GObject) callconv(.C) gboolean,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
};
pub const GSocketServiceClass = struct__GSocketServiceClass;
pub extern fn g_socket_service_get_type() GType;
pub extern fn g_socket_service_new() [*c]GSocketService;
pub extern fn g_socket_service_start(service: [*c]GSocketService) void;
pub extern fn g_socket_service_stop(service: [*c]GSocketService) void;
pub extern fn g_socket_service_is_active(service: [*c]GSocketService) gboolean;
pub extern fn g_srv_target_get_type() GType;
pub extern fn g_srv_target_new(hostname: [*c]const gchar, port: guint16, priority: guint16, weight: guint16) ?*GSrvTarget;
pub extern fn g_srv_target_copy(target: ?*GSrvTarget) ?*GSrvTarget;
pub extern fn g_srv_target_free(target: ?*GSrvTarget) void;
pub extern fn g_srv_target_get_hostname(target: ?*GSrvTarget) [*c]const gchar;
pub extern fn g_srv_target_get_port(target: ?*GSrvTarget) guint16;
pub extern fn g_srv_target_get_priority(target: ?*GSrvTarget) guint16;
pub extern fn g_srv_target_get_weight(target: ?*GSrvTarget) guint16;
pub extern fn g_srv_target_list_sort(targets: [*c]GList) [*c]GList;
pub extern fn g_subprocess_get_type() GType;
pub extern fn g_subprocess_new(flags: GSubprocessFlags, @"error": [*c][*c]GError, argv0: [*c]const gchar, ...) ?*GSubprocess;
pub extern fn g_subprocess_newv(argv: [*c]const [*c]const gchar, flags: GSubprocessFlags, @"error": [*c][*c]GError) ?*GSubprocess;
pub extern fn g_subprocess_get_stdin_pipe(subprocess: ?*GSubprocess) [*c]GOutputStream;
pub extern fn g_subprocess_get_stdout_pipe(subprocess: ?*GSubprocess) [*c]GInputStream;
pub extern fn g_subprocess_get_stderr_pipe(subprocess: ?*GSubprocess) [*c]GInputStream;
pub extern fn g_subprocess_get_identifier(subprocess: ?*GSubprocess) [*c]const gchar;
pub extern fn g_subprocess_send_signal(subprocess: ?*GSubprocess, signal_num: gint) void;
pub extern fn g_subprocess_force_exit(subprocess: ?*GSubprocess) void;
pub extern fn g_subprocess_wait(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_wait_async(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_wait_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_wait_check(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_wait_check_async(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_wait_check_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_get_status(subprocess: ?*GSubprocess) gint;
pub extern fn g_subprocess_get_successful(subprocess: ?*GSubprocess) gboolean;
pub extern fn g_subprocess_get_if_exited(subprocess: ?*GSubprocess) gboolean;
pub extern fn g_subprocess_get_exit_status(subprocess: ?*GSubprocess) gint;
pub extern fn g_subprocess_get_if_signaled(subprocess: ?*GSubprocess) gboolean;
pub extern fn g_subprocess_get_term_sig(subprocess: ?*GSubprocess) gint;
pub extern fn g_subprocess_communicate(subprocess: ?*GSubprocess, stdin_buf: ?*GBytes, cancellable: [*c]GCancellable, stdout_buf: [*c]?*GBytes, stderr_buf: [*c]?*GBytes, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_communicate_async(subprocess: ?*GSubprocess, stdin_buf: ?*GBytes, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_communicate_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, stdout_buf: [*c]?*GBytes, stderr_buf: [*c]?*GBytes, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_communicate_utf8(subprocess: ?*GSubprocess, stdin_buf: [*c]const u8, cancellable: [*c]GCancellable, stdout_buf: [*c][*c]u8, stderr_buf: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_communicate_utf8_async(subprocess: ?*GSubprocess, stdin_buf: [*c]const u8, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_communicate_utf8_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, stdout_buf: [*c][*c]u8, stderr_buf: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn g_subprocess_launcher_get_type() GType;
pub extern fn g_subprocess_launcher_new(flags: GSubprocessFlags) ?*GSubprocessLauncher;
pub extern fn g_subprocess_launcher_spawn(self: ?*GSubprocessLauncher, @"error": [*c][*c]GError, argv0: [*c]const gchar, ...) ?*GSubprocess;
pub extern fn g_subprocess_launcher_spawnv(self: ?*GSubprocessLauncher, argv: [*c]const [*c]const gchar, @"error": [*c][*c]GError) ?*GSubprocess;
pub extern fn g_subprocess_launcher_set_environ(self: ?*GSubprocessLauncher, env: [*c][*c]gchar) void;
pub extern fn g_subprocess_launcher_setenv(self: ?*GSubprocessLauncher, variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) void;
pub extern fn g_subprocess_launcher_unsetenv(self: ?*GSubprocessLauncher, variable: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_getenv(self: ?*GSubprocessLauncher, variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_subprocess_launcher_set_cwd(self: ?*GSubprocessLauncher, cwd: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_set_flags(self: ?*GSubprocessLauncher, flags: GSubprocessFlags) void;
pub extern fn g_subprocess_launcher_set_stdin_file_path(self: ?*GSubprocessLauncher, path: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_take_stdin_fd(self: ?*GSubprocessLauncher, fd: gint) void;
pub extern fn g_subprocess_launcher_set_stdout_file_path(self: ?*GSubprocessLauncher, path: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_take_stdout_fd(self: ?*GSubprocessLauncher, fd: gint) void;
pub extern fn g_subprocess_launcher_set_stderr_file_path(self: ?*GSubprocessLauncher, path: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_take_stderr_fd(self: ?*GSubprocessLauncher, fd: gint) void;
pub extern fn g_subprocess_launcher_take_fd(self: ?*GSubprocessLauncher, source_fd: gint, target_fd: gint) void;
pub extern fn g_subprocess_launcher_close(self: ?*GSubprocessLauncher) void;
pub extern fn g_subprocess_launcher_set_child_setup(self: ?*GSubprocessLauncher, child_setup: GSpawnChildSetupFunc, user_data: gpointer, destroy_notify: GDestroyNotify) void;
pub const struct__GTaskClass = opaque {};
pub const GTaskClass = struct__GTaskClass;
pub extern fn g_task_get_type() GType;
pub extern fn g_task_new(source_object: gpointer, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, callback_data: gpointer) ?*GTask;
pub extern fn g_task_report_error(source_object: gpointer, callback: GAsyncReadyCallback, callback_data: gpointer, source_tag: gpointer, @"error": [*c]GError) void;
pub extern fn g_task_report_new_error(source_object: gpointer, callback: GAsyncReadyCallback, callback_data: gpointer, source_tag: gpointer, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_task_set_task_data(task: ?*GTask, task_data: gpointer, task_data_destroy: GDestroyNotify) void;
pub extern fn g_task_set_priority(task: ?*GTask, priority: gint) void;
pub extern fn g_task_set_check_cancellable(task: ?*GTask, check_cancellable: gboolean) void;
pub extern fn g_task_set_source_tag(task: ?*GTask, source_tag: gpointer) void;
pub extern fn g_task_set_name(task: ?*GTask, name: [*c]const gchar) void;
pub extern fn g_task_set_static_name(task: ?*GTask, name: [*c]const gchar) void;
pub extern fn g_task_get_source_object(task: ?*GTask) gpointer;
pub extern fn g_task_get_task_data(task: ?*GTask) gpointer;
pub extern fn g_task_get_priority(task: ?*GTask) gint;
pub extern fn g_task_get_context(task: ?*GTask) ?*GMainContext;
pub extern fn g_task_get_cancellable(task: ?*GTask) [*c]GCancellable;
pub extern fn g_task_get_check_cancellable(task: ?*GTask) gboolean;
pub extern fn g_task_get_source_tag(task: ?*GTask) gpointer;
pub extern fn g_task_get_name(task: ?*GTask) [*c]const gchar;
pub extern fn g_task_is_valid(result: gpointer, source_object: gpointer) gboolean;
pub const GTaskThreadFunc = ?*const fn (?*GTask, gpointer, gpointer, [*c]GCancellable) callconv(.C) void;
pub extern fn g_task_run_in_thread(task: ?*GTask, task_func: GTaskThreadFunc) void;
pub extern fn g_task_run_in_thread_sync(task: ?*GTask, task_func: GTaskThreadFunc) void;
pub extern fn g_task_set_return_on_cancel(task: ?*GTask, return_on_cancel: gboolean) gboolean;
pub extern fn g_task_get_return_on_cancel(task: ?*GTask) gboolean;
pub extern fn g_task_attach_source(task: ?*GTask, source: [*c]GSource, callback: GSourceFunc) void;
pub extern fn g_task_return_pointer(task: ?*GTask, result: gpointer, result_destroy: GDestroyNotify) void;
pub extern fn g_task_return_boolean(task: ?*GTask, result: gboolean) void;
pub extern fn g_task_return_int(task: ?*GTask, result: gssize) void;
pub extern fn g_task_return_error(task: ?*GTask, @"error": [*c]GError) void;
pub extern fn g_task_return_new_error(task: ?*GTask, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_task_return_value(task: ?*GTask, result: [*c]GValue) void;
pub extern fn g_task_return_error_if_cancelled(task: ?*GTask) gboolean;
pub extern fn g_task_propagate_pointer(task: ?*GTask, @"error": [*c][*c]GError) gpointer;
pub extern fn g_task_propagate_boolean(task: ?*GTask, @"error": [*c][*c]GError) gboolean;
pub extern fn g_task_propagate_int(task: ?*GTask, @"error": [*c][*c]GError) gssize;
pub extern fn g_task_propagate_value(task: ?*GTask, value: [*c]GValue, @"error": [*c][*c]GError) gboolean;
pub extern fn g_task_had_error(task: ?*GTask) gboolean;
pub extern fn g_task_get_completed(task: ?*GTask) gboolean;
pub extern fn g_task_print_alive_tasks() void;
pub const struct__GTcpConnectionClass = extern struct {
    parent_class: GSocketConnectionClass,
};
pub const GTcpConnectionClass = struct__GTcpConnectionClass;
pub extern fn g_tcp_connection_get_type() GType;
pub extern fn g_tcp_connection_set_graceful_disconnect(connection: [*c]GTcpConnection, graceful_disconnect: gboolean) void;
pub extern fn g_tcp_connection_get_graceful_disconnect(connection: [*c]GTcpConnection) gboolean;
pub const struct__GTcpWrapperConnectionClass = extern struct {
    parent_class: GTcpConnectionClass,
};
pub const GTcpWrapperConnectionClass = struct__GTcpWrapperConnectionClass;
pub extern fn g_tcp_wrapper_connection_get_type() GType;
pub extern fn g_tcp_wrapper_connection_new(base_io_stream: [*c]GIOStream, socket: [*c]GSocket) [*c]GSocketConnection;
pub extern fn g_tcp_wrapper_connection_get_base_io_stream(conn: [*c]GTcpWrapperConnection) [*c]GIOStream;
pub extern fn g_test_dbus_get_type() GType;
pub extern fn g_test_dbus_new(flags: GTestDBusFlags) ?*GTestDBus;
pub extern fn g_test_dbus_get_flags(self: ?*GTestDBus) GTestDBusFlags;
pub extern fn g_test_dbus_get_bus_address(self: ?*GTestDBus) [*c]const gchar;
pub extern fn g_test_dbus_add_service_dir(self: ?*GTestDBus, path: [*c]const gchar) void;
pub extern fn g_test_dbus_up(self: ?*GTestDBus) void;
pub extern fn g_test_dbus_stop(self: ?*GTestDBus) void;
pub extern fn g_test_dbus_down(self: ?*GTestDBus) void;
pub extern fn g_test_dbus_unset() void;
pub const struct__GThemedIconClass = opaque {};
pub const GThemedIconClass = struct__GThemedIconClass;
pub extern fn g_themed_icon_get_type() GType;
pub extern fn g_themed_icon_new(iconname: [*c]const u8) ?*GIcon;
pub extern fn g_themed_icon_new_with_default_fallbacks(iconname: [*c]const u8) ?*GIcon;
pub extern fn g_themed_icon_new_from_names(iconnames: [*c][*c]u8, len: c_int) ?*GIcon;
pub extern fn g_themed_icon_prepend_name(icon: ?*GThemedIcon, iconname: [*c]const u8) void;
pub extern fn g_themed_icon_append_name(icon: ?*GThemedIcon, iconname: [*c]const u8) void;
pub extern fn g_themed_icon_get_names(icon: ?*GThemedIcon) [*c]const [*c]const gchar;
pub const struct__GThreadedSocketServiceClass = extern struct {
    parent_class: GSocketServiceClass,
    run: ?*const fn ([*c]GThreadedSocketService, [*c]GSocketConnection, [*c]GObject) callconv(.C) gboolean,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GThreadedSocketServiceClass = struct__GThreadedSocketServiceClass;
pub extern fn g_threaded_socket_service_get_type() GType;
pub extern fn g_threaded_socket_service_new(max_threads: c_int) [*c]GSocketService;
pub const struct__GTlsBackend = opaque {};
pub const GTlsBackend = struct__GTlsBackend;
pub const struct__GTlsBackendInterface = extern struct {
    g_iface: GTypeInterface,
    supports_tls: ?*const fn (?*GTlsBackend) callconv(.C) gboolean,
    get_certificate_type: ?*const fn () callconv(.C) GType,
    get_client_connection_type: ?*const fn () callconv(.C) GType,
    get_server_connection_type: ?*const fn () callconv(.C) GType,
    get_file_database_type: ?*const fn () callconv(.C) GType,
    get_default_database: ?*const fn (?*GTlsBackend) callconv(.C) [*c]GTlsDatabase,
    supports_dtls: ?*const fn (?*GTlsBackend) callconv(.C) gboolean,
    get_dtls_client_connection_type: ?*const fn () callconv(.C) GType,
    get_dtls_server_connection_type: ?*const fn () callconv(.C) GType,
};
pub const GTlsBackendInterface = struct__GTlsBackendInterface;
pub extern fn g_tls_backend_get_type() GType;
pub extern fn g_tls_backend_get_default() ?*GTlsBackend;
pub extern fn g_tls_backend_get_default_database(backend: ?*GTlsBackend) [*c]GTlsDatabase;
pub extern fn g_tls_backend_set_default_database(backend: ?*GTlsBackend, database: [*c]GTlsDatabase) void;
pub extern fn g_tls_backend_supports_tls(backend: ?*GTlsBackend) gboolean;
pub extern fn g_tls_backend_supports_dtls(backend: ?*GTlsBackend) gboolean;
pub extern fn g_tls_backend_get_certificate_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_client_connection_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_server_connection_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_file_database_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_dtls_client_connection_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_dtls_server_connection_type(backend: ?*GTlsBackend) GType;
pub const struct__GTlsCertificateClass = extern struct {
    parent_class: GObjectClass,
    verify: ?*const fn ([*c]GTlsCertificate, ?*GSocketConnectable, [*c]GTlsCertificate) callconv(.C) GTlsCertificateFlags,
    padding: [8]gpointer,
};
pub const GTlsCertificateClass = struct__GTlsCertificateClass;
pub extern fn g_tls_certificate_get_type() GType;
pub extern fn g_tls_certificate_new_from_pem(data: [*c]const gchar, length: gssize, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_pkcs12(data: [*c]const guint8, length: gsize, password: [*c]const gchar, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_file_with_password(file: [*c]const gchar, password: [*c]const gchar, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_file(file: [*c]const gchar, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_files(cert_file: [*c]const gchar, key_file: [*c]const gchar, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_pkcs11_uris(pkcs11_uri: [*c]const gchar, private_key_pkcs11_uri: [*c]const gchar, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_list_new_from_file(file: [*c]const gchar, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_tls_certificate_get_issuer(cert: [*c]GTlsCertificate) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_verify(cert: [*c]GTlsCertificate, identity: ?*GSocketConnectable, trusted_ca: [*c]GTlsCertificate) GTlsCertificateFlags;
pub extern fn g_tls_certificate_is_same(cert_one: [*c]GTlsCertificate, cert_two: [*c]GTlsCertificate) gboolean;
pub extern fn g_tls_certificate_get_not_valid_before(cert: [*c]GTlsCertificate) ?*GDateTime;
pub extern fn g_tls_certificate_get_not_valid_after(cert: [*c]GTlsCertificate) ?*GDateTime;
pub extern fn g_tls_certificate_get_subject_name(cert: [*c]GTlsCertificate) [*c]gchar;
pub extern fn g_tls_certificate_get_issuer_name(cert: [*c]GTlsCertificate) [*c]gchar;
pub extern fn g_tls_certificate_get_dns_names(cert: [*c]GTlsCertificate) [*c]GPtrArray;
pub extern fn g_tls_certificate_get_ip_addresses(cert: [*c]GTlsCertificate) [*c]GPtrArray;
pub const struct__GTlsConnectionClass = extern struct {
    parent_class: GIOStreamClass,
    accept_certificate: ?*const fn ([*c]GTlsConnection, [*c]GTlsCertificate, GTlsCertificateFlags) callconv(.C) gboolean,
    handshake: ?*const fn ([*c]GTlsConnection, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    handshake_async: ?*const fn ([*c]GTlsConnection, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    handshake_finish: ?*const fn ([*c]GTlsConnection, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_binding_data: ?*const fn ([*c]GTlsConnection, GTlsChannelBindingType, [*c]GByteArray, [*c][*c]GError) callconv(.C) gboolean,
    get_negotiated_protocol: ?*const fn ([*c]GTlsConnection) callconv(.C) [*c]const gchar,
    padding: [6]gpointer,
};
pub const GTlsConnectionClass = struct__GTlsConnectionClass;
pub extern fn g_tls_connection_get_type() GType;
pub extern fn g_tls_connection_set_use_system_certdb(conn: [*c]GTlsConnection, use_system_certdb: gboolean) void;
pub extern fn g_tls_connection_get_use_system_certdb(conn: [*c]GTlsConnection) gboolean;
pub extern fn g_tls_connection_set_database(conn: [*c]GTlsConnection, database: [*c]GTlsDatabase) void;
pub extern fn g_tls_connection_get_database(conn: [*c]GTlsConnection) [*c]GTlsDatabase;
pub extern fn g_tls_connection_set_certificate(conn: [*c]GTlsConnection, certificate: [*c]GTlsCertificate) void;
pub extern fn g_tls_connection_get_certificate(conn: [*c]GTlsConnection) [*c]GTlsCertificate;
pub extern fn g_tls_connection_set_interaction(conn: [*c]GTlsConnection, interaction: [*c]GTlsInteraction) void;
pub extern fn g_tls_connection_get_interaction(conn: [*c]GTlsConnection) [*c]GTlsInteraction;
pub extern fn g_tls_connection_get_peer_certificate(conn: [*c]GTlsConnection) [*c]GTlsCertificate;
pub extern fn g_tls_connection_get_peer_certificate_errors(conn: [*c]GTlsConnection) GTlsCertificateFlags;
pub extern fn g_tls_connection_set_require_close_notify(conn: [*c]GTlsConnection, require_close_notify: gboolean) void;
pub extern fn g_tls_connection_get_require_close_notify(conn: [*c]GTlsConnection) gboolean;
pub extern fn g_tls_connection_set_rehandshake_mode(conn: [*c]GTlsConnection, mode: GTlsRehandshakeMode) void;
pub extern fn g_tls_connection_get_rehandshake_mode(conn: [*c]GTlsConnection) GTlsRehandshakeMode;
pub extern fn g_tls_connection_set_advertised_protocols(conn: [*c]GTlsConnection, protocols: [*c]const [*c]const gchar) void;
pub extern fn g_tls_connection_get_negotiated_protocol(conn: [*c]GTlsConnection) [*c]const gchar;
pub extern fn g_tls_connection_get_channel_binding_data(conn: [*c]GTlsConnection, @"type": GTlsChannelBindingType, data: [*c]GByteArray, @"error": [*c][*c]GError) gboolean;
pub extern fn g_tls_connection_handshake(conn: [*c]GTlsConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_tls_connection_handshake_async(conn: [*c]GTlsConnection, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_connection_handshake_finish(conn: [*c]GTlsConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_tls_connection_get_protocol_version(conn: [*c]GTlsConnection) GTlsProtocolVersion;
pub extern fn g_tls_connection_get_ciphersuite_name(conn: [*c]GTlsConnection) [*c]gchar;
pub extern fn g_tls_error_quark() GQuark;
pub extern fn g_tls_channel_binding_error_quark() GQuark;
pub extern fn g_tls_connection_emit_accept_certificate(conn: [*c]GTlsConnection, peer_cert: [*c]GTlsCertificate, errors: GTlsCertificateFlags) gboolean;
pub const struct__GTlsClientConnectionInterface = extern struct {
    g_iface: GTypeInterface,
    copy_session_state: ?*const fn (?*GTlsClientConnection, ?*GTlsClientConnection) callconv(.C) void,
};
pub const GTlsClientConnectionInterface = struct__GTlsClientConnectionInterface;
pub extern fn g_tls_client_connection_get_type() GType;
pub extern fn g_tls_client_connection_new(base_io_stream: [*c]GIOStream, server_identity: ?*GSocketConnectable, @"error": [*c][*c]GError) [*c]GIOStream;
pub extern fn g_tls_client_connection_get_validation_flags(conn: ?*GTlsClientConnection) GTlsCertificateFlags;
pub extern fn g_tls_client_connection_set_validation_flags(conn: ?*GTlsClientConnection, flags: GTlsCertificateFlags) void;
pub extern fn g_tls_client_connection_get_server_identity(conn: ?*GTlsClientConnection) ?*GSocketConnectable;
pub extern fn g_tls_client_connection_set_server_identity(conn: ?*GTlsClientConnection, identity: ?*GSocketConnectable) void;
pub extern fn g_tls_client_connection_get_use_ssl3(conn: ?*GTlsClientConnection) gboolean;
pub extern fn g_tls_client_connection_set_use_ssl3(conn: ?*GTlsClientConnection, use_ssl3: gboolean) void;
pub extern fn g_tls_client_connection_get_accepted_cas(conn: ?*GTlsClientConnection) [*c]GList;
pub extern fn g_tls_client_connection_copy_session_state(conn: ?*GTlsClientConnection, source: ?*GTlsClientConnection) void;
pub const struct__GTlsDatabaseClass = extern struct {
    parent_class: GObjectClass,
    verify_chain: ?*const fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]const gchar, ?*GSocketConnectable, [*c]GTlsInteraction, GTlsDatabaseVerifyFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) GTlsCertificateFlags,
    verify_chain_async: ?*const fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]const gchar, ?*GSocketConnectable, [*c]GTlsInteraction, GTlsDatabaseVerifyFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    verify_chain_finish: ?*const fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c][*c]GError) callconv(.C) GTlsCertificateFlags,
    create_certificate_handle: ?*const fn ([*c]GTlsDatabase, [*c]GTlsCertificate) callconv(.C) [*c]gchar,
    lookup_certificate_for_handle: ?*const fn ([*c]GTlsDatabase, [*c]const gchar, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GTlsCertificate,
    lookup_certificate_for_handle_async: ?*const fn ([*c]GTlsDatabase, [*c]const gchar, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_certificate_for_handle_finish: ?*const fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GTlsCertificate,
    lookup_certificate_issuer: ?*const fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GTlsCertificate,
    lookup_certificate_issuer_async: ?*const fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_certificate_issuer_finish: ?*const fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GTlsCertificate,
    lookup_certificates_issued_by: ?*const fn ([*c]GTlsDatabase, [*c]GByteArray, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) [*c]GList,
    lookup_certificates_issued_by_async: ?*const fn ([*c]GTlsDatabase, [*c]GByteArray, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    lookup_certificates_issued_by_finish: ?*const fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c][*c]GError) callconv(.C) [*c]GList,
    padding: [16]gpointer,
};
pub const GTlsDatabaseClass = struct__GTlsDatabaseClass;
pub extern fn g_tls_database_get_type() GType;
pub extern fn g_tls_database_verify_chain(self: [*c]GTlsDatabase, chain: [*c]GTlsCertificate, purpose: [*c]const gchar, identity: ?*GSocketConnectable, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GTlsCertificateFlags;
pub extern fn g_tls_database_verify_chain_async(self: [*c]GTlsDatabase, chain: [*c]GTlsCertificate, purpose: [*c]const gchar, identity: ?*GSocketConnectable, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_verify_chain_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c][*c]GError) GTlsCertificateFlags;
pub extern fn g_tls_database_create_certificate_handle(self: [*c]GTlsDatabase, certificate: [*c]GTlsCertificate) [*c]gchar;
pub extern fn g_tls_database_lookup_certificate_for_handle(self: [*c]GTlsDatabase, handle: [*c]const gchar, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificate_for_handle_async(self: [*c]GTlsDatabase, handle: [*c]const gchar, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_lookup_certificate_for_handle_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificate_issuer(self: [*c]GTlsDatabase, certificate: [*c]GTlsCertificate, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificate_issuer_async(self: [*c]GTlsDatabase, certificate: [*c]GTlsCertificate, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_lookup_certificate_issuer_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificates_issued_by(self: [*c]GTlsDatabase, issuer_raw_dn: [*c]GByteArray, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) [*c]GList;
pub extern fn g_tls_database_lookup_certificates_issued_by_async(self: [*c]GTlsDatabase, issuer_raw_dn: [*c]GByteArray, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_lookup_certificates_issued_by_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GList;
pub const struct__GTlsFileDatabaseInterface = extern struct {
    g_iface: GTypeInterface,
    padding: [8]gpointer,
};
pub const GTlsFileDatabaseInterface = struct__GTlsFileDatabaseInterface;
pub extern fn g_tls_file_database_get_type() GType;
pub extern fn g_tls_file_database_new(anchors: [*c]const gchar, @"error": [*c][*c]GError) [*c]GTlsDatabase;
pub const struct__GTlsInteractionClass = extern struct {
    parent_class: GObjectClass,
    ask_password: ?*const fn ([*c]GTlsInteraction, [*c]GTlsPassword, [*c]GCancellable, [*c][*c]GError) callconv(.C) GTlsInteractionResult,
    ask_password_async: ?*const fn ([*c]GTlsInteraction, [*c]GTlsPassword, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    ask_password_finish: ?*const fn ([*c]GTlsInteraction, ?*GAsyncResult, [*c][*c]GError) callconv(.C) GTlsInteractionResult,
    request_certificate: ?*const fn ([*c]GTlsInteraction, [*c]GTlsConnection, GTlsCertificateRequestFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) GTlsInteractionResult,
    request_certificate_async: ?*const fn ([*c]GTlsInteraction, [*c]GTlsConnection, GTlsCertificateRequestFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    request_certificate_finish: ?*const fn ([*c]GTlsInteraction, ?*GAsyncResult, [*c][*c]GError) callconv(.C) GTlsInteractionResult,
    padding: [21]gpointer,
};
pub const GTlsInteractionClass = struct__GTlsInteractionClass;
pub extern fn g_tls_interaction_get_type() GType;
pub extern fn g_tls_interaction_invoke_ask_password(interaction: [*c]GTlsInteraction, password: [*c]GTlsPassword, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GTlsInteractionResult;
pub extern fn g_tls_interaction_ask_password(interaction: [*c]GTlsInteraction, password: [*c]GTlsPassword, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GTlsInteractionResult;
pub extern fn g_tls_interaction_ask_password_async(interaction: [*c]GTlsInteraction, password: [*c]GTlsPassword, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_interaction_ask_password_finish(interaction: [*c]GTlsInteraction, result: ?*GAsyncResult, @"error": [*c][*c]GError) GTlsInteractionResult;
pub extern fn g_tls_interaction_invoke_request_certificate(interaction: [*c]GTlsInteraction, connection: [*c]GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GTlsInteractionResult;
pub extern fn g_tls_interaction_request_certificate(interaction: [*c]GTlsInteraction, connection: [*c]GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) GTlsInteractionResult;
pub extern fn g_tls_interaction_request_certificate_async(interaction: [*c]GTlsInteraction, connection: [*c]GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_interaction_request_certificate_finish(interaction: [*c]GTlsInteraction, result: ?*GAsyncResult, @"error": [*c][*c]GError) GTlsInteractionResult;
pub const struct__GTlsPasswordClass = extern struct {
    parent_class: GObjectClass,
    get_value: ?*const fn ([*c]GTlsPassword, [*c]gsize) callconv(.C) [*c]const guchar,
    set_value: ?*const fn ([*c]GTlsPassword, [*c]guchar, gssize, GDestroyNotify) callconv(.C) void,
    get_default_warning: ?*const fn ([*c]GTlsPassword) callconv(.C) [*c]const gchar,
    padding: [4]gpointer,
};
pub const GTlsPasswordClass = struct__GTlsPasswordClass;
pub extern fn g_tls_password_get_type() GType;
pub extern fn g_tls_password_new(flags: GTlsPasswordFlags, description: [*c]const gchar) [*c]GTlsPassword;
pub extern fn g_tls_password_get_value(password: [*c]GTlsPassword, length: [*c]gsize) [*c]const guchar;
pub extern fn g_tls_password_set_value(password: [*c]GTlsPassword, value: [*c]const guchar, length: gssize) void;
pub extern fn g_tls_password_set_value_full(password: [*c]GTlsPassword, value: [*c]guchar, length: gssize, destroy: GDestroyNotify) void;
pub extern fn g_tls_password_get_flags(password: [*c]GTlsPassword) GTlsPasswordFlags;
pub extern fn g_tls_password_set_flags(password: [*c]GTlsPassword, flags: GTlsPasswordFlags) void;
pub extern fn g_tls_password_get_description(password: [*c]GTlsPassword) [*c]const gchar;
pub extern fn g_tls_password_set_description(password: [*c]GTlsPassword, description: [*c]const gchar) void;
pub extern fn g_tls_password_get_warning(password: [*c]GTlsPassword) [*c]const gchar;
pub extern fn g_tls_password_set_warning(password: [*c]GTlsPassword, warning: [*c]const gchar) void;
pub const struct__GTlsServerConnectionInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GTlsServerConnectionInterface = struct__GTlsServerConnectionInterface;
pub extern fn g_tls_server_connection_get_type() GType;
pub extern fn g_tls_server_connection_new(base_io_stream: [*c]GIOStream, certificate: [*c]GTlsCertificate, @"error": [*c][*c]GError) [*c]GIOStream;
pub const struct__GUnixConnectionPrivate = opaque {};
pub const GUnixConnectionPrivate = struct__GUnixConnectionPrivate;
pub const struct__GUnixConnection = extern struct {
    parent_instance: GSocketConnection,
    priv: ?*GUnixConnectionPrivate,
};
pub const GUnixConnection = struct__GUnixConnection;
pub const struct__GUnixConnectionClass = extern struct {
    parent_class: GSocketConnectionClass,
};
pub const GUnixConnectionClass = struct__GUnixConnectionClass;
pub const GUnixConnection_autoptr = [*c]GUnixConnection;
pub const GUnixConnection_listautoptr = [*c]GList;
pub const GUnixConnection_slistautoptr = [*c]GSList;
pub const GUnixConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GUnixConnection(arg__ptr: [*c]GUnixConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GUnixConnection(arg__ptr: [*c][*c]GUnixConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GUnixConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GUnixConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GUnixConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GUnixConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn g_unix_connection_get_type() GType;
pub extern fn g_unix_connection_send_fd(connection: [*c]GUnixConnection, fd: gint, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_unix_connection_receive_fd(connection: [*c]GUnixConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gint;
pub extern fn g_unix_connection_send_credentials(connection: [*c]GUnixConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn g_unix_connection_send_credentials_async(connection: [*c]GUnixConnection, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_unix_connection_send_credentials_finish(connection: [*c]GUnixConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_unix_connection_receive_credentials(connection: [*c]GUnixConnection, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GCredentials;
pub extern fn g_unix_connection_receive_credentials_async(connection: [*c]GUnixConnection, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_unix_connection_receive_credentials_finish(connection: [*c]GUnixConnection, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GCredentials;
pub const struct__GUnixCredentialsMessageClass = extern struct {
    parent_class: GSocketControlMessageClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
};
pub const GUnixCredentialsMessageClass = struct__GUnixCredentialsMessageClass;
pub const GUnixCredentialsMessage_autoptr = [*c]GUnixCredentialsMessage;
pub const GUnixCredentialsMessage_listautoptr = [*c]GList;
pub const GUnixCredentialsMessage_slistautoptr = [*c]GSList;
pub const GUnixCredentialsMessage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GUnixCredentialsMessage(arg__ptr: [*c]GUnixCredentialsMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GUnixCredentialsMessage(arg__ptr: [*c][*c]GUnixCredentialsMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GUnixCredentialsMessage(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GUnixCredentialsMessage(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GUnixCredentialsMessage(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GUnixCredentialsMessage(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn g_unix_credentials_message_get_type() GType;
pub extern fn g_unix_credentials_message_new() [*c]GSocketControlMessage;
pub extern fn g_unix_credentials_message_new_with_credentials(credentials: ?*GCredentials) [*c]GSocketControlMessage;
pub extern fn g_unix_credentials_message_get_credentials(message: [*c]GUnixCredentialsMessage) ?*GCredentials;
pub extern fn g_unix_credentials_message_is_supported() gboolean;
pub const GUnixFDList_autoptr = [*c]GUnixFDList;
pub const GUnixFDList_listautoptr = [*c]GList;
pub const GUnixFDList_slistautoptr = [*c]GSList;
pub const GUnixFDList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GUnixFDList(arg__ptr: [*c]GUnixFDList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GUnixFDList(arg__ptr: [*c][*c]GUnixFDList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GUnixFDList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GUnixFDList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GUnixFDList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GUnixFDList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GUnixFDListClass = extern struct {
    parent_class: GObjectClass,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
};
pub const GUnixFDListClass = struct__GUnixFDListClass;
pub extern fn g_unix_fd_list_get_type() GType;
pub extern fn g_unix_fd_list_new() [*c]GUnixFDList;
pub extern fn g_unix_fd_list_new_from_array(fds: [*c]const gint, n_fds: gint) [*c]GUnixFDList;
pub extern fn g_unix_fd_list_append(list: [*c]GUnixFDList, fd: gint, @"error": [*c][*c]GError) gint;
pub extern fn g_unix_fd_list_get_length(list: [*c]GUnixFDList) gint;
pub extern fn g_unix_fd_list_get(list: [*c]GUnixFDList, index_: gint, @"error": [*c][*c]GError) gint;
pub extern fn g_unix_fd_list_peek_fds(list: [*c]GUnixFDList, length: [*c]gint) [*c]const gint;
pub extern fn g_unix_fd_list_steal_fds(list: [*c]GUnixFDList, length: [*c]gint) [*c]gint;
pub const struct__GUnixSocketAddressPrivate = opaque {};
pub const GUnixSocketAddressPrivate = struct__GUnixSocketAddressPrivate;
pub const struct__GUnixSocketAddress = extern struct {
    parent_instance: GSocketAddress,
    priv: ?*GUnixSocketAddressPrivate,
};
pub const GUnixSocketAddress = struct__GUnixSocketAddress;
pub const struct__GUnixSocketAddressClass = extern struct {
    parent_class: GSocketAddressClass,
};
pub const GUnixSocketAddressClass = struct__GUnixSocketAddressClass;
pub const GUnixSocketAddress_autoptr = [*c]GUnixSocketAddress;
pub const GUnixSocketAddress_listautoptr = [*c]GList;
pub const GUnixSocketAddress_slistautoptr = [*c]GSList;
pub const GUnixSocketAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GUnixSocketAddress(arg__ptr: [*c]GUnixSocketAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GUnixSocketAddress(arg__ptr: [*c][*c]GUnixSocketAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GUnixSocketAddress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GUnixSocketAddress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GUnixSocketAddress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GUnixSocketAddress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn g_unix_socket_address_get_type() GType;
pub extern fn g_unix_socket_address_new(path: [*c]const gchar) [*c]GSocketAddress;
pub extern fn g_unix_socket_address_new_abstract(path: [*c]const gchar, path_len: gint) [*c]GSocketAddress;
pub extern fn g_unix_socket_address_new_with_type(path: [*c]const gchar, path_len: gint, @"type": GUnixSocketAddressType) [*c]GSocketAddress;
pub extern fn g_unix_socket_address_get_path(address: [*c]GUnixSocketAddress) [*c]const u8;
pub extern fn g_unix_socket_address_get_path_len(address: [*c]GUnixSocketAddress) gsize;
pub extern fn g_unix_socket_address_get_address_type(address: [*c]GUnixSocketAddress) GUnixSocketAddressType;
pub extern fn g_unix_socket_address_get_is_abstract(address: [*c]GUnixSocketAddress) gboolean;
pub extern fn g_unix_socket_address_abstract_names_supported() gboolean;
pub const GVfsFileLookupFunc = ?*const fn ([*c]GVfs, [*c]const u8, gpointer) callconv(.C) ?*GFile;
pub const struct__GVfsClass = extern struct {
    parent_class: GObjectClass,
    is_active: ?*const fn ([*c]GVfs) callconv(.C) gboolean,
    get_file_for_path: ?*const fn ([*c]GVfs, [*c]const u8) callconv(.C) ?*GFile,
    get_file_for_uri: ?*const fn ([*c]GVfs, [*c]const u8) callconv(.C) ?*GFile,
    get_supported_uri_schemes: ?*const fn ([*c]GVfs) callconv(.C) [*c]const [*c]const gchar,
    parse_name: ?*const fn ([*c]GVfs, [*c]const u8) callconv(.C) ?*GFile,
    local_file_add_info: ?*const fn ([*c]GVfs, [*c]const u8, guint64, ?*GFileAttributeMatcher, ?*GFileInfo, [*c]GCancellable, [*c]gpointer, [*c]GDestroyNotify) callconv(.C) void,
    add_writable_namespaces: ?*const fn ([*c]GVfs, [*c]GFileAttributeInfoList) callconv(.C) void,
    local_file_set_attributes: ?*const fn ([*c]GVfs, [*c]const u8, ?*GFileInfo, GFileQueryInfoFlags, [*c]GCancellable, [*c][*c]GError) callconv(.C) gboolean,
    local_file_removed: ?*const fn ([*c]GVfs, [*c]const u8) callconv(.C) void,
    local_file_moved: ?*const fn ([*c]GVfs, [*c]const u8, [*c]const u8) callconv(.C) void,
    deserialize_icon: ?*const fn ([*c]GVfs, ?*GVariant) callconv(.C) ?*GIcon,
    _g_reserved1: ?*const fn () callconv(.C) void,
    _g_reserved2: ?*const fn () callconv(.C) void,
    _g_reserved3: ?*const fn () callconv(.C) void,
    _g_reserved4: ?*const fn () callconv(.C) void,
    _g_reserved5: ?*const fn () callconv(.C) void,
    _g_reserved6: ?*const fn () callconv(.C) void,
};
pub const GVfsClass = struct__GVfsClass;
pub extern fn g_vfs_get_type() GType;
pub extern fn g_vfs_is_active(vfs: [*c]GVfs) gboolean;
pub extern fn g_vfs_get_file_for_path(vfs: [*c]GVfs, path: [*c]const u8) ?*GFile;
pub extern fn g_vfs_get_file_for_uri(vfs: [*c]GVfs, uri: [*c]const u8) ?*GFile;
pub extern fn g_vfs_get_supported_uri_schemes(vfs: [*c]GVfs) [*c]const [*c]const gchar;
pub extern fn g_vfs_parse_name(vfs: [*c]GVfs, parse_name: [*c]const u8) ?*GFile;
pub extern fn g_vfs_get_default() [*c]GVfs;
pub extern fn g_vfs_get_local() [*c]GVfs;
pub extern fn g_vfs_register_uri_scheme(vfs: [*c]GVfs, scheme: [*c]const u8, uri_func: GVfsFileLookupFunc, uri_data: gpointer, uri_destroy: GDestroyNotify, parse_name_func: GVfsFileLookupFunc, parse_name_data: gpointer, parse_name_destroy: GDestroyNotify) gboolean;
pub extern fn g_vfs_unregister_uri_scheme(vfs: [*c]GVfs, scheme: [*c]const u8) gboolean;
pub const struct__GVolumeIface = extern struct {
    g_iface: GTypeInterface,
    changed: ?*const fn (?*GVolume) callconv(.C) void,
    removed: ?*const fn (?*GVolume) callconv(.C) void,
    get_name: ?*const fn (?*GVolume) callconv(.C) [*c]u8,
    get_icon: ?*const fn (?*GVolume) callconv(.C) ?*GIcon,
    get_uuid: ?*const fn (?*GVolume) callconv(.C) [*c]u8,
    get_drive: ?*const fn (?*GVolume) callconv(.C) ?*GDrive,
    get_mount: ?*const fn (?*GVolume) callconv(.C) ?*GMount,
    can_mount: ?*const fn (?*GVolume) callconv(.C) gboolean,
    can_eject: ?*const fn (?*GVolume) callconv(.C) gboolean,
    mount_fn: ?*const fn (?*GVolume, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    mount_finish: ?*const fn (?*GVolume, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    eject: ?*const fn (?*GVolume, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_finish: ?*const fn (?*GVolume, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_identifier: ?*const fn (?*GVolume, [*c]const u8) callconv(.C) [*c]u8,
    enumerate_identifiers: ?*const fn (?*GVolume) callconv(.C) [*c][*c]u8,
    should_automount: ?*const fn (?*GVolume) callconv(.C) gboolean,
    get_activation_root: ?*const fn (?*GVolume) callconv(.C) ?*GFile,
    eject_with_operation: ?*const fn (?*GVolume, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    eject_with_operation_finish: ?*const fn (?*GVolume, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_sort_key: ?*const fn (?*GVolume) callconv(.C) [*c]const gchar,
    get_symbolic_icon: ?*const fn (?*GVolume) callconv(.C) ?*GIcon,
};
pub const GVolumeIface = struct__GVolumeIface;
pub extern fn g_volume_get_type() GType;
pub extern fn g_volume_get_name(volume: ?*GVolume) [*c]u8;
pub extern fn g_volume_get_icon(volume: ?*GVolume) ?*GIcon;
pub extern fn g_volume_get_symbolic_icon(volume: ?*GVolume) ?*GIcon;
pub extern fn g_volume_get_uuid(volume: ?*GVolume) [*c]u8;
pub extern fn g_volume_get_drive(volume: ?*GVolume) ?*GDrive;
pub extern fn g_volume_get_mount(volume: ?*GVolume) ?*GMount;
pub extern fn g_volume_can_mount(volume: ?*GVolume) gboolean;
pub extern fn g_volume_can_eject(volume: ?*GVolume) gboolean;
pub extern fn g_volume_should_automount(volume: ?*GVolume) gboolean;
pub extern fn g_volume_mount(volume: ?*GVolume, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_volume_mount_finish(volume: ?*GVolume, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_volume_eject(volume: ?*GVolume, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_volume_eject_finish(volume: ?*GVolume, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_volume_get_identifier(volume: ?*GVolume, kind: [*c]const u8) [*c]u8;
pub extern fn g_volume_enumerate_identifiers(volume: ?*GVolume) [*c][*c]u8;
pub extern fn g_volume_get_activation_root(volume: ?*GVolume) ?*GFile;
pub extern fn g_volume_eject_with_operation(volume: ?*GVolume, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_volume_eject_with_operation_finish(volume: ?*GVolume, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn g_volume_get_sort_key(volume: ?*GVolume) [*c]const gchar;
pub const struct__GZlibCompressorClass = extern struct {
    parent_class: GObjectClass,
};
pub const GZlibCompressorClass = struct__GZlibCompressorClass;
pub extern fn g_zlib_compressor_get_type() GType;
pub extern fn g_zlib_compressor_new(format: GZlibCompressorFormat, level: c_int) ?*GZlibCompressor;
pub extern fn g_zlib_compressor_get_file_info(compressor: ?*GZlibCompressor) ?*GFileInfo;
pub extern fn g_zlib_compressor_set_file_info(compressor: ?*GZlibCompressor, file_info: ?*GFileInfo) void;
pub const struct__GZlibDecompressorClass = extern struct {
    parent_class: GObjectClass,
};
pub const GZlibDecompressorClass = struct__GZlibDecompressorClass;
pub extern fn g_zlib_decompressor_get_type() GType;
pub extern fn g_zlib_decompressor_new(format: GZlibCompressorFormat) ?*GZlibDecompressor;
pub extern fn g_zlib_decompressor_get_file_info(decompressor: ?*GZlibDecompressor) ?*GFileInfo;
pub const GAction_autoptr = ?*GAction;
pub const GAction_listautoptr = [*c]GList;
pub const GAction_slistautoptr = [*c]GSList;
pub const GAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAction(arg__ptr: ?*GAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GAction(arg__ptr: [*c]?*GAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GActionMap_autoptr = ?*GActionMap;
pub const GActionMap_listautoptr = [*c]GList;
pub const GActionMap_slistautoptr = [*c]GSList;
pub const GActionMap_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GActionMap(arg__ptr: ?*GActionMap) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GActionMap(arg__ptr: [*c]?*GActionMap) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GActionMap(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GActionMap(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GActionMap(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GActionMap(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GAppInfo_autoptr = ?*GAppInfo;
pub const GAppInfo_listautoptr = [*c]GList;
pub const GAppInfo_slistautoptr = [*c]GSList;
pub const GAppInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAppInfo(arg__ptr: ?*GAppInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GAppInfo(arg__ptr: [*c]?*GAppInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAppInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAppInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAppInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAppInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GAppLaunchContext_autoptr = [*c]GAppLaunchContext;
pub const GAppLaunchContext_listautoptr = [*c]GList;
pub const GAppLaunchContext_slistautoptr = [*c]GSList;
pub const GAppLaunchContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAppLaunchContext(arg__ptr: [*c]GAppLaunchContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GAppLaunchContext(arg__ptr: [*c][*c]GAppLaunchContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAppLaunchContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAppLaunchContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAppLaunchContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAppLaunchContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GAppInfoMonitor_autoptr = ?*GAppInfoMonitor;
pub const GAppInfoMonitor_listautoptr = [*c]GList;
pub const GAppInfoMonitor_slistautoptr = [*c]GSList;
pub const GAppInfoMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAppInfoMonitor(arg__ptr: ?*GAppInfoMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GAppInfoMonitor(arg__ptr: [*c]?*GAppInfoMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAppInfoMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAppInfoMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAppInfoMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAppInfoMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GApplicationCommandLine_autoptr = [*c]GApplicationCommandLine;
pub const GApplicationCommandLine_listautoptr = [*c]GList;
pub const GApplicationCommandLine_slistautoptr = [*c]GSList;
pub const GApplicationCommandLine_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GApplicationCommandLine(arg__ptr: [*c]GApplicationCommandLine) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GApplicationCommandLine(arg__ptr: [*c][*c]GApplicationCommandLine) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GApplicationCommandLine(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GApplicationCommandLine(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GApplicationCommandLine(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GApplicationCommandLine(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GApplication_autoptr = [*c]GApplication;
pub const GApplication_listautoptr = [*c]GList;
pub const GApplication_slistautoptr = [*c]GSList;
pub const GApplication_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GApplication(arg__ptr: [*c]GApplication) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GApplication(arg__ptr: [*c][*c]GApplication) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GApplication(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GApplication(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GApplication(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GApplication(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GAsyncInitable_autoptr = ?*GAsyncInitable;
pub const GAsyncInitable_listautoptr = [*c]GList;
pub const GAsyncInitable_slistautoptr = [*c]GSList;
pub const GAsyncInitable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncInitable(arg__ptr: ?*GAsyncInitable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GAsyncInitable(arg__ptr: [*c]?*GAsyncInitable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAsyncInitable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAsyncInitable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAsyncInitable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAsyncInitable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GAsyncResult_autoptr = ?*GAsyncResult;
pub const GAsyncResult_listautoptr = [*c]GList;
pub const GAsyncResult_slistautoptr = [*c]GSList;
pub const GAsyncResult_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncResult(arg__ptr: ?*GAsyncResult) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GAsyncResult(arg__ptr: [*c]?*GAsyncResult) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GAsyncResult(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GAsyncResult(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GAsyncResult(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GAsyncResult(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GBufferedInputStream_autoptr = [*c]GBufferedInputStream;
pub const GBufferedInputStream_listautoptr = [*c]GList;
pub const GBufferedInputStream_slistautoptr = [*c]GSList;
pub const GBufferedInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBufferedInputStream(arg__ptr: [*c]GBufferedInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GBufferedInputStream(arg__ptr: [*c][*c]GBufferedInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBufferedInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBufferedInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GBufferedInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GBufferedInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GBufferedOutputStream_autoptr = [*c]GBufferedOutputStream;
pub const GBufferedOutputStream_listautoptr = [*c]GList;
pub const GBufferedOutputStream_slistautoptr = [*c]GSList;
pub const GBufferedOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBufferedOutputStream(arg__ptr: [*c]GBufferedOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GBufferedOutputStream(arg__ptr: [*c][*c]GBufferedOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBufferedOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBufferedOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GBufferedOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GBufferedOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GBytesIcon_autoptr = ?*GBytesIcon;
pub const GBytesIcon_listautoptr = [*c]GList;
pub const GBytesIcon_slistautoptr = [*c]GSList;
pub const GBytesIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBytesIcon(arg__ptr: ?*GBytesIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GBytesIcon(arg__ptr: [*c]?*GBytesIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GBytesIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GBytesIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GBytesIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GBytesIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GCancellable_autoptr = [*c]GCancellable;
pub const GCancellable_listautoptr = [*c]GList;
pub const GCancellable_slistautoptr = [*c]GSList;
pub const GCancellable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GCancellable(arg__ptr: [*c]GCancellable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GCancellable(arg__ptr: [*c][*c]GCancellable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GCancellable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GCancellable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GCancellable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GCancellable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GCharsetConverter_autoptr = ?*GCharsetConverter;
pub const GCharsetConverter_listautoptr = [*c]GList;
pub const GCharsetConverter_slistautoptr = [*c]GSList;
pub const GCharsetConverter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GCharsetConverter(arg__ptr: ?*GCharsetConverter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GCharsetConverter(arg__ptr: [*c]?*GCharsetConverter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GCharsetConverter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GCharsetConverter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GCharsetConverter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GCharsetConverter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GConverter_autoptr = ?*GConverter;
pub const GConverter_listautoptr = [*c]GList;
pub const GConverter_slistautoptr = [*c]GSList;
pub const GConverter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GConverter(arg__ptr: ?*GConverter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GConverter(arg__ptr: [*c]?*GConverter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GConverter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GConverter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GConverter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GConverter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GConverterInputStream_autoptr = [*c]GConverterInputStream;
pub const GConverterInputStream_listautoptr = [*c]GList;
pub const GConverterInputStream_slistautoptr = [*c]GSList;
pub const GConverterInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GConverterInputStream(arg__ptr: [*c]GConverterInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GConverterInputStream(arg__ptr: [*c][*c]GConverterInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GConverterInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GConverterInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GConverterInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GConverterInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GConverterOutputStream_autoptr = [*c]GConverterOutputStream;
pub const GConverterOutputStream_listautoptr = [*c]GList;
pub const GConverterOutputStream_slistautoptr = [*c]GSList;
pub const GConverterOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GConverterOutputStream(arg__ptr: [*c]GConverterOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GConverterOutputStream(arg__ptr: [*c][*c]GConverterOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GConverterOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GConverterOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GConverterOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GConverterOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GCredentials_autoptr = ?*GCredentials;
pub const GCredentials_listautoptr = [*c]GList;
pub const GCredentials_slistautoptr = [*c]GSList;
pub const GCredentials_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GCredentials(arg__ptr: ?*GCredentials) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GCredentials(arg__ptr: [*c]?*GCredentials) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GCredentials(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GCredentials(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GCredentials(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GCredentials(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDatagramBased_autoptr = ?*GDatagramBased;
pub const GDatagramBased_listautoptr = [*c]GList;
pub const GDatagramBased_slistautoptr = [*c]GSList;
pub const GDatagramBased_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDatagramBased(arg__ptr: ?*GDatagramBased) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDatagramBased(arg__ptr: [*c]?*GDatagramBased) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDatagramBased(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDatagramBased(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDatagramBased(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDatagramBased(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDataInputStream_autoptr = [*c]GDataInputStream;
pub const GDataInputStream_listautoptr = [*c]GList;
pub const GDataInputStream_slistautoptr = [*c]GSList;
pub const GDataInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDataInputStream(arg__ptr: [*c]GDataInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDataInputStream(arg__ptr: [*c][*c]GDataInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDataInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDataInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDataInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDataInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDataOutputStream_autoptr = [*c]GDataOutputStream;
pub const GDataOutputStream_listautoptr = [*c]GList;
pub const GDataOutputStream_slistautoptr = [*c]GSList;
pub const GDataOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDataOutputStream(arg__ptr: [*c]GDataOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDataOutputStream(arg__ptr: [*c][*c]GDataOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDataOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDataOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDataOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDataOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusActionGroup_autoptr = ?*GDBusActionGroup;
pub const GDBusActionGroup_listautoptr = [*c]GList;
pub const GDBusActionGroup_slistautoptr = [*c]GSList;
pub const GDBusActionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusActionGroup(arg__ptr: ?*GDBusActionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusActionGroup(arg__ptr: [*c]?*GDBusActionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusActionGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusActionGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusActionGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusActionGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusAuthObserver_autoptr = ?*GDBusAuthObserver;
pub const GDBusAuthObserver_listautoptr = [*c]GList;
pub const GDBusAuthObserver_slistautoptr = [*c]GSList;
pub const GDBusAuthObserver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusAuthObserver(arg__ptr: ?*GDBusAuthObserver) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusAuthObserver(arg__ptr: [*c]?*GDBusAuthObserver) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusAuthObserver(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusAuthObserver(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusAuthObserver(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusAuthObserver(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusConnection_autoptr = ?*GDBusConnection;
pub const GDBusConnection_listautoptr = [*c]GList;
pub const GDBusConnection_slistautoptr = [*c]GSList;
pub const GDBusConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusConnection(arg__ptr: ?*GDBusConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusConnection(arg__ptr: [*c]?*GDBusConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusInterface_autoptr = ?*GDBusInterface;
pub const GDBusInterface_listautoptr = [*c]GList;
pub const GDBusInterface_slistautoptr = [*c]GSList;
pub const GDBusInterface_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusInterface(arg__ptr: ?*GDBusInterface) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusInterface(arg__ptr: [*c]?*GDBusInterface) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusInterface(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusInterface(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusInterface(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusInterface(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusInterfaceSkeleton_autoptr = [*c]GDBusInterfaceSkeleton;
pub const GDBusInterfaceSkeleton_listautoptr = [*c]GList;
pub const GDBusInterfaceSkeleton_slistautoptr = [*c]GSList;
pub const GDBusInterfaceSkeleton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusInterfaceSkeleton(arg__ptr: [*c]GDBusInterfaceSkeleton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusInterfaceSkeleton(arg__ptr: [*c][*c]GDBusInterfaceSkeleton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusInterfaceSkeleton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusInterfaceSkeleton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusInterfaceSkeleton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusInterfaceSkeleton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusMenuModel_autoptr = ?*GDBusMenuModel;
pub const GDBusMenuModel_listautoptr = [*c]GList;
pub const GDBusMenuModel_slistautoptr = [*c]GSList;
pub const GDBusMenuModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusMenuModel(arg__ptr: ?*GDBusMenuModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusMenuModel(arg__ptr: [*c]?*GDBusMenuModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusMenuModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusMenuModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusMenuModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusMenuModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusMessage_autoptr = ?*GDBusMessage;
pub const GDBusMessage_listautoptr = [*c]GList;
pub const GDBusMessage_slistautoptr = [*c]GSList;
pub const GDBusMessage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusMessage(arg__ptr: ?*GDBusMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusMessage(arg__ptr: [*c]?*GDBusMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusMessage(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusMessage(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusMessage(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusMessage(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusMethodInvocation_autoptr = ?*GDBusMethodInvocation;
pub const GDBusMethodInvocation_listautoptr = [*c]GList;
pub const GDBusMethodInvocation_slistautoptr = [*c]GSList;
pub const GDBusMethodInvocation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusMethodInvocation(arg__ptr: ?*GDBusMethodInvocation) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusMethodInvocation(arg__ptr: [*c]?*GDBusMethodInvocation) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusMethodInvocation(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusMethodInvocation(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusMethodInvocation(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusMethodInvocation(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusNodeInfo_autoptr = [*c]GDBusNodeInfo;
pub const GDBusNodeInfo_listautoptr = [*c]GList;
pub const GDBusNodeInfo_slistautoptr = [*c]GSList;
pub const GDBusNodeInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusNodeInfo(arg__ptr: [*c]GDBusNodeInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_dbus_node_info_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GDBusNodeInfo(arg__ptr: [*c][*c]GDBusNodeInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusNodeInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusNodeInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_dbus_node_info_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusNodeInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_dbus_node_info_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusNodeInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_dbus_node_info_unref)))))));
    }
}
pub const GDBusObject_autoptr = ?*GDBusObject;
pub const GDBusObject_listautoptr = [*c]GList;
pub const GDBusObject_slistautoptr = [*c]GSList;
pub const GDBusObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObject(arg__ptr: ?*GDBusObject) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusObject(arg__ptr: [*c]?*GDBusObject) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusObject(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusObject(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusObject(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusObject(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusObjectManagerClient_autoptr = [*c]GDBusObjectManagerClient;
pub const GDBusObjectManagerClient_listautoptr = [*c]GList;
pub const GDBusObjectManagerClient_slistautoptr = [*c]GSList;
pub const GDBusObjectManagerClient_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectManagerClient(arg__ptr: [*c]GDBusObjectManagerClient) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusObjectManagerClient(arg__ptr: [*c][*c]GDBusObjectManagerClient) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusObjectManagerClient(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectManagerClient(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectManagerClient(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectManagerClient(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusObjectManager_autoptr = ?*GDBusObjectManager;
pub const GDBusObjectManager_listautoptr = [*c]GList;
pub const GDBusObjectManager_slistautoptr = [*c]GSList;
pub const GDBusObjectManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectManager(arg__ptr: ?*GDBusObjectManager) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusObjectManager(arg__ptr: [*c]?*GDBusObjectManager) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusObjectManager(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectManager(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectManager(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectManager(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusObjectManagerServer_autoptr = [*c]GDBusObjectManagerServer;
pub const GDBusObjectManagerServer_listautoptr = [*c]GList;
pub const GDBusObjectManagerServer_slistautoptr = [*c]GSList;
pub const GDBusObjectManagerServer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectManagerServer(arg__ptr: [*c]GDBusObjectManagerServer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusObjectManagerServer(arg__ptr: [*c][*c]GDBusObjectManagerServer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusObjectManagerServer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectManagerServer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectManagerServer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectManagerServer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusObjectProxy_autoptr = [*c]GDBusObjectProxy;
pub const GDBusObjectProxy_listautoptr = [*c]GList;
pub const GDBusObjectProxy_slistautoptr = [*c]GSList;
pub const GDBusObjectProxy_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectProxy(arg__ptr: [*c]GDBusObjectProxy) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusObjectProxy(arg__ptr: [*c][*c]GDBusObjectProxy) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusObjectProxy(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectProxy(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectProxy(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectProxy(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusObjectSkeleton_autoptr = [*c]GDBusObjectSkeleton;
pub const GDBusObjectSkeleton_listautoptr = [*c]GList;
pub const GDBusObjectSkeleton_slistautoptr = [*c]GSList;
pub const GDBusObjectSkeleton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectSkeleton(arg__ptr: [*c]GDBusObjectSkeleton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusObjectSkeleton(arg__ptr: [*c][*c]GDBusObjectSkeleton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusObjectSkeleton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectSkeleton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectSkeleton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectSkeleton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusProxy_autoptr = [*c]GDBusProxy;
pub const GDBusProxy_listautoptr = [*c]GList;
pub const GDBusProxy_slistautoptr = [*c]GSList;
pub const GDBusProxy_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusProxy(arg__ptr: [*c]GDBusProxy) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusProxy(arg__ptr: [*c][*c]GDBusProxy) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusProxy(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusProxy(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusProxy(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusProxy(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDBusServer_autoptr = ?*GDBusServer;
pub const GDBusServer_listautoptr = [*c]GList;
pub const GDBusServer_slistautoptr = [*c]GSList;
pub const GDBusServer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusServer(arg__ptr: ?*GDBusServer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDBusServer(arg__ptr: [*c]?*GDBusServer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDBusServer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDBusServer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDBusServer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDBusServer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDrive_autoptr = ?*GDrive;
pub const GDrive_listautoptr = [*c]GList;
pub const GDrive_slistautoptr = [*c]GSList;
pub const GDrive_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDrive(arg__ptr: ?*GDrive) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GDrive(arg__ptr: [*c]?*GDrive) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GDrive(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GDrive(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GDrive(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GDrive(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GEmblemedIcon_autoptr = [*c]GEmblemedIcon;
pub const GEmblemedIcon_listautoptr = [*c]GList;
pub const GEmblemedIcon_slistautoptr = [*c]GSList;
pub const GEmblemedIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEmblemedIcon(arg__ptr: [*c]GEmblemedIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GEmblemedIcon(arg__ptr: [*c][*c]GEmblemedIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GEmblemedIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GEmblemedIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GEmblemedIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GEmblemedIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GEmblem_autoptr = ?*GEmblem;
pub const GEmblem_listautoptr = [*c]GList;
pub const GEmblem_slistautoptr = [*c]GSList;
pub const GEmblem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEmblem(arg__ptr: ?*GEmblem) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GEmblem(arg__ptr: [*c]?*GEmblem) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GEmblem(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GEmblem(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GEmblem(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GEmblem(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileEnumerator_autoptr = [*c]GFileEnumerator;
pub const GFileEnumerator_listautoptr = [*c]GList;
pub const GFileEnumerator_slistautoptr = [*c]GSList;
pub const GFileEnumerator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileEnumerator(arg__ptr: [*c]GFileEnumerator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileEnumerator(arg__ptr: [*c][*c]GFileEnumerator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileEnumerator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileEnumerator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileEnumerator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileEnumerator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFile_autoptr = ?*GFile;
pub const GFile_listautoptr = [*c]GList;
pub const GFile_slistautoptr = [*c]GSList;
pub const GFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFile(arg__ptr: ?*GFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFile(arg__ptr: [*c]?*GFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileAttributeInfoList_autoptr = [*c]GFileAttributeInfoList;
pub const GFileAttributeInfoList_listautoptr = [*c]GList;
pub const GFileAttributeInfoList_slistautoptr = [*c]GSList;
pub const GFileAttributeInfoList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileAttributeInfoList(arg__ptr: [*c]GFileAttributeInfoList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_file_attribute_info_list_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GFileAttributeInfoList(arg__ptr: [*c][*c]GFileAttributeInfoList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileAttributeInfoList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileAttributeInfoList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_file_attribute_info_list_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileAttributeInfoList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_file_attribute_info_list_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileAttributeInfoList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_file_attribute_info_list_unref)))))));
    }
}
pub const GFileIcon_autoptr = ?*GFileIcon;
pub const GFileIcon_listautoptr = [*c]GList;
pub const GFileIcon_slistautoptr = [*c]GSList;
pub const GFileIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileIcon(arg__ptr: ?*GFileIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileIcon(arg__ptr: [*c]?*GFileIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileInfo_autoptr = ?*GFileInfo;
pub const GFileInfo_listautoptr = [*c]GList;
pub const GFileInfo_slistautoptr = [*c]GSList;
pub const GFileInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileInfo(arg__ptr: ?*GFileInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileInfo(arg__ptr: [*c]?*GFileInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileInputStream_autoptr = [*c]GFileInputStream;
pub const GFileInputStream_listautoptr = [*c]GList;
pub const GFileInputStream_slistautoptr = [*c]GSList;
pub const GFileInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileInputStream(arg__ptr: [*c]GFileInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileInputStream(arg__ptr: [*c][*c]GFileInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileIOStream_autoptr = [*c]GFileIOStream;
pub const GFileIOStream_listautoptr = [*c]GList;
pub const GFileIOStream_slistautoptr = [*c]GSList;
pub const GFileIOStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileIOStream(arg__ptr: [*c]GFileIOStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileIOStream(arg__ptr: [*c][*c]GFileIOStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileIOStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileIOStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileIOStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileIOStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileMonitor_autoptr = [*c]GFileMonitor;
pub const GFileMonitor_listautoptr = [*c]GList;
pub const GFileMonitor_slistautoptr = [*c]GSList;
pub const GFileMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileMonitor(arg__ptr: [*c]GFileMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileMonitor(arg__ptr: [*c][*c]GFileMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFilenameCompleter_autoptr = ?*GFilenameCompleter;
pub const GFilenameCompleter_listautoptr = [*c]GList;
pub const GFilenameCompleter_slistautoptr = [*c]GSList;
pub const GFilenameCompleter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFilenameCompleter(arg__ptr: ?*GFilenameCompleter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFilenameCompleter(arg__ptr: [*c]?*GFilenameCompleter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFilenameCompleter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFilenameCompleter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFilenameCompleter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFilenameCompleter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFileOutputStream_autoptr = [*c]GFileOutputStream;
pub const GFileOutputStream_listautoptr = [*c]GList;
pub const GFileOutputStream_slistautoptr = [*c]GSList;
pub const GFileOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileOutputStream(arg__ptr: [*c]GFileOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFileOutputStream(arg__ptr: [*c][*c]GFileOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFileOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFileOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFileOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFileOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFilterInputStream_autoptr = [*c]GFilterInputStream;
pub const GFilterInputStream_listautoptr = [*c]GList;
pub const GFilterInputStream_slistautoptr = [*c]GSList;
pub const GFilterInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFilterInputStream(arg__ptr: [*c]GFilterInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFilterInputStream(arg__ptr: [*c][*c]GFilterInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFilterInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFilterInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFilterInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFilterInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GFilterOutputStream_autoptr = [*c]GFilterOutputStream;
pub const GFilterOutputStream_listautoptr = [*c]GList;
pub const GFilterOutputStream_slistautoptr = [*c]GSList;
pub const GFilterOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFilterOutputStream(arg__ptr: [*c]GFilterOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GFilterOutputStream(arg__ptr: [*c][*c]GFilterOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GFilterOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GFilterOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GFilterOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GFilterOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GIcon_autoptr = ?*GIcon;
pub const GIcon_listautoptr = [*c]GList;
pub const GIcon_slistautoptr = [*c]GSList;
pub const GIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIcon(arg__ptr: ?*GIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GIcon(arg__ptr: [*c]?*GIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GInetAddress_autoptr = [*c]GInetAddress;
pub const GInetAddress_listautoptr = [*c]GList;
pub const GInetAddress_slistautoptr = [*c]GSList;
pub const GInetAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInetAddress(arg__ptr: [*c]GInetAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GInetAddress(arg__ptr: [*c][*c]GInetAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInetAddress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInetAddress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GInetAddress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GInetAddress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GInetAddressMask_autoptr = [*c]GInetAddressMask;
pub const GInetAddressMask_listautoptr = [*c]GList;
pub const GInetAddressMask_slistautoptr = [*c]GSList;
pub const GInetAddressMask_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInetAddressMask(arg__ptr: [*c]GInetAddressMask) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GInetAddressMask(arg__ptr: [*c][*c]GInetAddressMask) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInetAddressMask(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInetAddressMask(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GInetAddressMask(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GInetAddressMask(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GInetSocketAddress_autoptr = [*c]GInetSocketAddress;
pub const GInetSocketAddress_listautoptr = [*c]GList;
pub const GInetSocketAddress_slistautoptr = [*c]GSList;
pub const GInetSocketAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInetSocketAddress(arg__ptr: [*c]GInetSocketAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GInetSocketAddress(arg__ptr: [*c][*c]GInetSocketAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInetSocketAddress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInetSocketAddress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GInetSocketAddress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GInetSocketAddress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GInitable_autoptr = ?*GInitable;
pub const GInitable_listautoptr = [*c]GList;
pub const GInitable_slistautoptr = [*c]GSList;
pub const GInitable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInitable(arg__ptr: ?*GInitable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GInitable(arg__ptr: [*c]?*GInitable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInitable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInitable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GInitable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GInitable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GInputStream_autoptr = [*c]GInputStream;
pub const GInputStream_listautoptr = [*c]GList;
pub const GInputStream_slistautoptr = [*c]GSList;
pub const GInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInputStream(arg__ptr: [*c]GInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GInputStream(arg__ptr: [*c][*c]GInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GIOModule_autoptr = ?*GIOModule;
pub const GIOModule_listautoptr = [*c]GList;
pub const GIOModule_slistautoptr = [*c]GSList;
pub const GIOModule_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOModule(arg__ptr: ?*GIOModule) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GIOModule(arg__ptr: [*c]?*GIOModule) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GIOModule(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GIOModule(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GIOModule(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GIOModule(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GIOStream_autoptr = [*c]GIOStream;
pub const GIOStream_listautoptr = [*c]GList;
pub const GIOStream_slistautoptr = [*c]GSList;
pub const GIOStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOStream(arg__ptr: [*c]GIOStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GIOStream(arg__ptr: [*c][*c]GIOStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GIOStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GIOStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GIOStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GIOStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GLoadableIcon_autoptr = ?*GLoadableIcon;
pub const GLoadableIcon_listautoptr = [*c]GList;
pub const GLoadableIcon_slistautoptr = [*c]GSList;
pub const GLoadableIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GLoadableIcon(arg__ptr: ?*GLoadableIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GLoadableIcon(arg__ptr: [*c]?*GLoadableIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GLoadableIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GLoadableIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GLoadableIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GLoadableIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMemoryInputStream_autoptr = [*c]GMemoryInputStream;
pub const GMemoryInputStream_listautoptr = [*c]GList;
pub const GMemoryInputStream_slistautoptr = [*c]GSList;
pub const GMemoryInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMemoryInputStream(arg__ptr: [*c]GMemoryInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMemoryInputStream(arg__ptr: [*c][*c]GMemoryInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMemoryInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMemoryInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMemoryInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMemoryInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMemoryOutputStream_autoptr = [*c]GMemoryOutputStream;
pub const GMemoryOutputStream_listautoptr = [*c]GList;
pub const GMemoryOutputStream_slistautoptr = [*c]GSList;
pub const GMemoryOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMemoryOutputStream(arg__ptr: [*c]GMemoryOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMemoryOutputStream(arg__ptr: [*c][*c]GMemoryOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMemoryOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMemoryOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMemoryOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMemoryOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMenu_autoptr = ?*GMenu;
pub const GMenu_listautoptr = [*c]GList;
pub const GMenu_slistautoptr = [*c]GSList;
pub const GMenu_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenu(arg__ptr: ?*GMenu) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMenu(arg__ptr: [*c]?*GMenu) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMenu(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMenu(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMenu(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMenu(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMenuItem_autoptr = ?*GMenuItem;
pub const GMenuItem_listautoptr = [*c]GList;
pub const GMenuItem_slistautoptr = [*c]GSList;
pub const GMenuItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuItem(arg__ptr: ?*GMenuItem) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMenuItem(arg__ptr: [*c]?*GMenuItem) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMenuItem(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMenuItem(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMenuItem(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMenuItem(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMenuModel_autoptr = [*c]GMenuModel;
pub const GMenuModel_listautoptr = [*c]GList;
pub const GMenuModel_slistautoptr = [*c]GSList;
pub const GMenuModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuModel(arg__ptr: [*c]GMenuModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMenuModel(arg__ptr: [*c][*c]GMenuModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMenuModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMenuModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMenuModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMenuModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMenuAttributeIter_autoptr = [*c]GMenuAttributeIter;
pub const GMenuAttributeIter_listautoptr = [*c]GList;
pub const GMenuAttributeIter_slistautoptr = [*c]GSList;
pub const GMenuAttributeIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuAttributeIter(arg__ptr: [*c]GMenuAttributeIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMenuAttributeIter(arg__ptr: [*c][*c]GMenuAttributeIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMenuAttributeIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMenuAttributeIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMenuAttributeIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMenuAttributeIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMenuLinkIter_autoptr = [*c]GMenuLinkIter;
pub const GMenuLinkIter_listautoptr = [*c]GList;
pub const GMenuLinkIter_slistautoptr = [*c]GSList;
pub const GMenuLinkIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuLinkIter(arg__ptr: [*c]GMenuLinkIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMenuLinkIter(arg__ptr: [*c][*c]GMenuLinkIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMenuLinkIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMenuLinkIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMenuLinkIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMenuLinkIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMount_autoptr = ?*GMount;
pub const GMount_listautoptr = [*c]GList;
pub const GMount_slistautoptr = [*c]GSList;
pub const GMount_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMount(arg__ptr: ?*GMount) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMount(arg__ptr: [*c]?*GMount) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMount(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMount(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMount(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMount(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GMountOperation_autoptr = [*c]GMountOperation;
pub const GMountOperation_listautoptr = [*c]GList;
pub const GMountOperation_slistautoptr = [*c]GSList;
pub const GMountOperation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMountOperation(arg__ptr: [*c]GMountOperation) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GMountOperation(arg__ptr: [*c][*c]GMountOperation) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GMountOperation(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GMountOperation(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GMountOperation(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GMountOperation(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GNativeVolumeMonitor_autoptr = [*c]GNativeVolumeMonitor;
pub const GNativeVolumeMonitor_listautoptr = [*c]GList;
pub const GNativeVolumeMonitor_slistautoptr = [*c]GSList;
pub const GNativeVolumeMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNativeVolumeMonitor(arg__ptr: [*c]GNativeVolumeMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GNativeVolumeMonitor(arg__ptr: [*c][*c]GNativeVolumeMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNativeVolumeMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNativeVolumeMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GNativeVolumeMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GNativeVolumeMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GNetworkAddress_autoptr = [*c]GNetworkAddress;
pub const GNetworkAddress_listautoptr = [*c]GList;
pub const GNetworkAddress_slistautoptr = [*c]GSList;
pub const GNetworkAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNetworkAddress(arg__ptr: [*c]GNetworkAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GNetworkAddress(arg__ptr: [*c][*c]GNetworkAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNetworkAddress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNetworkAddress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GNetworkAddress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GNetworkAddress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GNetworkMonitor_autoptr = ?*GNetworkMonitor;
pub const GNetworkMonitor_listautoptr = [*c]GList;
pub const GNetworkMonitor_slistautoptr = [*c]GSList;
pub const GNetworkMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNetworkMonitor(arg__ptr: ?*GNetworkMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GNetworkMonitor(arg__ptr: [*c]?*GNetworkMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNetworkMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNetworkMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GNetworkMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GNetworkMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GNetworkService_autoptr = [*c]GNetworkService;
pub const GNetworkService_listautoptr = [*c]GList;
pub const GNetworkService_slistautoptr = [*c]GSList;
pub const GNetworkService_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNetworkService(arg__ptr: [*c]GNetworkService) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GNetworkService(arg__ptr: [*c][*c]GNetworkService) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNetworkService(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNetworkService(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GNetworkService(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GNetworkService(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GNotification_autoptr = ?*GNotification;
pub const GNotification_listautoptr = [*c]GList;
pub const GNotification_slistautoptr = [*c]GSList;
pub const GNotification_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNotification(arg__ptr: ?*GNotification) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GNotification(arg__ptr: [*c]?*GNotification) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GNotification(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GNotification(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GNotification(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GNotification(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GOutputStream_autoptr = [*c]GOutputStream;
pub const GOutputStream_listautoptr = [*c]GList;
pub const GOutputStream_slistautoptr = [*c]GSList;
pub const GOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOutputStream(arg__ptr: [*c]GOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GOutputStream(arg__ptr: [*c][*c]GOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GPermission_autoptr = [*c]GPermission;
pub const GPermission_listautoptr = [*c]GList;
pub const GPermission_slistautoptr = [*c]GSList;
pub const GPermission_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPermission(arg__ptr: [*c]GPermission) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GPermission(arg__ptr: [*c][*c]GPermission) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPermission(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPermission(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GPermission(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GPermission(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GPollableInputStream_autoptr = ?*GPollableInputStream;
pub const GPollableInputStream_listautoptr = [*c]GList;
pub const GPollableInputStream_slistautoptr = [*c]GSList;
pub const GPollableInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPollableInputStream(arg__ptr: ?*GPollableInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GPollableInputStream(arg__ptr: [*c]?*GPollableInputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPollableInputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPollableInputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GPollableInputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GPollableInputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GPollableOutputStream_autoptr = ?*GPollableOutputStream;
pub const GPollableOutputStream_listautoptr = [*c]GList;
pub const GPollableOutputStream_slistautoptr = [*c]GSList;
pub const GPollableOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPollableOutputStream(arg__ptr: ?*GPollableOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GPollableOutputStream(arg__ptr: [*c]?*GPollableOutputStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPollableOutputStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPollableOutputStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GPollableOutputStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GPollableOutputStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GPropertyAction_autoptr = ?*GPropertyAction;
pub const GPropertyAction_listautoptr = [*c]GList;
pub const GPropertyAction_slistautoptr = [*c]GSList;
pub const GPropertyAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPropertyAction(arg__ptr: ?*GPropertyAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GPropertyAction(arg__ptr: [*c]?*GPropertyAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GPropertyAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GPropertyAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GPropertyAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GPropertyAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GProxyAddressEnumerator_autoptr = [*c]GProxyAddressEnumerator;
pub const GProxyAddressEnumerator_listautoptr = [*c]GList;
pub const GProxyAddressEnumerator_slistautoptr = [*c]GSList;
pub const GProxyAddressEnumerator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxyAddressEnumerator(arg__ptr: [*c]GProxyAddressEnumerator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GProxyAddressEnumerator(arg__ptr: [*c][*c]GProxyAddressEnumerator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GProxyAddressEnumerator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GProxyAddressEnumerator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GProxyAddressEnumerator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GProxyAddressEnumerator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GProxyAddress_autoptr = [*c]GProxyAddress;
pub const GProxyAddress_listautoptr = [*c]GList;
pub const GProxyAddress_slistautoptr = [*c]GSList;
pub const GProxyAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxyAddress(arg__ptr: [*c]GProxyAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GProxyAddress(arg__ptr: [*c][*c]GProxyAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GProxyAddress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GProxyAddress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GProxyAddress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GProxyAddress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GProxy_autoptr = ?*GProxy;
pub const GProxy_listautoptr = [*c]GList;
pub const GProxy_slistautoptr = [*c]GSList;
pub const GProxy_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxy(arg__ptr: ?*GProxy) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GProxy(arg__ptr: [*c]?*GProxy) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GProxy(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GProxy(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GProxy(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GProxy(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GProxyResolver_autoptr = ?*GProxyResolver;
pub const GProxyResolver_listautoptr = [*c]GList;
pub const GProxyResolver_slistautoptr = [*c]GSList;
pub const GProxyResolver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxyResolver(arg__ptr: ?*GProxyResolver) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GProxyResolver(arg__ptr: [*c]?*GProxyResolver) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GProxyResolver(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GProxyResolver(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GProxyResolver(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GProxyResolver(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GRemoteActionGroup_autoptr = ?*GRemoteActionGroup;
pub const GRemoteActionGroup_listautoptr = [*c]GList;
pub const GRemoteActionGroup_slistautoptr = [*c]GSList;
pub const GRemoteActionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRemoteActionGroup(arg__ptr: ?*GRemoteActionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GRemoteActionGroup(arg__ptr: [*c]?*GRemoteActionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GRemoteActionGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GRemoteActionGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GRemoteActionGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GRemoteActionGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GResolver_autoptr = [*c]GResolver;
pub const GResolver_listautoptr = [*c]GList;
pub const GResolver_slistautoptr = [*c]GSList;
pub const GResolver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GResolver(arg__ptr: [*c]GResolver) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GResolver(arg__ptr: [*c][*c]GResolver) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GResolver(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GResolver(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GResolver(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GResolver(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GResource_autoptr = ?*GResource;
pub const GResource_listautoptr = [*c]GList;
pub const GResource_slistautoptr = [*c]GSList;
pub const GResource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GResource(arg__ptr: ?*GResource) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_resource_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GResource(arg__ptr: [*c]?*GResource) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GResource(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GResource(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_resource_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GResource(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_resource_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GResource(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_resource_unref)))))));
    }
}
pub const GSeekable_autoptr = ?*GSeekable;
pub const GSeekable_listautoptr = [*c]GList;
pub const GSeekable_slistautoptr = [*c]GSList;
pub const GSeekable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSeekable(arg__ptr: ?*GSeekable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSeekable(arg__ptr: [*c]?*GSeekable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSeekable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSeekable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSeekable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSeekable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSettingsBackend_autoptr = ?*GSettingsBackend;
pub const GSettingsBackend_listautoptr = [*c]GList;
pub const GSettingsBackend_slistautoptr = [*c]GSList;
pub const GSettingsBackend_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsBackend(arg__ptr: ?*GSettingsBackend) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSettingsBackend(arg__ptr: [*c]?*GSettingsBackend) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSettingsBackend(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSettingsBackend(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSettingsBackend(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSettingsBackend(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSettingsSchema_autoptr = ?*GSettingsSchema;
pub const GSettingsSchema_listautoptr = [*c]GList;
pub const GSettingsSchema_slistautoptr = [*c]GSList;
pub const GSettingsSchema_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsSchema(arg__ptr: ?*GSettingsSchema) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_settings_schema_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSettingsSchema(arg__ptr: [*c]?*GSettingsSchema) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSettingsSchema(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSettingsSchema(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSettingsSchema(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSettingsSchema(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_unref)))))));
    }
}
pub const GSettingsSchemaKey_autoptr = ?*GSettingsSchemaKey;
pub const GSettingsSchemaKey_listautoptr = [*c]GList;
pub const GSettingsSchemaKey_slistautoptr = [*c]GSList;
pub const GSettingsSchemaKey_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsSchemaKey(arg__ptr: ?*GSettingsSchemaKey) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_settings_schema_key_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSettingsSchemaKey(arg__ptr: [*c]?*GSettingsSchemaKey) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSettingsSchemaKey(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSettingsSchemaKey(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_key_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSettingsSchemaKey(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_key_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSettingsSchemaKey(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_key_unref)))))));
    }
}
pub const GSettingsSchemaSource_autoptr = ?*GSettingsSchemaSource;
pub const GSettingsSchemaSource_listautoptr = [*c]GList;
pub const GSettingsSchemaSource_slistautoptr = [*c]GSList;
pub const GSettingsSchemaSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsSchemaSource(arg__ptr: ?*GSettingsSchemaSource) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_settings_schema_source_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GSettingsSchemaSource(arg__ptr: [*c]?*GSettingsSchemaSource) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSettingsSchemaSource(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSettingsSchemaSource(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_source_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSettingsSchemaSource(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_source_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSettingsSchemaSource(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_settings_schema_source_unref)))))));
    }
}
pub const GSettings_autoptr = [*c]GSettings;
pub const GSettings_listautoptr = [*c]GList;
pub const GSettings_slistautoptr = [*c]GSList;
pub const GSettings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettings(arg__ptr: [*c]GSettings) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSettings(arg__ptr: [*c][*c]GSettings) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSettings(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSettings(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSettings(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSettings(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSimpleActionGroup_autoptr = [*c]GSimpleActionGroup;
pub const GSimpleActionGroup_listautoptr = [*c]GList;
pub const GSimpleActionGroup_slistautoptr = [*c]GSList;
pub const GSimpleActionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleActionGroup(arg__ptr: [*c]GSimpleActionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSimpleActionGroup(arg__ptr: [*c][*c]GSimpleActionGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSimpleActionGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSimpleActionGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSimpleActionGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSimpleActionGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSimpleAction_autoptr = ?*GSimpleAction;
pub const GSimpleAction_listautoptr = [*c]GList;
pub const GSimpleAction_slistautoptr = [*c]GSList;
pub const GSimpleAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleAction(arg__ptr: ?*GSimpleAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSimpleAction(arg__ptr: [*c]?*GSimpleAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSimpleAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSimpleAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSimpleAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSimpleAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSimpleAsyncResult_autoptr = ?*GSimpleAsyncResult;
pub const GSimpleAsyncResult_listautoptr = [*c]GList;
pub const GSimpleAsyncResult_slistautoptr = [*c]GSList;
pub const GSimpleAsyncResult_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleAsyncResult(arg__ptr: ?*GSimpleAsyncResult) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSimpleAsyncResult(arg__ptr: [*c]?*GSimpleAsyncResult) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSimpleAsyncResult(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSimpleAsyncResult(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSimpleAsyncResult(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSimpleAsyncResult(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSimplePermission_autoptr = ?*GSimplePermission;
pub const GSimplePermission_listautoptr = [*c]GList;
pub const GSimplePermission_slistautoptr = [*c]GSList;
pub const GSimplePermission_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimplePermission(arg__ptr: ?*GSimplePermission) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSimplePermission(arg__ptr: [*c]?*GSimplePermission) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSimplePermission(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSimplePermission(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSimplePermission(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSimplePermission(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSimpleProxyResolver_autoptr = [*c]GSimpleProxyResolver;
pub const GSimpleProxyResolver_listautoptr = [*c]GList;
pub const GSimpleProxyResolver_slistautoptr = [*c]GSList;
pub const GSimpleProxyResolver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleProxyResolver(arg__ptr: [*c]GSimpleProxyResolver) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSimpleProxyResolver(arg__ptr: [*c][*c]GSimpleProxyResolver) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSimpleProxyResolver(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSimpleProxyResolver(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSimpleProxyResolver(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSimpleProxyResolver(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketAddressEnumerator_autoptr = [*c]GSocketAddressEnumerator;
pub const GSocketAddressEnumerator_listautoptr = [*c]GList;
pub const GSocketAddressEnumerator_slistautoptr = [*c]GSList;
pub const GSocketAddressEnumerator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketAddressEnumerator(arg__ptr: [*c]GSocketAddressEnumerator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketAddressEnumerator(arg__ptr: [*c][*c]GSocketAddressEnumerator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketAddressEnumerator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketAddressEnumerator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketAddressEnumerator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketAddressEnumerator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketAddress_autoptr = [*c]GSocketAddress;
pub const GSocketAddress_listautoptr = [*c]GList;
pub const GSocketAddress_slistautoptr = [*c]GSList;
pub const GSocketAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketAddress(arg__ptr: [*c]GSocketAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketAddress(arg__ptr: [*c][*c]GSocketAddress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketAddress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketAddress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketAddress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketAddress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketClient_autoptr = [*c]GSocketClient;
pub const GSocketClient_listautoptr = [*c]GList;
pub const GSocketClient_slistautoptr = [*c]GSList;
pub const GSocketClient_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketClient(arg__ptr: [*c]GSocketClient) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketClient(arg__ptr: [*c][*c]GSocketClient) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketClient(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketClient(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketClient(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketClient(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketConnectable_autoptr = ?*GSocketConnectable;
pub const GSocketConnectable_listautoptr = [*c]GList;
pub const GSocketConnectable_slistautoptr = [*c]GSList;
pub const GSocketConnectable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketConnectable(arg__ptr: ?*GSocketConnectable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketConnectable(arg__ptr: [*c]?*GSocketConnectable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketConnectable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketConnectable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketConnectable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketConnectable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketConnection_autoptr = [*c]GSocketConnection;
pub const GSocketConnection_listautoptr = [*c]GList;
pub const GSocketConnection_slistautoptr = [*c]GSList;
pub const GSocketConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketConnection(arg__ptr: [*c]GSocketConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketConnection(arg__ptr: [*c][*c]GSocketConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketControlMessage_autoptr = [*c]GSocketControlMessage;
pub const GSocketControlMessage_listautoptr = [*c]GList;
pub const GSocketControlMessage_slistautoptr = [*c]GSList;
pub const GSocketControlMessage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketControlMessage(arg__ptr: [*c]GSocketControlMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketControlMessage(arg__ptr: [*c][*c]GSocketControlMessage) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketControlMessage(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketControlMessage(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketControlMessage(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketControlMessage(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocket_autoptr = [*c]GSocket;
pub const GSocket_listautoptr = [*c]GList;
pub const GSocket_slistautoptr = [*c]GSList;
pub const GSocket_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocket(arg__ptr: [*c]GSocket) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocket(arg__ptr: [*c][*c]GSocket) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocket(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocket(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocket(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocket(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketListener_autoptr = [*c]GSocketListener;
pub const GSocketListener_listautoptr = [*c]GList;
pub const GSocketListener_slistautoptr = [*c]GSList;
pub const GSocketListener_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketListener(arg__ptr: [*c]GSocketListener) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketListener(arg__ptr: [*c][*c]GSocketListener) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketListener(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketListener(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketListener(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketListener(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSocketService_autoptr = [*c]GSocketService;
pub const GSocketService_listautoptr = [*c]GList;
pub const GSocketService_slistautoptr = [*c]GSList;
pub const GSocketService_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketService(arg__ptr: [*c]GSocketService) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSocketService(arg__ptr: [*c][*c]GSocketService) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSocketService(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSocketService(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSocketService(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSocketService(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSubprocess_autoptr = ?*GSubprocess;
pub const GSubprocess_listautoptr = [*c]GList;
pub const GSubprocess_slistautoptr = [*c]GSList;
pub const GSubprocess_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSubprocess(arg__ptr: ?*GSubprocess) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSubprocess(arg__ptr: [*c]?*GSubprocess) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSubprocess(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSubprocess(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSubprocess(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSubprocess(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSubprocessLauncher_autoptr = ?*GSubprocessLauncher;
pub const GSubprocessLauncher_listautoptr = [*c]GList;
pub const GSubprocessLauncher_slistautoptr = [*c]GSList;
pub const GSubprocessLauncher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSubprocessLauncher(arg__ptr: ?*GSubprocessLauncher) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GSubprocessLauncher(arg__ptr: [*c]?*GSubprocessLauncher) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GSubprocessLauncher(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GSubprocessLauncher(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GSubprocessLauncher(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GSubprocessLauncher(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTask_autoptr = ?*GTask;
pub const GTask_listautoptr = [*c]GList;
pub const GTask_slistautoptr = [*c]GSList;
pub const GTask_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTask(arg__ptr: ?*GTask) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTask(arg__ptr: [*c]?*GTask) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTask(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTask(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTask(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTask(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTcpConnection_autoptr = [*c]GTcpConnection;
pub const GTcpConnection_listautoptr = [*c]GList;
pub const GTcpConnection_slistautoptr = [*c]GSList;
pub const GTcpConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTcpConnection(arg__ptr: [*c]GTcpConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTcpConnection(arg__ptr: [*c][*c]GTcpConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTcpConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTcpConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTcpConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTcpConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTcpWrapperConnection_autoptr = [*c]GTcpWrapperConnection;
pub const GTcpWrapperConnection_listautoptr = [*c]GList;
pub const GTcpWrapperConnection_slistautoptr = [*c]GSList;
pub const GTcpWrapperConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTcpWrapperConnection(arg__ptr: [*c]GTcpWrapperConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTcpWrapperConnection(arg__ptr: [*c][*c]GTcpWrapperConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTcpWrapperConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTcpWrapperConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTcpWrapperConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTcpWrapperConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTestDBus_autoptr = ?*GTestDBus;
pub const GTestDBus_listautoptr = [*c]GList;
pub const GTestDBus_slistautoptr = [*c]GSList;
pub const GTestDBus_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTestDBus(arg__ptr: ?*GTestDBus) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTestDBus(arg__ptr: [*c]?*GTestDBus) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTestDBus(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTestDBus(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTestDBus(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTestDBus(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GThemedIcon_autoptr = ?*GThemedIcon;
pub const GThemedIcon_listautoptr = [*c]GList;
pub const GThemedIcon_slistautoptr = [*c]GSList;
pub const GThemedIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThemedIcon(arg__ptr: ?*GThemedIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GThemedIcon(arg__ptr: [*c]?*GThemedIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GThemedIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GThemedIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GThemedIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GThemedIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GThreadedSocketService_autoptr = [*c]GThreadedSocketService;
pub const GThreadedSocketService_listautoptr = [*c]GList;
pub const GThreadedSocketService_slistautoptr = [*c]GSList;
pub const GThreadedSocketService_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThreadedSocketService(arg__ptr: [*c]GThreadedSocketService) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GThreadedSocketService(arg__ptr: [*c][*c]GThreadedSocketService) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GThreadedSocketService(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GThreadedSocketService(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GThreadedSocketService(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GThreadedSocketService(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsBackend_autoptr = ?*GTlsBackend;
pub const GTlsBackend_listautoptr = [*c]GList;
pub const GTlsBackend_slistautoptr = [*c]GSList;
pub const GTlsBackend_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsBackend(arg__ptr: ?*GTlsBackend) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsBackend(arg__ptr: [*c]?*GTlsBackend) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsBackend(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsBackend(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsBackend(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsBackend(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsCertificate_autoptr = [*c]GTlsCertificate;
pub const GTlsCertificate_listautoptr = [*c]GList;
pub const GTlsCertificate_slistautoptr = [*c]GSList;
pub const GTlsCertificate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsCertificate(arg__ptr: [*c]GTlsCertificate) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsCertificate(arg__ptr: [*c][*c]GTlsCertificate) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsCertificate(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsCertificate(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsCertificate(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsCertificate(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsClientConnection_autoptr = ?*GTlsClientConnection;
pub const GTlsClientConnection_listautoptr = [*c]GList;
pub const GTlsClientConnection_slistautoptr = [*c]GSList;
pub const GTlsClientConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsClientConnection(arg__ptr: ?*GTlsClientConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsClientConnection(arg__ptr: [*c]?*GTlsClientConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsClientConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsClientConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsClientConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsClientConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsConnection_autoptr = [*c]GTlsConnection;
pub const GTlsConnection_listautoptr = [*c]GList;
pub const GTlsConnection_slistautoptr = [*c]GSList;
pub const GTlsConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsConnection(arg__ptr: [*c]GTlsConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsConnection(arg__ptr: [*c][*c]GTlsConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsDatabase_autoptr = [*c]GTlsDatabase;
pub const GTlsDatabase_listautoptr = [*c]GList;
pub const GTlsDatabase_slistautoptr = [*c]GSList;
pub const GTlsDatabase_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsDatabase(arg__ptr: [*c]GTlsDatabase) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsDatabase(arg__ptr: [*c][*c]GTlsDatabase) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsDatabase(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsDatabase(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsDatabase(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsDatabase(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsFileDatabase_autoptr = ?*GTlsFileDatabase;
pub const GTlsFileDatabase_listautoptr = [*c]GList;
pub const GTlsFileDatabase_slistautoptr = [*c]GSList;
pub const GTlsFileDatabase_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsFileDatabase(arg__ptr: ?*GTlsFileDatabase) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsFileDatabase(arg__ptr: [*c]?*GTlsFileDatabase) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsFileDatabase(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsFileDatabase(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsFileDatabase(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsFileDatabase(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsInteraction_autoptr = [*c]GTlsInteraction;
pub const GTlsInteraction_listautoptr = [*c]GList;
pub const GTlsInteraction_slistautoptr = [*c]GSList;
pub const GTlsInteraction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsInteraction(arg__ptr: [*c]GTlsInteraction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsInteraction(arg__ptr: [*c][*c]GTlsInteraction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsInteraction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsInteraction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsInteraction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsInteraction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsPassword_autoptr = [*c]GTlsPassword;
pub const GTlsPassword_listautoptr = [*c]GList;
pub const GTlsPassword_slistautoptr = [*c]GSList;
pub const GTlsPassword_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsPassword(arg__ptr: [*c]GTlsPassword) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsPassword(arg__ptr: [*c][*c]GTlsPassword) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsPassword(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsPassword(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsPassword(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsPassword(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTlsServerConnection_autoptr = ?*GTlsServerConnection;
pub const GTlsServerConnection_listautoptr = [*c]GList;
pub const GTlsServerConnection_slistautoptr = [*c]GSList;
pub const GTlsServerConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsServerConnection(arg__ptr: ?*GTlsServerConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GTlsServerConnection(arg__ptr: [*c]?*GTlsServerConnection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GTlsServerConnection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GTlsServerConnection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GTlsServerConnection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GTlsServerConnection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GVfs_autoptr = [*c]GVfs;
pub const GVfs_listautoptr = [*c]GList;
pub const GVfs_slistautoptr = [*c]GSList;
pub const GVfs_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVfs(arg__ptr: [*c]GVfs) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GVfs(arg__ptr: [*c][*c]GVfs) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVfs(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVfs(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GVfs(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GVfs(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GVolume_autoptr = ?*GVolume;
pub const GVolume_listautoptr = [*c]GList;
pub const GVolume_slistautoptr = [*c]GSList;
pub const GVolume_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVolume(arg__ptr: ?*GVolume) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GVolume(arg__ptr: [*c]?*GVolume) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVolume(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVolume(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GVolume(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GVolume(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GVolumeMonitor_autoptr = [*c]GVolumeMonitor;
pub const GVolumeMonitor_listautoptr = [*c]GList;
pub const GVolumeMonitor_slistautoptr = [*c]GSList;
pub const GVolumeMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVolumeMonitor(arg__ptr: [*c]GVolumeMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GVolumeMonitor(arg__ptr: [*c][*c]GVolumeMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GVolumeMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GVolumeMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GVolumeMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GVolumeMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GZlibCompressor_autoptr = ?*GZlibCompressor;
pub const GZlibCompressor_listautoptr = [*c]GList;
pub const GZlibCompressor_slistautoptr = [*c]GSList;
pub const GZlibCompressor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GZlibCompressor(arg__ptr: ?*GZlibCompressor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GZlibCompressor(arg__ptr: [*c]?*GZlibCompressor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GZlibCompressor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GZlibCompressor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GZlibCompressor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GZlibCompressor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GZlibDecompressor_autoptr = ?*GZlibDecompressor;
pub const GZlibDecompressor_listautoptr = [*c]GList;
pub const GZlibDecompressor_slistautoptr = [*c]GSList;
pub const GZlibDecompressor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GZlibDecompressor(arg__ptr: ?*GZlibDecompressor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GZlibDecompressor(arg__ptr: [*c]?*GZlibDecompressor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GZlibDecompressor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GZlibDecompressor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GZlibDecompressor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GZlibDecompressor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCssSection = opaque {};
pub const GtkCssSection = struct__GtkCssSection;
pub extern fn gtk_css_section_get_type() GType;
pub extern fn gtk_css_section_new(file: ?*GFile, start: [*c]const GtkCssLocation, end: [*c]const GtkCssLocation) ?*GtkCssSection;
pub extern fn gtk_css_section_ref(section: ?*GtkCssSection) ?*GtkCssSection;
pub extern fn gtk_css_section_unref(section: ?*GtkCssSection) void;
pub extern fn gtk_css_section_print(section: ?*const GtkCssSection, string: [*c]GString) void;
pub extern fn gtk_css_section_to_string(section: ?*const GtkCssSection) [*c]u8;
pub extern fn gtk_css_section_get_parent(section: ?*const GtkCssSection) ?*GtkCssSection;
pub extern fn gtk_css_section_get_file(section: ?*const GtkCssSection) ?*GFile;
pub extern fn gtk_css_section_get_start_location(section: ?*const GtkCssSection) [*c]const GtkCssLocation;
pub extern fn gtk_css_section_get_end_location(section: ?*const GtkCssSection) [*c]const GtkCssLocation;
pub extern fn cairo_version() c_int;
pub extern fn cairo_version_string() [*c]const u8;
pub const cairo_bool_t = c_int;
pub const struct__cairo = opaque {};
pub const cairo_t = struct__cairo;
pub const struct__cairo_surface = opaque {};
pub const cairo_surface_t = struct__cairo_surface;
pub const struct__cairo_device = opaque {};
pub const cairo_device_t = struct__cairo_device;
pub const struct__cairo_matrix = extern struct {
    xx: f64,
    yx: f64,
    xy: f64,
    yy: f64,
    x0: f64,
    y0: f64,
};
pub const cairo_matrix_t = struct__cairo_matrix;
pub const struct__cairo_pattern = opaque {};
pub const cairo_pattern_t = struct__cairo_pattern;
pub const cairo_destroy_func_t = ?*const fn (?*anyopaque) callconv(.C) void;
pub const struct__cairo_user_data_key = extern struct {
    unused: c_int,
};
pub const cairo_user_data_key_t = struct__cairo_user_data_key;
pub const CAIRO_STATUS_SUCCESS: c_int = 0;
pub const CAIRO_STATUS_NO_MEMORY: c_int = 1;
pub const CAIRO_STATUS_INVALID_RESTORE: c_int = 2;
pub const CAIRO_STATUS_INVALID_POP_GROUP: c_int = 3;
pub const CAIRO_STATUS_NO_CURRENT_POINT: c_int = 4;
pub const CAIRO_STATUS_INVALID_MATRIX: c_int = 5;
pub const CAIRO_STATUS_INVALID_STATUS: c_int = 6;
pub const CAIRO_STATUS_NULL_POINTER: c_int = 7;
pub const CAIRO_STATUS_INVALID_STRING: c_int = 8;
pub const CAIRO_STATUS_INVALID_PATH_DATA: c_int = 9;
pub const CAIRO_STATUS_READ_ERROR: c_int = 10;
pub const CAIRO_STATUS_WRITE_ERROR: c_int = 11;
pub const CAIRO_STATUS_SURFACE_FINISHED: c_int = 12;
pub const CAIRO_STATUS_SURFACE_TYPE_MISMATCH: c_int = 13;
pub const CAIRO_STATUS_PATTERN_TYPE_MISMATCH: c_int = 14;
pub const CAIRO_STATUS_INVALID_CONTENT: c_int = 15;
pub const CAIRO_STATUS_INVALID_FORMAT: c_int = 16;
pub const CAIRO_STATUS_INVALID_VISUAL: c_int = 17;
pub const CAIRO_STATUS_FILE_NOT_FOUND: c_int = 18;
pub const CAIRO_STATUS_INVALID_DASH: c_int = 19;
pub const CAIRO_STATUS_INVALID_DSC_COMMENT: c_int = 20;
pub const CAIRO_STATUS_INVALID_INDEX: c_int = 21;
pub const CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: c_int = 22;
pub const CAIRO_STATUS_TEMP_FILE_ERROR: c_int = 23;
pub const CAIRO_STATUS_INVALID_STRIDE: c_int = 24;
pub const CAIRO_STATUS_FONT_TYPE_MISMATCH: c_int = 25;
pub const CAIRO_STATUS_USER_FONT_IMMUTABLE: c_int = 26;
pub const CAIRO_STATUS_USER_FONT_ERROR: c_int = 27;
pub const CAIRO_STATUS_NEGATIVE_COUNT: c_int = 28;
pub const CAIRO_STATUS_INVALID_CLUSTERS: c_int = 29;
pub const CAIRO_STATUS_INVALID_SLANT: c_int = 30;
pub const CAIRO_STATUS_INVALID_WEIGHT: c_int = 31;
pub const CAIRO_STATUS_INVALID_SIZE: c_int = 32;
pub const CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: c_int = 33;
pub const CAIRO_STATUS_DEVICE_TYPE_MISMATCH: c_int = 34;
pub const CAIRO_STATUS_DEVICE_ERROR: c_int = 35;
pub const CAIRO_STATUS_INVALID_MESH_CONSTRUCTION: c_int = 36;
pub const CAIRO_STATUS_DEVICE_FINISHED: c_int = 37;
pub const CAIRO_STATUS_JBIG2_GLOBAL_MISSING: c_int = 38;
pub const CAIRO_STATUS_PNG_ERROR: c_int = 39;
pub const CAIRO_STATUS_FREETYPE_ERROR: c_int = 40;
pub const CAIRO_STATUS_WIN32_GDI_ERROR: c_int = 41;
pub const CAIRO_STATUS_TAG_ERROR: c_int = 42;
pub const CAIRO_STATUS_DWRITE_ERROR: c_int = 43;
pub const CAIRO_STATUS_SVG_FONT_ERROR: c_int = 44;
pub const CAIRO_STATUS_LAST_STATUS: c_int = 45;
pub const enum__cairo_status = c_uint;
pub const cairo_status_t = enum__cairo_status;
pub const CAIRO_CONTENT_COLOR: c_int = 4096;
pub const CAIRO_CONTENT_ALPHA: c_int = 8192;
pub const CAIRO_CONTENT_COLOR_ALPHA: c_int = 12288;
pub const enum__cairo_content = c_uint;
pub const cairo_content_t = enum__cairo_content;
pub const CAIRO_FORMAT_INVALID: c_int = -1;
pub const CAIRO_FORMAT_ARGB32: c_int = 0;
pub const CAIRO_FORMAT_RGB24: c_int = 1;
pub const CAIRO_FORMAT_A8: c_int = 2;
pub const CAIRO_FORMAT_A1: c_int = 3;
pub const CAIRO_FORMAT_RGB16_565: c_int = 4;
pub const CAIRO_FORMAT_RGB30: c_int = 5;
pub const CAIRO_FORMAT_RGB96F: c_int = 6;
pub const CAIRO_FORMAT_RGBA128F: c_int = 7;
pub const enum__cairo_format = c_int;
pub const cairo_format_t = enum__cairo_format;
pub const CAIRO_DITHER_NONE: c_int = 0;
pub const CAIRO_DITHER_DEFAULT: c_int = 1;
pub const CAIRO_DITHER_FAST: c_int = 2;
pub const CAIRO_DITHER_GOOD: c_int = 3;
pub const CAIRO_DITHER_BEST: c_int = 4;
pub const enum__cairo_dither = c_uint;
pub const cairo_dither_t = enum__cairo_dither;
pub extern fn cairo_pattern_set_dither(pattern: ?*cairo_pattern_t, dither: cairo_dither_t) void;
pub extern fn cairo_pattern_get_dither(pattern: ?*cairo_pattern_t) cairo_dither_t;
pub const cairo_write_func_t = ?*const fn (?*anyopaque, [*c]const u8, c_uint) callconv(.C) cairo_status_t;
pub const cairo_read_func_t = ?*const fn (?*anyopaque, [*c]u8, c_uint) callconv(.C) cairo_status_t;
pub const struct__cairo_rectangle_int = extern struct {
    x: c_int,
    y: c_int,
    width: c_int,
    height: c_int,
};
pub const cairo_rectangle_int_t = struct__cairo_rectangle_int;
pub extern fn cairo_create(target: ?*cairo_surface_t) ?*cairo_t;
pub extern fn cairo_reference(cr: ?*cairo_t) ?*cairo_t;
pub extern fn cairo_destroy(cr: ?*cairo_t) void;
pub extern fn cairo_get_reference_count(cr: ?*cairo_t) c_uint;
pub extern fn cairo_get_user_data(cr: ?*cairo_t, key: [*c]const cairo_user_data_key_t) ?*anyopaque;
pub extern fn cairo_set_user_data(cr: ?*cairo_t, key: [*c]const cairo_user_data_key_t, user_data: ?*anyopaque, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_save(cr: ?*cairo_t) void;
pub extern fn cairo_restore(cr: ?*cairo_t) void;
pub extern fn cairo_push_group(cr: ?*cairo_t) void;
pub extern fn cairo_push_group_with_content(cr: ?*cairo_t, content: cairo_content_t) void;
pub extern fn cairo_pop_group(cr: ?*cairo_t) ?*cairo_pattern_t;
pub extern fn cairo_pop_group_to_source(cr: ?*cairo_t) void;
pub const CAIRO_OPERATOR_CLEAR: c_int = 0;
pub const CAIRO_OPERATOR_SOURCE: c_int = 1;
pub const CAIRO_OPERATOR_OVER: c_int = 2;
pub const CAIRO_OPERATOR_IN: c_int = 3;
pub const CAIRO_OPERATOR_OUT: c_int = 4;
pub const CAIRO_OPERATOR_ATOP: c_int = 5;
pub const CAIRO_OPERATOR_DEST: c_int = 6;
pub const CAIRO_OPERATOR_DEST_OVER: c_int = 7;
pub const CAIRO_OPERATOR_DEST_IN: c_int = 8;
pub const CAIRO_OPERATOR_DEST_OUT: c_int = 9;
pub const CAIRO_OPERATOR_DEST_ATOP: c_int = 10;
pub const CAIRO_OPERATOR_XOR: c_int = 11;
pub const CAIRO_OPERATOR_ADD: c_int = 12;
pub const CAIRO_OPERATOR_SATURATE: c_int = 13;
pub const CAIRO_OPERATOR_MULTIPLY: c_int = 14;
pub const CAIRO_OPERATOR_SCREEN: c_int = 15;
pub const CAIRO_OPERATOR_OVERLAY: c_int = 16;
pub const CAIRO_OPERATOR_DARKEN: c_int = 17;
pub const CAIRO_OPERATOR_LIGHTEN: c_int = 18;
pub const CAIRO_OPERATOR_COLOR_DODGE: c_int = 19;
pub const CAIRO_OPERATOR_COLOR_BURN: c_int = 20;
pub const CAIRO_OPERATOR_HARD_LIGHT: c_int = 21;
pub const CAIRO_OPERATOR_SOFT_LIGHT: c_int = 22;
pub const CAIRO_OPERATOR_DIFFERENCE: c_int = 23;
pub const CAIRO_OPERATOR_EXCLUSION: c_int = 24;
pub const CAIRO_OPERATOR_HSL_HUE: c_int = 25;
pub const CAIRO_OPERATOR_HSL_SATURATION: c_int = 26;
pub const CAIRO_OPERATOR_HSL_COLOR: c_int = 27;
pub const CAIRO_OPERATOR_HSL_LUMINOSITY: c_int = 28;
pub const enum__cairo_operator = c_uint;
pub const cairo_operator_t = enum__cairo_operator;
pub extern fn cairo_set_operator(cr: ?*cairo_t, op: cairo_operator_t) void;
pub extern fn cairo_set_source(cr: ?*cairo_t, source: ?*cairo_pattern_t) void;
pub extern fn cairo_set_source_rgb(cr: ?*cairo_t, red: f64, green: f64, blue: f64) void;
pub extern fn cairo_set_source_rgba(cr: ?*cairo_t, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_set_source_surface(cr: ?*cairo_t, surface: ?*cairo_surface_t, x: f64, y: f64) void;
pub extern fn cairo_set_tolerance(cr: ?*cairo_t, tolerance: f64) void;
pub const CAIRO_ANTIALIAS_DEFAULT: c_int = 0;
pub const CAIRO_ANTIALIAS_NONE: c_int = 1;
pub const CAIRO_ANTIALIAS_GRAY: c_int = 2;
pub const CAIRO_ANTIALIAS_SUBPIXEL: c_int = 3;
pub const CAIRO_ANTIALIAS_FAST: c_int = 4;
pub const CAIRO_ANTIALIAS_GOOD: c_int = 5;
pub const CAIRO_ANTIALIAS_BEST: c_int = 6;
pub const enum__cairo_antialias = c_uint;
pub const cairo_antialias_t = enum__cairo_antialias;
pub extern fn cairo_set_antialias(cr: ?*cairo_t, antialias: cairo_antialias_t) void;
pub const CAIRO_FILL_RULE_WINDING: c_int = 0;
pub const CAIRO_FILL_RULE_EVEN_ODD: c_int = 1;
pub const enum__cairo_fill_rule = c_uint;
pub const cairo_fill_rule_t = enum__cairo_fill_rule;
pub extern fn cairo_set_fill_rule(cr: ?*cairo_t, fill_rule: cairo_fill_rule_t) void;
pub extern fn cairo_set_line_width(cr: ?*cairo_t, width: f64) void;
pub extern fn cairo_set_hairline(cr: ?*cairo_t, set_hairline: cairo_bool_t) void;
pub const CAIRO_LINE_CAP_BUTT: c_int = 0;
pub const CAIRO_LINE_CAP_ROUND: c_int = 1;
pub const CAIRO_LINE_CAP_SQUARE: c_int = 2;
pub const enum__cairo_line_cap = c_uint;
pub const cairo_line_cap_t = enum__cairo_line_cap;
pub extern fn cairo_set_line_cap(cr: ?*cairo_t, line_cap: cairo_line_cap_t) void;
pub const CAIRO_LINE_JOIN_MITER: c_int = 0;
pub const CAIRO_LINE_JOIN_ROUND: c_int = 1;
pub const CAIRO_LINE_JOIN_BEVEL: c_int = 2;
pub const enum__cairo_line_join = c_uint;
pub const cairo_line_join_t = enum__cairo_line_join;
pub extern fn cairo_set_line_join(cr: ?*cairo_t, line_join: cairo_line_join_t) void;
pub extern fn cairo_set_dash(cr: ?*cairo_t, dashes: [*c]const f64, num_dashes: c_int, offset: f64) void;
pub extern fn cairo_set_miter_limit(cr: ?*cairo_t, limit: f64) void;
pub extern fn cairo_translate(cr: ?*cairo_t, tx: f64, ty: f64) void;
pub extern fn cairo_scale(cr: ?*cairo_t, sx: f64, sy: f64) void;
pub extern fn cairo_rotate(cr: ?*cairo_t, angle: f64) void;
pub extern fn cairo_transform(cr: ?*cairo_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_set_matrix(cr: ?*cairo_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_identity_matrix(cr: ?*cairo_t) void;
pub extern fn cairo_user_to_device(cr: ?*cairo_t, x: [*c]f64, y: [*c]f64) void;
pub extern fn cairo_user_to_device_distance(cr: ?*cairo_t, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn cairo_device_to_user(cr: ?*cairo_t, x: [*c]f64, y: [*c]f64) void;
pub extern fn cairo_device_to_user_distance(cr: ?*cairo_t, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn cairo_new_path(cr: ?*cairo_t) void;
pub extern fn cairo_move_to(cr: ?*cairo_t, x: f64, y: f64) void;
pub extern fn cairo_new_sub_path(cr: ?*cairo_t) void;
pub extern fn cairo_line_to(cr: ?*cairo_t, x: f64, y: f64) void;
pub extern fn cairo_curve_to(cr: ?*cairo_t, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64) void;
pub extern fn cairo_arc(cr: ?*cairo_t, xc: f64, yc: f64, radius: f64, angle1: f64, angle2: f64) void;
pub extern fn cairo_arc_negative(cr: ?*cairo_t, xc: f64, yc: f64, radius: f64, angle1: f64, angle2: f64) void;
pub extern fn cairo_rel_move_to(cr: ?*cairo_t, dx: f64, dy: f64) void;
pub extern fn cairo_rel_line_to(cr: ?*cairo_t, dx: f64, dy: f64) void;
pub extern fn cairo_rel_curve_to(cr: ?*cairo_t, dx1: f64, dy1: f64, dx2: f64, dy2: f64, dx3: f64, dy3: f64) void;
pub extern fn cairo_rectangle(cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn cairo_close_path(cr: ?*cairo_t) void;
pub extern fn cairo_path_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub extern fn cairo_paint(cr: ?*cairo_t) void;
pub extern fn cairo_paint_with_alpha(cr: ?*cairo_t, alpha: f64) void;
pub extern fn cairo_mask(cr: ?*cairo_t, pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_mask_surface(cr: ?*cairo_t, surface: ?*cairo_surface_t, surface_x: f64, surface_y: f64) void;
pub extern fn cairo_stroke(cr: ?*cairo_t) void;
pub extern fn cairo_stroke_preserve(cr: ?*cairo_t) void;
pub extern fn cairo_fill(cr: ?*cairo_t) void;
pub extern fn cairo_fill_preserve(cr: ?*cairo_t) void;
pub extern fn cairo_copy_page(cr: ?*cairo_t) void;
pub extern fn cairo_show_page(cr: ?*cairo_t) void;
pub extern fn cairo_in_stroke(cr: ?*cairo_t, x: f64, y: f64) cairo_bool_t;
pub extern fn cairo_in_fill(cr: ?*cairo_t, x: f64, y: f64) cairo_bool_t;
pub extern fn cairo_in_clip(cr: ?*cairo_t, x: f64, y: f64) cairo_bool_t;
pub extern fn cairo_stroke_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub extern fn cairo_fill_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub extern fn cairo_reset_clip(cr: ?*cairo_t) void;
pub extern fn cairo_clip(cr: ?*cairo_t) void;
pub extern fn cairo_clip_preserve(cr: ?*cairo_t) void;
pub extern fn cairo_clip_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub const struct__cairo_rectangle = extern struct {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
};
pub const cairo_rectangle_t = struct__cairo_rectangle;
pub const struct__cairo_rectangle_list = extern struct {
    status: cairo_status_t,
    rectangles: [*c]cairo_rectangle_t,
    num_rectangles: c_int,
};
pub const cairo_rectangle_list_t = struct__cairo_rectangle_list;
pub extern fn cairo_copy_clip_rectangle_list(cr: ?*cairo_t) [*c]cairo_rectangle_list_t;
pub extern fn cairo_rectangle_list_destroy(rectangle_list: [*c]cairo_rectangle_list_t) void;
pub extern fn cairo_tag_begin(cr: ?*cairo_t, tag_name: [*c]const u8, attributes: [*c]const u8) void;
pub extern fn cairo_tag_end(cr: ?*cairo_t, tag_name: [*c]const u8) void;
pub const struct__cairo_scaled_font = opaque {};
pub const cairo_scaled_font_t = struct__cairo_scaled_font;
pub const struct__cairo_font_face = opaque {};
pub const cairo_font_face_t = struct__cairo_font_face;
pub const cairo_glyph_t = extern struct {
    index: c_ulong,
    x: f64,
    y: f64,
};
pub extern fn cairo_glyph_allocate(num_glyphs: c_int) [*c]cairo_glyph_t;
pub extern fn cairo_glyph_free(glyphs: [*c]cairo_glyph_t) void;
pub const cairo_text_cluster_t = extern struct {
    num_bytes: c_int,
    num_glyphs: c_int,
};
pub extern fn cairo_text_cluster_allocate(num_clusters: c_int) [*c]cairo_text_cluster_t;
pub extern fn cairo_text_cluster_free(clusters: [*c]cairo_text_cluster_t) void;
pub const CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: c_int = 1;
pub const enum__cairo_text_cluster_flags = c_uint;
pub const cairo_text_cluster_flags_t = enum__cairo_text_cluster_flags;
pub const cairo_text_extents_t = extern struct {
    x_bearing: f64,
    y_bearing: f64,
    width: f64,
    height: f64,
    x_advance: f64,
    y_advance: f64,
};
pub const cairo_font_extents_t = extern struct {
    ascent: f64,
    descent: f64,
    height: f64,
    max_x_advance: f64,
    max_y_advance: f64,
};
pub const CAIRO_FONT_SLANT_NORMAL: c_int = 0;
pub const CAIRO_FONT_SLANT_ITALIC: c_int = 1;
pub const CAIRO_FONT_SLANT_OBLIQUE: c_int = 2;
pub const enum__cairo_font_slant = c_uint;
pub const cairo_font_slant_t = enum__cairo_font_slant;
pub const CAIRO_FONT_WEIGHT_NORMAL: c_int = 0;
pub const CAIRO_FONT_WEIGHT_BOLD: c_int = 1;
pub const enum__cairo_font_weight = c_uint;
pub const cairo_font_weight_t = enum__cairo_font_weight;
pub const CAIRO_SUBPIXEL_ORDER_DEFAULT: c_int = 0;
pub const CAIRO_SUBPIXEL_ORDER_RGB: c_int = 1;
pub const CAIRO_SUBPIXEL_ORDER_BGR: c_int = 2;
pub const CAIRO_SUBPIXEL_ORDER_VRGB: c_int = 3;
pub const CAIRO_SUBPIXEL_ORDER_VBGR: c_int = 4;
pub const enum__cairo_subpixel_order = c_uint;
pub const cairo_subpixel_order_t = enum__cairo_subpixel_order;
pub const CAIRO_HINT_STYLE_DEFAULT: c_int = 0;
pub const CAIRO_HINT_STYLE_NONE: c_int = 1;
pub const CAIRO_HINT_STYLE_SLIGHT: c_int = 2;
pub const CAIRO_HINT_STYLE_MEDIUM: c_int = 3;
pub const CAIRO_HINT_STYLE_FULL: c_int = 4;
pub const enum__cairo_hint_style = c_uint;
pub const cairo_hint_style_t = enum__cairo_hint_style;
pub const CAIRO_HINT_METRICS_DEFAULT: c_int = 0;
pub const CAIRO_HINT_METRICS_OFF: c_int = 1;
pub const CAIRO_HINT_METRICS_ON: c_int = 2;
pub const enum__cairo_hint_metrics = c_uint;
pub const cairo_hint_metrics_t = enum__cairo_hint_metrics;
pub const CAIRO_COLOR_MODE_DEFAULT: c_int = 0;
pub const CAIRO_COLOR_MODE_NO_COLOR: c_int = 1;
pub const CAIRO_COLOR_MODE_COLOR: c_int = 2;
pub const enum__cairo_color_mode = c_uint;
pub const cairo_color_mode_t = enum__cairo_color_mode;
pub const struct__cairo_font_options = opaque {};
pub const cairo_font_options_t = struct__cairo_font_options;
pub extern fn cairo_font_options_create() ?*cairo_font_options_t;
pub extern fn cairo_font_options_copy(original: ?*const cairo_font_options_t) ?*cairo_font_options_t;
pub extern fn cairo_font_options_destroy(options: ?*cairo_font_options_t) void;
pub extern fn cairo_font_options_status(options: ?*cairo_font_options_t) cairo_status_t;
pub extern fn cairo_font_options_merge(options: ?*cairo_font_options_t, other: ?*const cairo_font_options_t) void;
pub extern fn cairo_font_options_equal(options: ?*const cairo_font_options_t, other: ?*const cairo_font_options_t) cairo_bool_t;
pub extern fn cairo_font_options_hash(options: ?*const cairo_font_options_t) c_ulong;
pub extern fn cairo_font_options_set_antialias(options: ?*cairo_font_options_t, antialias: cairo_antialias_t) void;
pub extern fn cairo_font_options_get_antialias(options: ?*const cairo_font_options_t) cairo_antialias_t;
pub extern fn cairo_font_options_set_subpixel_order(options: ?*cairo_font_options_t, subpixel_order: cairo_subpixel_order_t) void;
pub extern fn cairo_font_options_get_subpixel_order(options: ?*const cairo_font_options_t) cairo_subpixel_order_t;
pub extern fn cairo_font_options_set_hint_style(options: ?*cairo_font_options_t, hint_style: cairo_hint_style_t) void;
pub extern fn cairo_font_options_get_hint_style(options: ?*const cairo_font_options_t) cairo_hint_style_t;
pub extern fn cairo_font_options_set_hint_metrics(options: ?*cairo_font_options_t, hint_metrics: cairo_hint_metrics_t) void;
pub extern fn cairo_font_options_get_hint_metrics(options: ?*const cairo_font_options_t) cairo_hint_metrics_t;
pub extern fn cairo_font_options_get_variations(options: ?*cairo_font_options_t) [*c]const u8;
pub extern fn cairo_font_options_set_variations(options: ?*cairo_font_options_t, variations: [*c]const u8) void;
pub extern fn cairo_font_options_set_color_mode(options: ?*cairo_font_options_t, color_mode: cairo_color_mode_t) void;
pub extern fn cairo_font_options_get_color_mode(options: ?*const cairo_font_options_t) cairo_color_mode_t;
pub extern fn cairo_font_options_get_color_palette(options: ?*const cairo_font_options_t) c_uint;
pub extern fn cairo_font_options_set_color_palette(options: ?*cairo_font_options_t, palette_index: c_uint) void;
pub extern fn cairo_font_options_set_custom_palette_color(options: ?*cairo_font_options_t, index: c_uint, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_font_options_get_custom_palette_color(options: ?*cairo_font_options_t, index: c_uint, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_select_font_face(cr: ?*cairo_t, family: [*c]const u8, slant: cairo_font_slant_t, weight: cairo_font_weight_t) void;
pub extern fn cairo_set_font_size(cr: ?*cairo_t, size: f64) void;
pub extern fn cairo_set_font_matrix(cr: ?*cairo_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_get_font_matrix(cr: ?*cairo_t, matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_set_font_options(cr: ?*cairo_t, options: ?*const cairo_font_options_t) void;
pub extern fn cairo_get_font_options(cr: ?*cairo_t, options: ?*cairo_font_options_t) void;
pub extern fn cairo_set_font_face(cr: ?*cairo_t, font_face: ?*cairo_font_face_t) void;
pub extern fn cairo_get_font_face(cr: ?*cairo_t) ?*cairo_font_face_t;
pub extern fn cairo_set_scaled_font(cr: ?*cairo_t, scaled_font: ?*const cairo_scaled_font_t) void;
pub extern fn cairo_get_scaled_font(cr: ?*cairo_t) ?*cairo_scaled_font_t;
pub extern fn cairo_show_text(cr: ?*cairo_t, utf8: [*c]const u8) void;
pub extern fn cairo_show_glyphs(cr: ?*cairo_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int) void;
pub extern fn cairo_show_text_glyphs(cr: ?*cairo_t, utf8: [*c]const u8, utf8_len: c_int, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int, clusters: [*c]const cairo_text_cluster_t, num_clusters: c_int, cluster_flags: cairo_text_cluster_flags_t) void;
pub extern fn cairo_text_path(cr: ?*cairo_t, utf8: [*c]const u8) void;
pub extern fn cairo_glyph_path(cr: ?*cairo_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int) void;
pub extern fn cairo_text_extents(cr: ?*cairo_t, utf8: [*c]const u8, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_glyph_extents(cr: ?*cairo_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_font_extents(cr: ?*cairo_t, extents: [*c]cairo_font_extents_t) void;
pub extern fn cairo_font_face_reference(font_face: ?*cairo_font_face_t) ?*cairo_font_face_t;
pub extern fn cairo_font_face_destroy(font_face: ?*cairo_font_face_t) void;
pub extern fn cairo_font_face_get_reference_count(font_face: ?*cairo_font_face_t) c_uint;
pub extern fn cairo_font_face_status(font_face: ?*cairo_font_face_t) cairo_status_t;
pub const CAIRO_FONT_TYPE_TOY: c_int = 0;
pub const CAIRO_FONT_TYPE_FT: c_int = 1;
pub const CAIRO_FONT_TYPE_WIN32: c_int = 2;
pub const CAIRO_FONT_TYPE_QUARTZ: c_int = 3;
pub const CAIRO_FONT_TYPE_USER: c_int = 4;
pub const CAIRO_FONT_TYPE_DWRITE: c_int = 5;
pub const enum__cairo_font_type = c_uint;
pub const cairo_font_type_t = enum__cairo_font_type;
pub extern fn cairo_font_face_get_type(font_face: ?*cairo_font_face_t) cairo_font_type_t;
pub extern fn cairo_font_face_get_user_data(font_face: ?*cairo_font_face_t, key: [*c]const cairo_user_data_key_t) ?*anyopaque;
pub extern fn cairo_font_face_set_user_data(font_face: ?*cairo_font_face_t, key: [*c]const cairo_user_data_key_t, user_data: ?*anyopaque, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_scaled_font_create(font_face: ?*cairo_font_face_t, font_matrix: [*c]const cairo_matrix_t, ctm: [*c]const cairo_matrix_t, options: ?*const cairo_font_options_t) ?*cairo_scaled_font_t;
pub extern fn cairo_scaled_font_reference(scaled_font: ?*cairo_scaled_font_t) ?*cairo_scaled_font_t;
pub extern fn cairo_scaled_font_destroy(scaled_font: ?*cairo_scaled_font_t) void;
pub extern fn cairo_scaled_font_get_reference_count(scaled_font: ?*cairo_scaled_font_t) c_uint;
pub extern fn cairo_scaled_font_status(scaled_font: ?*cairo_scaled_font_t) cairo_status_t;
pub extern fn cairo_scaled_font_get_type(scaled_font: ?*cairo_scaled_font_t) cairo_font_type_t;
pub extern fn cairo_scaled_font_get_user_data(scaled_font: ?*cairo_scaled_font_t, key: [*c]const cairo_user_data_key_t) ?*anyopaque;
pub extern fn cairo_scaled_font_set_user_data(scaled_font: ?*cairo_scaled_font_t, key: [*c]const cairo_user_data_key_t, user_data: ?*anyopaque, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_scaled_font_extents(scaled_font: ?*cairo_scaled_font_t, extents: [*c]cairo_font_extents_t) void;
pub extern fn cairo_scaled_font_text_extents(scaled_font: ?*cairo_scaled_font_t, utf8: [*c]const u8, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_scaled_font_glyph_extents(scaled_font: ?*cairo_scaled_font_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_scaled_font_text_to_glyphs(scaled_font: ?*cairo_scaled_font_t, x: f64, y: f64, utf8: [*c]const u8, utf8_len: c_int, glyphs: [*c][*c]cairo_glyph_t, num_glyphs: [*c]c_int, clusters: [*c][*c]cairo_text_cluster_t, num_clusters: [*c]c_int, cluster_flags: [*c]cairo_text_cluster_flags_t) cairo_status_t;
pub extern fn cairo_scaled_font_get_font_face(scaled_font: ?*cairo_scaled_font_t) ?*cairo_font_face_t;
pub extern fn cairo_scaled_font_get_font_matrix(scaled_font: ?*cairo_scaled_font_t, font_matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_scaled_font_get_ctm(scaled_font: ?*cairo_scaled_font_t, ctm: [*c]cairo_matrix_t) void;
pub extern fn cairo_scaled_font_get_scale_matrix(scaled_font: ?*cairo_scaled_font_t, scale_matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_scaled_font_get_font_options(scaled_font: ?*cairo_scaled_font_t, options: ?*cairo_font_options_t) void;
pub extern fn cairo_toy_font_face_create(family: [*c]const u8, slant: cairo_font_slant_t, weight: cairo_font_weight_t) ?*cairo_font_face_t;
pub extern fn cairo_toy_font_face_get_family(font_face: ?*cairo_font_face_t) [*c]const u8;
pub extern fn cairo_toy_font_face_get_slant(font_face: ?*cairo_font_face_t) cairo_font_slant_t;
pub extern fn cairo_toy_font_face_get_weight(font_face: ?*cairo_font_face_t) cairo_font_weight_t;
pub extern fn cairo_user_font_face_create() ?*cairo_font_face_t;
pub const cairo_user_scaled_font_init_func_t = ?*const fn (?*cairo_scaled_font_t, ?*cairo_t, [*c]cairo_font_extents_t) callconv(.C) cairo_status_t;
pub const cairo_user_scaled_font_render_glyph_func_t = ?*const fn (?*cairo_scaled_font_t, c_ulong, ?*cairo_t, [*c]cairo_text_extents_t) callconv(.C) cairo_status_t;
pub const cairo_user_scaled_font_text_to_glyphs_func_t = ?*const fn (?*cairo_scaled_font_t, [*c]const u8, c_int, [*c][*c]cairo_glyph_t, [*c]c_int, [*c][*c]cairo_text_cluster_t, [*c]c_int, [*c]cairo_text_cluster_flags_t) callconv(.C) cairo_status_t;
pub const cairo_user_scaled_font_unicode_to_glyph_func_t = ?*const fn (?*cairo_scaled_font_t, c_ulong, [*c]c_ulong) callconv(.C) cairo_status_t;
pub extern fn cairo_user_font_face_set_init_func(font_face: ?*cairo_font_face_t, init_func: cairo_user_scaled_font_init_func_t) void;
pub extern fn cairo_user_font_face_set_render_glyph_func(font_face: ?*cairo_font_face_t, render_glyph_func: cairo_user_scaled_font_render_glyph_func_t) void;
pub extern fn cairo_user_font_face_set_render_color_glyph_func(font_face: ?*cairo_font_face_t, render_glyph_func: cairo_user_scaled_font_render_glyph_func_t) void;
pub extern fn cairo_user_font_face_set_text_to_glyphs_func(font_face: ?*cairo_font_face_t, text_to_glyphs_func: cairo_user_scaled_font_text_to_glyphs_func_t) void;
pub extern fn cairo_user_font_face_set_unicode_to_glyph_func(font_face: ?*cairo_font_face_t, unicode_to_glyph_func: cairo_user_scaled_font_unicode_to_glyph_func_t) void;
pub extern fn cairo_user_font_face_get_init_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_init_func_t;
pub extern fn cairo_user_font_face_get_render_glyph_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_render_glyph_func_t;
pub extern fn cairo_user_font_face_get_render_color_glyph_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_render_glyph_func_t;
pub extern fn cairo_user_font_face_get_text_to_glyphs_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_text_to_glyphs_func_t;
pub extern fn cairo_user_font_face_get_unicode_to_glyph_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_unicode_to_glyph_func_t;
pub extern fn cairo_user_scaled_font_get_foreground_marker(scaled_font: ?*cairo_scaled_font_t) ?*cairo_pattern_t;
pub extern fn cairo_user_scaled_font_get_foreground_source(scaled_font: ?*cairo_scaled_font_t) ?*cairo_pattern_t;
pub extern fn cairo_get_operator(cr: ?*cairo_t) cairo_operator_t;
pub extern fn cairo_get_source(cr: ?*cairo_t) ?*cairo_pattern_t;
pub extern fn cairo_get_tolerance(cr: ?*cairo_t) f64;
pub extern fn cairo_get_antialias(cr: ?*cairo_t) cairo_antialias_t;
pub extern fn cairo_has_current_point(cr: ?*cairo_t) cairo_bool_t;
pub extern fn cairo_get_current_point(cr: ?*cairo_t, x: [*c]f64, y: [*c]f64) void;
pub extern fn cairo_get_fill_rule(cr: ?*cairo_t) cairo_fill_rule_t;
pub extern fn cairo_get_line_width(cr: ?*cairo_t) f64;
pub extern fn cairo_get_hairline(cr: ?*cairo_t) cairo_bool_t;
pub extern fn cairo_get_line_cap(cr: ?*cairo_t) cairo_line_cap_t;
pub extern fn cairo_get_line_join(cr: ?*cairo_t) cairo_line_join_t;
pub extern fn cairo_get_miter_limit(cr: ?*cairo_t) f64;
pub extern fn cairo_get_dash_count(cr: ?*cairo_t) c_int;
pub extern fn cairo_get_dash(cr: ?*cairo_t, dashes: [*c]f64, offset: [*c]f64) void;
pub extern fn cairo_get_matrix(cr: ?*cairo_t, matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_get_target(cr: ?*cairo_t) ?*cairo_surface_t;
pub extern fn cairo_get_group_target(cr: ?*cairo_t) ?*cairo_surface_t;
pub const CAIRO_PATH_MOVE_TO: c_int = 0;
pub const CAIRO_PATH_LINE_TO: c_int = 1;
pub const CAIRO_PATH_CURVE_TO: c_int = 2;
pub const CAIRO_PATH_CLOSE_PATH: c_int = 3;
pub const enum__cairo_path_data_type = c_uint;
pub const cairo_path_data_type_t = enum__cairo_path_data_type;
const struct_unnamed_48 = extern struct {
    type: cairo_path_data_type_t,
    length: c_int,
};
const struct_unnamed_49 = extern struct {
    x: f64,
    y: f64,
};
pub const union__cairo_path_data_t = extern union {
    header: struct_unnamed_48,
    point: struct_unnamed_49,
};
pub const cairo_path_data_t = union__cairo_path_data_t;
pub const struct_cairo_path = extern struct {
    status: cairo_status_t,
    data: [*c]cairo_path_data_t,
    num_data: c_int,
};
pub const cairo_path_t = struct_cairo_path;
pub extern fn cairo_copy_path(cr: ?*cairo_t) [*c]cairo_path_t;
pub extern fn cairo_copy_path_flat(cr: ?*cairo_t) [*c]cairo_path_t;
pub extern fn cairo_append_path(cr: ?*cairo_t, path: [*c]const cairo_path_t) void;
pub extern fn cairo_path_destroy(path: [*c]cairo_path_t) void;
pub extern fn cairo_status(cr: ?*cairo_t) cairo_status_t;
pub extern fn cairo_status_to_string(status: cairo_status_t) [*c]const u8;
pub extern fn cairo_device_reference(device: ?*cairo_device_t) ?*cairo_device_t;
pub const CAIRO_DEVICE_TYPE_DRM: c_int = 0;
pub const CAIRO_DEVICE_TYPE_GL: c_int = 1;
pub const CAIRO_DEVICE_TYPE_SCRIPT: c_int = 2;
pub const CAIRO_DEVICE_TYPE_XCB: c_int = 3;
pub const CAIRO_DEVICE_TYPE_XLIB: c_int = 4;
pub const CAIRO_DEVICE_TYPE_XML: c_int = 5;
pub const CAIRO_DEVICE_TYPE_COGL: c_int = 6;
pub const CAIRO_DEVICE_TYPE_WIN32: c_int = 7;
pub const CAIRO_DEVICE_TYPE_INVALID: c_int = -1;
pub const enum__cairo_device_type = c_int;
pub const cairo_device_type_t = enum__cairo_device_type;
pub extern fn cairo_device_get_type(device: ?*cairo_device_t) cairo_device_type_t;
pub extern fn cairo_device_status(device: ?*cairo_device_t) cairo_status_t;
pub extern fn cairo_device_acquire(device: ?*cairo_device_t) cairo_status_t;
pub extern fn cairo_device_release(device: ?*cairo_device_t) void;
pub extern fn cairo_device_flush(device: ?*cairo_device_t) void;
pub extern fn cairo_device_finish(device: ?*cairo_device_t) void;
pub extern fn cairo_device_destroy(device: ?*cairo_device_t) void;
pub extern fn cairo_device_get_reference_count(device: ?*cairo_device_t) c_uint;
pub extern fn cairo_device_get_user_data(device: ?*cairo_device_t, key: [*c]const cairo_user_data_key_t) ?*anyopaque;
pub extern fn cairo_device_set_user_data(device: ?*cairo_device_t, key: [*c]const cairo_user_data_key_t, user_data: ?*anyopaque, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_surface_create_similar(other: ?*cairo_surface_t, content: cairo_content_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn cairo_surface_create_similar_image(other: ?*cairo_surface_t, format: cairo_format_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn cairo_surface_map_to_image(surface: ?*cairo_surface_t, extents: [*c]const cairo_rectangle_int_t) ?*cairo_surface_t;
pub extern fn cairo_surface_unmap_image(surface: ?*cairo_surface_t, image: ?*cairo_surface_t) void;
pub extern fn cairo_surface_create_for_rectangle(target: ?*cairo_surface_t, x: f64, y: f64, width: f64, height: f64) ?*cairo_surface_t;
pub const CAIRO_SURFACE_OBSERVER_NORMAL: c_int = 0;
pub const CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS: c_int = 1;
pub const cairo_surface_observer_mode_t = c_uint;
pub extern fn cairo_surface_create_observer(target: ?*cairo_surface_t, mode: cairo_surface_observer_mode_t) ?*cairo_surface_t;
pub const cairo_surface_observer_callback_t = ?*const fn (?*cairo_surface_t, ?*cairo_surface_t, ?*anyopaque) callconv(.C) void;
pub extern fn cairo_surface_observer_add_paint_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_add_mask_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_add_fill_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_add_stroke_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_add_glyphs_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_add_flush_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_add_finish_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_print(abstract_surface: ?*cairo_surface_t, write_func: cairo_write_func_t, closure: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_observer_elapsed(abstract_surface: ?*cairo_surface_t) f64;
pub extern fn cairo_device_observer_print(abstract_device: ?*cairo_device_t, write_func: cairo_write_func_t, closure: ?*anyopaque) cairo_status_t;
pub extern fn cairo_device_observer_elapsed(abstract_device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_paint_elapsed(abstract_device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_mask_elapsed(abstract_device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_fill_elapsed(abstract_device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_stroke_elapsed(abstract_device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_glyphs_elapsed(abstract_device: ?*cairo_device_t) f64;
pub extern fn cairo_surface_reference(surface: ?*cairo_surface_t) ?*cairo_surface_t;
pub extern fn cairo_surface_finish(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_destroy(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_get_device(surface: ?*cairo_surface_t) ?*cairo_device_t;
pub extern fn cairo_surface_get_reference_count(surface: ?*cairo_surface_t) c_uint;
pub extern fn cairo_surface_status(surface: ?*cairo_surface_t) cairo_status_t;
pub const CAIRO_SURFACE_TYPE_IMAGE: c_int = 0;
pub const CAIRO_SURFACE_TYPE_PDF: c_int = 1;
pub const CAIRO_SURFACE_TYPE_PS: c_int = 2;
pub const CAIRO_SURFACE_TYPE_XLIB: c_int = 3;
pub const CAIRO_SURFACE_TYPE_XCB: c_int = 4;
pub const CAIRO_SURFACE_TYPE_GLITZ: c_int = 5;
pub const CAIRO_SURFACE_TYPE_QUARTZ: c_int = 6;
pub const CAIRO_SURFACE_TYPE_WIN32: c_int = 7;
pub const CAIRO_SURFACE_TYPE_BEOS: c_int = 8;
pub const CAIRO_SURFACE_TYPE_DIRECTFB: c_int = 9;
pub const CAIRO_SURFACE_TYPE_SVG: c_int = 10;
pub const CAIRO_SURFACE_TYPE_OS2: c_int = 11;
pub const CAIRO_SURFACE_TYPE_WIN32_PRINTING: c_int = 12;
pub const CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: c_int = 13;
pub const CAIRO_SURFACE_TYPE_SCRIPT: c_int = 14;
pub const CAIRO_SURFACE_TYPE_QT: c_int = 15;
pub const CAIRO_SURFACE_TYPE_RECORDING: c_int = 16;
pub const CAIRO_SURFACE_TYPE_VG: c_int = 17;
pub const CAIRO_SURFACE_TYPE_GL: c_int = 18;
pub const CAIRO_SURFACE_TYPE_DRM: c_int = 19;
pub const CAIRO_SURFACE_TYPE_TEE: c_int = 20;
pub const CAIRO_SURFACE_TYPE_XML: c_int = 21;
pub const CAIRO_SURFACE_TYPE_SKIA: c_int = 22;
pub const CAIRO_SURFACE_TYPE_SUBSURFACE: c_int = 23;
pub const CAIRO_SURFACE_TYPE_COGL: c_int = 24;
pub const enum__cairo_surface_type = c_uint;
pub const cairo_surface_type_t = enum__cairo_surface_type;
pub extern fn cairo_surface_get_type(surface: ?*cairo_surface_t) cairo_surface_type_t;
pub extern fn cairo_surface_get_content(surface: ?*cairo_surface_t) cairo_content_t;
pub extern fn cairo_surface_write_to_png(surface: ?*cairo_surface_t, filename: [*c]const u8) cairo_status_t;
pub extern fn cairo_surface_write_to_png_stream(surface: ?*cairo_surface_t, write_func: cairo_write_func_t, closure: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_get_user_data(surface: ?*cairo_surface_t, key: [*c]const cairo_user_data_key_t) ?*anyopaque;
pub extern fn cairo_surface_set_user_data(surface: ?*cairo_surface_t, key: [*c]const cairo_user_data_key_t, user_data: ?*anyopaque, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_surface_get_mime_data(surface: ?*cairo_surface_t, mime_type: [*c]const u8, data: [*c][*c]const u8, length: [*c]c_ulong) void;
pub extern fn cairo_surface_set_mime_data(surface: ?*cairo_surface_t, mime_type: [*c]const u8, data: [*c]const u8, length: c_ulong, destroy: cairo_destroy_func_t, closure: ?*anyopaque) cairo_status_t;
pub extern fn cairo_surface_supports_mime_type(surface: ?*cairo_surface_t, mime_type: [*c]const u8) cairo_bool_t;
pub extern fn cairo_surface_get_font_options(surface: ?*cairo_surface_t, options: ?*cairo_font_options_t) void;
pub extern fn cairo_surface_flush(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_mark_dirty(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_mark_dirty_rectangle(surface: ?*cairo_surface_t, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn cairo_surface_set_device_scale(surface: ?*cairo_surface_t, x_scale: f64, y_scale: f64) void;
pub extern fn cairo_surface_get_device_scale(surface: ?*cairo_surface_t, x_scale: [*c]f64, y_scale: [*c]f64) void;
pub extern fn cairo_surface_set_device_offset(surface: ?*cairo_surface_t, x_offset: f64, y_offset: f64) void;
pub extern fn cairo_surface_get_device_offset(surface: ?*cairo_surface_t, x_offset: [*c]f64, y_offset: [*c]f64) void;
pub extern fn cairo_surface_set_fallback_resolution(surface: ?*cairo_surface_t, x_pixels_per_inch: f64, y_pixels_per_inch: f64) void;
pub extern fn cairo_surface_get_fallback_resolution(surface: ?*cairo_surface_t, x_pixels_per_inch: [*c]f64, y_pixels_per_inch: [*c]f64) void;
pub extern fn cairo_surface_copy_page(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_show_page(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_has_show_text_glyphs(surface: ?*cairo_surface_t) cairo_bool_t;
pub extern fn cairo_image_surface_create(format: cairo_format_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn cairo_format_stride_for_width(format: cairo_format_t, width: c_int) c_int;
pub extern fn cairo_image_surface_create_for_data(data: [*c]u8, format: cairo_format_t, width: c_int, height: c_int, stride: c_int) ?*cairo_surface_t;
pub extern fn cairo_image_surface_get_data(surface: ?*cairo_surface_t) [*c]u8;
pub extern fn cairo_image_surface_get_format(surface: ?*cairo_surface_t) cairo_format_t;
pub extern fn cairo_image_surface_get_width(surface: ?*cairo_surface_t) c_int;
pub extern fn cairo_image_surface_get_height(surface: ?*cairo_surface_t) c_int;
pub extern fn cairo_image_surface_get_stride(surface: ?*cairo_surface_t) c_int;
pub extern fn cairo_image_surface_create_from_png(filename: [*c]const u8) ?*cairo_surface_t;
pub extern fn cairo_image_surface_create_from_png_stream(read_func: cairo_read_func_t, closure: ?*anyopaque) ?*cairo_surface_t;
pub extern fn cairo_recording_surface_create(content: cairo_content_t, extents: [*c]const cairo_rectangle_t) ?*cairo_surface_t;
pub extern fn cairo_recording_surface_ink_extents(surface: ?*cairo_surface_t, x0: [*c]f64, y0: [*c]f64, width: [*c]f64, height: [*c]f64) void;
pub extern fn cairo_recording_surface_get_extents(surface: ?*cairo_surface_t, extents: [*c]cairo_rectangle_t) cairo_bool_t;
pub const cairo_raster_source_acquire_func_t = ?*const fn (?*cairo_pattern_t, ?*anyopaque, ?*cairo_surface_t, [*c]const cairo_rectangle_int_t) callconv(.C) ?*cairo_surface_t;
pub const cairo_raster_source_release_func_t = ?*const fn (?*cairo_pattern_t, ?*anyopaque, ?*cairo_surface_t) callconv(.C) void;
pub const cairo_raster_source_snapshot_func_t = ?*const fn (?*cairo_pattern_t, ?*anyopaque) callconv(.C) cairo_status_t;
pub const cairo_raster_source_copy_func_t = ?*const fn (?*cairo_pattern_t, ?*anyopaque, ?*const cairo_pattern_t) callconv(.C) cairo_status_t;
pub const cairo_raster_source_finish_func_t = ?*const fn (?*cairo_pattern_t, ?*anyopaque) callconv(.C) void;
pub extern fn cairo_pattern_create_raster_source(user_data: ?*anyopaque, content: cairo_content_t, width: c_int, height: c_int) ?*cairo_pattern_t;
pub extern fn cairo_raster_source_pattern_set_callback_data(pattern: ?*cairo_pattern_t, data: ?*anyopaque) void;
pub extern fn cairo_raster_source_pattern_get_callback_data(pattern: ?*cairo_pattern_t) ?*anyopaque;
pub extern fn cairo_raster_source_pattern_set_acquire(pattern: ?*cairo_pattern_t, acquire: cairo_raster_source_acquire_func_t, release: cairo_raster_source_release_func_t) void;
pub extern fn cairo_raster_source_pattern_get_acquire(pattern: ?*cairo_pattern_t, acquire: [*c]cairo_raster_source_acquire_func_t, release: [*c]cairo_raster_source_release_func_t) void;
pub extern fn cairo_raster_source_pattern_set_snapshot(pattern: ?*cairo_pattern_t, snapshot: cairo_raster_source_snapshot_func_t) void;
pub extern fn cairo_raster_source_pattern_get_snapshot(pattern: ?*cairo_pattern_t) cairo_raster_source_snapshot_func_t;
pub extern fn cairo_raster_source_pattern_set_copy(pattern: ?*cairo_pattern_t, copy: cairo_raster_source_copy_func_t) void;
pub extern fn cairo_raster_source_pattern_get_copy(pattern: ?*cairo_pattern_t) cairo_raster_source_copy_func_t;
pub extern fn cairo_raster_source_pattern_set_finish(pattern: ?*cairo_pattern_t, finish: cairo_raster_source_finish_func_t) void;
pub extern fn cairo_raster_source_pattern_get_finish(pattern: ?*cairo_pattern_t) cairo_raster_source_finish_func_t;
pub extern fn cairo_pattern_create_rgb(red: f64, green: f64, blue: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_rgba(red: f64, green: f64, blue: f64, alpha: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_for_surface(surface: ?*cairo_surface_t) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_linear(x0: f64, y0: f64, x1: f64, y1: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_radial(cx0: f64, cy0: f64, radius0: f64, cx1: f64, cy1: f64, radius1: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_mesh() ?*cairo_pattern_t;
pub extern fn cairo_pattern_reference(pattern: ?*cairo_pattern_t) ?*cairo_pattern_t;
pub extern fn cairo_pattern_destroy(pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_pattern_get_reference_count(pattern: ?*cairo_pattern_t) c_uint;
pub extern fn cairo_pattern_status(pattern: ?*cairo_pattern_t) cairo_status_t;
pub extern fn cairo_pattern_get_user_data(pattern: ?*cairo_pattern_t, key: [*c]const cairo_user_data_key_t) ?*anyopaque;
pub extern fn cairo_pattern_set_user_data(pattern: ?*cairo_pattern_t, key: [*c]const cairo_user_data_key_t, user_data: ?*anyopaque, destroy: cairo_destroy_func_t) cairo_status_t;
pub const CAIRO_PATTERN_TYPE_SOLID: c_int = 0;
pub const CAIRO_PATTERN_TYPE_SURFACE: c_int = 1;
pub const CAIRO_PATTERN_TYPE_LINEAR: c_int = 2;
pub const CAIRO_PATTERN_TYPE_RADIAL: c_int = 3;
pub const CAIRO_PATTERN_TYPE_MESH: c_int = 4;
pub const CAIRO_PATTERN_TYPE_RASTER_SOURCE: c_int = 5;
pub const enum__cairo_pattern_type = c_uint;
pub const cairo_pattern_type_t = enum__cairo_pattern_type;
pub extern fn cairo_pattern_get_type(pattern: ?*cairo_pattern_t) cairo_pattern_type_t;
pub extern fn cairo_pattern_add_color_stop_rgb(pattern: ?*cairo_pattern_t, offset: f64, red: f64, green: f64, blue: f64) void;
pub extern fn cairo_pattern_add_color_stop_rgba(pattern: ?*cairo_pattern_t, offset: f64, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_mesh_pattern_begin_patch(pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_mesh_pattern_end_patch(pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_mesh_pattern_curve_to(pattern: ?*cairo_pattern_t, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64) void;
pub extern fn cairo_mesh_pattern_line_to(pattern: ?*cairo_pattern_t, x: f64, y: f64) void;
pub extern fn cairo_mesh_pattern_move_to(pattern: ?*cairo_pattern_t, x: f64, y: f64) void;
pub extern fn cairo_mesh_pattern_set_control_point(pattern: ?*cairo_pattern_t, point_num: c_uint, x: f64, y: f64) void;
pub extern fn cairo_mesh_pattern_set_corner_color_rgb(pattern: ?*cairo_pattern_t, corner_num: c_uint, red: f64, green: f64, blue: f64) void;
pub extern fn cairo_mesh_pattern_set_corner_color_rgba(pattern: ?*cairo_pattern_t, corner_num: c_uint, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_pattern_set_matrix(pattern: ?*cairo_pattern_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_pattern_get_matrix(pattern: ?*cairo_pattern_t, matrix: [*c]cairo_matrix_t) void;
pub const CAIRO_EXTEND_NONE: c_int = 0;
pub const CAIRO_EXTEND_REPEAT: c_int = 1;
pub const CAIRO_EXTEND_REFLECT: c_int = 2;
pub const CAIRO_EXTEND_PAD: c_int = 3;
pub const enum__cairo_extend = c_uint;
pub const cairo_extend_t = enum__cairo_extend;
pub extern fn cairo_pattern_set_extend(pattern: ?*cairo_pattern_t, extend: cairo_extend_t) void;
pub extern fn cairo_pattern_get_extend(pattern: ?*cairo_pattern_t) cairo_extend_t;
pub const CAIRO_FILTER_FAST: c_int = 0;
pub const CAIRO_FILTER_GOOD: c_int = 1;
pub const CAIRO_FILTER_BEST: c_int = 2;
pub const CAIRO_FILTER_NEAREST: c_int = 3;
pub const CAIRO_FILTER_BILINEAR: c_int = 4;
pub const CAIRO_FILTER_GAUSSIAN: c_int = 5;
pub const enum__cairo_filter = c_uint;
pub const cairo_filter_t = enum__cairo_filter;
pub extern fn cairo_pattern_set_filter(pattern: ?*cairo_pattern_t, filter: cairo_filter_t) void;
pub extern fn cairo_pattern_get_filter(pattern: ?*cairo_pattern_t) cairo_filter_t;
pub extern fn cairo_pattern_get_rgba(pattern: ?*cairo_pattern_t, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_pattern_get_surface(pattern: ?*cairo_pattern_t, surface: [*c]?*cairo_surface_t) cairo_status_t;
pub extern fn cairo_pattern_get_color_stop_rgba(pattern: ?*cairo_pattern_t, index: c_int, offset: [*c]f64, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_pattern_get_color_stop_count(pattern: ?*cairo_pattern_t, count: [*c]c_int) cairo_status_t;
pub extern fn cairo_pattern_get_linear_points(pattern: ?*cairo_pattern_t, x0: [*c]f64, y0: [*c]f64, x1: [*c]f64, y1: [*c]f64) cairo_status_t;
pub extern fn cairo_pattern_get_radial_circles(pattern: ?*cairo_pattern_t, x0: [*c]f64, y0: [*c]f64, r0: [*c]f64, x1: [*c]f64, y1: [*c]f64, r1: [*c]f64) cairo_status_t;
pub extern fn cairo_mesh_pattern_get_patch_count(pattern: ?*cairo_pattern_t, count: [*c]c_uint) cairo_status_t;
pub extern fn cairo_mesh_pattern_get_path(pattern: ?*cairo_pattern_t, patch_num: c_uint) [*c]cairo_path_t;
pub extern fn cairo_mesh_pattern_get_corner_color_rgba(pattern: ?*cairo_pattern_t, patch_num: c_uint, corner_num: c_uint, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_mesh_pattern_get_control_point(pattern: ?*cairo_pattern_t, patch_num: c_uint, point_num: c_uint, x: [*c]f64, y: [*c]f64) cairo_status_t;
pub extern fn cairo_matrix_init(matrix: [*c]cairo_matrix_t, xx: f64, yx: f64, xy: f64, yy: f64, x0: f64, y0: f64) void;
pub extern fn cairo_matrix_init_identity(matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_matrix_init_translate(matrix: [*c]cairo_matrix_t, tx: f64, ty: f64) void;
pub extern fn cairo_matrix_init_scale(matrix: [*c]cairo_matrix_t, sx: f64, sy: f64) void;
pub extern fn cairo_matrix_init_rotate(matrix: [*c]cairo_matrix_t, radians: f64) void;
pub extern fn cairo_matrix_translate(matrix: [*c]cairo_matrix_t, tx: f64, ty: f64) void;
pub extern fn cairo_matrix_scale(matrix: [*c]cairo_matrix_t, sx: f64, sy: f64) void;
pub extern fn cairo_matrix_rotate(matrix: [*c]cairo_matrix_t, radians: f64) void;
pub extern fn cairo_matrix_invert(matrix: [*c]cairo_matrix_t) cairo_status_t;
pub extern fn cairo_matrix_multiply(result: [*c]cairo_matrix_t, a: [*c]const cairo_matrix_t, b: [*c]const cairo_matrix_t) void;
pub extern fn cairo_matrix_transform_distance(matrix: [*c]const cairo_matrix_t, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn cairo_matrix_transform_point(matrix: [*c]const cairo_matrix_t, x: [*c]f64, y: [*c]f64) void;
pub const struct__cairo_region = opaque {};
pub const cairo_region_t = struct__cairo_region;
pub const CAIRO_REGION_OVERLAP_IN: c_int = 0;
pub const CAIRO_REGION_OVERLAP_OUT: c_int = 1;
pub const CAIRO_REGION_OVERLAP_PART: c_int = 2;
pub const enum__cairo_region_overlap = c_uint;
pub const cairo_region_overlap_t = enum__cairo_region_overlap;
pub extern fn cairo_region_create() ?*cairo_region_t;
pub extern fn cairo_region_create_rectangle(rectangle: [*c]const cairo_rectangle_int_t) ?*cairo_region_t;
pub extern fn cairo_region_create_rectangles(rects: [*c]const cairo_rectangle_int_t, count: c_int) ?*cairo_region_t;
pub extern fn cairo_region_copy(original: ?*const cairo_region_t) ?*cairo_region_t;
pub extern fn cairo_region_reference(region: ?*cairo_region_t) ?*cairo_region_t;
pub extern fn cairo_region_destroy(region: ?*cairo_region_t) void;
pub extern fn cairo_region_equal(a: ?*const cairo_region_t, b: ?*const cairo_region_t) cairo_bool_t;
pub extern fn cairo_region_status(region: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_get_extents(region: ?*const cairo_region_t, extents: [*c]cairo_rectangle_int_t) void;
pub extern fn cairo_region_num_rectangles(region: ?*const cairo_region_t) c_int;
pub extern fn cairo_region_get_rectangle(region: ?*const cairo_region_t, nth: c_int, rectangle: [*c]cairo_rectangle_int_t) void;
pub extern fn cairo_region_is_empty(region: ?*const cairo_region_t) cairo_bool_t;
pub extern fn cairo_region_contains_rectangle(region: ?*const cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_region_overlap_t;
pub extern fn cairo_region_contains_point(region: ?*const cairo_region_t, x: c_int, y: c_int) cairo_bool_t;
pub extern fn cairo_region_translate(region: ?*cairo_region_t, dx: c_int, dy: c_int) void;
pub extern fn cairo_region_subtract(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_subtract_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_region_intersect(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_intersect_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_region_union(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_union_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_region_xor(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_xor_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_debug_reset_static_data() void;
pub const int_least8_t = __int_least8_t;
pub const int_least16_t = __int_least16_t;
pub const int_least32_t = __int_least32_t;
pub const int_least64_t = __int_least64_t;
pub const uint_least8_t = __uint_least8_t;
pub const uint_least16_t = __uint_least16_t;
pub const uint_least32_t = __uint_least32_t;
pub const uint_least64_t = __uint_least64_t;
pub const int_fast8_t = i8;
pub const int_fast16_t = c_long;
pub const int_fast32_t = c_long;
pub const int_fast64_t = c_long;
pub const uint_fast8_t = u8;
pub const uint_fast16_t = c_ulong;
pub const uint_fast32_t = c_ulong;
pub const uint_fast64_t = c_ulong;
pub const intmax_t = __intmax_t;
pub const uintmax_t = __uintmax_t;
pub const hb_bool_t = c_int;
pub const hb_codepoint_t = u32;
pub const hb_position_t = i32;
pub const hb_mask_t = u32;
pub const union__hb_var_int_t = extern union {
    u32: u32,
    i32: i32,
    u16: [2]u16,
    i16: [2]i16,
    u8: [4]u8,
    i8: [4]i8,
};
pub const hb_var_int_t = union__hb_var_int_t;
pub const union__hb_var_num_t = extern union {
    f: f32,
    u32: u32,
    i32: i32,
    u16: [2]u16,
    i16: [2]i16,
    u8: [4]u8,
    i8: [4]i8,
};
pub const hb_var_num_t = union__hb_var_num_t;
pub const hb_tag_t = u32;
pub extern fn hb_tag_from_string(str: [*c]const u8, len: c_int) hb_tag_t;
pub extern fn hb_tag_to_string(tag: hb_tag_t, buf: [*c]u8) void;
pub const HB_DIRECTION_INVALID: c_int = 0;
pub const HB_DIRECTION_LTR: c_int = 4;
pub const HB_DIRECTION_RTL: c_int = 5;
pub const HB_DIRECTION_TTB: c_int = 6;
pub const HB_DIRECTION_BTT: c_int = 7;
pub const hb_direction_t = c_uint;
pub extern fn hb_direction_from_string(str: [*c]const u8, len: c_int) hb_direction_t;
pub extern fn hb_direction_to_string(direction: hb_direction_t) [*c]const u8;
pub const struct_hb_language_impl_t = opaque {};
pub const hb_language_t = ?*const struct_hb_language_impl_t;
pub extern fn hb_language_from_string(str: [*c]const u8, len: c_int) hb_language_t;
pub extern fn hb_language_to_string(language: hb_language_t) [*c]const u8;
pub extern fn hb_language_get_default() hb_language_t;
pub extern fn hb_language_matches(language: hb_language_t, specific: hb_language_t) hb_bool_t;
pub const HB_SCRIPT_COMMON: c_int = 1517910393;
pub const HB_SCRIPT_INHERITED: c_int = 1516858984;
pub const HB_SCRIPT_UNKNOWN: c_int = 1517976186;
pub const HB_SCRIPT_ARABIC: c_int = 1098015074;
pub const HB_SCRIPT_ARMENIAN: c_int = 1098018158;
pub const HB_SCRIPT_BENGALI: c_int = 1113943655;
pub const HB_SCRIPT_CYRILLIC: c_int = 1132032620;
pub const HB_SCRIPT_DEVANAGARI: c_int = 1147500129;
pub const HB_SCRIPT_GEORGIAN: c_int = 1197830002;
pub const HB_SCRIPT_GREEK: c_int = 1198679403;
pub const HB_SCRIPT_GUJARATI: c_int = 1198877298;
pub const HB_SCRIPT_GURMUKHI: c_int = 1198879349;
pub const HB_SCRIPT_HANGUL: c_int = 1214344807;
pub const HB_SCRIPT_HAN: c_int = 1214344809;
pub const HB_SCRIPT_HEBREW: c_int = 1214603890;
pub const HB_SCRIPT_HIRAGANA: c_int = 1214870113;
pub const HB_SCRIPT_KANNADA: c_int = 1265525857;
pub const HB_SCRIPT_KATAKANA: c_int = 1264676449;
pub const HB_SCRIPT_LAO: c_int = 1281453935;
pub const HB_SCRIPT_LATIN: c_int = 1281455214;
pub const HB_SCRIPT_MALAYALAM: c_int = 1298954605;
pub const HB_SCRIPT_ORIYA: c_int = 1332902241;
pub const HB_SCRIPT_TAMIL: c_int = 1415671148;
pub const HB_SCRIPT_TELUGU: c_int = 1415933045;
pub const HB_SCRIPT_THAI: c_int = 1416126825;
pub const HB_SCRIPT_TIBETAN: c_int = 1416192628;
pub const HB_SCRIPT_BOPOMOFO: c_int = 1114599535;
pub const HB_SCRIPT_BRAILLE: c_int = 1114792297;
pub const HB_SCRIPT_CANADIAN_SYLLABICS: c_int = 1130458739;
pub const HB_SCRIPT_CHEROKEE: c_int = 1130915186;
pub const HB_SCRIPT_ETHIOPIC: c_int = 1165256809;
pub const HB_SCRIPT_KHMER: c_int = 1265134962;
pub const HB_SCRIPT_MONGOLIAN: c_int = 1299148391;
pub const HB_SCRIPT_MYANMAR: c_int = 1299803506;
pub const HB_SCRIPT_OGHAM: c_int = 1332175213;
pub const HB_SCRIPT_RUNIC: c_int = 1383427698;
pub const HB_SCRIPT_SINHALA: c_int = 1399418472;
pub const HB_SCRIPT_SYRIAC: c_int = 1400468067;
pub const HB_SCRIPT_THAANA: c_int = 1416126817;
pub const HB_SCRIPT_YI: c_int = 1500080489;
pub const HB_SCRIPT_DESERET: c_int = 1148416628;
pub const HB_SCRIPT_GOTHIC: c_int = 1198486632;
pub const HB_SCRIPT_OLD_ITALIC: c_int = 1232363884;
pub const HB_SCRIPT_BUHID: c_int = 1114990692;
pub const HB_SCRIPT_HANUNOO: c_int = 1214344815;
pub const HB_SCRIPT_TAGALOG: c_int = 1416064103;
pub const HB_SCRIPT_TAGBANWA: c_int = 1415669602;
pub const HB_SCRIPT_CYPRIOT: c_int = 1131442804;
pub const HB_SCRIPT_LIMBU: c_int = 1281977698;
pub const HB_SCRIPT_LINEAR_B: c_int = 1281977954;
pub const HB_SCRIPT_OSMANYA: c_int = 1332964705;
pub const HB_SCRIPT_SHAVIAN: c_int = 1399349623;
pub const HB_SCRIPT_TAI_LE: c_int = 1415670885;
pub const HB_SCRIPT_UGARITIC: c_int = 1432838514;
pub const HB_SCRIPT_BUGINESE: c_int = 1114990441;
pub const HB_SCRIPT_COPTIC: c_int = 1131376756;
pub const HB_SCRIPT_GLAGOLITIC: c_int = 1198285159;
pub const HB_SCRIPT_KHAROSHTHI: c_int = 1265131890;
pub const HB_SCRIPT_NEW_TAI_LUE: c_int = 1415670901;
pub const HB_SCRIPT_OLD_PERSIAN: c_int = 1483761007;
pub const HB_SCRIPT_SYLOTI_NAGRI: c_int = 1400466543;
pub const HB_SCRIPT_TIFINAGH: c_int = 1415999079;
pub const HB_SCRIPT_BALINESE: c_int = 1113681001;
pub const HB_SCRIPT_CUNEIFORM: c_int = 1483961720;
pub const HB_SCRIPT_NKO: c_int = 1315663727;
pub const HB_SCRIPT_PHAGS_PA: c_int = 1349017959;
pub const HB_SCRIPT_PHOENICIAN: c_int = 1349021304;
pub const HB_SCRIPT_CARIAN: c_int = 1130459753;
pub const HB_SCRIPT_CHAM: c_int = 1130914157;
pub const HB_SCRIPT_KAYAH_LI: c_int = 1264675945;
pub const HB_SCRIPT_LEPCHA: c_int = 1281716323;
pub const HB_SCRIPT_LYCIAN: c_int = 1283023721;
pub const HB_SCRIPT_LYDIAN: c_int = 1283023977;
pub const HB_SCRIPT_OL_CHIKI: c_int = 1332503403;
pub const HB_SCRIPT_REJANG: c_int = 1382706791;
pub const HB_SCRIPT_SAURASHTRA: c_int = 1398895986;
pub const HB_SCRIPT_SUNDANESE: c_int = 1400204900;
pub const HB_SCRIPT_VAI: c_int = 1449224553;
pub const HB_SCRIPT_AVESTAN: c_int = 1098281844;
pub const HB_SCRIPT_BAMUM: c_int = 1113681269;
pub const HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: c_int = 1164409200;
pub const HB_SCRIPT_IMPERIAL_ARAMAIC: c_int = 1098018153;
pub const HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: c_int = 1349020777;
pub const HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: c_int = 1349678185;
pub const HB_SCRIPT_JAVANESE: c_int = 1247901281;
pub const HB_SCRIPT_KAITHI: c_int = 1265920105;
pub const HB_SCRIPT_LISU: c_int = 1281979253;
pub const HB_SCRIPT_MEETEI_MAYEK: c_int = 1299473769;
pub const HB_SCRIPT_OLD_SOUTH_ARABIAN: c_int = 1398895202;
pub const HB_SCRIPT_OLD_TURKIC: c_int = 1332898664;
pub const HB_SCRIPT_SAMARITAN: c_int = 1398893938;
pub const HB_SCRIPT_TAI_THAM: c_int = 1281453665;
pub const HB_SCRIPT_TAI_VIET: c_int = 1415673460;
pub const HB_SCRIPT_BATAK: c_int = 1113683051;
pub const HB_SCRIPT_BRAHMI: c_int = 1114792296;
pub const HB_SCRIPT_MANDAIC: c_int = 1298230884;
pub const HB_SCRIPT_CHAKMA: c_int = 1130457965;
pub const HB_SCRIPT_MEROITIC_CURSIVE: c_int = 1298494051;
pub const HB_SCRIPT_MEROITIC_HIEROGLYPHS: c_int = 1298494063;
pub const HB_SCRIPT_MIAO: c_int = 1349284452;
pub const HB_SCRIPT_SHARADA: c_int = 1399353956;
pub const HB_SCRIPT_SORA_SOMPENG: c_int = 1399812705;
pub const HB_SCRIPT_TAKRI: c_int = 1415670642;
pub const HB_SCRIPT_BASSA_VAH: c_int = 1113682803;
pub const HB_SCRIPT_CAUCASIAN_ALBANIAN: c_int = 1097295970;
pub const HB_SCRIPT_DUPLOYAN: c_int = 1148547180;
pub const HB_SCRIPT_ELBASAN: c_int = 1164730977;
pub const HB_SCRIPT_GRANTHA: c_int = 1198678382;
pub const HB_SCRIPT_KHOJKI: c_int = 1265135466;
pub const HB_SCRIPT_KHUDAWADI: c_int = 1399418468;
pub const HB_SCRIPT_LINEAR_A: c_int = 1281977953;
pub const HB_SCRIPT_MAHAJANI: c_int = 1298229354;
pub const HB_SCRIPT_MANICHAEAN: c_int = 1298230889;
pub const HB_SCRIPT_MENDE_KIKAKUI: c_int = 1298493028;
pub const HB_SCRIPT_MODI: c_int = 1299145833;
pub const HB_SCRIPT_MRO: c_int = 1299345263;
pub const HB_SCRIPT_NABATAEAN: c_int = 1315070324;
pub const HB_SCRIPT_OLD_NORTH_ARABIAN: c_int = 1315009122;
pub const HB_SCRIPT_OLD_PERMIC: c_int = 1348825709;
pub const HB_SCRIPT_PAHAWH_HMONG: c_int = 1215131239;
pub const HB_SCRIPT_PALMYRENE: c_int = 1348562029;
pub const HB_SCRIPT_PAU_CIN_HAU: c_int = 1348564323;
pub const HB_SCRIPT_PSALTER_PAHLAVI: c_int = 1349020784;
pub const HB_SCRIPT_SIDDHAM: c_int = 1399415908;
pub const HB_SCRIPT_TIRHUTA: c_int = 1416196712;
pub const HB_SCRIPT_WARANG_CITI: c_int = 1466004065;
pub const HB_SCRIPT_AHOM: c_int = 1097363309;
pub const HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: c_int = 1215067511;
pub const HB_SCRIPT_HATRAN: c_int = 1214346354;
pub const HB_SCRIPT_MULTANI: c_int = 1299541108;
pub const HB_SCRIPT_OLD_HUNGARIAN: c_int = 1215655527;
pub const HB_SCRIPT_SIGNWRITING: c_int = 1399287415;
pub const HB_SCRIPT_ADLAM: c_int = 1097100397;
pub const HB_SCRIPT_BHAIKSUKI: c_int = 1114139507;
pub const HB_SCRIPT_MARCHEN: c_int = 1298231907;
pub const HB_SCRIPT_OSAGE: c_int = 1332963173;
pub const HB_SCRIPT_TANGUT: c_int = 1415671399;
pub const HB_SCRIPT_NEWA: c_int = 1315272545;
pub const HB_SCRIPT_MASARAM_GONDI: c_int = 1198485101;
pub const HB_SCRIPT_NUSHU: c_int = 1316186229;
pub const HB_SCRIPT_SOYOMBO: c_int = 1399814511;
pub const HB_SCRIPT_ZANABAZAR_SQUARE: c_int = 1516334690;
pub const HB_SCRIPT_DOGRA: c_int = 1148151666;
pub const HB_SCRIPT_GUNJALA_GONDI: c_int = 1198485095;
pub const HB_SCRIPT_HANIFI_ROHINGYA: c_int = 1383032935;
pub const HB_SCRIPT_MAKASAR: c_int = 1298230113;
pub const HB_SCRIPT_MEDEFAIDRIN: c_int = 1298490470;
pub const HB_SCRIPT_OLD_SOGDIAN: c_int = 1399809903;
pub const HB_SCRIPT_SOGDIAN: c_int = 1399809892;
pub const HB_SCRIPT_ELYMAIC: c_int = 1164736877;
pub const HB_SCRIPT_NANDINAGARI: c_int = 1315008100;
pub const HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: c_int = 1215131248;
pub const HB_SCRIPT_WANCHO: c_int = 1466132591;
pub const HB_SCRIPT_CHORASMIAN: c_int = 1130918515;
pub const HB_SCRIPT_DIVES_AKURU: c_int = 1147756907;
pub const HB_SCRIPT_KHITAN_SMALL_SCRIPT: c_int = 1265202291;
pub const HB_SCRIPT_YEZIDI: c_int = 1499822697;
pub const HB_SCRIPT_CYPRO_MINOAN: c_int = 1131441518;
pub const HB_SCRIPT_OLD_UYGHUR: c_int = 1333094258;
pub const HB_SCRIPT_TANGSA: c_int = 1416524641;
pub const HB_SCRIPT_TOTO: c_int = 1416590447;
pub const HB_SCRIPT_VITHKUQI: c_int = 1449751656;
pub const HB_SCRIPT_MATH: c_int = 1517122664;
pub const HB_SCRIPT_KAWI: c_int = 1264678761;
pub const HB_SCRIPT_NAG_MUNDARI: c_int = 1315006317;
pub const HB_SCRIPT_INVALID: c_int = 0;
pub const _HB_SCRIPT_MAX_VALUE: c_int = 2147483647;
pub const _HB_SCRIPT_MAX_VALUE_SIGNED: c_int = 2147483647;
pub const hb_script_t = c_uint;
pub extern fn hb_script_from_iso15924_tag(tag: hb_tag_t) hb_script_t;
pub extern fn hb_script_from_string(str: [*c]const u8, len: c_int) hb_script_t;
pub extern fn hb_script_to_iso15924_tag(script: hb_script_t) hb_tag_t;
pub extern fn hb_script_get_horizontal_direction(script: hb_script_t) hb_direction_t;
pub const struct_hb_user_data_key_t = extern struct {
    unused: u8,
};
pub const hb_user_data_key_t = struct_hb_user_data_key_t;
pub const hb_destroy_func_t = ?*const fn (?*anyopaque) callconv(.C) void;
pub const struct_hb_feature_t = extern struct {
    tag: hb_tag_t,
    value: u32,
    start: c_uint,
    end: c_uint,
};
pub const hb_feature_t = struct_hb_feature_t;
pub extern fn hb_feature_from_string(str: [*c]const u8, len: c_int, feature: [*c]hb_feature_t) hb_bool_t;
pub extern fn hb_feature_to_string(feature: [*c]hb_feature_t, buf: [*c]u8, size: c_uint) void;
pub const struct_hb_variation_t = extern struct {
    tag: hb_tag_t,
    value: f32,
};
pub const hb_variation_t = struct_hb_variation_t;
pub extern fn hb_variation_from_string(str: [*c]const u8, len: c_int, variation: [*c]hb_variation_t) hb_bool_t;
pub extern fn hb_variation_to_string(variation: [*c]hb_variation_t, buf: [*c]u8, size: c_uint) void;
pub const hb_color_t = u32;
pub extern fn hb_color_get_alpha(color: hb_color_t) u8;
pub extern fn hb_color_get_red(color: hb_color_t) u8;
pub extern fn hb_color_get_green(color: hb_color_t) u8;
pub extern fn hb_color_get_blue(color: hb_color_t) u8;
pub const struct_hb_glyph_extents_t = extern struct {
    x_bearing: hb_position_t,
    y_bearing: hb_position_t,
    width: hb_position_t,
    height: hb_position_t,
};
pub const hb_glyph_extents_t = struct_hb_glyph_extents_t;
pub const struct_hb_font_t = opaque {};
pub const hb_font_t = struct_hb_font_t;
pub const HB_MEMORY_MODE_DUPLICATE: c_int = 0;
pub const HB_MEMORY_MODE_READONLY: c_int = 1;
pub const HB_MEMORY_MODE_WRITABLE: c_int = 2;
pub const HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE: c_int = 3;
pub const hb_memory_mode_t = c_uint;
pub const struct_hb_blob_t = opaque {};
pub const hb_blob_t = struct_hb_blob_t;
pub extern fn hb_blob_create(data: [*c]const u8, length: c_uint, mode: hb_memory_mode_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) ?*hb_blob_t;
pub extern fn hb_blob_create_or_fail(data: [*c]const u8, length: c_uint, mode: hb_memory_mode_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) ?*hb_blob_t;
pub extern fn hb_blob_create_from_file(file_name: [*c]const u8) ?*hb_blob_t;
pub extern fn hb_blob_create_from_file_or_fail(file_name: [*c]const u8) ?*hb_blob_t;
pub extern fn hb_blob_create_sub_blob(parent: ?*hb_blob_t, offset: c_uint, length: c_uint) ?*hb_blob_t;
pub extern fn hb_blob_copy_writable_or_fail(blob: ?*hb_blob_t) ?*hb_blob_t;
pub extern fn hb_blob_get_empty() ?*hb_blob_t;
pub extern fn hb_blob_reference(blob: ?*hb_blob_t) ?*hb_blob_t;
pub extern fn hb_blob_destroy(blob: ?*hb_blob_t) void;
pub extern fn hb_blob_set_user_data(blob: ?*hb_blob_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_blob_get_user_data(blob: ?*const hb_blob_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_blob_make_immutable(blob: ?*hb_blob_t) void;
pub extern fn hb_blob_is_immutable(blob: ?*hb_blob_t) hb_bool_t;
pub extern fn hb_blob_get_length(blob: ?*hb_blob_t) c_uint;
pub extern fn hb_blob_get_data(blob: ?*hb_blob_t, length: [*c]c_uint) [*c]const u8;
pub extern fn hb_blob_get_data_writable(blob: ?*hb_blob_t, length: [*c]c_uint) [*c]u8;
pub const HB_UNICODE_GENERAL_CATEGORY_CONTROL: c_int = 0;
pub const HB_UNICODE_GENERAL_CATEGORY_FORMAT: c_int = 1;
pub const HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED: c_int = 2;
pub const HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE: c_int = 3;
pub const HB_UNICODE_GENERAL_CATEGORY_SURROGATE: c_int = 4;
pub const HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER: c_int = 5;
pub const HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER: c_int = 6;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER: c_int = 7;
pub const HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER: c_int = 8;
pub const HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER: c_int = 9;
pub const HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK: c_int = 10;
pub const HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK: c_int = 11;
pub const HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK: c_int = 12;
pub const HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER: c_int = 13;
pub const HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER: c_int = 14;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER: c_int = 15;
pub const HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION: c_int = 16;
pub const HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION: c_int = 17;
pub const HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION: c_int = 18;
pub const HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION: c_int = 19;
pub const HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION: c_int = 20;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION: c_int = 21;
pub const HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION: c_int = 22;
pub const HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL: c_int = 23;
pub const HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL: c_int = 24;
pub const HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL: c_int = 25;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL: c_int = 26;
pub const HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR: c_int = 27;
pub const HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR: c_int = 28;
pub const HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR: c_int = 29;
pub const hb_unicode_general_category_t = c_uint;
pub const HB_UNICODE_COMBINING_CLASS_NOT_REORDERED: c_int = 0;
pub const HB_UNICODE_COMBINING_CLASS_OVERLAY: c_int = 1;
pub const HB_UNICODE_COMBINING_CLASS_NUKTA: c_int = 7;
pub const HB_UNICODE_COMBINING_CLASS_KANA_VOICING: c_int = 8;
pub const HB_UNICODE_COMBINING_CLASS_VIRAMA: c_int = 9;
pub const HB_UNICODE_COMBINING_CLASS_CCC10: c_int = 10;
pub const HB_UNICODE_COMBINING_CLASS_CCC11: c_int = 11;
pub const HB_UNICODE_COMBINING_CLASS_CCC12: c_int = 12;
pub const HB_UNICODE_COMBINING_CLASS_CCC13: c_int = 13;
pub const HB_UNICODE_COMBINING_CLASS_CCC14: c_int = 14;
pub const HB_UNICODE_COMBINING_CLASS_CCC15: c_int = 15;
pub const HB_UNICODE_COMBINING_CLASS_CCC16: c_int = 16;
pub const HB_UNICODE_COMBINING_CLASS_CCC17: c_int = 17;
pub const HB_UNICODE_COMBINING_CLASS_CCC18: c_int = 18;
pub const HB_UNICODE_COMBINING_CLASS_CCC19: c_int = 19;
pub const HB_UNICODE_COMBINING_CLASS_CCC20: c_int = 20;
pub const HB_UNICODE_COMBINING_CLASS_CCC21: c_int = 21;
pub const HB_UNICODE_COMBINING_CLASS_CCC22: c_int = 22;
pub const HB_UNICODE_COMBINING_CLASS_CCC23: c_int = 23;
pub const HB_UNICODE_COMBINING_CLASS_CCC24: c_int = 24;
pub const HB_UNICODE_COMBINING_CLASS_CCC25: c_int = 25;
pub const HB_UNICODE_COMBINING_CLASS_CCC26: c_int = 26;
pub const HB_UNICODE_COMBINING_CLASS_CCC27: c_int = 27;
pub const HB_UNICODE_COMBINING_CLASS_CCC28: c_int = 28;
pub const HB_UNICODE_COMBINING_CLASS_CCC29: c_int = 29;
pub const HB_UNICODE_COMBINING_CLASS_CCC30: c_int = 30;
pub const HB_UNICODE_COMBINING_CLASS_CCC31: c_int = 31;
pub const HB_UNICODE_COMBINING_CLASS_CCC32: c_int = 32;
pub const HB_UNICODE_COMBINING_CLASS_CCC33: c_int = 33;
pub const HB_UNICODE_COMBINING_CLASS_CCC34: c_int = 34;
pub const HB_UNICODE_COMBINING_CLASS_CCC35: c_int = 35;
pub const HB_UNICODE_COMBINING_CLASS_CCC36: c_int = 36;
pub const HB_UNICODE_COMBINING_CLASS_CCC84: c_int = 84;
pub const HB_UNICODE_COMBINING_CLASS_CCC91: c_int = 91;
pub const HB_UNICODE_COMBINING_CLASS_CCC103: c_int = 103;
pub const HB_UNICODE_COMBINING_CLASS_CCC107: c_int = 107;
pub const HB_UNICODE_COMBINING_CLASS_CCC118: c_int = 118;
pub const HB_UNICODE_COMBINING_CLASS_CCC122: c_int = 122;
pub const HB_UNICODE_COMBINING_CLASS_CCC129: c_int = 129;
pub const HB_UNICODE_COMBINING_CLASS_CCC130: c_int = 130;
pub const HB_UNICODE_COMBINING_CLASS_CCC132: c_int = 132;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT: c_int = 200;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW: c_int = 202;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE: c_int = 214;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT: c_int = 216;
pub const HB_UNICODE_COMBINING_CLASS_BELOW_LEFT: c_int = 218;
pub const HB_UNICODE_COMBINING_CLASS_BELOW: c_int = 220;
pub const HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT: c_int = 222;
pub const HB_UNICODE_COMBINING_CLASS_LEFT: c_int = 224;
pub const HB_UNICODE_COMBINING_CLASS_RIGHT: c_int = 226;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT: c_int = 228;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE: c_int = 230;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT: c_int = 232;
pub const HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW: c_int = 233;
pub const HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE: c_int = 234;
pub const HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT: c_int = 240;
pub const HB_UNICODE_COMBINING_CLASS_INVALID: c_int = 255;
pub const hb_unicode_combining_class_t = c_uint;
pub const struct_hb_unicode_funcs_t = opaque {};
pub const hb_unicode_funcs_t = struct_hb_unicode_funcs_t;
pub extern fn hb_unicode_funcs_get_default() ?*hb_unicode_funcs_t;
pub extern fn hb_unicode_funcs_create(parent: ?*hb_unicode_funcs_t) ?*hb_unicode_funcs_t;
pub extern fn hb_unicode_funcs_get_empty() ?*hb_unicode_funcs_t;
pub extern fn hb_unicode_funcs_reference(ufuncs: ?*hb_unicode_funcs_t) ?*hb_unicode_funcs_t;
pub extern fn hb_unicode_funcs_destroy(ufuncs: ?*hb_unicode_funcs_t) void;
pub extern fn hb_unicode_funcs_set_user_data(ufuncs: ?*hb_unicode_funcs_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_unicode_funcs_get_user_data(ufuncs: ?*const hb_unicode_funcs_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_unicode_funcs_make_immutable(ufuncs: ?*hb_unicode_funcs_t) void;
pub extern fn hb_unicode_funcs_is_immutable(ufuncs: ?*hb_unicode_funcs_t) hb_bool_t;
pub extern fn hb_unicode_funcs_get_parent(ufuncs: ?*hb_unicode_funcs_t) ?*hb_unicode_funcs_t;
pub const hb_unicode_combining_class_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, ?*anyopaque) callconv(.C) hb_unicode_combining_class_t;
pub const hb_unicode_general_category_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, ?*anyopaque) callconv(.C) hb_unicode_general_category_t;
pub const hb_unicode_mirroring_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, ?*anyopaque) callconv(.C) hb_codepoint_t;
pub const hb_unicode_script_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, ?*anyopaque) callconv(.C) hb_script_t;
pub const hb_unicode_compose_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, hb_codepoint_t, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_unicode_decompose_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, [*c]hb_codepoint_t, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub extern fn hb_unicode_funcs_set_combining_class_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_combining_class_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_funcs_set_general_category_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_general_category_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_funcs_set_mirroring_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_mirroring_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_funcs_set_script_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_script_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_funcs_set_compose_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_compose_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_funcs_set_decompose_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_decompose_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_combining_class(ufuncs: ?*hb_unicode_funcs_t, unicode: hb_codepoint_t) hb_unicode_combining_class_t;
pub extern fn hb_unicode_general_category(ufuncs: ?*hb_unicode_funcs_t, unicode: hb_codepoint_t) hb_unicode_general_category_t;
pub extern fn hb_unicode_mirroring(ufuncs: ?*hb_unicode_funcs_t, unicode: hb_codepoint_t) hb_codepoint_t;
pub extern fn hb_unicode_script(ufuncs: ?*hb_unicode_funcs_t, unicode: hb_codepoint_t) hb_script_t;
pub extern fn hb_unicode_compose(ufuncs: ?*hb_unicode_funcs_t, a: hb_codepoint_t, b: hb_codepoint_t, ab: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_unicode_decompose(ufuncs: ?*hb_unicode_funcs_t, ab: hb_codepoint_t, a: [*c]hb_codepoint_t, b: [*c]hb_codepoint_t) hb_bool_t;
pub const struct_hb_set_t = opaque {};
pub const hb_set_t = struct_hb_set_t;
pub extern fn hb_set_create() ?*hb_set_t;
pub extern fn hb_set_get_empty() ?*hb_set_t;
pub extern fn hb_set_reference(set: ?*hb_set_t) ?*hb_set_t;
pub extern fn hb_set_destroy(set: ?*hb_set_t) void;
pub extern fn hb_set_set_user_data(set: ?*hb_set_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_set_get_user_data(set: ?*const hb_set_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_set_allocation_successful(set: ?*const hb_set_t) hb_bool_t;
pub extern fn hb_set_copy(set: ?*const hb_set_t) ?*hb_set_t;
pub extern fn hb_set_clear(set: ?*hb_set_t) void;
pub extern fn hb_set_is_empty(set: ?*const hb_set_t) hb_bool_t;
pub extern fn hb_set_invert(set: ?*hb_set_t) void;
pub extern fn hb_set_is_inverted(set: ?*const hb_set_t) hb_bool_t;
pub extern fn hb_set_has(set: ?*const hb_set_t, codepoint: hb_codepoint_t) hb_bool_t;
pub extern fn hb_set_add(set: ?*hb_set_t, codepoint: hb_codepoint_t) void;
pub extern fn hb_set_add_range(set: ?*hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t) void;
pub extern fn hb_set_add_sorted_array(set: ?*hb_set_t, sorted_codepoints: [*c]const hb_codepoint_t, num_codepoints: c_uint) void;
pub extern fn hb_set_del(set: ?*hb_set_t, codepoint: hb_codepoint_t) void;
pub extern fn hb_set_del_range(set: ?*hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t) void;
pub extern fn hb_set_is_equal(set: ?*const hb_set_t, other: ?*const hb_set_t) hb_bool_t;
pub extern fn hb_set_hash(set: ?*const hb_set_t) c_uint;
pub extern fn hb_set_is_subset(set: ?*const hb_set_t, larger_set: ?*const hb_set_t) hb_bool_t;
pub extern fn hb_set_set(set: ?*hb_set_t, other: ?*const hb_set_t) void;
pub extern fn hb_set_union(set: ?*hb_set_t, other: ?*const hb_set_t) void;
pub extern fn hb_set_intersect(set: ?*hb_set_t, other: ?*const hb_set_t) void;
pub extern fn hb_set_subtract(set: ?*hb_set_t, other: ?*const hb_set_t) void;
pub extern fn hb_set_symmetric_difference(set: ?*hb_set_t, other: ?*const hb_set_t) void;
pub extern fn hb_set_get_population(set: ?*const hb_set_t) c_uint;
pub extern fn hb_set_get_min(set: ?*const hb_set_t) hb_codepoint_t;
pub extern fn hb_set_get_max(set: ?*const hb_set_t) hb_codepoint_t;
pub extern fn hb_set_next(set: ?*const hb_set_t, codepoint: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_set_previous(set: ?*const hb_set_t, codepoint: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_set_next_range(set: ?*const hb_set_t, first: [*c]hb_codepoint_t, last: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_set_previous_range(set: ?*const hb_set_t, first: [*c]hb_codepoint_t, last: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_set_next_many(set: ?*const hb_set_t, codepoint: hb_codepoint_t, out: [*c]hb_codepoint_t, size: c_uint) c_uint;
pub const struct_hb_map_t = opaque {};
pub const hb_map_t = struct_hb_map_t;
pub extern fn hb_map_create() ?*hb_map_t;
pub extern fn hb_map_get_empty() ?*hb_map_t;
pub extern fn hb_map_reference(map: ?*hb_map_t) ?*hb_map_t;
pub extern fn hb_map_destroy(map: ?*hb_map_t) void;
pub extern fn hb_map_set_user_data(map: ?*hb_map_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_map_get_user_data(map: ?*const hb_map_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_map_allocation_successful(map: ?*const hb_map_t) hb_bool_t;
pub extern fn hb_map_copy(map: ?*const hb_map_t) ?*hb_map_t;
pub extern fn hb_map_clear(map: ?*hb_map_t) void;
pub extern fn hb_map_is_empty(map: ?*const hb_map_t) hb_bool_t;
pub extern fn hb_map_get_population(map: ?*const hb_map_t) c_uint;
pub extern fn hb_map_is_equal(map: ?*const hb_map_t, other: ?*const hb_map_t) hb_bool_t;
pub extern fn hb_map_hash(map: ?*const hb_map_t) c_uint;
pub extern fn hb_map_set(map: ?*hb_map_t, key: hb_codepoint_t, value: hb_codepoint_t) void;
pub extern fn hb_map_get(map: ?*const hb_map_t, key: hb_codepoint_t) hb_codepoint_t;
pub extern fn hb_map_del(map: ?*hb_map_t, key: hb_codepoint_t) void;
pub extern fn hb_map_has(map: ?*const hb_map_t, key: hb_codepoint_t) hb_bool_t;
pub extern fn hb_map_update(map: ?*hb_map_t, other: ?*const hb_map_t) void;
pub extern fn hb_map_next(map: ?*const hb_map_t, idx: [*c]c_int, key: [*c]hb_codepoint_t, value: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_map_keys(map: ?*const hb_map_t, keys: ?*hb_set_t) void;
pub extern fn hb_map_values(map: ?*const hb_map_t, values: ?*hb_set_t) void;
pub extern fn hb_face_count(blob: ?*hb_blob_t) c_uint;
pub const struct_hb_face_t = opaque {};
pub const hb_face_t = struct_hb_face_t;
pub extern fn hb_face_create(blob: ?*hb_blob_t, index: c_uint) ?*hb_face_t;
pub const hb_reference_table_func_t = ?*const fn (?*hb_face_t, hb_tag_t, ?*anyopaque) callconv(.C) ?*hb_blob_t;
pub extern fn hb_face_create_for_tables(reference_table_func: hb_reference_table_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) ?*hb_face_t;
pub extern fn hb_face_get_empty() ?*hb_face_t;
pub extern fn hb_face_reference(face: ?*hb_face_t) ?*hb_face_t;
pub extern fn hb_face_destroy(face: ?*hb_face_t) void;
pub extern fn hb_face_set_user_data(face: ?*hb_face_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_face_get_user_data(face: ?*const hb_face_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_face_make_immutable(face: ?*hb_face_t) void;
pub extern fn hb_face_is_immutable(face: ?*const hb_face_t) hb_bool_t;
pub extern fn hb_face_reference_table(face: ?*const hb_face_t, tag: hb_tag_t) ?*hb_blob_t;
pub extern fn hb_face_reference_blob(face: ?*hb_face_t) ?*hb_blob_t;
pub extern fn hb_face_set_index(face: ?*hb_face_t, index: c_uint) void;
pub extern fn hb_face_get_index(face: ?*const hb_face_t) c_uint;
pub extern fn hb_face_set_upem(face: ?*hb_face_t, upem: c_uint) void;
pub extern fn hb_face_get_upem(face: ?*const hb_face_t) c_uint;
pub extern fn hb_face_set_glyph_count(face: ?*hb_face_t, glyph_count: c_uint) void;
pub extern fn hb_face_get_glyph_count(face: ?*const hb_face_t) c_uint;
pub extern fn hb_face_get_table_tags(face: ?*const hb_face_t, start_offset: c_uint, table_count: [*c]c_uint, table_tags: [*c]hb_tag_t) c_uint;
pub extern fn hb_face_collect_unicodes(face: ?*hb_face_t, out: ?*hb_set_t) void;
pub extern fn hb_face_collect_nominal_glyph_mapping(face: ?*hb_face_t, mapping: ?*hb_map_t, unicodes: ?*hb_set_t) void;
pub extern fn hb_face_collect_variation_selectors(face: ?*hb_face_t, out: ?*hb_set_t) void;
pub extern fn hb_face_collect_variation_unicodes(face: ?*hb_face_t, variation_selector: hb_codepoint_t, out: ?*hb_set_t) void;
pub extern fn hb_face_builder_create() ?*hb_face_t;
pub extern fn hb_face_builder_add_table(face: ?*hb_face_t, tag: hb_tag_t, blob: ?*hb_blob_t) hb_bool_t;
pub extern fn hb_face_builder_sort_tables(face: ?*hb_face_t, tags: [*c]const hb_tag_t) void;
pub const struct_hb_draw_state_t = extern struct {
    path_open: hb_bool_t,
    path_start_x: f32,
    path_start_y: f32,
    current_x: f32,
    current_y: f32,
    reserved1: hb_var_num_t,
    reserved2: hb_var_num_t,
    reserved3: hb_var_num_t,
    reserved4: hb_var_num_t,
    reserved5: hb_var_num_t,
    reserved6: hb_var_num_t,
    reserved7: hb_var_num_t,
};
pub const hb_draw_state_t = struct_hb_draw_state_t;
pub const struct_hb_draw_funcs_t = opaque {};
pub const hb_draw_funcs_t = struct_hb_draw_funcs_t;
pub const hb_draw_move_to_func_t = ?*const fn (?*hb_draw_funcs_t, ?*anyopaque, [*c]hb_draw_state_t, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_draw_line_to_func_t = ?*const fn (?*hb_draw_funcs_t, ?*anyopaque, [*c]hb_draw_state_t, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_draw_quadratic_to_func_t = ?*const fn (?*hb_draw_funcs_t, ?*anyopaque, [*c]hb_draw_state_t, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_draw_cubic_to_func_t = ?*const fn (?*hb_draw_funcs_t, ?*anyopaque, [*c]hb_draw_state_t, f32, f32, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_draw_close_path_func_t = ?*const fn (?*hb_draw_funcs_t, ?*anyopaque, [*c]hb_draw_state_t, ?*anyopaque) callconv(.C) void;
pub extern fn hb_draw_funcs_set_move_to_func(dfuncs: ?*hb_draw_funcs_t, func: hb_draw_move_to_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_draw_funcs_set_line_to_func(dfuncs: ?*hb_draw_funcs_t, func: hb_draw_line_to_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_draw_funcs_set_quadratic_to_func(dfuncs: ?*hb_draw_funcs_t, func: hb_draw_quadratic_to_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_draw_funcs_set_cubic_to_func(dfuncs: ?*hb_draw_funcs_t, func: hb_draw_cubic_to_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_draw_funcs_set_close_path_func(dfuncs: ?*hb_draw_funcs_t, func: hb_draw_close_path_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_draw_funcs_create() ?*hb_draw_funcs_t;
pub extern fn hb_draw_funcs_get_empty() ?*hb_draw_funcs_t;
pub extern fn hb_draw_funcs_reference(dfuncs: ?*hb_draw_funcs_t) ?*hb_draw_funcs_t;
pub extern fn hb_draw_funcs_destroy(dfuncs: ?*hb_draw_funcs_t) void;
pub extern fn hb_draw_funcs_set_user_data(dfuncs: ?*hb_draw_funcs_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_draw_funcs_get_user_data(dfuncs: ?*const hb_draw_funcs_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_draw_funcs_make_immutable(dfuncs: ?*hb_draw_funcs_t) void;
pub extern fn hb_draw_funcs_is_immutable(dfuncs: ?*hb_draw_funcs_t) hb_bool_t;
pub extern fn hb_draw_move_to(dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque, st: [*c]hb_draw_state_t, to_x: f32, to_y: f32) void;
pub extern fn hb_draw_line_to(dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque, st: [*c]hb_draw_state_t, to_x: f32, to_y: f32) void;
pub extern fn hb_draw_quadratic_to(dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque, st: [*c]hb_draw_state_t, control_x: f32, control_y: f32, to_x: f32, to_y: f32) void;
pub extern fn hb_draw_cubic_to(dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque, st: [*c]hb_draw_state_t, control1_x: f32, control1_y: f32, control2_x: f32, control2_y: f32, to_x: f32, to_y: f32) void;
pub extern fn hb_draw_close_path(dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque, st: [*c]hb_draw_state_t) void;
pub const struct_hb_paint_funcs_t = opaque {};
pub const hb_paint_funcs_t = struct_hb_paint_funcs_t;
pub extern fn hb_paint_funcs_create() ?*hb_paint_funcs_t;
pub extern fn hb_paint_funcs_get_empty() ?*hb_paint_funcs_t;
pub extern fn hb_paint_funcs_reference(funcs: ?*hb_paint_funcs_t) ?*hb_paint_funcs_t;
pub extern fn hb_paint_funcs_destroy(funcs: ?*hb_paint_funcs_t) void;
pub extern fn hb_paint_funcs_set_user_data(funcs: ?*hb_paint_funcs_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_paint_funcs_get_user_data(funcs: ?*const hb_paint_funcs_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_paint_funcs_make_immutable(funcs: ?*hb_paint_funcs_t) void;
pub extern fn hb_paint_funcs_is_immutable(funcs: ?*hb_paint_funcs_t) hb_bool_t;
pub const hb_paint_push_transform_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, f32, f32, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_paint_pop_transform_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, ?*anyopaque) callconv(.C) void;
pub const hb_paint_color_glyph_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, hb_codepoint_t, ?*hb_font_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_paint_push_clip_glyph_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, hb_codepoint_t, ?*hb_font_t, ?*anyopaque) callconv(.C) void;
pub const hb_paint_push_clip_rectangle_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_paint_pop_clip_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, ?*anyopaque) callconv(.C) void;
pub const hb_paint_color_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, hb_bool_t, hb_color_t, ?*anyopaque) callconv(.C) void;
pub const hb_paint_image_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, ?*hb_blob_t, c_uint, c_uint, hb_tag_t, f32, [*c]hb_glyph_extents_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_color_stop_t = extern struct {
    offset: f32,
    is_foreground: hb_bool_t,
    color: hb_color_t,
};
pub const HB_PAINT_EXTEND_PAD: c_int = 0;
pub const HB_PAINT_EXTEND_REPEAT: c_int = 1;
pub const HB_PAINT_EXTEND_REFLECT: c_int = 2;
pub const hb_paint_extend_t = c_uint;
pub const hb_color_line_t = struct_hb_color_line_t;
pub const hb_color_line_get_color_stops_func_t = ?*const fn ([*c]hb_color_line_t, ?*anyopaque, c_uint, [*c]c_uint, [*c]hb_color_stop_t, ?*anyopaque) callconv(.C) c_uint;
pub const hb_color_line_get_extend_func_t = ?*const fn ([*c]hb_color_line_t, ?*anyopaque, ?*anyopaque) callconv(.C) hb_paint_extend_t;
pub const struct_hb_color_line_t = extern struct {
    data: ?*anyopaque,
    get_color_stops: hb_color_line_get_color_stops_func_t,
    get_color_stops_user_data: ?*anyopaque,
    get_extend: hb_color_line_get_extend_func_t,
    get_extend_user_data: ?*anyopaque,
    reserved0: ?*anyopaque,
    reserved1: ?*anyopaque,
    reserved2: ?*anyopaque,
    reserved3: ?*anyopaque,
    reserved5: ?*anyopaque,
    reserved6: ?*anyopaque,
    reserved7: ?*anyopaque,
    reserved8: ?*anyopaque,
};
pub extern fn hb_color_line_get_color_stops(color_line: [*c]hb_color_line_t, start: c_uint, count: [*c]c_uint, color_stops: [*c]hb_color_stop_t) c_uint;
pub extern fn hb_color_line_get_extend(color_line: [*c]hb_color_line_t) hb_paint_extend_t;
pub const hb_paint_linear_gradient_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, [*c]hb_color_line_t, f32, f32, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_paint_radial_gradient_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, [*c]hb_color_line_t, f32, f32, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const hb_paint_sweep_gradient_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, [*c]hb_color_line_t, f32, f32, f32, f32, ?*anyopaque) callconv(.C) void;
pub const HB_PAINT_COMPOSITE_MODE_CLEAR: c_int = 0;
pub const HB_PAINT_COMPOSITE_MODE_SRC: c_int = 1;
pub const HB_PAINT_COMPOSITE_MODE_DEST: c_int = 2;
pub const HB_PAINT_COMPOSITE_MODE_SRC_OVER: c_int = 3;
pub const HB_PAINT_COMPOSITE_MODE_DEST_OVER: c_int = 4;
pub const HB_PAINT_COMPOSITE_MODE_SRC_IN: c_int = 5;
pub const HB_PAINT_COMPOSITE_MODE_DEST_IN: c_int = 6;
pub const HB_PAINT_COMPOSITE_MODE_SRC_OUT: c_int = 7;
pub const HB_PAINT_COMPOSITE_MODE_DEST_OUT: c_int = 8;
pub const HB_PAINT_COMPOSITE_MODE_SRC_ATOP: c_int = 9;
pub const HB_PAINT_COMPOSITE_MODE_DEST_ATOP: c_int = 10;
pub const HB_PAINT_COMPOSITE_MODE_XOR: c_int = 11;
pub const HB_PAINT_COMPOSITE_MODE_PLUS: c_int = 12;
pub const HB_PAINT_COMPOSITE_MODE_SCREEN: c_int = 13;
pub const HB_PAINT_COMPOSITE_MODE_OVERLAY: c_int = 14;
pub const HB_PAINT_COMPOSITE_MODE_DARKEN: c_int = 15;
pub const HB_PAINT_COMPOSITE_MODE_LIGHTEN: c_int = 16;
pub const HB_PAINT_COMPOSITE_MODE_COLOR_DODGE: c_int = 17;
pub const HB_PAINT_COMPOSITE_MODE_COLOR_BURN: c_int = 18;
pub const HB_PAINT_COMPOSITE_MODE_HARD_LIGHT: c_int = 19;
pub const HB_PAINT_COMPOSITE_MODE_SOFT_LIGHT: c_int = 20;
pub const HB_PAINT_COMPOSITE_MODE_DIFFERENCE: c_int = 21;
pub const HB_PAINT_COMPOSITE_MODE_EXCLUSION: c_int = 22;
pub const HB_PAINT_COMPOSITE_MODE_MULTIPLY: c_int = 23;
pub const HB_PAINT_COMPOSITE_MODE_HSL_HUE: c_int = 24;
pub const HB_PAINT_COMPOSITE_MODE_HSL_SATURATION: c_int = 25;
pub const HB_PAINT_COMPOSITE_MODE_HSL_COLOR: c_int = 26;
pub const HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY: c_int = 27;
pub const hb_paint_composite_mode_t = c_uint;
pub const hb_paint_push_group_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, ?*anyopaque) callconv(.C) void;
pub const hb_paint_pop_group_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, hb_paint_composite_mode_t, ?*anyopaque) callconv(.C) void;
pub const hb_paint_custom_palette_color_func_t = ?*const fn (?*hb_paint_funcs_t, ?*anyopaque, c_uint, [*c]hb_color_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub extern fn hb_paint_funcs_set_push_transform_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_push_transform_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_pop_transform_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_pop_transform_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_color_glyph_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_color_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_push_clip_glyph_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_push_clip_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_push_clip_rectangle_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_push_clip_rectangle_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_pop_clip_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_pop_clip_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_color_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_color_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_image_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_image_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_linear_gradient_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_linear_gradient_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_radial_gradient_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_radial_gradient_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_sweep_gradient_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_sweep_gradient_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_push_group_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_push_group_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_pop_group_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_pop_group_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_funcs_set_custom_palette_color_func(funcs: ?*hb_paint_funcs_t, func: hb_paint_custom_palette_color_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_paint_push_transform(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, xx: f32, yx: f32, xy: f32, yy: f32, dx: f32, dy: f32) void;
pub extern fn hb_paint_pop_transform(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque) void;
pub extern fn hb_paint_color_glyph(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, glyph: hb_codepoint_t, font: ?*hb_font_t) hb_bool_t;
pub extern fn hb_paint_push_clip_glyph(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, glyph: hb_codepoint_t, font: ?*hb_font_t) void;
pub extern fn hb_paint_push_clip_rectangle(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, xmin: f32, ymin: f32, xmax: f32, ymax: f32) void;
pub extern fn hb_paint_pop_clip(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque) void;
pub extern fn hb_paint_color(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, is_foreground: hb_bool_t, color: hb_color_t) void;
pub extern fn hb_paint_image(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, image: ?*hb_blob_t, width: c_uint, height: c_uint, format: hb_tag_t, slant: f32, extents: [*c]hb_glyph_extents_t) void;
pub extern fn hb_paint_linear_gradient(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, color_line: [*c]hb_color_line_t, x0: f32, y0: f32, x1: f32, y1: f32, x2: f32, y2: f32) void;
pub extern fn hb_paint_radial_gradient(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, color_line: [*c]hb_color_line_t, x0: f32, y0: f32, r0: f32, x1: f32, y1: f32, r1: f32) void;
pub extern fn hb_paint_sweep_gradient(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, color_line: [*c]hb_color_line_t, x0: f32, y0: f32, start_angle: f32, end_angle: f32) void;
pub extern fn hb_paint_push_group(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque) void;
pub extern fn hb_paint_pop_group(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, mode: hb_paint_composite_mode_t) void;
pub extern fn hb_paint_custom_palette_color(funcs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, color_index: c_uint, color: [*c]hb_color_t) hb_bool_t;
pub const struct_hb_font_funcs_t = opaque {};
pub const hb_font_funcs_t = struct_hb_font_funcs_t;
pub extern fn hb_font_funcs_create() ?*hb_font_funcs_t;
pub extern fn hb_font_funcs_get_empty() ?*hb_font_funcs_t;
pub extern fn hb_font_funcs_reference(ffuncs: ?*hb_font_funcs_t) ?*hb_font_funcs_t;
pub extern fn hb_font_funcs_destroy(ffuncs: ?*hb_font_funcs_t) void;
pub extern fn hb_font_funcs_set_user_data(ffuncs: ?*hb_font_funcs_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_font_funcs_get_user_data(ffuncs: ?*const hb_font_funcs_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_font_funcs_make_immutable(ffuncs: ?*hb_font_funcs_t) void;
pub extern fn hb_font_funcs_is_immutable(ffuncs: ?*hb_font_funcs_t) hb_bool_t;
pub const struct_hb_font_extents_t = extern struct {
    ascender: hb_position_t,
    descender: hb_position_t,
    line_gap: hb_position_t,
    reserved9: hb_position_t,
    reserved8: hb_position_t,
    reserved7: hb_position_t,
    reserved6: hb_position_t,
    reserved5: hb_position_t,
    reserved4: hb_position_t,
    reserved3: hb_position_t,
    reserved2: hb_position_t,
    reserved1: hb_position_t,
};
pub const hb_font_extents_t = struct_hb_font_extents_t;
pub const hb_font_get_font_extents_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, [*c]hb_font_extents_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_font_h_extents_func_t = hb_font_get_font_extents_func_t;
pub const hb_font_get_font_v_extents_func_t = hb_font_get_font_extents_func_t;
pub const hb_font_get_nominal_glyph_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_variation_glyph_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, hb_codepoint_t, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_nominal_glyphs_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, c_uint, [*c]const hb_codepoint_t, c_uint, [*c]hb_codepoint_t, c_uint, ?*anyopaque) callconv(.C) c_uint;
pub const hb_font_get_glyph_advance_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, ?*anyopaque) callconv(.C) hb_position_t;
pub const hb_font_get_glyph_h_advance_func_t = hb_font_get_glyph_advance_func_t;
pub const hb_font_get_glyph_v_advance_func_t = hb_font_get_glyph_advance_func_t;
pub const hb_font_get_glyph_advances_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, c_uint, [*c]const hb_codepoint_t, c_uint, [*c]hb_position_t, c_uint, ?*anyopaque) callconv(.C) void;
pub const hb_font_get_glyph_h_advances_func_t = hb_font_get_glyph_advances_func_t;
pub const hb_font_get_glyph_v_advances_func_t = hb_font_get_glyph_advances_func_t;
pub const hb_font_get_glyph_origin_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, [*c]hb_position_t, [*c]hb_position_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_glyph_h_origin_func_t = hb_font_get_glyph_origin_func_t;
pub const hb_font_get_glyph_v_origin_func_t = hb_font_get_glyph_origin_func_t;
pub const hb_font_get_glyph_kerning_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, hb_codepoint_t, ?*anyopaque) callconv(.C) hb_position_t;
pub const hb_font_get_glyph_h_kerning_func_t = hb_font_get_glyph_kerning_func_t;
pub const hb_font_get_glyph_extents_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, [*c]hb_glyph_extents_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_glyph_contour_point_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, c_uint, [*c]hb_position_t, [*c]hb_position_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_glyph_name_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, [*c]u8, c_uint, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_get_glyph_from_name_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, [*c]const u8, c_int, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub const hb_font_draw_glyph_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, ?*hb_draw_funcs_t, ?*anyopaque, ?*anyopaque) callconv(.C) void;
pub const hb_font_paint_glyph_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, ?*hb_paint_funcs_t, ?*anyopaque, c_uint, hb_color_t, ?*anyopaque) callconv(.C) void;
pub extern fn hb_font_funcs_set_font_h_extents_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_font_h_extents_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_font_v_extents_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_font_v_extents_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_nominal_glyph_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_nominal_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_nominal_glyphs_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_nominal_glyphs_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_variation_glyph_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_variation_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_h_advance_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_h_advance_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_v_advance_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_v_advance_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_h_advances_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_h_advances_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_v_advances_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_v_advances_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_h_origin_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_h_origin_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_v_origin_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_v_origin_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_h_kerning_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_h_kerning_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_extents_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_extents_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_contour_point_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_contour_point_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_name_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_name_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_glyph_from_name_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_from_name_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_draw_glyph_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_draw_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_funcs_set_paint_glyph_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_paint_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_get_h_extents(font: ?*hb_font_t, extents: [*c]hb_font_extents_t) hb_bool_t;
pub extern fn hb_font_get_v_extents(font: ?*hb_font_t, extents: [*c]hb_font_extents_t) hb_bool_t;
pub extern fn hb_font_get_nominal_glyph(font: ?*hb_font_t, unicode: hb_codepoint_t, glyph: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_font_get_variation_glyph(font: ?*hb_font_t, unicode: hb_codepoint_t, variation_selector: hb_codepoint_t, glyph: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_font_get_nominal_glyphs(font: ?*hb_font_t, count: c_uint, first_unicode: [*c]const hb_codepoint_t, unicode_stride: c_uint, first_glyph: [*c]hb_codepoint_t, glyph_stride: c_uint) c_uint;
pub extern fn hb_font_get_glyph_h_advance(font: ?*hb_font_t, glyph: hb_codepoint_t) hb_position_t;
pub extern fn hb_font_get_glyph_v_advance(font: ?*hb_font_t, glyph: hb_codepoint_t) hb_position_t;
pub extern fn hb_font_get_glyph_h_advances(font: ?*hb_font_t, count: c_uint, first_glyph: [*c]const hb_codepoint_t, glyph_stride: c_uint, first_advance: [*c]hb_position_t, advance_stride: c_uint) void;
pub extern fn hb_font_get_glyph_v_advances(font: ?*hb_font_t, count: c_uint, first_glyph: [*c]const hb_codepoint_t, glyph_stride: c_uint, first_advance: [*c]hb_position_t, advance_stride: c_uint) void;
pub extern fn hb_font_get_glyph_h_origin(font: ?*hb_font_t, glyph: hb_codepoint_t, x: [*c]hb_position_t, y: [*c]hb_position_t) hb_bool_t;
pub extern fn hb_font_get_glyph_v_origin(font: ?*hb_font_t, glyph: hb_codepoint_t, x: [*c]hb_position_t, y: [*c]hb_position_t) hb_bool_t;
pub extern fn hb_font_get_glyph_h_kerning(font: ?*hb_font_t, left_glyph: hb_codepoint_t, right_glyph: hb_codepoint_t) hb_position_t;
pub extern fn hb_font_get_glyph_extents(font: ?*hb_font_t, glyph: hb_codepoint_t, extents: [*c]hb_glyph_extents_t) hb_bool_t;
pub extern fn hb_font_get_glyph_contour_point(font: ?*hb_font_t, glyph: hb_codepoint_t, point_index: c_uint, x: [*c]hb_position_t, y: [*c]hb_position_t) hb_bool_t;
pub extern fn hb_font_get_glyph_name(font: ?*hb_font_t, glyph: hb_codepoint_t, name: [*c]u8, size: c_uint) hb_bool_t;
pub extern fn hb_font_get_glyph_from_name(font: ?*hb_font_t, name: [*c]const u8, len: c_int, glyph: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_font_draw_glyph(font: ?*hb_font_t, glyph: hb_codepoint_t, dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque) void;
pub extern fn hb_font_paint_glyph(font: ?*hb_font_t, glyph: hb_codepoint_t, pfuncs: ?*hb_paint_funcs_t, paint_data: ?*anyopaque, palette_index: c_uint, foreground: hb_color_t) void;
pub extern fn hb_font_get_glyph(font: ?*hb_font_t, unicode: hb_codepoint_t, variation_selector: hb_codepoint_t, glyph: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_font_get_extents_for_direction(font: ?*hb_font_t, direction: hb_direction_t, extents: [*c]hb_font_extents_t) void;
pub extern fn hb_font_get_glyph_advance_for_direction(font: ?*hb_font_t, glyph: hb_codepoint_t, direction: hb_direction_t, x: [*c]hb_position_t, y: [*c]hb_position_t) void;
pub extern fn hb_font_get_glyph_advances_for_direction(font: ?*hb_font_t, direction: hb_direction_t, count: c_uint, first_glyph: [*c]const hb_codepoint_t, glyph_stride: c_uint, first_advance: [*c]hb_position_t, advance_stride: c_uint) void;
pub extern fn hb_font_get_glyph_origin_for_direction(font: ?*hb_font_t, glyph: hb_codepoint_t, direction: hb_direction_t, x: [*c]hb_position_t, y: [*c]hb_position_t) void;
pub extern fn hb_font_add_glyph_origin_for_direction(font: ?*hb_font_t, glyph: hb_codepoint_t, direction: hb_direction_t, x: [*c]hb_position_t, y: [*c]hb_position_t) void;
pub extern fn hb_font_subtract_glyph_origin_for_direction(font: ?*hb_font_t, glyph: hb_codepoint_t, direction: hb_direction_t, x: [*c]hb_position_t, y: [*c]hb_position_t) void;
pub extern fn hb_font_get_glyph_kerning_for_direction(font: ?*hb_font_t, first_glyph: hb_codepoint_t, second_glyph: hb_codepoint_t, direction: hb_direction_t, x: [*c]hb_position_t, y: [*c]hb_position_t) void;
pub extern fn hb_font_get_glyph_extents_for_origin(font: ?*hb_font_t, glyph: hb_codepoint_t, direction: hb_direction_t, extents: [*c]hb_glyph_extents_t) hb_bool_t;
pub extern fn hb_font_get_glyph_contour_point_for_origin(font: ?*hb_font_t, glyph: hb_codepoint_t, point_index: c_uint, direction: hb_direction_t, x: [*c]hb_position_t, y: [*c]hb_position_t) hb_bool_t;
pub extern fn hb_font_glyph_to_string(font: ?*hb_font_t, glyph: hb_codepoint_t, s: [*c]u8, size: c_uint) void;
pub extern fn hb_font_glyph_from_string(font: ?*hb_font_t, s: [*c]const u8, len: c_int, glyph: [*c]hb_codepoint_t) hb_bool_t;
pub extern fn hb_font_create(face: ?*hb_face_t) ?*hb_font_t;
pub extern fn hb_font_create_sub_font(parent: ?*hb_font_t) ?*hb_font_t;
pub extern fn hb_font_get_empty() ?*hb_font_t;
pub extern fn hb_font_reference(font: ?*hb_font_t) ?*hb_font_t;
pub extern fn hb_font_destroy(font: ?*hb_font_t) void;
pub extern fn hb_font_set_user_data(font: ?*hb_font_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_font_get_user_data(font: ?*const hb_font_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_font_make_immutable(font: ?*hb_font_t) void;
pub extern fn hb_font_is_immutable(font: ?*hb_font_t) hb_bool_t;
pub extern fn hb_font_get_serial(font: ?*hb_font_t) c_uint;
pub extern fn hb_font_changed(font: ?*hb_font_t) void;
pub extern fn hb_font_set_parent(font: ?*hb_font_t, parent: ?*hb_font_t) void;
pub extern fn hb_font_get_parent(font: ?*hb_font_t) ?*hb_font_t;
pub extern fn hb_font_set_face(font: ?*hb_font_t, face: ?*hb_face_t) void;
pub extern fn hb_font_get_face(font: ?*hb_font_t) ?*hb_face_t;
pub extern fn hb_font_set_funcs(font: ?*hb_font_t, klass: ?*hb_font_funcs_t, font_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_set_funcs_data(font: ?*hb_font_t, font_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_set_scale(font: ?*hb_font_t, x_scale: c_int, y_scale: c_int) void;
pub extern fn hb_font_get_scale(font: ?*hb_font_t, x_scale: [*c]c_int, y_scale: [*c]c_int) void;
pub extern fn hb_font_set_ppem(font: ?*hb_font_t, x_ppem: c_uint, y_ppem: c_uint) void;
pub extern fn hb_font_get_ppem(font: ?*hb_font_t, x_ppem: [*c]c_uint, y_ppem: [*c]c_uint) void;
pub extern fn hb_font_set_ptem(font: ?*hb_font_t, ptem: f32) void;
pub extern fn hb_font_get_ptem(font: ?*hb_font_t) f32;
pub extern fn hb_font_set_synthetic_bold(font: ?*hb_font_t, x_embolden: f32, y_embolden: f32, in_place: hb_bool_t) void;
pub extern fn hb_font_get_synthetic_bold(font: ?*hb_font_t, x_embolden: [*c]f32, y_embolden: [*c]f32, in_place: [*c]hb_bool_t) void;
pub extern fn hb_font_set_synthetic_slant(font: ?*hb_font_t, slant: f32) void;
pub extern fn hb_font_get_synthetic_slant(font: ?*hb_font_t) f32;
pub extern fn hb_font_set_variations(font: ?*hb_font_t, variations: [*c]const hb_variation_t, variations_length: c_uint) void;
pub extern fn hb_font_set_variation(font: ?*hb_font_t, tag: hb_tag_t, value: f32) void;
pub extern fn hb_font_set_var_coords_design(font: ?*hb_font_t, coords: [*c]const f32, coords_length: c_uint) void;
pub extern fn hb_font_get_var_coords_design(font: ?*hb_font_t, length: [*c]c_uint) [*c]const f32;
pub extern fn hb_font_set_var_coords_normalized(font: ?*hb_font_t, coords: [*c]const c_int, coords_length: c_uint) void;
pub extern fn hb_font_get_var_coords_normalized(font: ?*hb_font_t, length: [*c]c_uint) [*c]const c_int;
pub extern fn hb_font_set_var_named_instance(font: ?*hb_font_t, instance_index: c_uint) void;
pub extern fn hb_font_get_var_named_instance(font: ?*hb_font_t) c_uint;
pub const struct_hb_glyph_info_t = extern struct {
    codepoint: hb_codepoint_t,
    mask: hb_mask_t,
    cluster: u32,
    var1: hb_var_int_t,
    var2: hb_var_int_t,
};
pub const hb_glyph_info_t = struct_hb_glyph_info_t;
pub const HB_GLYPH_FLAG_UNSAFE_TO_BREAK: c_int = 1;
pub const HB_GLYPH_FLAG_UNSAFE_TO_CONCAT: c_int = 2;
pub const HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL: c_int = 4;
pub const HB_GLYPH_FLAG_DEFINED: c_int = 7;
pub const hb_glyph_flags_t = c_uint;
pub extern fn hb_glyph_info_get_glyph_flags(info: [*c]const hb_glyph_info_t) hb_glyph_flags_t;
pub const struct_hb_glyph_position_t = extern struct {
    x_advance: hb_position_t,
    y_advance: hb_position_t,
    x_offset: hb_position_t,
    y_offset: hb_position_t,
    @"var": hb_var_int_t,
};
pub const hb_glyph_position_t = struct_hb_glyph_position_t;
pub const struct_hb_segment_properties_t = extern struct {
    direction: hb_direction_t,
    script: hb_script_t,
    language: hb_language_t,
    reserved1: ?*anyopaque,
    reserved2: ?*anyopaque,
};
pub const hb_segment_properties_t = struct_hb_segment_properties_t;
pub extern fn hb_segment_properties_equal(a: [*c]const hb_segment_properties_t, b: [*c]const hb_segment_properties_t) hb_bool_t;
pub extern fn hb_segment_properties_hash(p: [*c]const hb_segment_properties_t) c_uint;
pub extern fn hb_segment_properties_overlay(p: [*c]hb_segment_properties_t, src: [*c]const hb_segment_properties_t) void;
pub const struct_hb_buffer_t = opaque {};
pub const hb_buffer_t = struct_hb_buffer_t;
pub extern fn hb_buffer_create() ?*hb_buffer_t;
pub extern fn hb_buffer_create_similar(src: ?*const hb_buffer_t) ?*hb_buffer_t;
pub extern fn hb_buffer_reset(buffer: ?*hb_buffer_t) void;
pub extern fn hb_buffer_get_empty() ?*hb_buffer_t;
pub extern fn hb_buffer_reference(buffer: ?*hb_buffer_t) ?*hb_buffer_t;
pub extern fn hb_buffer_destroy(buffer: ?*hb_buffer_t) void;
pub extern fn hb_buffer_set_user_data(buffer: ?*hb_buffer_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_buffer_get_user_data(buffer: ?*const hb_buffer_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub const HB_BUFFER_CONTENT_TYPE_INVALID: c_int = 0;
pub const HB_BUFFER_CONTENT_TYPE_UNICODE: c_int = 1;
pub const HB_BUFFER_CONTENT_TYPE_GLYPHS: c_int = 2;
pub const hb_buffer_content_type_t = c_uint;
pub extern fn hb_buffer_set_content_type(buffer: ?*hb_buffer_t, content_type: hb_buffer_content_type_t) void;
pub extern fn hb_buffer_get_content_type(buffer: ?*const hb_buffer_t) hb_buffer_content_type_t;
pub extern fn hb_buffer_set_unicode_funcs(buffer: ?*hb_buffer_t, unicode_funcs: ?*hb_unicode_funcs_t) void;
pub extern fn hb_buffer_get_unicode_funcs(buffer: ?*const hb_buffer_t) ?*hb_unicode_funcs_t;
pub extern fn hb_buffer_set_direction(buffer: ?*hb_buffer_t, direction: hb_direction_t) void;
pub extern fn hb_buffer_get_direction(buffer: ?*const hb_buffer_t) hb_direction_t;
pub extern fn hb_buffer_set_script(buffer: ?*hb_buffer_t, script: hb_script_t) void;
pub extern fn hb_buffer_get_script(buffer: ?*const hb_buffer_t) hb_script_t;
pub extern fn hb_buffer_set_language(buffer: ?*hb_buffer_t, language: hb_language_t) void;
pub extern fn hb_buffer_get_language(buffer: ?*const hb_buffer_t) hb_language_t;
pub extern fn hb_buffer_set_segment_properties(buffer: ?*hb_buffer_t, props: [*c]const hb_segment_properties_t) void;
pub extern fn hb_buffer_get_segment_properties(buffer: ?*const hb_buffer_t, props: [*c]hb_segment_properties_t) void;
pub extern fn hb_buffer_guess_segment_properties(buffer: ?*hb_buffer_t) void;
pub const HB_BUFFER_FLAG_DEFAULT: c_int = 0;
pub const HB_BUFFER_FLAG_BOT: c_int = 1;
pub const HB_BUFFER_FLAG_EOT: c_int = 2;
pub const HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES: c_int = 4;
pub const HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES: c_int = 8;
pub const HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE: c_int = 16;
pub const HB_BUFFER_FLAG_VERIFY: c_int = 32;
pub const HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT: c_int = 64;
pub const HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL: c_int = 128;
pub const HB_BUFFER_FLAG_DEFINED: c_int = 255;
pub const hb_buffer_flags_t = c_uint;
pub extern fn hb_buffer_set_flags(buffer: ?*hb_buffer_t, flags: hb_buffer_flags_t) void;
pub extern fn hb_buffer_get_flags(buffer: ?*const hb_buffer_t) hb_buffer_flags_t;
pub const HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: c_int = 0;
pub const HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: c_int = 1;
pub const HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: c_int = 2;
pub const HB_BUFFER_CLUSTER_LEVEL_DEFAULT: c_int = 0;
pub const hb_buffer_cluster_level_t = c_uint;
pub extern fn hb_buffer_set_cluster_level(buffer: ?*hb_buffer_t, cluster_level: hb_buffer_cluster_level_t) void;
pub extern fn hb_buffer_get_cluster_level(buffer: ?*const hb_buffer_t) hb_buffer_cluster_level_t;
pub extern fn hb_buffer_set_replacement_codepoint(buffer: ?*hb_buffer_t, replacement: hb_codepoint_t) void;
pub extern fn hb_buffer_get_replacement_codepoint(buffer: ?*const hb_buffer_t) hb_codepoint_t;
pub extern fn hb_buffer_set_invisible_glyph(buffer: ?*hb_buffer_t, invisible: hb_codepoint_t) void;
pub extern fn hb_buffer_get_invisible_glyph(buffer: ?*const hb_buffer_t) hb_codepoint_t;
pub extern fn hb_buffer_set_not_found_glyph(buffer: ?*hb_buffer_t, not_found: hb_codepoint_t) void;
pub extern fn hb_buffer_get_not_found_glyph(buffer: ?*const hb_buffer_t) hb_codepoint_t;
pub extern fn hb_buffer_clear_contents(buffer: ?*hb_buffer_t) void;
pub extern fn hb_buffer_pre_allocate(buffer: ?*hb_buffer_t, size: c_uint) hb_bool_t;
pub extern fn hb_buffer_allocation_successful(buffer: ?*hb_buffer_t) hb_bool_t;
pub extern fn hb_buffer_reverse(buffer: ?*hb_buffer_t) void;
pub extern fn hb_buffer_reverse_range(buffer: ?*hb_buffer_t, start: c_uint, end: c_uint) void;
pub extern fn hb_buffer_reverse_clusters(buffer: ?*hb_buffer_t) void;
pub extern fn hb_buffer_add(buffer: ?*hb_buffer_t, codepoint: hb_codepoint_t, cluster: c_uint) void;
pub extern fn hb_buffer_add_utf8(buffer: ?*hb_buffer_t, text: [*c]const u8, text_length: c_int, item_offset: c_uint, item_length: c_int) void;
pub extern fn hb_buffer_add_utf16(buffer: ?*hb_buffer_t, text: [*c]const u16, text_length: c_int, item_offset: c_uint, item_length: c_int) void;
pub extern fn hb_buffer_add_utf32(buffer: ?*hb_buffer_t, text: [*c]const u32, text_length: c_int, item_offset: c_uint, item_length: c_int) void;
pub extern fn hb_buffer_add_latin1(buffer: ?*hb_buffer_t, text: [*c]const u8, text_length: c_int, item_offset: c_uint, item_length: c_int) void;
pub extern fn hb_buffer_add_codepoints(buffer: ?*hb_buffer_t, text: [*c]const hb_codepoint_t, text_length: c_int, item_offset: c_uint, item_length: c_int) void;
pub extern fn hb_buffer_append(buffer: ?*hb_buffer_t, source: ?*const hb_buffer_t, start: c_uint, end: c_uint) void;
pub extern fn hb_buffer_set_length(buffer: ?*hb_buffer_t, length: c_uint) hb_bool_t;
pub extern fn hb_buffer_get_length(buffer: ?*const hb_buffer_t) c_uint;
pub extern fn hb_buffer_get_glyph_infos(buffer: ?*hb_buffer_t, length: [*c]c_uint) [*c]hb_glyph_info_t;
pub extern fn hb_buffer_get_glyph_positions(buffer: ?*hb_buffer_t, length: [*c]c_uint) [*c]hb_glyph_position_t;
pub extern fn hb_buffer_has_positions(buffer: ?*hb_buffer_t) hb_bool_t;
pub extern fn hb_buffer_normalize_glyphs(buffer: ?*hb_buffer_t) void;
pub const HB_BUFFER_SERIALIZE_FLAG_DEFAULT: c_int = 0;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: c_int = 1;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: c_int = 2;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: c_int = 4;
pub const HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: c_int = 8;
pub const HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: c_int = 16;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: c_int = 32;
pub const HB_BUFFER_SERIALIZE_FLAG_DEFINED: c_int = 63;
pub const hb_buffer_serialize_flags_t = c_uint;
pub const HB_BUFFER_SERIALIZE_FORMAT_TEXT: c_int = 1413830740;
pub const HB_BUFFER_SERIALIZE_FORMAT_JSON: c_int = 1246973774;
pub const HB_BUFFER_SERIALIZE_FORMAT_INVALID: c_int = 0;
pub const hb_buffer_serialize_format_t = c_uint;
pub extern fn hb_buffer_serialize_format_from_string(str: [*c]const u8, len: c_int) hb_buffer_serialize_format_t;
pub extern fn hb_buffer_serialize_format_to_string(format: hb_buffer_serialize_format_t) [*c]const u8;
pub extern fn hb_buffer_serialize_list_formats() [*c][*c]const u8;
pub extern fn hb_buffer_serialize_glyphs(buffer: ?*hb_buffer_t, start: c_uint, end: c_uint, buf: [*c]u8, buf_size: c_uint, buf_consumed: [*c]c_uint, font: ?*hb_font_t, format: hb_buffer_serialize_format_t, flags: hb_buffer_serialize_flags_t) c_uint;
pub extern fn hb_buffer_serialize_unicode(buffer: ?*hb_buffer_t, start: c_uint, end: c_uint, buf: [*c]u8, buf_size: c_uint, buf_consumed: [*c]c_uint, format: hb_buffer_serialize_format_t, flags: hb_buffer_serialize_flags_t) c_uint;
pub extern fn hb_buffer_serialize(buffer: ?*hb_buffer_t, start: c_uint, end: c_uint, buf: [*c]u8, buf_size: c_uint, buf_consumed: [*c]c_uint, font: ?*hb_font_t, format: hb_buffer_serialize_format_t, flags: hb_buffer_serialize_flags_t) c_uint;
pub extern fn hb_buffer_deserialize_glyphs(buffer: ?*hb_buffer_t, buf: [*c]const u8, buf_len: c_int, end_ptr: [*c][*c]const u8, font: ?*hb_font_t, format: hb_buffer_serialize_format_t) hb_bool_t;
pub extern fn hb_buffer_deserialize_unicode(buffer: ?*hb_buffer_t, buf: [*c]const u8, buf_len: c_int, end_ptr: [*c][*c]const u8, format: hb_buffer_serialize_format_t) hb_bool_t;
pub const HB_BUFFER_DIFF_FLAG_EQUAL: c_int = 0;
pub const HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH: c_int = 1;
pub const HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH: c_int = 2;
pub const HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT: c_int = 4;
pub const HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT: c_int = 8;
pub const HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH: c_int = 16;
pub const HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH: c_int = 32;
pub const HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH: c_int = 64;
pub const HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH: c_int = 128;
pub const hb_buffer_diff_flags_t = c_uint;
pub extern fn hb_buffer_diff(buffer: ?*hb_buffer_t, reference: ?*hb_buffer_t, dottedcircle_glyph: hb_codepoint_t, position_fuzz: c_uint) hb_buffer_diff_flags_t;
pub const hb_buffer_message_func_t = ?*const fn (?*hb_buffer_t, ?*hb_font_t, [*c]const u8, ?*anyopaque) callconv(.C) hb_bool_t;
pub extern fn hb_buffer_set_message_func(buffer: ?*hb_buffer_t, func: hb_buffer_message_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub const hb_font_get_glyph_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, hb_codepoint_t, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) hb_bool_t;
pub extern fn hb_font_funcs_set_glyph_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub const hb_unicode_eastasian_width_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, ?*anyopaque) callconv(.C) c_uint;
pub extern fn hb_unicode_funcs_set_eastasian_width_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_eastasian_width_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_eastasian_width(ufuncs: ?*hb_unicode_funcs_t, unicode: hb_codepoint_t) c_uint;
pub const hb_unicode_decompose_compatibility_func_t = ?*const fn (?*hb_unicode_funcs_t, hb_codepoint_t, [*c]hb_codepoint_t, ?*anyopaque) callconv(.C) c_uint;
pub extern fn hb_unicode_funcs_set_decompose_compatibility_func(ufuncs: ?*hb_unicode_funcs_t, func: hb_unicode_decompose_compatibility_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_unicode_decompose_compatibility(ufuncs: ?*hb_unicode_funcs_t, u: hb_codepoint_t, decomposed: [*c]hb_codepoint_t) c_uint;
pub const hb_font_get_glyph_v_kerning_func_t = hb_font_get_glyph_kerning_func_t;
pub extern fn hb_font_funcs_set_glyph_v_kerning_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_v_kerning_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_get_glyph_v_kerning(font: ?*hb_font_t, top_glyph: hb_codepoint_t, bottom_glyph: hb_codepoint_t) hb_position_t;
pub const hb_font_get_glyph_shape_func_t = ?*const fn (?*hb_font_t, ?*anyopaque, hb_codepoint_t, ?*hb_draw_funcs_t, ?*anyopaque, ?*anyopaque) callconv(.C) void;
pub extern fn hb_font_funcs_set_glyph_shape_func(ffuncs: ?*hb_font_funcs_t, func: hb_font_get_glyph_shape_func_t, user_data: ?*anyopaque, destroy: hb_destroy_func_t) void;
pub extern fn hb_font_get_glyph_shape(font: ?*hb_font_t, glyph: hb_codepoint_t, dfuncs: ?*hb_draw_funcs_t, draw_data: ?*anyopaque) void;
pub extern fn hb_shape(font: ?*hb_font_t, buffer: ?*hb_buffer_t, features: [*c]const hb_feature_t, num_features: c_uint) void;
pub extern fn hb_shape_full(font: ?*hb_font_t, buffer: ?*hb_buffer_t, features: [*c]const hb_feature_t, num_features: c_uint, shaper_list: [*c]const [*c]const u8) hb_bool_t;
pub extern fn hb_shape_justify(font: ?*hb_font_t, buffer: ?*hb_buffer_t, features: [*c]const hb_feature_t, num_features: c_uint, shaper_list: [*c]const [*c]const u8, min_target_advance: f32, max_target_advance: f32, advance: [*c]f32, var_tag: [*c]hb_tag_t, var_value: [*c]f32) hb_bool_t;
pub extern fn hb_shape_list_shapers() [*c][*c]const u8;
pub const struct_hb_shape_plan_t = opaque {};
pub const hb_shape_plan_t = struct_hb_shape_plan_t;
pub extern fn hb_shape_plan_create(face: ?*hb_face_t, props: [*c]const hb_segment_properties_t, user_features: [*c]const hb_feature_t, num_user_features: c_uint, shaper_list: [*c]const [*c]const u8) ?*hb_shape_plan_t;
pub extern fn hb_shape_plan_create_cached(face: ?*hb_face_t, props: [*c]const hb_segment_properties_t, user_features: [*c]const hb_feature_t, num_user_features: c_uint, shaper_list: [*c]const [*c]const u8) ?*hb_shape_plan_t;
pub extern fn hb_shape_plan_create2(face: ?*hb_face_t, props: [*c]const hb_segment_properties_t, user_features: [*c]const hb_feature_t, num_user_features: c_uint, coords: [*c]const c_int, num_coords: c_uint, shaper_list: [*c]const [*c]const u8) ?*hb_shape_plan_t;
pub extern fn hb_shape_plan_create_cached2(face: ?*hb_face_t, props: [*c]const hb_segment_properties_t, user_features: [*c]const hb_feature_t, num_user_features: c_uint, coords: [*c]const c_int, num_coords: c_uint, shaper_list: [*c]const [*c]const u8) ?*hb_shape_plan_t;
pub extern fn hb_shape_plan_get_empty() ?*hb_shape_plan_t;
pub extern fn hb_shape_plan_reference(shape_plan: ?*hb_shape_plan_t) ?*hb_shape_plan_t;
pub extern fn hb_shape_plan_destroy(shape_plan: ?*hb_shape_plan_t) void;
pub extern fn hb_shape_plan_set_user_data(shape_plan: ?*hb_shape_plan_t, key: [*c]hb_user_data_key_t, data: ?*anyopaque, destroy: hb_destroy_func_t, replace: hb_bool_t) hb_bool_t;
pub extern fn hb_shape_plan_get_user_data(shape_plan: ?*const hb_shape_plan_t, key: [*c]hb_user_data_key_t) ?*anyopaque;
pub extern fn hb_shape_plan_execute(shape_plan: ?*hb_shape_plan_t, font: ?*hb_font_t, buffer: ?*hb_buffer_t, features: [*c]const hb_feature_t, num_features: c_uint) hb_bool_t;
pub extern fn hb_shape_plan_get_shaper(shape_plan: ?*hb_shape_plan_t) [*c]const u8;
pub const HB_STYLE_TAG_ITALIC: c_int = 1769234796;
pub const HB_STYLE_TAG_OPTICAL_SIZE: c_int = 1869640570;
pub const HB_STYLE_TAG_SLANT_ANGLE: c_int = 1936486004;
pub const HB_STYLE_TAG_SLANT_RATIO: c_int = 1399615092;
pub const HB_STYLE_TAG_WIDTH: c_int = 2003072104;
pub const HB_STYLE_TAG_WEIGHT: c_int = 2003265652;
pub const _HB_STYLE_TAG_MAX_VALUE: c_int = 2147483647;
pub const hb_style_tag_t = c_uint;
pub extern fn hb_style_get_value(font: ?*hb_font_t, style_tag: hb_style_tag_t) f32;
pub extern fn hb_version(major: [*c]c_uint, minor: [*c]c_uint, micro: [*c]c_uint) void;
pub extern fn hb_version_string() [*c]const u8;
pub extern fn hb_version_atleast(major: c_uint, minor: c_uint, micro: c_uint) hb_bool_t;
pub const struct__PangoCoverage = opaque {};
pub const PangoCoverage = struct__PangoCoverage;
pub const PANGO_COVERAGE_NONE: c_int = 0;
pub const PANGO_COVERAGE_FALLBACK: c_int = 1;
pub const PANGO_COVERAGE_APPROXIMATE: c_int = 2;
pub const PANGO_COVERAGE_EXACT: c_int = 3;
pub const PangoCoverageLevel = c_uint;
pub extern fn pango_coverage_get_type() GType;
pub extern fn pango_coverage_new() ?*PangoCoverage;
pub extern fn pango_coverage_ref(coverage: ?*PangoCoverage) ?*PangoCoverage;
pub extern fn pango_coverage_unref(coverage: ?*PangoCoverage) void;
pub extern fn pango_coverage_copy(coverage: ?*PangoCoverage) ?*PangoCoverage;
pub extern fn pango_coverage_get(coverage: ?*PangoCoverage, index_: c_int) PangoCoverageLevel;
pub extern fn pango_coverage_set(coverage: ?*PangoCoverage, index_: c_int, level: PangoCoverageLevel) void;
pub extern fn pango_coverage_max(coverage: ?*PangoCoverage, other: ?*PangoCoverage) void;
pub extern fn pango_coverage_to_bytes(coverage: ?*PangoCoverage, bytes: [*c][*c]guchar, n_bytes: [*c]c_int) void;
pub extern fn pango_coverage_from_bytes(bytes: [*c]guchar, n_bytes: c_int) ?*PangoCoverage;
pub const PangoCoverage_autoptr = ?*PangoCoverage;
pub const PangoCoverage_listautoptr = [*c]GList;
pub const PangoCoverage_slistautoptr = [*c]GSList;
pub const PangoCoverage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoCoverage(arg__ptr: ?*PangoCoverage) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_PangoCoverage(arg__ptr: [*c]?*PangoCoverage) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoCoverage(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoCoverage(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoCoverage(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoCoverage(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
} // /usr/include/pango-1.0/pango/pango-break.h:85:9: warning: struct demoted to opaque type - has bitfield
pub const struct__PangoLogAttr = opaque {};
pub const PangoLogAttr = struct__PangoLogAttr;
pub const struct__PangoEngine = extern struct {
    parent_instance: GObject,
};
pub const PangoEngine = struct__PangoEngine;
pub const struct__PangoEngineLang = extern struct {
    parent_instance: PangoEngine,
};
pub const PangoEngineLang = struct__PangoEngineLang;
pub const struct__PangoEngineShape = extern struct {
    parent_instance: PangoEngine,
};
pub const PangoEngineShape = struct__PangoEngineShape;
pub const struct__PangoFont = extern struct {
    parent_instance: GObject,
};
pub const PangoFont = struct__PangoFont;
pub const struct__PangoFontMap = extern struct {
    parent_instance: GObject,
};
pub const PangoFontMap = struct__PangoFontMap;
pub const struct__PangoRectangle = extern struct {
    x: c_int,
    y: c_int,
    width: c_int,
    height: c_int,
};
pub const PangoRectangle = struct__PangoRectangle;
pub const struct__PangoContext = opaque {};
pub const PangoContext = struct__PangoContext;
pub const struct__PangoLanguage = opaque {};
pub const PangoLanguage = struct__PangoLanguage;
pub const PangoGlyph = guint32;
pub extern fn pango_units_from_double(d: f64) c_int;
pub extern fn pango_units_to_double(i: c_int) f64;
pub extern fn pango_extents_to_pixels(inclusive: [*c]PangoRectangle, nearest: [*c]PangoRectangle) void;
pub const PANGO_GRAVITY_SOUTH: c_int = 0;
pub const PANGO_GRAVITY_EAST: c_int = 1;
pub const PANGO_GRAVITY_NORTH: c_int = 2;
pub const PANGO_GRAVITY_WEST: c_int = 3;
pub const PANGO_GRAVITY_AUTO: c_int = 4;
pub const PangoGravity = c_uint;
pub const PANGO_GRAVITY_HINT_NATURAL: c_int = 0;
pub const PANGO_GRAVITY_HINT_STRONG: c_int = 1;
pub const PANGO_GRAVITY_HINT_LINE: c_int = 2;
pub const PangoGravityHint = c_uint;
pub const struct__PangoMatrix = extern struct {
    xx: f64,
    xy: f64,
    yx: f64,
    yy: f64,
    x0: f64,
    y0: f64,
};
pub const PangoMatrix = struct__PangoMatrix;
pub extern fn pango_matrix_get_type() GType;
pub extern fn pango_matrix_copy(matrix: [*c]const PangoMatrix) [*c]PangoMatrix;
pub extern fn pango_matrix_free(matrix: [*c]PangoMatrix) void;
pub extern fn pango_matrix_translate(matrix: [*c]PangoMatrix, tx: f64, ty: f64) void;
pub extern fn pango_matrix_scale(matrix: [*c]PangoMatrix, scale_x: f64, scale_y: f64) void;
pub extern fn pango_matrix_rotate(matrix: [*c]PangoMatrix, degrees: f64) void;
pub extern fn pango_matrix_concat(matrix: [*c]PangoMatrix, new_matrix: [*c]const PangoMatrix) void;
pub extern fn pango_matrix_transform_point(matrix: [*c]const PangoMatrix, x: [*c]f64, y: [*c]f64) void;
pub extern fn pango_matrix_transform_distance(matrix: [*c]const PangoMatrix, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn pango_matrix_transform_rectangle(matrix: [*c]const PangoMatrix, rect: [*c]PangoRectangle) void;
pub extern fn pango_matrix_transform_pixel_rectangle(matrix: [*c]const PangoMatrix, rect: [*c]PangoRectangle) void;
pub extern fn pango_matrix_get_font_scale_factor(matrix: [*c]const PangoMatrix) f64;
pub extern fn pango_matrix_get_font_scale_factors(matrix: [*c]const PangoMatrix, xscale: [*c]f64, yscale: [*c]f64) void;
pub extern fn pango_matrix_get_slant_ratio(matrix: [*c]const PangoMatrix) f64;
pub const struct__PangoScriptIter = opaque {};
pub const PangoScriptIter = struct__PangoScriptIter;
pub const PANGO_SCRIPT_INVALID_CODE: c_int = -1;
pub const PANGO_SCRIPT_COMMON: c_int = 0;
pub const PANGO_SCRIPT_INHERITED: c_int = 1;
pub const PANGO_SCRIPT_ARABIC: c_int = 2;
pub const PANGO_SCRIPT_ARMENIAN: c_int = 3;
pub const PANGO_SCRIPT_BENGALI: c_int = 4;
pub const PANGO_SCRIPT_BOPOMOFO: c_int = 5;
pub const PANGO_SCRIPT_CHEROKEE: c_int = 6;
pub const PANGO_SCRIPT_COPTIC: c_int = 7;
pub const PANGO_SCRIPT_CYRILLIC: c_int = 8;
pub const PANGO_SCRIPT_DESERET: c_int = 9;
pub const PANGO_SCRIPT_DEVANAGARI: c_int = 10;
pub const PANGO_SCRIPT_ETHIOPIC: c_int = 11;
pub const PANGO_SCRIPT_GEORGIAN: c_int = 12;
pub const PANGO_SCRIPT_GOTHIC: c_int = 13;
pub const PANGO_SCRIPT_GREEK: c_int = 14;
pub const PANGO_SCRIPT_GUJARATI: c_int = 15;
pub const PANGO_SCRIPT_GURMUKHI: c_int = 16;
pub const PANGO_SCRIPT_HAN: c_int = 17;
pub const PANGO_SCRIPT_HANGUL: c_int = 18;
pub const PANGO_SCRIPT_HEBREW: c_int = 19;
pub const PANGO_SCRIPT_HIRAGANA: c_int = 20;
pub const PANGO_SCRIPT_KANNADA: c_int = 21;
pub const PANGO_SCRIPT_KATAKANA: c_int = 22;
pub const PANGO_SCRIPT_KHMER: c_int = 23;
pub const PANGO_SCRIPT_LAO: c_int = 24;
pub const PANGO_SCRIPT_LATIN: c_int = 25;
pub const PANGO_SCRIPT_MALAYALAM: c_int = 26;
pub const PANGO_SCRIPT_MONGOLIAN: c_int = 27;
pub const PANGO_SCRIPT_MYANMAR: c_int = 28;
pub const PANGO_SCRIPT_OGHAM: c_int = 29;
pub const PANGO_SCRIPT_OLD_ITALIC: c_int = 30;
pub const PANGO_SCRIPT_ORIYA: c_int = 31;
pub const PANGO_SCRIPT_RUNIC: c_int = 32;
pub const PANGO_SCRIPT_SINHALA: c_int = 33;
pub const PANGO_SCRIPT_SYRIAC: c_int = 34;
pub const PANGO_SCRIPT_TAMIL: c_int = 35;
pub const PANGO_SCRIPT_TELUGU: c_int = 36;
pub const PANGO_SCRIPT_THAANA: c_int = 37;
pub const PANGO_SCRIPT_THAI: c_int = 38;
pub const PANGO_SCRIPT_TIBETAN: c_int = 39;
pub const PANGO_SCRIPT_CANADIAN_ABORIGINAL: c_int = 40;
pub const PANGO_SCRIPT_YI: c_int = 41;
pub const PANGO_SCRIPT_TAGALOG: c_int = 42;
pub const PANGO_SCRIPT_HANUNOO: c_int = 43;
pub const PANGO_SCRIPT_BUHID: c_int = 44;
pub const PANGO_SCRIPT_TAGBANWA: c_int = 45;
pub const PANGO_SCRIPT_BRAILLE: c_int = 46;
pub const PANGO_SCRIPT_CYPRIOT: c_int = 47;
pub const PANGO_SCRIPT_LIMBU: c_int = 48;
pub const PANGO_SCRIPT_OSMANYA: c_int = 49;
pub const PANGO_SCRIPT_SHAVIAN: c_int = 50;
pub const PANGO_SCRIPT_LINEAR_B: c_int = 51;
pub const PANGO_SCRIPT_TAI_LE: c_int = 52;
pub const PANGO_SCRIPT_UGARITIC: c_int = 53;
pub const PANGO_SCRIPT_NEW_TAI_LUE: c_int = 54;
pub const PANGO_SCRIPT_BUGINESE: c_int = 55;
pub const PANGO_SCRIPT_GLAGOLITIC: c_int = 56;
pub const PANGO_SCRIPT_TIFINAGH: c_int = 57;
pub const PANGO_SCRIPT_SYLOTI_NAGRI: c_int = 58;
pub const PANGO_SCRIPT_OLD_PERSIAN: c_int = 59;
pub const PANGO_SCRIPT_KHAROSHTHI: c_int = 60;
pub const PANGO_SCRIPT_UNKNOWN: c_int = 61;
pub const PANGO_SCRIPT_BALINESE: c_int = 62;
pub const PANGO_SCRIPT_CUNEIFORM: c_int = 63;
pub const PANGO_SCRIPT_PHOENICIAN: c_int = 64;
pub const PANGO_SCRIPT_PHAGS_PA: c_int = 65;
pub const PANGO_SCRIPT_NKO: c_int = 66;
pub const PANGO_SCRIPT_KAYAH_LI: c_int = 67;
pub const PANGO_SCRIPT_LEPCHA: c_int = 68;
pub const PANGO_SCRIPT_REJANG: c_int = 69;
pub const PANGO_SCRIPT_SUNDANESE: c_int = 70;
pub const PANGO_SCRIPT_SAURASHTRA: c_int = 71;
pub const PANGO_SCRIPT_CHAM: c_int = 72;
pub const PANGO_SCRIPT_OL_CHIKI: c_int = 73;
pub const PANGO_SCRIPT_VAI: c_int = 74;
pub const PANGO_SCRIPT_CARIAN: c_int = 75;
pub const PANGO_SCRIPT_LYCIAN: c_int = 76;
pub const PANGO_SCRIPT_LYDIAN: c_int = 77;
pub const PANGO_SCRIPT_BATAK: c_int = 78;
pub const PANGO_SCRIPT_BRAHMI: c_int = 79;
pub const PANGO_SCRIPT_MANDAIC: c_int = 80;
pub const PANGO_SCRIPT_CHAKMA: c_int = 81;
pub const PANGO_SCRIPT_MEROITIC_CURSIVE: c_int = 82;
pub const PANGO_SCRIPT_MEROITIC_HIEROGLYPHS: c_int = 83;
pub const PANGO_SCRIPT_MIAO: c_int = 84;
pub const PANGO_SCRIPT_SHARADA: c_int = 85;
pub const PANGO_SCRIPT_SORA_SOMPENG: c_int = 86;
pub const PANGO_SCRIPT_TAKRI: c_int = 87;
pub const PANGO_SCRIPT_BASSA_VAH: c_int = 88;
pub const PANGO_SCRIPT_CAUCASIAN_ALBANIAN: c_int = 89;
pub const PANGO_SCRIPT_DUPLOYAN: c_int = 90;
pub const PANGO_SCRIPT_ELBASAN: c_int = 91;
pub const PANGO_SCRIPT_GRANTHA: c_int = 92;
pub const PANGO_SCRIPT_KHOJKI: c_int = 93;
pub const PANGO_SCRIPT_KHUDAWADI: c_int = 94;
pub const PANGO_SCRIPT_LINEAR_A: c_int = 95;
pub const PANGO_SCRIPT_MAHAJANI: c_int = 96;
pub const PANGO_SCRIPT_MANICHAEAN: c_int = 97;
pub const PANGO_SCRIPT_MENDE_KIKAKUI: c_int = 98;
pub const PANGO_SCRIPT_MODI: c_int = 99;
pub const PANGO_SCRIPT_MRO: c_int = 100;
pub const PANGO_SCRIPT_NABATAEAN: c_int = 101;
pub const PANGO_SCRIPT_OLD_NORTH_ARABIAN: c_int = 102;
pub const PANGO_SCRIPT_OLD_PERMIC: c_int = 103;
pub const PANGO_SCRIPT_PAHAWH_HMONG: c_int = 104;
pub const PANGO_SCRIPT_PALMYRENE: c_int = 105;
pub const PANGO_SCRIPT_PAU_CIN_HAU: c_int = 106;
pub const PANGO_SCRIPT_PSALTER_PAHLAVI: c_int = 107;
pub const PANGO_SCRIPT_SIDDHAM: c_int = 108;
pub const PANGO_SCRIPT_TIRHUTA: c_int = 109;
pub const PANGO_SCRIPT_WARANG_CITI: c_int = 110;
pub const PANGO_SCRIPT_AHOM: c_int = 111;
pub const PANGO_SCRIPT_ANATOLIAN_HIEROGLYPHS: c_int = 112;
pub const PANGO_SCRIPT_HATRAN: c_int = 113;
pub const PANGO_SCRIPT_MULTANI: c_int = 114;
pub const PANGO_SCRIPT_OLD_HUNGARIAN: c_int = 115;
pub const PANGO_SCRIPT_SIGNWRITING: c_int = 116;
pub const PangoScript = c_int;
pub extern fn pango_script_for_unichar(ch: gunichar) PangoScript;
pub extern fn pango_script_iter_get_type() GType;
pub extern fn pango_script_iter_new(text: [*c]const u8, length: c_int) ?*PangoScriptIter;
pub extern fn pango_script_iter_get_range(iter: ?*PangoScriptIter, start: [*c][*c]const u8, end: [*c][*c]const u8, script: [*c]PangoScript) void;
pub extern fn pango_script_iter_next(iter: ?*PangoScriptIter) gboolean;
pub extern fn pango_script_iter_free(iter: ?*PangoScriptIter) void;
pub extern fn pango_language_get_type() GType;
pub extern fn pango_language_get_default() ?*PangoLanguage;
pub extern fn pango_language_get_preferred() [*c]?*PangoLanguage;
pub extern fn pango_language_from_string(language: [*c]const u8) ?*PangoLanguage;
pub extern fn pango_language_to_string(language: ?*PangoLanguage) [*c]const u8;
pub extern fn pango_language_get_sample_string(language: ?*PangoLanguage) [*c]const u8;
pub extern fn pango_language_matches(language: ?*PangoLanguage, range_list: [*c]const u8) gboolean;
pub extern fn pango_language_includes_script(language: ?*PangoLanguage, script: PangoScript) gboolean;
pub extern fn pango_language_get_scripts(language: ?*PangoLanguage, num_scripts: [*c]c_int) [*c]const PangoScript;
pub extern fn pango_script_get_sample_language(script: PangoScript) ?*PangoLanguage;
pub extern fn pango_gravity_to_rotation(gravity: PangoGravity) f64;
pub extern fn pango_gravity_get_for_matrix(matrix: [*c]const PangoMatrix) PangoGravity;
pub extern fn pango_gravity_get_for_script(script: PangoScript, base_gravity: PangoGravity, hint: PangoGravityHint) PangoGravity;
pub extern fn pango_gravity_get_for_script_and_width(script: PangoScript, wide: gboolean, base_gravity: PangoGravity, hint: PangoGravityHint) PangoGravity;
pub const PANGO_DIRECTION_LTR: c_int = 0;
pub const PANGO_DIRECTION_RTL: c_int = 1;
pub const PANGO_DIRECTION_TTB_LTR: c_int = 2;
pub const PANGO_DIRECTION_TTB_RTL: c_int = 3;
pub const PANGO_DIRECTION_WEAK_LTR: c_int = 4;
pub const PANGO_DIRECTION_WEAK_RTL: c_int = 5;
pub const PANGO_DIRECTION_NEUTRAL: c_int = 6;
pub const PangoDirection = c_uint;
pub const PANGO_BIDI_TYPE_L: c_int = 0;
pub const PANGO_BIDI_TYPE_LRE: c_int = 1;
pub const PANGO_BIDI_TYPE_LRO: c_int = 2;
pub const PANGO_BIDI_TYPE_R: c_int = 3;
pub const PANGO_BIDI_TYPE_AL: c_int = 4;
pub const PANGO_BIDI_TYPE_RLE: c_int = 5;
pub const PANGO_BIDI_TYPE_RLO: c_int = 6;
pub const PANGO_BIDI_TYPE_PDF: c_int = 7;
pub const PANGO_BIDI_TYPE_EN: c_int = 8;
pub const PANGO_BIDI_TYPE_ES: c_int = 9;
pub const PANGO_BIDI_TYPE_ET: c_int = 10;
pub const PANGO_BIDI_TYPE_AN: c_int = 11;
pub const PANGO_BIDI_TYPE_CS: c_int = 12;
pub const PANGO_BIDI_TYPE_NSM: c_int = 13;
pub const PANGO_BIDI_TYPE_BN: c_int = 14;
pub const PANGO_BIDI_TYPE_B: c_int = 15;
pub const PANGO_BIDI_TYPE_S: c_int = 16;
pub const PANGO_BIDI_TYPE_WS: c_int = 17;
pub const PANGO_BIDI_TYPE_ON: c_int = 18;
pub const PANGO_BIDI_TYPE_LRI: c_int = 19;
pub const PANGO_BIDI_TYPE_RLI: c_int = 20;
pub const PANGO_BIDI_TYPE_FSI: c_int = 21;
pub const PANGO_BIDI_TYPE_PDI: c_int = 22;
pub const PangoBidiType = c_uint;
pub extern fn pango_bidi_type_for_unichar(ch: gunichar) PangoBidiType;
pub extern fn pango_unichar_direction(ch: gunichar) PangoDirection;
pub extern fn pango_find_base_dir(text: [*c]const gchar, length: gint) PangoDirection;
pub extern fn pango_get_mirror_char(ch: gunichar, mirrored_ch: [*c]gunichar) gboolean;
pub const struct__PangoFontDescription = opaque {};
pub const PangoFontDescription = struct__PangoFontDescription;
pub const struct__PangoFontMetrics = extern struct {
    ref_count: guint,
    ascent: c_int,
    descent: c_int,
    height: c_int,
    approximate_char_width: c_int,
    approximate_digit_width: c_int,
    underline_position: c_int,
    underline_thickness: c_int,
    strikethrough_position: c_int,
    strikethrough_thickness: c_int,
};
pub const PangoFontMetrics = struct__PangoFontMetrics;
pub const PANGO_STYLE_NORMAL: c_int = 0;
pub const PANGO_STYLE_OBLIQUE: c_int = 1;
pub const PANGO_STYLE_ITALIC: c_int = 2;
pub const PangoStyle = c_uint;
pub const PANGO_VARIANT_NORMAL: c_int = 0;
pub const PANGO_VARIANT_SMALL_CAPS: c_int = 1;
pub const PANGO_VARIANT_ALL_SMALL_CAPS: c_int = 2;
pub const PANGO_VARIANT_PETITE_CAPS: c_int = 3;
pub const PANGO_VARIANT_ALL_PETITE_CAPS: c_int = 4;
pub const PANGO_VARIANT_UNICASE: c_int = 5;
pub const PANGO_VARIANT_TITLE_CAPS: c_int = 6;
pub const PangoVariant = c_uint;
pub const PANGO_WEIGHT_THIN: c_int = 100;
pub const PANGO_WEIGHT_ULTRALIGHT: c_int = 200;
pub const PANGO_WEIGHT_LIGHT: c_int = 300;
pub const PANGO_WEIGHT_SEMILIGHT: c_int = 350;
pub const PANGO_WEIGHT_BOOK: c_int = 380;
pub const PANGO_WEIGHT_NORMAL: c_int = 400;
pub const PANGO_WEIGHT_MEDIUM: c_int = 500;
pub const PANGO_WEIGHT_SEMIBOLD: c_int = 600;
pub const PANGO_WEIGHT_BOLD: c_int = 700;
pub const PANGO_WEIGHT_ULTRABOLD: c_int = 800;
pub const PANGO_WEIGHT_HEAVY: c_int = 900;
pub const PANGO_WEIGHT_ULTRAHEAVY: c_int = 1000;
pub const PangoWeight = c_uint;
pub const PANGO_STRETCH_ULTRA_CONDENSED: c_int = 0;
pub const PANGO_STRETCH_EXTRA_CONDENSED: c_int = 1;
pub const PANGO_STRETCH_CONDENSED: c_int = 2;
pub const PANGO_STRETCH_SEMI_CONDENSED: c_int = 3;
pub const PANGO_STRETCH_NORMAL: c_int = 4;
pub const PANGO_STRETCH_SEMI_EXPANDED: c_int = 5;
pub const PANGO_STRETCH_EXPANDED: c_int = 6;
pub const PANGO_STRETCH_EXTRA_EXPANDED: c_int = 7;
pub const PANGO_STRETCH_ULTRA_EXPANDED: c_int = 8;
pub const PangoStretch = c_uint;
pub const PANGO_FONT_MASK_FAMILY: c_int = 1;
pub const PANGO_FONT_MASK_STYLE: c_int = 2;
pub const PANGO_FONT_MASK_VARIANT: c_int = 4;
pub const PANGO_FONT_MASK_WEIGHT: c_int = 8;
pub const PANGO_FONT_MASK_STRETCH: c_int = 16;
pub const PANGO_FONT_MASK_SIZE: c_int = 32;
pub const PANGO_FONT_MASK_GRAVITY: c_int = 64;
pub const PANGO_FONT_MASK_VARIATIONS: c_int = 128;
pub const PangoFontMask = c_uint;
pub extern fn pango_font_description_get_type() GType;
pub extern fn pango_font_description_new() ?*PangoFontDescription;
pub extern fn pango_font_description_copy(desc: ?*const PangoFontDescription) ?*PangoFontDescription;
pub extern fn pango_font_description_copy_static(desc: ?*const PangoFontDescription) ?*PangoFontDescription;
pub extern fn pango_font_description_hash(desc: ?*const PangoFontDescription) guint;
pub extern fn pango_font_description_equal(desc1: ?*const PangoFontDescription, desc2: ?*const PangoFontDescription) gboolean;
pub extern fn pango_font_description_free(desc: ?*PangoFontDescription) void;
pub extern fn pango_font_descriptions_free(descs: [*c]?*PangoFontDescription, n_descs: c_int) void;
pub extern fn pango_font_description_set_family(desc: ?*PangoFontDescription, family: [*c]const u8) void;
pub extern fn pango_font_description_set_family_static(desc: ?*PangoFontDescription, family: [*c]const u8) void;
pub extern fn pango_font_description_get_family(desc: ?*const PangoFontDescription) [*c]const u8;
pub extern fn pango_font_description_set_style(desc: ?*PangoFontDescription, style: PangoStyle) void;
pub extern fn pango_font_description_get_style(desc: ?*const PangoFontDescription) PangoStyle;
pub extern fn pango_font_description_set_variant(desc: ?*PangoFontDescription, variant: PangoVariant) void;
pub extern fn pango_font_description_get_variant(desc: ?*const PangoFontDescription) PangoVariant;
pub extern fn pango_font_description_set_weight(desc: ?*PangoFontDescription, weight: PangoWeight) void;
pub extern fn pango_font_description_get_weight(desc: ?*const PangoFontDescription) PangoWeight;
pub extern fn pango_font_description_set_stretch(desc: ?*PangoFontDescription, stretch: PangoStretch) void;
pub extern fn pango_font_description_get_stretch(desc: ?*const PangoFontDescription) PangoStretch;
pub extern fn pango_font_description_set_size(desc: ?*PangoFontDescription, size: gint) void;
pub extern fn pango_font_description_get_size(desc: ?*const PangoFontDescription) gint;
pub extern fn pango_font_description_set_absolute_size(desc: ?*PangoFontDescription, size: f64) void;
pub extern fn pango_font_description_get_size_is_absolute(desc: ?*const PangoFontDescription) gboolean;
pub extern fn pango_font_description_set_gravity(desc: ?*PangoFontDescription, gravity: PangoGravity) void;
pub extern fn pango_font_description_get_gravity(desc: ?*const PangoFontDescription) PangoGravity;
pub extern fn pango_font_description_set_variations_static(desc: ?*PangoFontDescription, variations: [*c]const u8) void;
pub extern fn pango_font_description_set_variations(desc: ?*PangoFontDescription, variations: [*c]const u8) void;
pub extern fn pango_font_description_get_variations(desc: ?*const PangoFontDescription) [*c]const u8;
pub extern fn pango_font_description_get_set_fields(desc: ?*const PangoFontDescription) PangoFontMask;
pub extern fn pango_font_description_unset_fields(desc: ?*PangoFontDescription, to_unset: PangoFontMask) void;
pub extern fn pango_font_description_merge(desc: ?*PangoFontDescription, desc_to_merge: ?*const PangoFontDescription, replace_existing: gboolean) void;
pub extern fn pango_font_description_merge_static(desc: ?*PangoFontDescription, desc_to_merge: ?*const PangoFontDescription, replace_existing: gboolean) void;
pub extern fn pango_font_description_better_match(desc: ?*const PangoFontDescription, old_match: ?*const PangoFontDescription, new_match: ?*const PangoFontDescription) gboolean;
pub extern fn pango_font_description_from_string(str: [*c]const u8) ?*PangoFontDescription;
pub extern fn pango_font_description_to_string(desc: ?*const PangoFontDescription) [*c]u8;
pub extern fn pango_font_description_to_filename(desc: ?*const PangoFontDescription) [*c]u8;
pub extern fn pango_font_metrics_get_type() GType;
pub extern fn pango_font_metrics_ref(metrics: [*c]PangoFontMetrics) [*c]PangoFontMetrics;
pub extern fn pango_font_metrics_unref(metrics: [*c]PangoFontMetrics) void;
pub extern fn pango_font_metrics_get_ascent(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_descent(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_height(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_approximate_char_width(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_approximate_digit_width(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_underline_position(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_underline_thickness(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_strikethrough_position(metrics: [*c]PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_strikethrough_thickness(metrics: [*c]PangoFontMetrics) c_int;
pub const struct__PangoFontFace = extern struct {
    parent_instance: GObject,
};
pub const PangoFontFace = struct__PangoFontFace;
pub const struct__PangoFontFamily = extern struct {
    parent_instance: GObject,
};
pub const PangoFontFamily = struct__PangoFontFamily;
pub const struct__PangoFontFamilyClass = extern struct {
    parent_class: GObjectClass,
    list_faces: ?*const fn ([*c]PangoFontFamily, [*c][*c][*c]PangoFontFace, [*c]c_int) callconv(.C) void,
    get_name: ?*const fn ([*c]PangoFontFamily) callconv(.C) [*c]const u8,
    is_monospace: ?*const fn ([*c]PangoFontFamily) callconv(.C) gboolean,
    is_variable: ?*const fn ([*c]PangoFontFamily) callconv(.C) gboolean,
    get_face: ?*const fn ([*c]PangoFontFamily, [*c]const u8) callconv(.C) [*c]PangoFontFace,
    _pango_reserved2: ?*const fn () callconv(.C) void,
};
pub const PangoFontFamilyClass = struct__PangoFontFamilyClass;
pub extern fn pango_font_family_get_type() GType;
pub extern fn pango_font_family_list_faces(family: [*c]PangoFontFamily, faces: [*c][*c][*c]PangoFontFace, n_faces: [*c]c_int) void;
pub extern fn pango_font_family_get_name(family: [*c]PangoFontFamily) [*c]const u8;
pub extern fn pango_font_family_is_monospace(family: [*c]PangoFontFamily) gboolean;
pub extern fn pango_font_family_is_variable(family: [*c]PangoFontFamily) gboolean;
pub extern fn pango_font_family_get_face(family: [*c]PangoFontFamily, name: [*c]const u8) [*c]PangoFontFace;
pub const struct__PangoFontFaceClass = extern struct {
    parent_class: GObjectClass,
    get_face_name: ?*const fn ([*c]PangoFontFace) callconv(.C) [*c]const u8,
    describe: ?*const fn ([*c]PangoFontFace) callconv(.C) ?*PangoFontDescription,
    list_sizes: ?*const fn ([*c]PangoFontFace, [*c][*c]c_int, [*c]c_int) callconv(.C) void,
    is_synthesized: ?*const fn ([*c]PangoFontFace) callconv(.C) gboolean,
    get_family: ?*const fn ([*c]PangoFontFace) callconv(.C) [*c]PangoFontFamily,
    _pango_reserved3: ?*const fn () callconv(.C) void,
    _pango_reserved4: ?*const fn () callconv(.C) void,
};
pub const PangoFontFaceClass = struct__PangoFontFaceClass;
pub extern fn pango_font_face_get_type() GType;
pub extern fn pango_font_face_describe(face: [*c]PangoFontFace) ?*PangoFontDescription;
pub extern fn pango_font_face_get_face_name(face: [*c]PangoFontFace) [*c]const u8;
pub extern fn pango_font_face_list_sizes(face: [*c]PangoFontFace, sizes: [*c][*c]c_int, n_sizes: [*c]c_int) void;
pub extern fn pango_font_face_is_synthesized(face: [*c]PangoFontFace) gboolean;
pub extern fn pango_font_face_get_family(face: [*c]PangoFontFace) [*c]PangoFontFamily;
pub const struct__PangoFontClass = extern struct {
    parent_class: GObjectClass,
    describe: ?*const fn ([*c]PangoFont) callconv(.C) ?*PangoFontDescription,
    get_coverage: ?*const fn ([*c]PangoFont, ?*PangoLanguage) callconv(.C) ?*PangoCoverage,
    get_glyph_extents: ?*const fn ([*c]PangoFont, PangoGlyph, [*c]PangoRectangle, [*c]PangoRectangle) callconv(.C) void,
    get_metrics: ?*const fn ([*c]PangoFont, ?*PangoLanguage) callconv(.C) [*c]PangoFontMetrics,
    get_font_map: ?*const fn ([*c]PangoFont) callconv(.C) [*c]PangoFontMap,
    describe_absolute: ?*const fn ([*c]PangoFont) callconv(.C) ?*PangoFontDescription,
    get_features: ?*const fn ([*c]PangoFont, [*c]hb_feature_t, guint, [*c]guint) callconv(.C) void,
    create_hb_font: ?*const fn ([*c]PangoFont) callconv(.C) ?*hb_font_t,
};
pub const PangoFontClass = struct__PangoFontClass;
pub extern fn pango_font_get_type() GType;
pub extern fn pango_font_describe(font: [*c]PangoFont) ?*PangoFontDescription;
pub extern fn pango_font_describe_with_absolute_size(font: [*c]PangoFont) ?*PangoFontDescription;
pub extern fn pango_font_get_coverage(font: [*c]PangoFont, language: ?*PangoLanguage) ?*PangoCoverage;
pub extern fn pango_font_find_shaper(font: [*c]PangoFont, language: ?*PangoLanguage, ch: guint32) [*c]PangoEngineShape;
pub extern fn pango_font_get_metrics(font: [*c]PangoFont, language: ?*PangoLanguage) [*c]PangoFontMetrics;
pub extern fn pango_font_get_glyph_extents(font: [*c]PangoFont, glyph: PangoGlyph, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_font_get_font_map(font: [*c]PangoFont) [*c]PangoFontMap;
pub extern fn pango_font_get_face(font: [*c]PangoFont) [*c]PangoFontFace;
pub extern fn pango_font_has_char(font: [*c]PangoFont, wc: gunichar) gboolean;
pub extern fn pango_font_get_features(font: [*c]PangoFont, features: [*c]hb_feature_t, len: guint, num_features: [*c]guint) void;
pub extern fn pango_font_get_hb_font(font: [*c]PangoFont) ?*hb_font_t;
pub extern fn pango_font_get_languages(font: [*c]PangoFont) [*c]?*PangoLanguage;
pub extern fn pango_font_serialize(font: [*c]PangoFont) ?*GBytes;
pub extern fn pango_font_deserialize(context: ?*PangoContext, bytes: ?*GBytes, @"error": [*c][*c]GError) [*c]PangoFont;
pub const PangoFontFamily_autoptr = [*c]PangoFontFamily;
pub const PangoFontFamily_listautoptr = [*c]GList;
pub const PangoFontFamily_slistautoptr = [*c]GSList;
pub const PangoFontFamily_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoFontFamily(arg__ptr: [*c]PangoFontFamily) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_PangoFontFamily(arg__ptr: [*c][*c]PangoFontFamily) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoFontFamily(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoFontFamily(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoFontFamily(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoFontFamily(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const PangoFontFace_autoptr = [*c]PangoFontFace;
pub const PangoFontFace_listautoptr = [*c]GList;
pub const PangoFontFace_slistautoptr = [*c]GSList;
pub const PangoFontFace_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoFontFace(arg__ptr: [*c]PangoFontFace) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_PangoFontFace(arg__ptr: [*c][*c]PangoFontFace) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoFontFace(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoFontFace(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoFontFace(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoFontFace(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const PangoFont_autoptr = [*c]PangoFont;
pub const PangoFont_listautoptr = [*c]GList;
pub const PangoFont_slistautoptr = [*c]GSList;
pub const PangoFont_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoFont(arg__ptr: [*c]PangoFont) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_PangoFont(arg__ptr: [*c][*c]PangoFont) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoFont(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoFont(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoFont(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoFont(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const PangoFontDescription_autoptr = ?*PangoFontDescription;
pub const PangoFontDescription_listautoptr = [*c]GList;
pub const PangoFontDescription_slistautoptr = [*c]GSList;
pub const PangoFontDescription_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoFontDescription(arg__ptr: ?*PangoFontDescription) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        pango_font_description_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_PangoFontDescription(arg__ptr: [*c]?*PangoFontDescription) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoFontDescription(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoFontDescription(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_font_description_free)))))));
}
pub fn glib_slistautoptr_cleanup_PangoFontDescription(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_font_description_free)))))));
}
pub fn glib_queueautoptr_cleanup_PangoFontDescription(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_font_description_free)))))));
    }
}
pub const struct__PangoColor = extern struct {
    red: guint16,
    green: guint16,
    blue: guint16,
};
pub const PangoColor = struct__PangoColor;
pub extern fn pango_color_get_type() GType;
pub extern fn pango_color_copy(src: [*c]const PangoColor) [*c]PangoColor;
pub extern fn pango_color_free(color: [*c]PangoColor) void;
pub extern fn pango_color_parse(color: [*c]PangoColor, spec: [*c]const u8) gboolean;
pub extern fn pango_color_parse_with_alpha(color: [*c]PangoColor, alpha: [*c]guint16, spec: [*c]const u8) gboolean;
pub extern fn pango_color_to_string(color: [*c]const PangoColor) [*c]u8;
pub const PangoAttribute = struct__PangoAttribute;
pub const struct__PangoAttrClass = extern struct {
    type: PangoAttrType,
    copy: ?*const fn ([*c]const PangoAttribute) callconv(.C) [*c]PangoAttribute,
    destroy: ?*const fn ([*c]PangoAttribute) callconv(.C) void,
    equal: ?*const fn ([*c]const PangoAttribute, [*c]const PangoAttribute) callconv(.C) gboolean,
};
pub const PangoAttrClass = struct__PangoAttrClass;
pub const struct__PangoAttribute = extern struct {
    klass: [*c]const PangoAttrClass,
    start_index: guint,
    end_index: guint,
};
pub const struct__PangoAttrString = extern struct {
    attr: PangoAttribute,
    value: [*c]u8,
};
pub const PangoAttrString = struct__PangoAttrString;
pub const struct__PangoAttrLanguage = extern struct {
    attr: PangoAttribute,
    value: ?*PangoLanguage,
};
pub const PangoAttrLanguage = struct__PangoAttrLanguage;
pub const struct__PangoAttrInt = extern struct {
    attr: PangoAttribute,
    value: c_int,
};
pub const PangoAttrInt = struct__PangoAttrInt; // /usr/include/pango-1.0/pango/pango-attributes.h:444:9: warning: struct demoted to opaque type - has bitfield
pub const struct__PangoAttrSize = opaque {};
pub const PangoAttrSize = struct__PangoAttrSize;
pub const struct__PangoAttrFloat = extern struct {
    attr: PangoAttribute,
    value: f64,
};
pub const PangoAttrFloat = struct__PangoAttrFloat;
pub const struct__PangoAttrColor = extern struct {
    attr: PangoAttribute,
    color: PangoColor,
};
pub const PangoAttrColor = struct__PangoAttrColor;
pub const struct__PangoAttrFontDesc = extern struct {
    attr: PangoAttribute,
    desc: ?*PangoFontDescription,
};
pub const PangoAttrFontDesc = struct__PangoAttrFontDesc;
pub const PangoAttrDataCopyFunc = ?*const fn (gconstpointer) callconv(.C) gpointer;
pub const struct__PangoAttrShape = extern struct {
    attr: PangoAttribute,
    ink_rect: PangoRectangle,
    logical_rect: PangoRectangle,
    data: gpointer,
    copy_func: PangoAttrDataCopyFunc,
    destroy_func: GDestroyNotify,
};
pub const PangoAttrShape = struct__PangoAttrShape;
pub const struct__PangoAttrFontFeatures = extern struct {
    attr: PangoAttribute,
    features: [*c]gchar,
};
pub const PangoAttrFontFeatures = struct__PangoAttrFontFeatures;
pub const PANGO_ATTR_INVALID: c_int = 0;
pub const PANGO_ATTR_LANGUAGE: c_int = 1;
pub const PANGO_ATTR_FAMILY: c_int = 2;
pub const PANGO_ATTR_STYLE: c_int = 3;
pub const PANGO_ATTR_WEIGHT: c_int = 4;
pub const PANGO_ATTR_VARIANT: c_int = 5;
pub const PANGO_ATTR_STRETCH: c_int = 6;
pub const PANGO_ATTR_SIZE: c_int = 7;
pub const PANGO_ATTR_FONT_DESC: c_int = 8;
pub const PANGO_ATTR_FOREGROUND: c_int = 9;
pub const PANGO_ATTR_BACKGROUND: c_int = 10;
pub const PANGO_ATTR_UNDERLINE: c_int = 11;
pub const PANGO_ATTR_STRIKETHROUGH: c_int = 12;
pub const PANGO_ATTR_RISE: c_int = 13;
pub const PANGO_ATTR_SHAPE: c_int = 14;
pub const PANGO_ATTR_SCALE: c_int = 15;
pub const PANGO_ATTR_FALLBACK: c_int = 16;
pub const PANGO_ATTR_LETTER_SPACING: c_int = 17;
pub const PANGO_ATTR_UNDERLINE_COLOR: c_int = 18;
pub const PANGO_ATTR_STRIKETHROUGH_COLOR: c_int = 19;
pub const PANGO_ATTR_ABSOLUTE_SIZE: c_int = 20;
pub const PANGO_ATTR_GRAVITY: c_int = 21;
pub const PANGO_ATTR_GRAVITY_HINT: c_int = 22;
pub const PANGO_ATTR_FONT_FEATURES: c_int = 23;
pub const PANGO_ATTR_FOREGROUND_ALPHA: c_int = 24;
pub const PANGO_ATTR_BACKGROUND_ALPHA: c_int = 25;
pub const PANGO_ATTR_ALLOW_BREAKS: c_int = 26;
pub const PANGO_ATTR_SHOW: c_int = 27;
pub const PANGO_ATTR_INSERT_HYPHENS: c_int = 28;
pub const PANGO_ATTR_OVERLINE: c_int = 29;
pub const PANGO_ATTR_OVERLINE_COLOR: c_int = 30;
pub const PANGO_ATTR_LINE_HEIGHT: c_int = 31;
pub const PANGO_ATTR_ABSOLUTE_LINE_HEIGHT: c_int = 32;
pub const PANGO_ATTR_TEXT_TRANSFORM: c_int = 33;
pub const PANGO_ATTR_WORD: c_int = 34;
pub const PANGO_ATTR_SENTENCE: c_int = 35;
pub const PANGO_ATTR_BASELINE_SHIFT: c_int = 36;
pub const PANGO_ATTR_FONT_SCALE: c_int = 37;
pub const PangoAttrType = c_uint;
pub const PANGO_UNDERLINE_NONE: c_int = 0;
pub const PANGO_UNDERLINE_SINGLE: c_int = 1;
pub const PANGO_UNDERLINE_DOUBLE: c_int = 2;
pub const PANGO_UNDERLINE_LOW: c_int = 3;
pub const PANGO_UNDERLINE_ERROR: c_int = 4;
pub const PANGO_UNDERLINE_SINGLE_LINE: c_int = 5;
pub const PANGO_UNDERLINE_DOUBLE_LINE: c_int = 6;
pub const PANGO_UNDERLINE_ERROR_LINE: c_int = 7;
pub const PangoUnderline = c_uint;
pub const PANGO_OVERLINE_NONE: c_int = 0;
pub const PANGO_OVERLINE_SINGLE: c_int = 1;
pub const PangoOverline = c_uint;
pub const PANGO_SHOW_NONE: c_int = 0;
pub const PANGO_SHOW_SPACES: c_int = 1;
pub const PANGO_SHOW_LINE_BREAKS: c_int = 2;
pub const PANGO_SHOW_IGNORABLES: c_int = 4;
pub const PangoShowFlags = c_uint;
pub const PANGO_TEXT_TRANSFORM_NONE: c_int = 0;
pub const PANGO_TEXT_TRANSFORM_LOWERCASE: c_int = 1;
pub const PANGO_TEXT_TRANSFORM_UPPERCASE: c_int = 2;
pub const PANGO_TEXT_TRANSFORM_CAPITALIZE: c_int = 3;
pub const PangoTextTransform = c_uint;
pub const PANGO_BASELINE_SHIFT_NONE: c_int = 0;
pub const PANGO_BASELINE_SHIFT_SUPERSCRIPT: c_int = 1;
pub const PANGO_BASELINE_SHIFT_SUBSCRIPT: c_int = 2;
pub const PangoBaselineShift = c_uint;
pub const PANGO_FONT_SCALE_NONE: c_int = 0;
pub const PANGO_FONT_SCALE_SUPERSCRIPT: c_int = 1;
pub const PANGO_FONT_SCALE_SUBSCRIPT: c_int = 2;
pub const PANGO_FONT_SCALE_SMALL_CAPS: c_int = 3;
pub const PangoFontScale = c_uint;
pub const PangoAttrFilterFunc = ?*const fn ([*c]PangoAttribute, gpointer) callconv(.C) gboolean;
pub extern fn pango_attribute_get_type() GType;
pub extern fn pango_attr_type_register(name: [*c]const u8) PangoAttrType;
pub extern fn pango_attr_type_get_name(@"type": PangoAttrType) [*c]const u8;
pub extern fn pango_attribute_init(attr: [*c]PangoAttribute, klass: [*c]const PangoAttrClass) void;
pub extern fn pango_attribute_copy(attr: [*c]const PangoAttribute) [*c]PangoAttribute;
pub extern fn pango_attribute_destroy(attr: [*c]PangoAttribute) void;
pub extern fn pango_attribute_equal(attr1: [*c]const PangoAttribute, attr2: [*c]const PangoAttribute) gboolean;
pub extern fn pango_attr_language_new(language: ?*PangoLanguage) [*c]PangoAttribute;
pub extern fn pango_attr_family_new(family: [*c]const u8) [*c]PangoAttribute;
pub extern fn pango_attr_foreground_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_background_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_size_new(size: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_size_new_absolute(size: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_style_new(style: PangoStyle) [*c]PangoAttribute;
pub extern fn pango_attr_weight_new(weight: PangoWeight) [*c]PangoAttribute;
pub extern fn pango_attr_variant_new(variant: PangoVariant) [*c]PangoAttribute;
pub extern fn pango_attr_stretch_new(stretch: PangoStretch) [*c]PangoAttribute;
pub extern fn pango_attr_font_desc_new(desc: ?*const PangoFontDescription) [*c]PangoAttribute;
pub extern fn pango_attr_underline_new(underline: PangoUnderline) [*c]PangoAttribute;
pub extern fn pango_attr_underline_color_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_strikethrough_new(strikethrough: gboolean) [*c]PangoAttribute;
pub extern fn pango_attr_strikethrough_color_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_rise_new(rise: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_baseline_shift_new(shift: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_font_scale_new(scale: PangoFontScale) [*c]PangoAttribute;
pub extern fn pango_attr_scale_new(scale_factor: f64) [*c]PangoAttribute;
pub extern fn pango_attr_fallback_new(enable_fallback: gboolean) [*c]PangoAttribute;
pub extern fn pango_attr_letter_spacing_new(letter_spacing: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_shape_new(ink_rect: [*c]const PangoRectangle, logical_rect: [*c]const PangoRectangle) [*c]PangoAttribute;
pub extern fn pango_attr_shape_new_with_data(ink_rect: [*c]const PangoRectangle, logical_rect: [*c]const PangoRectangle, data: gpointer, copy_func: PangoAttrDataCopyFunc, destroy_func: GDestroyNotify) [*c]PangoAttribute;
pub extern fn pango_attr_gravity_new(gravity: PangoGravity) [*c]PangoAttribute;
pub extern fn pango_attr_gravity_hint_new(hint: PangoGravityHint) [*c]PangoAttribute;
pub extern fn pango_attr_font_features_new(features: [*c]const u8) [*c]PangoAttribute;
pub extern fn pango_attr_foreground_alpha_new(alpha: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_background_alpha_new(alpha: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_allow_breaks_new(allow_breaks: gboolean) [*c]PangoAttribute;
pub extern fn pango_attr_word_new() [*c]PangoAttribute;
pub extern fn pango_attr_sentence_new() [*c]PangoAttribute;
pub extern fn pango_attr_insert_hyphens_new(insert_hyphens: gboolean) [*c]PangoAttribute;
pub extern fn pango_attr_overline_new(overline: PangoOverline) [*c]PangoAttribute;
pub extern fn pango_attr_overline_color_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_show_new(flags: PangoShowFlags) [*c]PangoAttribute;
pub extern fn pango_attr_line_height_new(factor: f64) [*c]PangoAttribute;
pub extern fn pango_attr_line_height_new_absolute(height: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_text_transform_new(transform: PangoTextTransform) [*c]PangoAttribute;
pub extern fn pango_attribute_as_string(attr: [*c]PangoAttribute) [*c]PangoAttrString;
pub extern fn pango_attribute_as_language(attr: [*c]PangoAttribute) [*c]PangoAttrLanguage;
pub extern fn pango_attribute_as_int(attr: [*c]PangoAttribute) [*c]PangoAttrInt;
pub extern fn pango_attribute_as_size(attr: [*c]PangoAttribute) ?*PangoAttrSize;
pub extern fn pango_attribute_as_float(attr: [*c]PangoAttribute) [*c]PangoAttrFloat;
pub extern fn pango_attribute_as_color(attr: [*c]PangoAttribute) [*c]PangoAttrColor;
pub extern fn pango_attribute_as_font_desc(attr: [*c]PangoAttribute) [*c]PangoAttrFontDesc;
pub extern fn pango_attribute_as_shape(attr: [*c]PangoAttribute) [*c]PangoAttrShape;
pub extern fn pango_attribute_as_font_features(attr: [*c]PangoAttribute) [*c]PangoAttrFontFeatures;
pub const struct__PangoAttrList = opaque {};
pub const PangoAttrList = struct__PangoAttrList;
pub const struct__PangoAttrIterator = opaque {};
pub const PangoAttrIterator = struct__PangoAttrIterator;
pub extern fn pango_attr_list_get_type() GType;
pub extern fn pango_attr_list_new() ?*PangoAttrList;
pub extern fn pango_attr_list_ref(list: ?*PangoAttrList) ?*PangoAttrList;
pub extern fn pango_attr_list_unref(list: ?*PangoAttrList) void;
pub extern fn pango_attr_list_copy(list: ?*PangoAttrList) ?*PangoAttrList;
pub extern fn pango_attr_list_insert(list: ?*PangoAttrList, attr: [*c]PangoAttribute) void;
pub extern fn pango_attr_list_insert_before(list: ?*PangoAttrList, attr: [*c]PangoAttribute) void;
pub extern fn pango_attr_list_change(list: ?*PangoAttrList, attr: [*c]PangoAttribute) void;
pub extern fn pango_attr_list_splice(list: ?*PangoAttrList, other: ?*PangoAttrList, pos: c_int, len: c_int) void;
pub extern fn pango_attr_list_update(list: ?*PangoAttrList, pos: c_int, remove: c_int, add: c_int) void;
pub extern fn pango_attr_list_filter(list: ?*PangoAttrList, func: PangoAttrFilterFunc, data: gpointer) ?*PangoAttrList;
pub extern fn pango_attr_list_get_attributes(list: ?*PangoAttrList) [*c]GSList;
pub extern fn pango_attr_list_equal(list: ?*PangoAttrList, other_list: ?*PangoAttrList) gboolean;
pub extern fn pango_attr_list_to_string(list: ?*PangoAttrList) [*c]u8;
pub extern fn pango_attr_list_from_string(text: [*c]const u8) ?*PangoAttrList;
pub extern fn pango_attr_iterator_get_type() GType;
pub extern fn pango_attr_list_get_iterator(list: ?*PangoAttrList) ?*PangoAttrIterator;
pub extern fn pango_attr_iterator_range(iterator: ?*PangoAttrIterator, start: [*c]c_int, end: [*c]c_int) void;
pub extern fn pango_attr_iterator_next(iterator: ?*PangoAttrIterator) gboolean;
pub extern fn pango_attr_iterator_copy(iterator: ?*PangoAttrIterator) ?*PangoAttrIterator;
pub extern fn pango_attr_iterator_destroy(iterator: ?*PangoAttrIterator) void;
pub extern fn pango_attr_iterator_get(iterator: ?*PangoAttrIterator, @"type": PangoAttrType) [*c]PangoAttribute;
pub extern fn pango_attr_iterator_get_font(iterator: ?*PangoAttrIterator, desc: ?*PangoFontDescription, language: [*c]?*PangoLanguage, extra_attrs: [*c][*c]GSList) void;
pub extern fn pango_attr_iterator_get_attrs(iterator: ?*PangoAttrIterator) [*c]GSList;
pub const PangoAttribute_autoptr = [*c]PangoAttribute;
pub const PangoAttribute_listautoptr = [*c]GList;
pub const PangoAttribute_slistautoptr = [*c]GSList;
pub const PangoAttribute_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoAttribute(arg__ptr: [*c]PangoAttribute) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        pango_attribute_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_PangoAttribute(arg__ptr: [*c][*c]PangoAttribute) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoAttribute(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoAttribute(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attribute_destroy)))))));
}
pub fn glib_slistautoptr_cleanup_PangoAttribute(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attribute_destroy)))))));
}
pub fn glib_queueautoptr_cleanup_PangoAttribute(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attribute_destroy)))))));
    }
}
pub const PangoAttrList_autoptr = ?*PangoAttrList;
pub const PangoAttrList_listautoptr = [*c]GList;
pub const PangoAttrList_slistautoptr = [*c]GSList;
pub const PangoAttrList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoAttrList(arg__ptr: ?*PangoAttrList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        pango_attr_list_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_PangoAttrList(arg__ptr: [*c]?*PangoAttrList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoAttrList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoAttrList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attr_list_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoAttrList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attr_list_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoAttrList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attr_list_unref)))))));
    }
}
pub const PangoAttrIterator_autoptr = ?*PangoAttrIterator;
pub const PangoAttrIterator_listautoptr = [*c]GList;
pub const PangoAttrIterator_slistautoptr = [*c]GSList;
pub const PangoAttrIterator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoAttrIterator(arg__ptr: ?*PangoAttrIterator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        pango_attr_iterator_destroy(_ptr);
    }
}
pub fn glib_autoptr_cleanup_PangoAttrIterator(arg__ptr: [*c]?*PangoAttrIterator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoAttrIterator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoAttrIterator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attr_iterator_destroy)))))));
}
pub fn glib_slistautoptr_cleanup_PangoAttrIterator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attr_iterator_destroy)))))));
}
pub fn glib_queueautoptr_cleanup_PangoAttrIterator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_attr_iterator_destroy)))))));
    }
}
pub const struct__PangoAnalysis = extern struct {
    shape_engine: [*c]PangoEngineShape,
    lang_engine: [*c]PangoEngineLang,
    font: [*c]PangoFont,
    level: guint8,
    gravity: guint8,
    flags: guint8,
    script: guint8,
    language: ?*PangoLanguage,
    extra_attrs: [*c]GSList,
};
pub const PangoAnalysis = struct__PangoAnalysis;
pub const struct__PangoItem = extern struct {
    offset: c_int,
    length: c_int,
    num_chars: c_int,
    analysis: PangoAnalysis,
};
pub const PangoItem = struct__PangoItem;
pub extern fn pango_item_get_type() GType;
pub extern fn pango_item_new() [*c]PangoItem;
pub extern fn pango_item_copy(item: [*c]PangoItem) [*c]PangoItem;
pub extern fn pango_item_free(item: [*c]PangoItem) void;
pub extern fn pango_item_split(orig: [*c]PangoItem, split_index: c_int, split_offset: c_int) [*c]PangoItem;
pub extern fn pango_item_apply_attrs(item: [*c]PangoItem, iter: ?*PangoAttrIterator) void;
pub extern fn pango_reorder_items(items: [*c]GList) [*c]GList;
pub extern fn pango_itemize(context: ?*PangoContext, text: [*c]const u8, start_index: c_int, length: c_int, attrs: ?*PangoAttrList, cached_iter: ?*PangoAttrIterator) [*c]GList;
pub extern fn pango_itemize_with_base_dir(context: ?*PangoContext, base_dir: PangoDirection, text: [*c]const u8, start_index: c_int, length: c_int, attrs: ?*PangoAttrList, cached_iter: ?*PangoAttrIterator) [*c]GList;
pub extern fn pango_break(text: [*c]const u8, length: c_int, analysis: [*c]PangoAnalysis, attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_get_log_attrs(text: [*c]const u8, length: c_int, level: c_int, language: ?*PangoLanguage, attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_default_break(text: [*c]const u8, length: c_int, analysis: [*c]PangoAnalysis, attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_tailor_break(text: [*c]const u8, length: c_int, analysis: [*c]PangoAnalysis, offset: c_int, attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_attr_break(text: [*c]const u8, length: c_int, attr_list: ?*PangoAttrList, offset: c_int, attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_fontset_get_type() GType;
pub const struct__PangoFontset = extern struct {
    parent_instance: GObject,
};
pub const PangoFontset = struct__PangoFontset;
pub const PangoFontsetForeachFunc = ?*const fn ([*c]PangoFontset, [*c]PangoFont, gpointer) callconv(.C) gboolean;
pub const struct__PangoFontsetClass = extern struct {
    parent_class: GObjectClass,
    get_font: ?*const fn ([*c]PangoFontset, guint) callconv(.C) [*c]PangoFont,
    get_metrics: ?*const fn ([*c]PangoFontset) callconv(.C) [*c]PangoFontMetrics,
    get_language: ?*const fn ([*c]PangoFontset) callconv(.C) ?*PangoLanguage,
    foreach: ?*const fn ([*c]PangoFontset, PangoFontsetForeachFunc, gpointer) callconv(.C) void,
    _pango_reserved1: ?*const fn () callconv(.C) void,
    _pango_reserved2: ?*const fn () callconv(.C) void,
    _pango_reserved3: ?*const fn () callconv(.C) void,
    _pango_reserved4: ?*const fn () callconv(.C) void,
};
pub const PangoFontsetClass = struct__PangoFontsetClass;
pub extern fn pango_fontset_get_font(fontset: [*c]PangoFontset, wc: guint) [*c]PangoFont;
pub extern fn pango_fontset_get_metrics(fontset: [*c]PangoFontset) [*c]PangoFontMetrics;
pub extern fn pango_fontset_foreach(fontset: [*c]PangoFontset, func: PangoFontsetForeachFunc, data: gpointer) void;
pub const struct__PangoFontMapClass = extern struct {
    parent_class: GObjectClass,
    load_font: ?*const fn ([*c]PangoFontMap, ?*PangoContext, ?*const PangoFontDescription) callconv(.C) [*c]PangoFont,
    list_families: ?*const fn ([*c]PangoFontMap, [*c][*c][*c]PangoFontFamily, [*c]c_int) callconv(.C) void,
    load_fontset: ?*const fn ([*c]PangoFontMap, ?*PangoContext, ?*const PangoFontDescription, ?*PangoLanguage) callconv(.C) [*c]PangoFontset,
    shape_engine_type: [*c]const u8,
    get_serial: ?*const fn ([*c]PangoFontMap) callconv(.C) guint,
    changed: ?*const fn ([*c]PangoFontMap) callconv(.C) void,
    get_family: ?*const fn ([*c]PangoFontMap, [*c]const u8) callconv(.C) [*c]PangoFontFamily,
    get_face: ?*const fn ([*c]PangoFontMap, [*c]PangoFont) callconv(.C) [*c]PangoFontFace,
};
pub const PangoFontMapClass = struct__PangoFontMapClass;
pub extern fn pango_font_map_get_type() GType;
pub extern fn pango_font_map_create_context(fontmap: [*c]PangoFontMap) ?*PangoContext;
pub extern fn pango_font_map_load_font(fontmap: [*c]PangoFontMap, context: ?*PangoContext, desc: ?*const PangoFontDescription) [*c]PangoFont;
pub extern fn pango_font_map_load_fontset(fontmap: [*c]PangoFontMap, context: ?*PangoContext, desc: ?*const PangoFontDescription, language: ?*PangoLanguage) [*c]PangoFontset;
pub extern fn pango_font_map_list_families(fontmap: [*c]PangoFontMap, families: [*c][*c][*c]PangoFontFamily, n_families: [*c]c_int) void;
pub extern fn pango_font_map_get_serial(fontmap: [*c]PangoFontMap) guint;
pub extern fn pango_font_map_changed(fontmap: [*c]PangoFontMap) void;
pub extern fn pango_font_map_get_family(fontmap: [*c]PangoFontMap, name: [*c]const u8) [*c]PangoFontFamily;
pub const PangoFontMap_autoptr = [*c]PangoFontMap;
pub const PangoFontMap_listautoptr = [*c]GList;
pub const PangoFontMap_slistautoptr = [*c]GSList;
pub const PangoFontMap_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoFontMap(arg__ptr: [*c]PangoFontMap) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_PangoFontMap(arg__ptr: [*c][*c]PangoFontMap) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoFontMap(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoFontMap(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoFontMap(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoFontMap(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__PangoContextClass = opaque {};
pub const PangoContextClass = struct__PangoContextClass;
pub extern fn pango_context_get_type() GType;
pub extern fn pango_context_new() ?*PangoContext;
pub extern fn pango_context_changed(context: ?*PangoContext) void;
pub extern fn pango_context_set_font_map(context: ?*PangoContext, font_map: [*c]PangoFontMap) void;
pub extern fn pango_context_get_font_map(context: ?*PangoContext) [*c]PangoFontMap;
pub extern fn pango_context_get_serial(context: ?*PangoContext) guint;
pub extern fn pango_context_list_families(context: ?*PangoContext, families: [*c][*c][*c]PangoFontFamily, n_families: [*c]c_int) void;
pub extern fn pango_context_load_font(context: ?*PangoContext, desc: ?*const PangoFontDescription) [*c]PangoFont;
pub extern fn pango_context_load_fontset(context: ?*PangoContext, desc: ?*const PangoFontDescription, language: ?*PangoLanguage) [*c]PangoFontset;
pub extern fn pango_context_get_metrics(context: ?*PangoContext, desc: ?*const PangoFontDescription, language: ?*PangoLanguage) [*c]PangoFontMetrics;
pub extern fn pango_context_set_font_description(context: ?*PangoContext, desc: ?*const PangoFontDescription) void;
pub extern fn pango_context_get_font_description(context: ?*PangoContext) ?*PangoFontDescription;
pub extern fn pango_context_get_language(context: ?*PangoContext) ?*PangoLanguage;
pub extern fn pango_context_set_language(context: ?*PangoContext, language: ?*PangoLanguage) void;
pub extern fn pango_context_set_base_dir(context: ?*PangoContext, direction: PangoDirection) void;
pub extern fn pango_context_get_base_dir(context: ?*PangoContext) PangoDirection;
pub extern fn pango_context_set_base_gravity(context: ?*PangoContext, gravity: PangoGravity) void;
pub extern fn pango_context_get_base_gravity(context: ?*PangoContext) PangoGravity;
pub extern fn pango_context_get_gravity(context: ?*PangoContext) PangoGravity;
pub extern fn pango_context_set_gravity_hint(context: ?*PangoContext, hint: PangoGravityHint) void;
pub extern fn pango_context_get_gravity_hint(context: ?*PangoContext) PangoGravityHint;
pub extern fn pango_context_set_matrix(context: ?*PangoContext, matrix: [*c]const PangoMatrix) void;
pub extern fn pango_context_get_matrix(context: ?*PangoContext) [*c]const PangoMatrix;
pub extern fn pango_context_set_round_glyph_positions(context: ?*PangoContext, round_positions: gboolean) void;
pub extern fn pango_context_get_round_glyph_positions(context: ?*PangoContext) gboolean;
pub const PangoGlyphUnit = gint32;
pub const struct__PangoGlyphGeometry = extern struct {
    width: PangoGlyphUnit,
    x_offset: PangoGlyphUnit,
    y_offset: PangoGlyphUnit,
};
pub const PangoGlyphGeometry = struct__PangoGlyphGeometry; // /usr/include/pango-1.0/pango/pango-glyph.h:105:9: warning: struct demoted to opaque type - has bitfield
pub const struct__PangoGlyphVisAttr = opaque {};
pub const PangoGlyphVisAttr = struct__PangoGlyphVisAttr;
pub const struct__PangoGlyphInfo = extern struct {
    glyph: PangoGlyph,
    geometry: PangoGlyphGeometry,
    attr: PangoGlyphVisAttr,
};
pub const PangoGlyphInfo = struct__PangoGlyphInfo;
pub const struct__PangoGlyphString = extern struct {
    num_glyphs: c_int,
    glyphs: ?*PangoGlyphInfo,
    log_clusters: [*c]c_int,
    space: c_int,
};
pub const PangoGlyphString = struct__PangoGlyphString;
pub extern fn pango_glyph_string_get_type() GType;
pub extern fn pango_glyph_string_new() [*c]PangoGlyphString;
pub extern fn pango_glyph_string_set_size(string: [*c]PangoGlyphString, new_len: c_int) void;
pub extern fn pango_glyph_string_copy(string: [*c]PangoGlyphString) [*c]PangoGlyphString;
pub extern fn pango_glyph_string_free(string: [*c]PangoGlyphString) void;
pub extern fn pango_glyph_string_extents(glyphs: [*c]PangoGlyphString, font: [*c]PangoFont, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_glyph_string_get_width(glyphs: [*c]PangoGlyphString) c_int;
pub extern fn pango_glyph_string_extents_range(glyphs: [*c]PangoGlyphString, start: c_int, end: c_int, font: [*c]PangoFont, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_glyph_string_get_logical_widths(glyphs: [*c]PangoGlyphString, text: [*c]const u8, length: c_int, embedding_level: c_int, logical_widths: [*c]c_int) void;
pub extern fn pango_glyph_string_index_to_x(glyphs: [*c]PangoGlyphString, text: [*c]const u8, length: c_int, analysis: [*c]PangoAnalysis, index_: c_int, trailing: gboolean, x_pos: [*c]c_int) void;
pub extern fn pango_glyph_string_x_to_index(glyphs: [*c]PangoGlyphString, text: [*c]const u8, length: c_int, analysis: [*c]PangoAnalysis, x_pos: c_int, index_: [*c]c_int, trailing: [*c]c_int) void;
pub extern fn pango_glyph_string_index_to_x_full(glyphs: [*c]PangoGlyphString, text: [*c]const u8, length: c_int, analysis: [*c]PangoAnalysis, attrs: ?*PangoLogAttr, index_: c_int, trailing: gboolean, x_pos: [*c]c_int) void;
pub const PANGO_SHAPE_NONE: c_int = 0;
pub const PANGO_SHAPE_ROUND_POSITIONS: c_int = 1;
pub const PangoShapeFlags = c_uint;
pub extern fn pango_shape(text: [*c]const u8, length: c_int, analysis: [*c]const PangoAnalysis, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_shape_full(item_text: [*c]const u8, item_length: c_int, paragraph_text: [*c]const u8, paragraph_length: c_int, analysis: [*c]const PangoAnalysis, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_shape_with_flags(item_text: [*c]const u8, item_length: c_int, paragraph_text: [*c]const u8, paragraph_length: c_int, analysis: [*c]const PangoAnalysis, glyphs: [*c]PangoGlyphString, flags: PangoShapeFlags) void;
pub extern fn pango_shape_item(item: [*c]PangoItem, paragraph_text: [*c]const u8, paragraph_length: c_int, log_attrs: ?*PangoLogAttr, glyphs: [*c]PangoGlyphString, flags: PangoShapeFlags) void;
pub const struct__PangoEngineClass = extern struct {
    parent_class: GObjectClass,
};
pub const PangoEngineClass = struct__PangoEngineClass;
pub extern fn pango_engine_get_type() GType;
pub const struct__PangoEngineLangClass = extern struct {
    parent_class: PangoEngineClass,
    script_break: ?*const fn ([*c]PangoEngineLang, [*c]const u8, c_int, [*c]PangoAnalysis, ?*PangoLogAttr, c_int) callconv(.C) void,
};
pub const PangoEngineLangClass = struct__PangoEngineLangClass;
pub extern fn pango_engine_lang_get_type() GType;
pub const struct__PangoEngineShapeClass = extern struct {
    parent_class: PangoEngineClass,
    script_shape: ?*const fn ([*c]PangoEngineShape, [*c]PangoFont, [*c]const u8, c_uint, [*c]const PangoAnalysis, [*c]PangoGlyphString, [*c]const u8, c_uint) callconv(.C) void,
    covers: ?*const fn ([*c]PangoEngineShape, [*c]PangoFont, ?*PangoLanguage, gunichar) callconv(.C) PangoCoverageLevel,
};
pub const PangoEngineShapeClass = struct__PangoEngineShapeClass;
pub extern fn pango_engine_shape_get_type() GType;
pub const struct__PangoEngineScriptInfo = extern struct {
    script: PangoScript,
    langs: [*c]const gchar,
};
pub const PangoEngineScriptInfo = struct__PangoEngineScriptInfo;
pub const struct__PangoEngineInfo = extern struct {
    id: [*c]const gchar,
    engine_type: [*c]const gchar,
    render_type: [*c]const gchar,
    scripts: [*c]PangoEngineScriptInfo,
    n_scripts: gint,
};
pub const PangoEngineInfo = struct__PangoEngineInfo;
pub extern fn script_engine_list(engines: [*c][*c]PangoEngineInfo, n_engines: [*c]c_int) void;
pub extern fn script_engine_init(module: [*c]GTypeModule) void;
pub extern fn script_engine_exit() void;
pub extern fn script_engine_create(id: [*c]const u8) [*c]PangoEngine;
pub extern fn pango_attr_type_get_type() GType;
pub extern fn pango_underline_get_type() GType;
pub extern fn pango_overline_get_type() GType;
pub extern fn pango_show_flags_get_type() GType;
pub extern fn pango_text_transform_get_type() GType;
pub extern fn pango_baseline_shift_get_type() GType;
pub extern fn pango_font_scale_get_type() GType;
pub extern fn pango_bidi_type_get_type() GType;
pub extern fn pango_coverage_level_get_type() GType;
pub extern fn pango_direction_get_type() GType;
pub extern fn pango_style_get_type() GType;
pub extern fn pango_variant_get_type() GType;
pub extern fn pango_weight_get_type() GType;
pub extern fn pango_stretch_get_type() GType;
pub extern fn pango_font_mask_get_type() GType;
pub extern fn pango_shape_flags_get_type() GType;
pub extern fn pango_gravity_get_type() GType;
pub extern fn pango_gravity_hint_get_type() GType;
pub extern fn pango_alignment_get_type() GType;
pub extern fn pango_wrap_mode_get_type() GType;
pub extern fn pango_ellipsize_mode_get_type() GType;
pub extern fn pango_layout_serialize_flags_get_type() GType;
pub extern fn pango_layout_deserialize_error_get_type() GType;
pub extern fn pango_layout_deserialize_flags_get_type() GType;
pub extern fn pango_render_part_get_type() GType;
pub extern fn pango_script_get_type() GType;
pub extern fn pango_tab_align_get_type() GType;
pub const struct__PangoFontsetSimple = opaque {};
pub const PangoFontsetSimple = struct__PangoFontsetSimple;
pub const struct__PangoFontsetSimpleClass = opaque {};
pub const PangoFontsetSimpleClass = struct__PangoFontsetSimpleClass;
pub extern fn pango_fontset_simple_get_type() GType;
pub extern fn pango_fontset_simple_new(language: ?*PangoLanguage) ?*PangoFontsetSimple;
pub extern fn pango_fontset_simple_append(fontset: ?*PangoFontsetSimple, font: [*c]PangoFont) void;
pub extern fn pango_fontset_simple_size(fontset: ?*PangoFontsetSimple) c_int;
pub const struct__PangoGlyphItem = extern struct {
    item: [*c]PangoItem,
    glyphs: [*c]PangoGlyphString,
    y_offset: c_int,
    start_x_offset: c_int,
    end_x_offset: c_int,
};
pub const PangoGlyphItem = struct__PangoGlyphItem;
pub extern fn pango_glyph_item_get_type() GType;
pub extern fn pango_glyph_item_split(orig: [*c]PangoGlyphItem, text: [*c]const u8, split_index: c_int) [*c]PangoGlyphItem;
pub extern fn pango_glyph_item_copy(orig: [*c]PangoGlyphItem) [*c]PangoGlyphItem;
pub extern fn pango_glyph_item_free(glyph_item: [*c]PangoGlyphItem) void;
pub extern fn pango_glyph_item_apply_attrs(glyph_item: [*c]PangoGlyphItem, text: [*c]const u8, list: ?*PangoAttrList) [*c]GSList;
pub extern fn pango_glyph_item_letter_space(glyph_item: [*c]PangoGlyphItem, text: [*c]const u8, log_attrs: ?*PangoLogAttr, letter_spacing: c_int) void;
pub extern fn pango_glyph_item_get_logical_widths(glyph_item: [*c]PangoGlyphItem, text: [*c]const u8, logical_widths: [*c]c_int) void;
pub const struct__PangoGlyphItemIter = extern struct {
    glyph_item: [*c]PangoGlyphItem,
    text: [*c]const gchar,
    start_glyph: c_int,
    start_index: c_int,
    start_char: c_int,
    end_glyph: c_int,
    end_index: c_int,
    end_char: c_int,
};
pub const PangoGlyphItemIter = struct__PangoGlyphItemIter;
pub extern fn pango_glyph_item_iter_get_type() GType;
pub extern fn pango_glyph_item_iter_copy(orig: [*c]PangoGlyphItemIter) [*c]PangoGlyphItemIter;
pub extern fn pango_glyph_item_iter_free(iter: [*c]PangoGlyphItemIter) void;
pub extern fn pango_glyph_item_iter_init_start(iter: [*c]PangoGlyphItemIter, glyph_item: [*c]PangoGlyphItem, text: [*c]const u8) gboolean;
pub extern fn pango_glyph_item_iter_init_end(iter: [*c]PangoGlyphItemIter, glyph_item: [*c]PangoGlyphItem, text: [*c]const u8) gboolean;
pub extern fn pango_glyph_item_iter_next_cluster(iter: [*c]PangoGlyphItemIter) gboolean;
pub extern fn pango_glyph_item_iter_prev_cluster(iter: [*c]PangoGlyphItemIter) gboolean;
pub const struct__PangoTabArray = opaque {};
pub const PangoTabArray = struct__PangoTabArray;
pub const PANGO_TAB_LEFT: c_int = 0;
pub const PANGO_TAB_RIGHT: c_int = 1;
pub const PANGO_TAB_CENTER: c_int = 2;
pub const PANGO_TAB_DECIMAL: c_int = 3;
pub const PangoTabAlign = c_uint;
pub extern fn pango_tab_array_new(initial_size: gint, positions_in_pixels: gboolean) ?*PangoTabArray;
pub extern fn pango_tab_array_new_with_positions(size: gint, positions_in_pixels: gboolean, first_alignment: PangoTabAlign, first_position: gint, ...) ?*PangoTabArray;
pub extern fn pango_tab_array_get_type() GType;
pub extern fn pango_tab_array_copy(src: ?*PangoTabArray) ?*PangoTabArray;
pub extern fn pango_tab_array_free(tab_array: ?*PangoTabArray) void;
pub extern fn pango_tab_array_get_size(tab_array: ?*PangoTabArray) gint;
pub extern fn pango_tab_array_resize(tab_array: ?*PangoTabArray, new_size: gint) void;
pub extern fn pango_tab_array_set_tab(tab_array: ?*PangoTabArray, tab_index: gint, alignment: PangoTabAlign, location: gint) void;
pub extern fn pango_tab_array_get_tab(tab_array: ?*PangoTabArray, tab_index: gint, alignment: [*c]PangoTabAlign, location: [*c]gint) void;
pub extern fn pango_tab_array_get_tabs(tab_array: ?*PangoTabArray, alignments: [*c][*c]PangoTabAlign, locations: [*c][*c]gint) void;
pub extern fn pango_tab_array_get_positions_in_pixels(tab_array: ?*PangoTabArray) gboolean;
pub extern fn pango_tab_array_set_positions_in_pixels(tab_array: ?*PangoTabArray, positions_in_pixels: gboolean) void;
pub extern fn pango_tab_array_to_string(tab_array: ?*PangoTabArray) [*c]u8;
pub extern fn pango_tab_array_from_string(text: [*c]const u8) ?*PangoTabArray;
pub extern fn pango_tab_array_set_decimal_point(tab_array: ?*PangoTabArray, tab_index: c_int, decimal_point: gunichar) void;
pub extern fn pango_tab_array_get_decimal_point(tab_array: ?*PangoTabArray, tab_index: c_int) gunichar;
pub extern fn pango_tab_array_sort(tab_array: ?*PangoTabArray) void;
pub const PangoTabArray_autoptr = ?*PangoTabArray;
pub const PangoTabArray_listautoptr = [*c]GList;
pub const PangoTabArray_slistautoptr = [*c]GSList;
pub const PangoTabArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoTabArray(arg__ptr: ?*PangoTabArray) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        pango_tab_array_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_PangoTabArray(arg__ptr: [*c]?*PangoTabArray) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoTabArray(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoTabArray(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_tab_array_free)))))));
}
pub fn glib_slistautoptr_cleanup_PangoTabArray(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_tab_array_free)))))));
}
pub fn glib_queueautoptr_cleanup_PangoTabArray(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_tab_array_free)))))));
    }
}
pub const struct__PangoLayout = opaque {};
pub const PangoLayout = struct__PangoLayout;
pub const struct__PangoLayoutClass = opaque {};
pub const PangoLayoutClass = struct__PangoLayoutClass; // /usr/include/pango-1.0/pango/pango-layout.h:132:16: warning: struct demoted to opaque type - has bitfield
pub const struct__PangoLayoutLine = opaque {};
pub const PangoLayoutLine = struct__PangoLayoutLine;
pub const PangoLayoutRun = PangoGlyphItem;
pub const PANGO_ALIGN_LEFT: c_int = 0;
pub const PANGO_ALIGN_CENTER: c_int = 1;
pub const PANGO_ALIGN_RIGHT: c_int = 2;
pub const PangoAlignment = c_uint;
pub const PANGO_WRAP_WORD: c_int = 0;
pub const PANGO_WRAP_CHAR: c_int = 1;
pub const PANGO_WRAP_WORD_CHAR: c_int = 2;
pub const PangoWrapMode = c_uint;
pub const PANGO_ELLIPSIZE_NONE: c_int = 0;
pub const PANGO_ELLIPSIZE_START: c_int = 1;
pub const PANGO_ELLIPSIZE_MIDDLE: c_int = 2;
pub const PANGO_ELLIPSIZE_END: c_int = 3;
pub const PangoEllipsizeMode = c_uint;
pub extern fn pango_layout_get_type() GType;
pub extern fn pango_layout_new(context: ?*PangoContext) ?*PangoLayout;
pub extern fn pango_layout_copy(src: ?*PangoLayout) ?*PangoLayout;
pub extern fn pango_layout_get_context(layout: ?*PangoLayout) ?*PangoContext;
pub extern fn pango_layout_set_attributes(layout: ?*PangoLayout, attrs: ?*PangoAttrList) void;
pub extern fn pango_layout_get_attributes(layout: ?*PangoLayout) ?*PangoAttrList;
pub extern fn pango_layout_set_text(layout: ?*PangoLayout, text: [*c]const u8, length: c_int) void;
pub extern fn pango_layout_get_text(layout: ?*PangoLayout) [*c]const u8;
pub extern fn pango_layout_get_character_count(layout: ?*PangoLayout) gint;
pub extern fn pango_layout_set_markup(layout: ?*PangoLayout, markup: [*c]const u8, length: c_int) void;
pub extern fn pango_layout_set_markup_with_accel(layout: ?*PangoLayout, markup: [*c]const u8, length: c_int, accel_marker: gunichar, accel_char: [*c]gunichar) void;
pub extern fn pango_layout_set_font_description(layout: ?*PangoLayout, desc: ?*const PangoFontDescription) void;
pub extern fn pango_layout_get_font_description(layout: ?*PangoLayout) ?*const PangoFontDescription;
pub extern fn pango_layout_set_width(layout: ?*PangoLayout, width: c_int) void;
pub extern fn pango_layout_get_width(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_height(layout: ?*PangoLayout, height: c_int) void;
pub extern fn pango_layout_get_height(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_wrap(layout: ?*PangoLayout, wrap: PangoWrapMode) void;
pub extern fn pango_layout_get_wrap(layout: ?*PangoLayout) PangoWrapMode;
pub extern fn pango_layout_is_wrapped(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_indent(layout: ?*PangoLayout, indent: c_int) void;
pub extern fn pango_layout_get_indent(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_spacing(layout: ?*PangoLayout, spacing: c_int) void;
pub extern fn pango_layout_get_spacing(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_line_spacing(layout: ?*PangoLayout, factor: f32) void;
pub extern fn pango_layout_get_line_spacing(layout: ?*PangoLayout) f32;
pub extern fn pango_layout_set_justify(layout: ?*PangoLayout, justify: gboolean) void;
pub extern fn pango_layout_get_justify(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_justify_last_line(layout: ?*PangoLayout, justify: gboolean) void;
pub extern fn pango_layout_get_justify_last_line(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_auto_dir(layout: ?*PangoLayout, auto_dir: gboolean) void;
pub extern fn pango_layout_get_auto_dir(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_alignment(layout: ?*PangoLayout, alignment: PangoAlignment) void;
pub extern fn pango_layout_get_alignment(layout: ?*PangoLayout) PangoAlignment;
pub extern fn pango_layout_set_tabs(layout: ?*PangoLayout, tabs: ?*PangoTabArray) void;
pub extern fn pango_layout_get_tabs(layout: ?*PangoLayout) ?*PangoTabArray;
pub extern fn pango_layout_set_single_paragraph_mode(layout: ?*PangoLayout, setting: gboolean) void;
pub extern fn pango_layout_get_single_paragraph_mode(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_ellipsize(layout: ?*PangoLayout, ellipsize: PangoEllipsizeMode) void;
pub extern fn pango_layout_get_ellipsize(layout: ?*PangoLayout) PangoEllipsizeMode;
pub extern fn pango_layout_is_ellipsized(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_get_unknown_glyphs_count(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_get_direction(layout: ?*PangoLayout, index: c_int) PangoDirection;
pub extern fn pango_layout_context_changed(layout: ?*PangoLayout) void;
pub extern fn pango_layout_get_serial(layout: ?*PangoLayout) guint;
pub extern fn pango_layout_get_log_attrs(layout: ?*PangoLayout, attrs: [*c]?*PangoLogAttr, n_attrs: [*c]gint) void;
pub extern fn pango_layout_get_log_attrs_readonly(layout: ?*PangoLayout, n_attrs: [*c]gint) ?*const PangoLogAttr;
pub extern fn pango_layout_index_to_pos(layout: ?*PangoLayout, index_: c_int, pos: [*c]PangoRectangle) void;
pub extern fn pango_layout_index_to_line_x(layout: ?*PangoLayout, index_: c_int, trailing: gboolean, line: [*c]c_int, x_pos: [*c]c_int) void;
pub extern fn pango_layout_get_cursor_pos(layout: ?*PangoLayout, index_: c_int, strong_pos: [*c]PangoRectangle, weak_pos: [*c]PangoRectangle) void;
pub extern fn pango_layout_get_caret_pos(layout: ?*PangoLayout, index_: c_int, strong_pos: [*c]PangoRectangle, weak_pos: [*c]PangoRectangle) void;
pub extern fn pango_layout_move_cursor_visually(layout: ?*PangoLayout, strong: gboolean, old_index: c_int, old_trailing: c_int, direction: c_int, new_index: [*c]c_int, new_trailing: [*c]c_int) void;
pub extern fn pango_layout_xy_to_index(layout: ?*PangoLayout, x: c_int, y: c_int, index_: [*c]c_int, trailing: [*c]c_int) gboolean;
pub extern fn pango_layout_get_extents(layout: ?*PangoLayout, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_get_pixel_extents(layout: ?*PangoLayout, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_get_size(layout: ?*PangoLayout, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn pango_layout_get_pixel_size(layout: ?*PangoLayout, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn pango_layout_get_baseline(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_get_line_count(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_get_line(layout: ?*PangoLayout, line: c_int) ?*PangoLayoutLine;
pub extern fn pango_layout_get_line_readonly(layout: ?*PangoLayout, line: c_int) ?*PangoLayoutLine;
pub extern fn pango_layout_get_lines(layout: ?*PangoLayout) [*c]GSList;
pub extern fn pango_layout_get_lines_readonly(layout: ?*PangoLayout) [*c]GSList;
pub const PANGO_LAYOUT_SERIALIZE_DEFAULT: c_int = 0;
pub const PANGO_LAYOUT_SERIALIZE_CONTEXT: c_int = 1;
pub const PANGO_LAYOUT_SERIALIZE_OUTPUT: c_int = 2;
pub const PangoLayoutSerializeFlags = c_uint;
pub extern fn pango_layout_serialize(layout: ?*PangoLayout, flags: PangoLayoutSerializeFlags) ?*GBytes;
pub extern fn pango_layout_write_to_file(layout: ?*PangoLayout, flags: PangoLayoutSerializeFlags, filename: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub const PANGO_LAYOUT_DESERIALIZE_INVALID: c_int = 0;
pub const PANGO_LAYOUT_DESERIALIZE_INVALID_VALUE: c_int = 1;
pub const PANGO_LAYOUT_DESERIALIZE_MISSING_VALUE: c_int = 2;
pub const PangoLayoutDeserializeError = c_uint;
pub extern fn pango_layout_deserialize_error_quark() GQuark;
pub const PANGO_LAYOUT_DESERIALIZE_DEFAULT: c_int = 0;
pub const PANGO_LAYOUT_DESERIALIZE_CONTEXT: c_int = 1;
pub const PangoLayoutDeserializeFlags = c_uint;
pub extern fn pango_layout_deserialize(context: ?*PangoContext, bytes: ?*GBytes, flags: PangoLayoutDeserializeFlags, @"error": [*c][*c]GError) ?*PangoLayout;
pub extern fn pango_layout_line_get_type() GType;
pub extern fn pango_layout_line_ref(line: ?*PangoLayoutLine) ?*PangoLayoutLine;
pub extern fn pango_layout_line_unref(line: ?*PangoLayoutLine) void;
pub extern fn pango_layout_line_get_start_index(line: ?*PangoLayoutLine) c_int;
pub extern fn pango_layout_line_get_length(line: ?*PangoLayoutLine) c_int;
pub extern fn pango_layout_line_is_paragraph_start(line: ?*PangoLayoutLine) gboolean;
pub extern fn pango_layout_line_get_resolved_direction(line: ?*PangoLayoutLine) PangoDirection;
pub extern fn pango_layout_line_x_to_index(line: ?*PangoLayoutLine, x_pos: c_int, index_: [*c]c_int, trailing: [*c]c_int) gboolean;
pub extern fn pango_layout_line_index_to_x(line: ?*PangoLayoutLine, index_: c_int, trailing: gboolean, x_pos: [*c]c_int) void;
pub extern fn pango_layout_line_get_x_ranges(line: ?*PangoLayoutLine, start_index: c_int, end_index: c_int, ranges: [*c][*c]c_int, n_ranges: [*c]c_int) void;
pub extern fn pango_layout_line_get_extents(line: ?*PangoLayoutLine, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_line_get_height(line: ?*PangoLayoutLine, height: [*c]c_int) void;
pub extern fn pango_layout_line_get_pixel_extents(layout_line: ?*PangoLayoutLine, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub const struct__PangoLayoutIter = opaque {};
pub const PangoLayoutIter = struct__PangoLayoutIter;
pub extern fn pango_layout_iter_get_type() GType;
pub extern fn pango_layout_get_iter(layout: ?*PangoLayout) ?*PangoLayoutIter;
pub extern fn pango_layout_iter_copy(iter: ?*PangoLayoutIter) ?*PangoLayoutIter;
pub extern fn pango_layout_iter_free(iter: ?*PangoLayoutIter) void;
pub extern fn pango_layout_iter_get_index(iter: ?*PangoLayoutIter) c_int;
pub extern fn pango_layout_iter_get_run(iter: ?*PangoLayoutIter) [*c]PangoLayoutRun;
pub extern fn pango_layout_iter_get_run_readonly(iter: ?*PangoLayoutIter) [*c]PangoLayoutRun;
pub extern fn pango_layout_iter_get_line(iter: ?*PangoLayoutIter) ?*PangoLayoutLine;
pub extern fn pango_layout_iter_get_line_readonly(iter: ?*PangoLayoutIter) ?*PangoLayoutLine;
pub extern fn pango_layout_iter_at_last_line(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_get_layout(iter: ?*PangoLayoutIter) ?*PangoLayout;
pub extern fn pango_layout_iter_next_char(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_next_cluster(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_next_run(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_next_line(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_get_char_extents(iter: ?*PangoLayoutIter, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_cluster_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_run_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_line_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_line_yrange(iter: ?*PangoLayoutIter, y0_: [*c]c_int, y1_: [*c]c_int) void;
pub extern fn pango_layout_iter_get_layout_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_baseline(iter: ?*PangoLayoutIter) c_int;
pub extern fn pango_layout_iter_get_run_baseline(iter: ?*PangoLayoutIter) c_int;
pub const PangoLayout_autoptr = ?*PangoLayout;
pub const PangoLayout_listautoptr = [*c]GList;
pub const PangoLayout_slistautoptr = [*c]GSList;
pub const PangoLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoLayout(arg__ptr: ?*PangoLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_PangoLayout(arg__ptr: [*c]?*PangoLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_PangoLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_PangoLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const PangoLayoutIter_autoptr = ?*PangoLayoutIter;
pub const PangoLayoutIter_listautoptr = [*c]GList;
pub const PangoLayoutIter_slistautoptr = [*c]GSList;
pub const PangoLayoutIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_PangoLayoutIter(arg__ptr: ?*PangoLayoutIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        pango_layout_iter_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_PangoLayoutIter(arg__ptr: [*c]?*PangoLayoutIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_PangoLayoutIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_PangoLayoutIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_layout_iter_free)))))));
}
pub fn glib_slistautoptr_cleanup_PangoLayoutIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_layout_iter_free)))))));
}
pub fn glib_queueautoptr_cleanup_PangoLayoutIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&pango_layout_iter_free)))))));
    }
}
pub extern fn pango_markup_parser_new(accel_marker: gunichar) ?*GMarkupParseContext;
pub extern fn pango_markup_parser_finish(context: ?*GMarkupParseContext, attr_list: [*c]?*PangoAttrList, text: [*c][*c]u8, accel_char: [*c]gunichar, @"error": [*c][*c]GError) gboolean;
pub extern fn pango_parse_markup(markup_text: [*c]const u8, length: c_int, accel_marker: gunichar, attr_list: [*c]?*PangoAttrList, text: [*c][*c]u8, accel_char: [*c]gunichar, @"error": [*c][*c]GError) gboolean;
pub const struct__PangoRendererPrivate = opaque {};
pub const PangoRendererPrivate = struct__PangoRendererPrivate;
pub const struct__PangoRenderer = extern struct {
    parent_instance: GObject,
    underline: PangoUnderline,
    strikethrough: gboolean,
    active_count: c_int,
    matrix: [*c]PangoMatrix,
    priv: ?*PangoRendererPrivate,
};
pub const PangoRenderer = struct__PangoRenderer;
pub const struct__PangoRendererClass = extern struct {
    parent_class: GObjectClass,
    draw_glyphs: ?*const fn ([*c]PangoRenderer, [*c]PangoFont, [*c]PangoGlyphString, c_int, c_int) callconv(.C) void,
    draw_rectangle: ?*const fn ([*c]PangoRenderer, PangoRenderPart, c_int, c_int, c_int, c_int) callconv(.C) void,
    draw_error_underline: ?*const fn ([*c]PangoRenderer, c_int, c_int, c_int, c_int) callconv(.C) void,
    draw_shape: ?*const fn ([*c]PangoRenderer, [*c]PangoAttrShape, c_int, c_int) callconv(.C) void,
    draw_trapezoid: ?*const fn ([*c]PangoRenderer, PangoRenderPart, f64, f64, f64, f64, f64, f64) callconv(.C) void,
    draw_glyph: ?*const fn ([*c]PangoRenderer, [*c]PangoFont, PangoGlyph, f64, f64) callconv(.C) void,
    part_changed: ?*const fn ([*c]PangoRenderer, PangoRenderPart) callconv(.C) void,
    begin: ?*const fn ([*c]PangoRenderer) callconv(.C) void,
    end: ?*const fn ([*c]PangoRenderer) callconv(.C) void,
    prepare_run: ?*const fn ([*c]PangoRenderer, [*c]PangoLayoutRun) callconv(.C) void,
    draw_glyph_item: ?*const fn ([*c]PangoRenderer, [*c]const u8, [*c]PangoGlyphItem, c_int, c_int) callconv(.C) void,
    _pango_reserved2: ?*const fn () callconv(.C) void,
    _pango_reserved3: ?*const fn () callconv(.C) void,
    _pango_reserved4: ?*const fn () callconv(.C) void,
};
pub const PangoRendererClass = struct__PangoRendererClass;
pub const PANGO_RENDER_PART_FOREGROUND: c_int = 0;
pub const PANGO_RENDER_PART_BACKGROUND: c_int = 1;
pub const PANGO_RENDER_PART_UNDERLINE: c_int = 2;
pub const PANGO_RENDER_PART_STRIKETHROUGH: c_int = 3;
pub const PANGO_RENDER_PART_OVERLINE: c_int = 4;
pub const PangoRenderPart = c_uint;
pub extern fn pango_renderer_get_type() GType;
pub extern fn pango_renderer_draw_layout(renderer: [*c]PangoRenderer, layout: ?*PangoLayout, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_layout_line(renderer: [*c]PangoRenderer, line: ?*PangoLayoutLine, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_glyphs(renderer: [*c]PangoRenderer, font: [*c]PangoFont, glyphs: [*c]PangoGlyphString, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_glyph_item(renderer: [*c]PangoRenderer, text: [*c]const u8, glyph_item: [*c]PangoGlyphItem, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_rectangle(renderer: [*c]PangoRenderer, part: PangoRenderPart, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn pango_renderer_draw_error_underline(renderer: [*c]PangoRenderer, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn pango_renderer_draw_trapezoid(renderer: [*c]PangoRenderer, part: PangoRenderPart, y1_: f64, x11: f64, x21: f64, y2: f64, x12: f64, x22: f64) void;
pub extern fn pango_renderer_draw_glyph(renderer: [*c]PangoRenderer, font: [*c]PangoFont, glyph: PangoGlyph, x: f64, y: f64) void;
pub extern fn pango_renderer_activate(renderer: [*c]PangoRenderer) void;
pub extern fn pango_renderer_deactivate(renderer: [*c]PangoRenderer) void;
pub extern fn pango_renderer_part_changed(renderer: [*c]PangoRenderer, part: PangoRenderPart) void;
pub extern fn pango_renderer_set_color(renderer: [*c]PangoRenderer, part: PangoRenderPart, color: [*c]const PangoColor) void;
pub extern fn pango_renderer_get_color(renderer: [*c]PangoRenderer, part: PangoRenderPart) [*c]PangoColor;
pub extern fn pango_renderer_set_alpha(renderer: [*c]PangoRenderer, part: PangoRenderPart, alpha: guint16) void;
pub extern fn pango_renderer_get_alpha(renderer: [*c]PangoRenderer, part: PangoRenderPart) guint16;
pub extern fn pango_renderer_set_matrix(renderer: [*c]PangoRenderer, matrix: [*c]const PangoMatrix) void;
pub extern fn pango_renderer_get_matrix(renderer: [*c]PangoRenderer) [*c]const PangoMatrix;
pub extern fn pango_renderer_get_layout(renderer: [*c]PangoRenderer) ?*PangoLayout;
pub extern fn pango_renderer_get_layout_line(renderer: [*c]PangoRenderer) ?*PangoLayoutLine;
const union_unnamed_50 = extern union {
    __wch: c_uint,
    __wchb: [4]u8,
};
pub const __mbstate_t = extern struct {
    __count: c_int,
    __value: union_unnamed_50,
};
pub const struct__G_fpos_t = extern struct {
    __pos: __off_t,
    __state: __mbstate_t,
};
pub const __fpos_t = struct__G_fpos_t;
pub const struct__G_fpos64_t = extern struct {
    __pos: __off64_t,
    __state: __mbstate_t,
};
pub const __fpos64_t = struct__G_fpos64_t;
pub const struct__IO_marker = opaque {};
pub const _IO_lock_t = anyopaque;
pub const struct__IO_codecvt = opaque {};
pub const struct__IO_wide_data = opaque {};
pub const struct__IO_FILE = extern struct {
    _flags: c_int,
    _IO_read_ptr: [*c]u8,
    _IO_read_end: [*c]u8,
    _IO_read_base: [*c]u8,
    _IO_write_base: [*c]u8,
    _IO_write_ptr: [*c]u8,
    _IO_write_end: [*c]u8,
    _IO_buf_base: [*c]u8,
    _IO_buf_end: [*c]u8,
    _IO_save_base: [*c]u8,
    _IO_backup_base: [*c]u8,
    _IO_save_end: [*c]u8,
    _markers: ?*struct__IO_marker,
    _chain: [*c]struct__IO_FILE,
    _fileno: c_int,
    _flags2: c_int,
    _old_offset: __off_t,
    _cur_column: c_ushort,
    _vtable_offset: i8,
    _shortbuf: [1]u8,
    _lock: ?*_IO_lock_t,
    _offset: __off64_t,
    _codecvt: ?*struct__IO_codecvt,
    _wide_data: ?*struct__IO_wide_data,
    _freeres_list: [*c]struct__IO_FILE,
    _freeres_buf: ?*anyopaque,
    __pad5: usize,
    _mode: c_int,
    _unused2: [20]u8,
};
pub const __FILE = struct__IO_FILE;
pub const FILE = struct__IO_FILE;
pub const cookie_read_function_t = fn (?*anyopaque, [*c]u8, usize) callconv(.C) __ssize_t;
pub const cookie_write_function_t = fn (?*anyopaque, [*c]const u8, usize) callconv(.C) __ssize_t;
pub const cookie_seek_function_t = fn (?*anyopaque, [*c]__off64_t, c_int) callconv(.C) c_int;
pub const cookie_close_function_t = fn (?*anyopaque) callconv(.C) c_int;
pub const struct__IO_cookie_io_functions_t = extern struct {
    read: ?*const cookie_read_function_t,
    write: ?*const cookie_write_function_t,
    seek: ?*const cookie_seek_function_t,
    close: ?*const cookie_close_function_t,
};
pub const cookie_io_functions_t = struct__IO_cookie_io_functions_t;
pub const fpos_t = __fpos_t;
pub extern var stdin: [*c]FILE;
pub extern var stdout: [*c]FILE;
pub extern var stderr: [*c]FILE;
pub extern fn remove(__filename: [*c]const u8) c_int;
pub extern fn rename(__old: [*c]const u8, __new: [*c]const u8) c_int;
pub extern fn renameat(__oldfd: c_int, __old: [*c]const u8, __newfd: c_int, __new: [*c]const u8) c_int;
pub extern fn fclose(__stream: [*c]FILE) c_int;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpnam([*c]u8) [*c]u8;
pub extern fn tmpnam_r(__s: [*c]u8) [*c]u8;
pub extern fn tempnam(__dir: [*c]const u8, __pfx: [*c]const u8) [*c]u8;
pub extern fn fflush(__stream: [*c]FILE) c_int;
pub extern fn fflush_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fopen(__filename: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn freopen(noalias __filename: [*c]const u8, noalias __modes: [*c]const u8, noalias __stream: [*c]FILE) [*c]FILE;
pub extern fn fdopen(__fd: c_int, __modes: [*c]const u8) [*c]FILE;
pub extern fn fopencookie(noalias __magic_cookie: ?*anyopaque, noalias __modes: [*c]const u8, __io_funcs: cookie_io_functions_t) [*c]FILE;
pub extern fn fmemopen(__s: ?*anyopaque, __len: usize, __modes: [*c]const u8) [*c]FILE;
pub extern fn open_memstream(__bufloc: [*c][*c]u8, __sizeloc: [*c]usize) [*c]FILE;
pub extern fn setbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8) void;
pub extern fn setvbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __modes: c_int, __n: usize) c_int;
pub extern fn setbuffer(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __size: usize) void;
pub extern fn setlinebuf(__stream: [*c]FILE) void;
pub extern fn fprintf(__stream: [*c]FILE, __format: [*c]const u8, ...) c_int;
pub extern fn printf(__format: [*c]const u8, ...) c_int;
pub extern fn sprintf(__s: [*c]u8, __format: [*c]const u8, ...) c_int;
pub extern fn vfprintf(__s: [*c]FILE, __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vprintf(__format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vsprintf(__s: [*c]u8, __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn snprintf(__s: [*c]u8, __maxlen: c_ulong, __format: [*c]const u8, ...) c_int;
pub extern fn vsnprintf(__s: [*c]u8, __maxlen: c_ulong, __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vasprintf(noalias __ptr: [*c][*c]u8, noalias __f: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn __asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn vdprintf(__fd: c_int, noalias __fmt: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn dprintf(__fd: c_int, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn fscanf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, ...) c_int;
pub extern fn scanf(noalias __format: [*c]const u8, ...) c_int;
pub extern fn sscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, ...) c_int;
pub extern fn vfscanf(noalias __s: [*c]FILE, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vscanf(noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vsscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn fgetc(__stream: [*c]FILE) c_int;
pub extern fn getc(__stream: [*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn getc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn getchar_unlocked() c_int;
pub extern fn fgetc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fputc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar(__c: c_int) c_int;
pub extern fn fputc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar_unlocked(__c: c_int) c_int;
pub extern fn getw(__stream: [*c]FILE) c_int;
pub extern fn putw(__w: c_int, __stream: [*c]FILE) c_int;
pub extern fn fgets(noalias __s: [*c]u8, __n: c_int, noalias __stream: [*c]FILE) [*c]u8;
pub extern fn __getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getline(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn fputs(noalias __s: [*c]const u8, noalias __stream: [*c]FILE) c_int;
pub extern fn puts(__s: [*c]const u8) c_int;
pub extern fn ungetc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn fread(__ptr: ?*anyopaque, __size: c_ulong, __n: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn fwrite(__ptr: ?*const anyopaque, __size: c_ulong, __n: c_ulong, __s: [*c]FILE) c_ulong;
pub extern fn fread_unlocked(noalias __ptr: ?*anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fwrite_unlocked(noalias __ptr: ?*const anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fseek(__stream: [*c]FILE, __off: c_long, __whence: c_int) c_int;
pub extern fn ftell(__stream: [*c]FILE) c_long;
pub extern fn rewind(__stream: [*c]FILE) void;
pub extern fn fseeko(__stream: [*c]FILE, __off: __off_t, __whence: c_int) c_int;
pub extern fn ftello(__stream: [*c]FILE) __off_t;
pub extern fn fgetpos(noalias __stream: [*c]FILE, noalias __pos: [*c]fpos_t) c_int;
pub extern fn fsetpos(__stream: [*c]FILE, __pos: [*c]const fpos_t) c_int;
pub extern fn clearerr(__stream: [*c]FILE) void;
pub extern fn feof(__stream: [*c]FILE) c_int;
pub extern fn ferror(__stream: [*c]FILE) c_int;
pub extern fn clearerr_unlocked(__stream: [*c]FILE) void;
pub extern fn feof_unlocked(__stream: [*c]FILE) c_int;
pub extern fn ferror_unlocked(__stream: [*c]FILE) c_int;
pub extern fn perror(__s: [*c]const u8) void;
pub extern fn fileno(__stream: [*c]FILE) c_int;
pub extern fn fileno_unlocked(__stream: [*c]FILE) c_int;
pub extern fn pclose(__stream: [*c]FILE) c_int;
pub extern fn popen(__command: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn ctermid(__s: [*c]u8) [*c]u8;
pub extern fn flockfile(__stream: [*c]FILE) void;
pub extern fn ftrylockfile(__stream: [*c]FILE) c_int;
pub extern fn funlockfile(__stream: [*c]FILE) void;
pub extern fn __uflow([*c]FILE) c_int;
pub extern fn __overflow([*c]FILE, c_int) c_int;
pub extern fn pango_split_file_list(str: [*c]const u8) [*c][*c]u8;
pub extern fn pango_trim_string(str: [*c]const u8) [*c]u8;
pub extern fn pango_read_line(stream: [*c]FILE, str: [*c]GString) gint;
pub extern fn pango_skip_space(pos: [*c][*c]const u8) gboolean;
pub extern fn pango_scan_word(pos: [*c][*c]const u8, out: [*c]GString) gboolean;
pub extern fn pango_scan_string(pos: [*c][*c]const u8, out: [*c]GString) gboolean;
pub extern fn pango_scan_int(pos: [*c][*c]const u8, out: [*c]c_int) gboolean;
pub extern fn pango_parse_enum(@"type": GType, str: [*c]const u8, value: [*c]c_int, warn: gboolean, possible_values: [*c][*c]u8) gboolean;
pub extern fn pango_parse_style(str: [*c]const u8, style: [*c]PangoStyle, warn: gboolean) gboolean;
pub extern fn pango_parse_variant(str: [*c]const u8, variant: [*c]PangoVariant, warn: gboolean) gboolean;
pub extern fn pango_parse_weight(str: [*c]const u8, weight: [*c]PangoWeight, warn: gboolean) gboolean;
pub extern fn pango_parse_stretch(str: [*c]const u8, stretch: [*c]PangoStretch, warn: gboolean) gboolean;
pub extern fn pango_quantize_line_geometry(thickness: [*c]c_int, position: [*c]c_int) void;
pub extern fn pango_log2vis_get_embedding_levels(text: [*c]const gchar, length: c_int, pbase_dir: [*c]PangoDirection) [*c]guint8;
pub extern fn pango_is_zero_width(ch: gunichar) gboolean;
pub extern fn pango_find_paragraph_boundary(text: [*c]const u8, length: c_int, paragraph_delimiter_index: [*c]c_int, next_paragraph_start: [*c]c_int) void;
pub extern fn pango_version() c_int;
pub extern fn pango_version_string() [*c]const u8;
pub extern fn pango_version_check(required_major: c_int, required_minor: c_int, required_micro: c_int) [*c]const u8;
pub const GDK_GL_API_GL: c_int = 1;
pub const GDK_GL_API_GLES: c_int = 2;
pub const GdkGLAPI = c_uint;
pub const GDK_GRAVITY_NORTH_WEST: c_int = 1;
pub const GDK_GRAVITY_NORTH: c_int = 2;
pub const GDK_GRAVITY_NORTH_EAST: c_int = 3;
pub const GDK_GRAVITY_WEST: c_int = 4;
pub const GDK_GRAVITY_CENTER: c_int = 5;
pub const GDK_GRAVITY_EAST: c_int = 6;
pub const GDK_GRAVITY_SOUTH_WEST: c_int = 7;
pub const GDK_GRAVITY_SOUTH: c_int = 8;
pub const GDK_GRAVITY_SOUTH_EAST: c_int = 9;
pub const GDK_GRAVITY_STATIC: c_int = 10;
pub const GdkGravity = c_uint;
pub const GDK_SHIFT_MASK: c_int = 1;
pub const GDK_LOCK_MASK: c_int = 2;
pub const GDK_CONTROL_MASK: c_int = 4;
pub const GDK_ALT_MASK: c_int = 8;
pub const GDK_BUTTON1_MASK: c_int = 256;
pub const GDK_BUTTON2_MASK: c_int = 512;
pub const GDK_BUTTON3_MASK: c_int = 1024;
pub const GDK_BUTTON4_MASK: c_int = 2048;
pub const GDK_BUTTON5_MASK: c_int = 4096;
pub const GDK_SUPER_MASK: c_int = 67108864;
pub const GDK_HYPER_MASK: c_int = 134217728;
pub const GDK_META_MASK: c_int = 268435456;
pub const GdkModifierType = c_uint;
pub const GDK_GL_ERROR_NOT_AVAILABLE: c_int = 0;
pub const GDK_GL_ERROR_UNSUPPORTED_FORMAT: c_int = 1;
pub const GDK_GL_ERROR_UNSUPPORTED_PROFILE: c_int = 2;
pub const GDK_GL_ERROR_COMPILATION_FAILED: c_int = 3;
pub const GDK_GL_ERROR_LINK_FAILED: c_int = 4;
pub const GdkGLError = c_uint;
pub const GDK_VULKAN_ERROR_UNSUPPORTED: c_int = 0;
pub const GDK_VULKAN_ERROR_NOT_AVAILABLE: c_int = 1;
pub const GdkVulkanError = c_uint;
pub const GDK_AXIS_IGNORE: c_int = 0;
pub const GDK_AXIS_X: c_int = 1;
pub const GDK_AXIS_Y: c_int = 2;
pub const GDK_AXIS_DELTA_X: c_int = 3;
pub const GDK_AXIS_DELTA_Y: c_int = 4;
pub const GDK_AXIS_PRESSURE: c_int = 5;
pub const GDK_AXIS_XTILT: c_int = 6;
pub const GDK_AXIS_YTILT: c_int = 7;
pub const GDK_AXIS_WHEEL: c_int = 8;
pub const GDK_AXIS_DISTANCE: c_int = 9;
pub const GDK_AXIS_ROTATION: c_int = 10;
pub const GDK_AXIS_SLIDER: c_int = 11;
pub const GDK_AXIS_LAST: c_int = 12;
pub const GdkAxisUse = c_uint;
pub const GDK_AXIS_FLAG_X: c_int = 2;
pub const GDK_AXIS_FLAG_Y: c_int = 4;
pub const GDK_AXIS_FLAG_DELTA_X: c_int = 8;
pub const GDK_AXIS_FLAG_DELTA_Y: c_int = 16;
pub const GDK_AXIS_FLAG_PRESSURE: c_int = 32;
pub const GDK_AXIS_FLAG_XTILT: c_int = 64;
pub const GDK_AXIS_FLAG_YTILT: c_int = 128;
pub const GDK_AXIS_FLAG_WHEEL: c_int = 256;
pub const GDK_AXIS_FLAG_DISTANCE: c_int = 512;
pub const GDK_AXIS_FLAG_ROTATION: c_int = 1024;
pub const GDK_AXIS_FLAG_SLIDER: c_int = 2048;
pub const GdkAxisFlags = c_uint;
pub const GDK_ACTION_COPY: c_int = 1;
pub const GDK_ACTION_MOVE: c_int = 2;
pub const GDK_ACTION_LINK: c_int = 4;
pub const GDK_ACTION_ASK: c_int = 8;
pub const GdkDragAction = c_uint;
pub const GDK_MEMORY_B8G8R8A8_PREMULTIPLIED: c_int = 0;
pub const GDK_MEMORY_A8R8G8B8_PREMULTIPLIED: c_int = 1;
pub const GDK_MEMORY_R8G8B8A8_PREMULTIPLIED: c_int = 2;
pub const GDK_MEMORY_B8G8R8A8: c_int = 3;
pub const GDK_MEMORY_A8R8G8B8: c_int = 4;
pub const GDK_MEMORY_R8G8B8A8: c_int = 5;
pub const GDK_MEMORY_A8B8G8R8: c_int = 6;
pub const GDK_MEMORY_R8G8B8: c_int = 7;
pub const GDK_MEMORY_B8G8R8: c_int = 8;
pub const GDK_MEMORY_R16G16B16: c_int = 9;
pub const GDK_MEMORY_R16G16B16A16_PREMULTIPLIED: c_int = 10;
pub const GDK_MEMORY_R16G16B16A16: c_int = 11;
pub const GDK_MEMORY_R16G16B16_FLOAT: c_int = 12;
pub const GDK_MEMORY_R16G16B16A16_FLOAT_PREMULTIPLIED: c_int = 13;
pub const GDK_MEMORY_R16G16B16A16_FLOAT: c_int = 14;
pub const GDK_MEMORY_R32G32B32_FLOAT: c_int = 15;
pub const GDK_MEMORY_R32G32B32A32_FLOAT_PREMULTIPLIED: c_int = 16;
pub const GDK_MEMORY_R32G32B32A32_FLOAT: c_int = 17;
pub const GDK_MEMORY_G8A8_PREMULTIPLIED: c_int = 18;
pub const GDK_MEMORY_G8A8: c_int = 19;
pub const GDK_MEMORY_G8: c_int = 20;
pub const GDK_MEMORY_G16A16_PREMULTIPLIED: c_int = 21;
pub const GDK_MEMORY_G16A16: c_int = 22;
pub const GDK_MEMORY_G16: c_int = 23;
pub const GDK_MEMORY_A8: c_int = 24;
pub const GDK_MEMORY_A16: c_int = 25;
pub const GDK_MEMORY_A16_FLOAT: c_int = 26;
pub const GDK_MEMORY_A32_FLOAT: c_int = 27;
pub const GDK_MEMORY_N_FORMATS: c_int = 28;
pub const GdkMemoryFormat = c_uint;
pub const GdkRectangle = cairo_rectangle_int_t;
pub const struct__GdkRGBA = extern struct {
    red: f32,
    green: f32,
    blue: f32,
    alpha: f32,
};
pub const GdkRGBA = struct__GdkRGBA;
pub const struct__GdkContentFormats = opaque {};
pub const GdkContentFormats = struct__GdkContentFormats;
pub const struct__GdkContentProvider = extern struct {
    parent: GObject,
};
pub const GdkContentProvider = struct__GdkContentProvider;
pub const struct__GdkCursor = opaque {};
pub const GdkCursor = struct__GdkCursor;
pub const struct__GdkTexture = opaque {};
pub const GdkTexture = struct__GdkTexture;
pub const struct__GdkTextureDownloader = opaque {};
pub const GdkTextureDownloader = struct__GdkTextureDownloader;
pub const struct__GdkDevice = opaque {};
pub const GdkDevice = struct__GdkDevice;
pub const struct__GdkDrag = opaque {};
pub const GdkDrag = struct__GdkDrag;
pub const struct__GdkDrop = opaque {};
pub const GdkDrop = struct__GdkDrop;
pub const struct__GdkClipboard = opaque {};
pub const GdkClipboard = struct__GdkClipboard;
pub const struct__GdkDisplayManager = opaque {};
pub const GdkDisplayManager = struct__GdkDisplayManager;
pub const struct__GdkDisplay = opaque {};
pub const GdkDisplay = struct__GdkDisplay;
pub const struct__GdkSurface = opaque {};
pub const GdkSurface = struct__GdkSurface;
pub const struct__GdkAppLaunchContext = opaque {};
pub const GdkAppLaunchContext = struct__GdkAppLaunchContext;
pub const struct__GdkSeat = extern struct {
    parent_instance: GObject,
};
pub const GdkSeat = struct__GdkSeat;
pub const struct__GdkSnapshot = opaque {};
pub const GdkSnapshot = struct__GdkSnapshot;
pub const struct__GdkDrawContext = opaque {};
pub const GdkDrawContext = struct__GdkDrawContext;
pub const struct__GdkCairoContext = opaque {};
pub const GdkCairoContext = struct__GdkCairoContext;
pub const struct__GdkGLContext = opaque {};
pub const GdkGLContext = struct__GdkGLContext;
pub const struct__GdkVulkanContext = opaque {};
pub const GdkVulkanContext = struct__GdkVulkanContext;
pub const struct__GdkKeymapKey = extern struct {
    keycode: guint,
    group: c_int,
    level: c_int,
};
pub const GdkKeymapKey = struct__GdkKeymapKey;
pub extern fn gdk_app_launch_context_get_type() GType;
pub extern fn gdk_app_launch_context_get_display(context: ?*GdkAppLaunchContext) ?*GdkDisplay;
pub extern fn gdk_app_launch_context_set_desktop(context: ?*GdkAppLaunchContext, desktop: c_int) void;
pub extern fn gdk_app_launch_context_set_timestamp(context: ?*GdkAppLaunchContext, timestamp: guint32) void;
pub extern fn gdk_app_launch_context_set_icon(context: ?*GdkAppLaunchContext, icon: ?*GIcon) void;
pub extern fn gdk_app_launch_context_set_icon_name(context: ?*GdkAppLaunchContext, icon_name: [*c]const u8) void;
pub const GdkAppLaunchContext_autoptr = ?*GdkAppLaunchContext;
pub const GdkAppLaunchContext_listautoptr = [*c]GList;
pub const GdkAppLaunchContext_slistautoptr = [*c]GSList;
pub const GdkAppLaunchContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkAppLaunchContext(arg__ptr: ?*GdkAppLaunchContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkAppLaunchContext(arg__ptr: [*c]?*GdkAppLaunchContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkAppLaunchContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkAppLaunchContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkAppLaunchContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkAppLaunchContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern const gdk_pixbuf_major_version: guint;
pub extern const gdk_pixbuf_minor_version: guint;
pub extern const gdk_pixbuf_micro_version: guint;
pub extern var gdk_pixbuf_version: [*c]const u8;
pub const GDK_PIXBUF_ALPHA_BILEVEL: c_int = 0;
pub const GDK_PIXBUF_ALPHA_FULL: c_int = 1;
pub const GdkPixbufAlphaMode = c_uint;
pub const GDK_COLORSPACE_RGB: c_int = 0;
pub const GdkColorspace = c_uint;
pub const struct__GdkPixbuf = opaque {};
pub const GdkPixbuf = struct__GdkPixbuf;
pub const GdkPixbufDestroyNotify = ?*const fn ([*c]guchar, gpointer) callconv(.C) void;
pub const GDK_PIXBUF_ERROR_CORRUPT_IMAGE: c_int = 0;
pub const GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY: c_int = 1;
pub const GDK_PIXBUF_ERROR_BAD_OPTION: c_int = 2;
pub const GDK_PIXBUF_ERROR_UNKNOWN_TYPE: c_int = 3;
pub const GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION: c_int = 4;
pub const GDK_PIXBUF_ERROR_FAILED: c_int = 5;
pub const GDK_PIXBUF_ERROR_INCOMPLETE_ANIMATION: c_int = 6;
pub const GdkPixbufError = c_uint;
pub extern fn gdk_pixbuf_error_quark() GQuark;
pub extern fn gdk_pixbuf_get_type() GType;
pub extern fn gdk_pixbuf_ref(pixbuf: ?*GdkPixbuf) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_unref(pixbuf: ?*GdkPixbuf) void;
pub extern fn gdk_pixbuf_get_colorspace(pixbuf: ?*const GdkPixbuf) GdkColorspace;
pub extern fn gdk_pixbuf_get_n_channels(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_has_alpha(pixbuf: ?*const GdkPixbuf) gboolean;
pub extern fn gdk_pixbuf_get_bits_per_sample(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_pixels(pixbuf: ?*const GdkPixbuf) [*c]guchar;
pub extern fn gdk_pixbuf_get_width(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_height(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_rowstride(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_byte_length(pixbuf: ?*const GdkPixbuf) gsize;
pub extern fn gdk_pixbuf_get_pixels_with_length(pixbuf: ?*const GdkPixbuf, length: [*c]guint) [*c]guchar;
pub extern fn gdk_pixbuf_read_pixels(pixbuf: ?*const GdkPixbuf) [*c]const guint8;
pub extern fn gdk_pixbuf_read_pixel_bytes(pixbuf: ?*const GdkPixbuf) ?*GBytes;
pub extern fn gdk_pixbuf_new(colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_calculate_rowstride(colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int) gint;
pub extern fn gdk_pixbuf_copy(pixbuf: ?*const GdkPixbuf) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_subpixbuf(src_pixbuf: ?*GdkPixbuf, src_x: c_int, src_y: c_int, width: c_int, height: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file(filename: [*c]const u8, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_at_size(filename: [*c]const u8, width: c_int, height: c_int, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_at_scale(filename: [*c]const u8, width: c_int, height: c_int, preserve_aspect_ratio: gboolean, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_resource(resource_path: [*c]const u8, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_resource_at_scale(resource_path: [*c]const u8, width: c_int, height: c_int, preserve_aspect_ratio: gboolean, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_data(data: [*c]const guchar, colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int, rowstride: c_int, destroy_fn: GdkPixbufDestroyNotify, destroy_fn_data: gpointer) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_bytes(data: ?*GBytes, colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int, rowstride: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_xpm_data(data: [*c][*c]const u8) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_inline(data_length: gint, data: [*c]const guint8, copy_pixels: gboolean, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_fill(pixbuf: ?*GdkPixbuf, pixel: guint32) void;
pub extern fn gdk_pixbuf_save(pixbuf: ?*GdkPixbuf, filename: [*c]const u8, @"type": [*c]const u8, @"error": [*c][*c]GError, ...) gboolean;
pub extern fn gdk_pixbuf_savev(pixbuf: ?*GdkPixbuf, filename: [*c]const u8, @"type": [*c]const u8, option_keys: [*c][*c]u8, option_values: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub const GdkPixbufSaveFunc = ?*const fn ([*c]const gchar, gsize, [*c][*c]GError, gpointer) callconv(.C) gboolean;
pub extern fn gdk_pixbuf_save_to_callback(pixbuf: ?*GdkPixbuf, save_func: GdkPixbufSaveFunc, user_data: gpointer, @"type": [*c]const u8, @"error": [*c][*c]GError, ...) gboolean;
pub extern fn gdk_pixbuf_save_to_callbackv(pixbuf: ?*GdkPixbuf, save_func: GdkPixbufSaveFunc, user_data: gpointer, @"type": [*c]const u8, option_keys: [*c][*c]u8, option_values: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_save_to_buffer(pixbuf: ?*GdkPixbuf, buffer: [*c][*c]gchar, buffer_size: [*c]gsize, @"type": [*c]const u8, @"error": [*c][*c]GError, ...) gboolean;
pub extern fn gdk_pixbuf_save_to_bufferv(pixbuf: ?*GdkPixbuf, buffer: [*c][*c]gchar, buffer_size: [*c]gsize, @"type": [*c]const u8, option_keys: [*c][*c]u8, option_values: [*c][*c]u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_new_from_stream(stream: [*c]GInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_stream_async(stream: [*c]GInputStream, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_new_from_stream_finish(async_result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_stream_at_scale(stream: [*c]GInputStream, width: gint, height: gint, preserve_aspect_ratio: gboolean, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_stream_at_scale_async(stream: [*c]GInputStream, width: gint, height: gint, preserve_aspect_ratio: gboolean, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_save_to_stream(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, @"type": [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError, ...) gboolean;
pub extern fn gdk_pixbuf_save_to_stream_async(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, @"type": [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer, ...) void;
pub extern fn gdk_pixbuf_save_to_stream_finish(async_result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_save_to_streamv_async(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, @"type": [*c]const gchar, option_keys: [*c][*c]gchar, option_values: [*c][*c]gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_save_to_streamv(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, @"type": [*c]const u8, option_keys: [*c][*c]u8, option_values: [*c][*c]u8, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_add_alpha(pixbuf: ?*const GdkPixbuf, substitute_color: gboolean, r: guchar, g: guchar, b: guchar) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_copy_area(src_pixbuf: ?*const GdkPixbuf, src_x: c_int, src_y: c_int, width: c_int, height: c_int, dest_pixbuf: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int) void;
pub extern fn gdk_pixbuf_saturate_and_pixelate(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, saturation: gfloat, pixelate: gboolean) void;
pub extern fn gdk_pixbuf_apply_embedded_orientation(src: ?*GdkPixbuf) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_set_option(pixbuf: ?*GdkPixbuf, key: [*c]const gchar, value: [*c]const gchar) gboolean;
pub extern fn gdk_pixbuf_get_option(pixbuf: ?*GdkPixbuf, key: [*c]const gchar) [*c]const gchar;
pub extern fn gdk_pixbuf_remove_option(pixbuf: ?*GdkPixbuf, key: [*c]const gchar) gboolean;
pub extern fn gdk_pixbuf_get_options(pixbuf: ?*GdkPixbuf) ?*GHashTable;
pub extern fn gdk_pixbuf_copy_options(src_pixbuf: ?*GdkPixbuf, dest_pixbuf: ?*GdkPixbuf) gboolean;
pub const GDK_INTERP_NEAREST: c_int = 0;
pub const GDK_INTERP_TILES: c_int = 1;
pub const GDK_INTERP_BILINEAR: c_int = 2;
pub const GDK_INTERP_HYPER: c_int = 3;
pub const GdkInterpType = c_uint;
pub const GDK_PIXBUF_ROTATE_NONE: c_int = 0;
pub const GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE: c_int = 90;
pub const GDK_PIXBUF_ROTATE_UPSIDEDOWN: c_int = 180;
pub const GDK_PIXBUF_ROTATE_CLOCKWISE: c_int = 270;
pub const GdkPixbufRotation = c_uint;
pub extern fn gdk_pixbuf_scale(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int, dest_width: c_int, dest_height: c_int, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: GdkInterpType) void;
pub extern fn gdk_pixbuf_composite(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int, dest_width: c_int, dest_height: c_int, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: GdkInterpType, overall_alpha: c_int) void;
pub extern fn gdk_pixbuf_composite_color(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int, dest_width: c_int, dest_height: c_int, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: GdkInterpType, overall_alpha: c_int, check_x: c_int, check_y: c_int, check_size: c_int, color1: guint32, color2: guint32) void;
pub extern fn gdk_pixbuf_scale_simple(src: ?*const GdkPixbuf, dest_width: c_int, dest_height: c_int, interp_type: GdkInterpType) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_composite_color_simple(src: ?*const GdkPixbuf, dest_width: c_int, dest_height: c_int, interp_type: GdkInterpType, overall_alpha: c_int, check_size: c_int, color1: guint32, color2: guint32) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_rotate_simple(src: ?*const GdkPixbuf, angle: GdkPixbufRotation) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_flip(src: ?*const GdkPixbuf, horizontal: gboolean) ?*GdkPixbuf;
pub const struct__GdkPixbufAnimation = opaque {};
pub const GdkPixbufAnimation = struct__GdkPixbufAnimation;
pub const struct__GdkPixbufAnimationIter = opaque {};
pub const GdkPixbufAnimationIter = struct__GdkPixbufAnimationIter;
pub extern fn gdk_pixbuf_animation_get_type() GType;
pub extern fn gdk_pixbuf_animation_new_from_file(filename: [*c]const u8, @"error": [*c][*c]GError) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_stream(stream: [*c]GInputStream, cancellable: [*c]GCancellable, @"error": [*c][*c]GError) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_stream_async(stream: [*c]GInputStream, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_animation_new_from_stream_finish(async_result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_resource(resource_path: [*c]const u8, @"error": [*c][*c]GError) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_ref(animation: ?*GdkPixbufAnimation) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_unref(animation: ?*GdkPixbufAnimation) void;
pub extern fn gdk_pixbuf_animation_get_width(animation: ?*GdkPixbufAnimation) c_int;
pub extern fn gdk_pixbuf_animation_get_height(animation: ?*GdkPixbufAnimation) c_int;
pub extern fn gdk_pixbuf_animation_is_static_image(animation: ?*GdkPixbufAnimation) gboolean;
pub extern fn gdk_pixbuf_animation_get_static_image(animation: ?*GdkPixbufAnimation) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_animation_get_iter(animation: ?*GdkPixbufAnimation, start_time: [*c]const GTimeVal) ?*GdkPixbufAnimationIter;
pub extern fn gdk_pixbuf_animation_iter_get_type() GType;
pub extern fn gdk_pixbuf_animation_iter_get_delay_time(iter: ?*GdkPixbufAnimationIter) c_int;
pub extern fn gdk_pixbuf_animation_iter_get_pixbuf(iter: ?*GdkPixbufAnimationIter) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_animation_iter_on_currently_loading_frame(iter: ?*GdkPixbufAnimationIter) gboolean;
pub extern fn gdk_pixbuf_animation_iter_advance(iter: ?*GdkPixbufAnimationIter, current_time: [*c]const GTimeVal) gboolean;
pub const struct__GdkPixbufSimpleAnim = opaque {};
pub const GdkPixbufSimpleAnim = struct__GdkPixbufSimpleAnim;
pub const struct__GdkPixbufSimpleAnimClass = opaque {};
pub const GdkPixbufSimpleAnimClass = struct__GdkPixbufSimpleAnimClass;
pub extern fn gdk_pixbuf_simple_anim_get_type() GType;
pub extern fn gdk_pixbuf_simple_anim_iter_get_type() GType;
pub extern fn gdk_pixbuf_simple_anim_new(width: gint, height: gint, rate: gfloat) ?*GdkPixbufSimpleAnim;
pub extern fn gdk_pixbuf_simple_anim_add_frame(animation: ?*GdkPixbufSimpleAnim, pixbuf: ?*GdkPixbuf) void;
pub extern fn gdk_pixbuf_simple_anim_set_loop(animation: ?*GdkPixbufSimpleAnim, loop: gboolean) void;
pub extern fn gdk_pixbuf_simple_anim_get_loop(animation: ?*GdkPixbufSimpleAnim) gboolean;
pub const struct__GdkPixbufFormat = opaque {};
pub const GdkPixbufFormat = struct__GdkPixbufFormat;
pub extern fn gdk_pixbuf_init_modules(path: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_format_get_type() GType;
pub extern fn gdk_pixbuf_get_formats() [*c]GSList;
pub extern fn gdk_pixbuf_format_get_name(format: ?*GdkPixbufFormat) [*c]gchar;
pub extern fn gdk_pixbuf_format_get_description(format: ?*GdkPixbufFormat) [*c]gchar;
pub extern fn gdk_pixbuf_format_get_mime_types(format: ?*GdkPixbufFormat) [*c][*c]gchar;
pub extern fn gdk_pixbuf_format_get_extensions(format: ?*GdkPixbufFormat) [*c][*c]gchar;
pub extern fn gdk_pixbuf_format_is_save_option_supported(format: ?*GdkPixbufFormat, option_key: [*c]const gchar) gboolean;
pub extern fn gdk_pixbuf_format_is_writable(format: ?*GdkPixbufFormat) gboolean;
pub extern fn gdk_pixbuf_format_is_scalable(format: ?*GdkPixbufFormat) gboolean;
pub extern fn gdk_pixbuf_format_is_disabled(format: ?*GdkPixbufFormat) gboolean;
pub extern fn gdk_pixbuf_format_set_disabled(format: ?*GdkPixbufFormat, disabled: gboolean) void;
pub extern fn gdk_pixbuf_format_get_license(format: ?*GdkPixbufFormat) [*c]gchar;
pub extern fn gdk_pixbuf_get_file_info(filename: [*c]const gchar, width: [*c]gint, height: [*c]gint) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_get_file_info_async(filename: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_get_file_info_finish(async_result: ?*GAsyncResult, width: [*c]gint, height: [*c]gint, @"error": [*c][*c]GError) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_format_copy(format: ?*const GdkPixbufFormat) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_format_free(format: ?*GdkPixbufFormat) void;
pub const struct__GdkPixbufLoader = extern struct {
    parent_instance: GObject,
    priv: gpointer,
};
pub const GdkPixbufLoader = struct__GdkPixbufLoader;
pub const struct__GdkPixbufLoaderClass = extern struct {
    parent_class: GObjectClass,
    size_prepared: ?*const fn ([*c]GdkPixbufLoader, c_int, c_int) callconv(.C) void,
    area_prepared: ?*const fn ([*c]GdkPixbufLoader) callconv(.C) void,
    area_updated: ?*const fn ([*c]GdkPixbufLoader, c_int, c_int, c_int, c_int) callconv(.C) void,
    closed: ?*const fn ([*c]GdkPixbufLoader) callconv(.C) void,
};
pub const GdkPixbufLoaderClass = struct__GdkPixbufLoaderClass;
pub extern fn gdk_pixbuf_loader_get_type() GType;
pub extern fn gdk_pixbuf_loader_new() [*c]GdkPixbufLoader;
pub extern fn gdk_pixbuf_loader_new_with_type(image_type: [*c]const u8, @"error": [*c][*c]GError) [*c]GdkPixbufLoader;
pub extern fn gdk_pixbuf_loader_new_with_mime_type(mime_type: [*c]const u8, @"error": [*c][*c]GError) [*c]GdkPixbufLoader;
pub extern fn gdk_pixbuf_loader_set_size(loader: [*c]GdkPixbufLoader, width: c_int, height: c_int) void;
pub extern fn gdk_pixbuf_loader_write(loader: [*c]GdkPixbufLoader, buf: [*c]const guchar, count: gsize, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_loader_write_bytes(loader: [*c]GdkPixbufLoader, buffer: ?*GBytes, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_loader_get_pixbuf(loader: [*c]GdkPixbufLoader) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_loader_get_animation(loader: [*c]GdkPixbufLoader) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_loader_close(loader: [*c]GdkPixbufLoader, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_pixbuf_loader_get_format(loader: [*c]GdkPixbufLoader) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_alpha_mode_get_type() GType;
pub extern fn gdk_colorspace_get_type() GType;
pub extern fn gdk_pixbuf_error_get_type() GType;
pub extern fn gdk_interp_type_get_type() GType;
pub extern fn gdk_pixbuf_rotation_get_type() GType;
pub const GdkPixbuf_autoptr = ?*GdkPixbuf;
pub const GdkPixbuf_listautoptr = [*c]GList;
pub const GdkPixbuf_slistautoptr = [*c]GSList;
pub const GdkPixbuf_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbuf(arg__ptr: ?*GdkPixbuf) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkPixbuf(arg__ptr: [*c]?*GdkPixbuf) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPixbuf(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbuf(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbuf(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbuf(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GdkPixbufAnimation_autoptr = ?*GdkPixbufAnimation;
pub const GdkPixbufAnimation_listautoptr = [*c]GList;
pub const GdkPixbufAnimation_slistautoptr = [*c]GSList;
pub const GdkPixbufAnimation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufAnimation(arg__ptr: ?*GdkPixbufAnimation) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkPixbufAnimation(arg__ptr: [*c]?*GdkPixbufAnimation) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPixbufAnimation(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufAnimation(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufAnimation(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufAnimation(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GdkPixbufAnimationIter_autoptr = ?*GdkPixbufAnimationIter;
pub const GdkPixbufAnimationIter_listautoptr = [*c]GList;
pub const GdkPixbufAnimationIter_slistautoptr = [*c]GSList;
pub const GdkPixbufAnimationIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufAnimationIter(arg__ptr: ?*GdkPixbufAnimationIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkPixbufAnimationIter(arg__ptr: [*c]?*GdkPixbufAnimationIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPixbufAnimationIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufAnimationIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufAnimationIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufAnimationIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GdkPixbufLoader_autoptr = [*c]GdkPixbufLoader;
pub const GdkPixbufLoader_listautoptr = [*c]GList;
pub const GdkPixbufLoader_slistautoptr = [*c]GSList;
pub const GdkPixbufLoader_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufLoader(arg__ptr: [*c]GdkPixbufLoader) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkPixbufLoader(arg__ptr: [*c][*c]GdkPixbufLoader) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPixbufLoader(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufLoader(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufLoader(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufLoader(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GdkPixbufSimpleAnim_autoptr = ?*GdkPixbufSimpleAnim;
pub const GdkPixbufSimpleAnim_listautoptr = [*c]GList;
pub const GdkPixbufSimpleAnim_slistautoptr = [*c]GSList;
pub const GdkPixbufSimpleAnim_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufSimpleAnim(arg__ptr: ?*GdkPixbufSimpleAnim) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkPixbufSimpleAnim(arg__ptr: [*c]?*GdkPixbufSimpleAnim) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPixbufSimpleAnim(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufSimpleAnim(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufSimpleAnim(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufSimpleAnim(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_pixbuf_get_from_surface(surface: ?*cairo_surface_t, src_x: c_int, src_y: c_int, width: c_int, height: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_get_from_texture(texture: ?*GdkTexture) ?*GdkPixbuf;
pub const struct__PangoCairoFont = opaque {};
pub const PangoCairoFont = struct__PangoCairoFont;
pub const struct__PangoCairoFontMap = opaque {};
pub const PangoCairoFontMap = struct__PangoCairoFontMap;
pub const PangoCairoShapeRendererFunc = ?*const fn (?*cairo_t, [*c]PangoAttrShape, gboolean, gpointer) callconv(.C) void;
pub extern fn pango_cairo_font_map_get_type() GType;
pub extern fn pango_cairo_font_map_new() [*c]PangoFontMap;
pub extern fn pango_cairo_font_map_new_for_font_type(fonttype: cairo_font_type_t) [*c]PangoFontMap;
pub extern fn pango_cairo_font_map_get_default() [*c]PangoFontMap;
pub extern fn pango_cairo_font_map_set_default(fontmap: ?*PangoCairoFontMap) void;
pub extern fn pango_cairo_font_map_get_font_type(fontmap: ?*PangoCairoFontMap) cairo_font_type_t;
pub extern fn pango_cairo_font_map_set_resolution(fontmap: ?*PangoCairoFontMap, dpi: f64) void;
pub extern fn pango_cairo_font_map_get_resolution(fontmap: ?*PangoCairoFontMap) f64;
pub extern fn pango_cairo_font_map_create_context(fontmap: ?*PangoCairoFontMap) ?*PangoContext;
pub extern fn pango_cairo_font_get_type() GType;
pub extern fn pango_cairo_font_get_scaled_font(font: ?*PangoCairoFont) ?*cairo_scaled_font_t;
pub extern fn pango_cairo_update_context(cr: ?*cairo_t, context: ?*PangoContext) void;
pub extern fn pango_cairo_context_set_font_options(context: ?*PangoContext, options: ?*const cairo_font_options_t) void;
pub extern fn pango_cairo_context_get_font_options(context: ?*PangoContext) ?*const cairo_font_options_t;
pub extern fn pango_cairo_context_set_resolution(context: ?*PangoContext, dpi: f64) void;
pub extern fn pango_cairo_context_get_resolution(context: ?*PangoContext) f64;
pub extern fn pango_cairo_context_set_shape_renderer(context: ?*PangoContext, func: PangoCairoShapeRendererFunc, data: gpointer, dnotify: GDestroyNotify) void;
pub extern fn pango_cairo_context_get_shape_renderer(context: ?*PangoContext, data: [*c]gpointer) PangoCairoShapeRendererFunc;
pub extern fn pango_cairo_create_context(cr: ?*cairo_t) ?*PangoContext;
pub extern fn pango_cairo_create_layout(cr: ?*cairo_t) ?*PangoLayout;
pub extern fn pango_cairo_update_layout(cr: ?*cairo_t, layout: ?*PangoLayout) void;
pub extern fn pango_cairo_show_glyph_string(cr: ?*cairo_t, font: [*c]PangoFont, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_cairo_show_glyph_item(cr: ?*cairo_t, text: [*c]const u8, glyph_item: [*c]PangoGlyphItem) void;
pub extern fn pango_cairo_show_layout_line(cr: ?*cairo_t, line: ?*PangoLayoutLine) void;
pub extern fn pango_cairo_show_layout(cr: ?*cairo_t, layout: ?*PangoLayout) void;
pub extern fn pango_cairo_show_error_underline(cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn pango_cairo_glyph_string_path(cr: ?*cairo_t, font: [*c]PangoFont, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_cairo_layout_line_path(cr: ?*cairo_t, line: ?*PangoLayoutLine) void;
pub extern fn pango_cairo_layout_path(cr: ?*cairo_t, layout: ?*PangoLayout) void;
pub extern fn pango_cairo_error_underline_path(cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gdk_cairo_set_source_rgba(cr: ?*cairo_t, rgba: [*c]const GdkRGBA) void;
pub extern fn gdk_cairo_set_source_pixbuf(cr: ?*cairo_t, pixbuf: ?*const GdkPixbuf, pixbuf_x: f64, pixbuf_y: f64) void;
pub extern fn gdk_cairo_rectangle(cr: ?*cairo_t, rectangle: [*c]const GdkRectangle) void;
pub extern fn gdk_cairo_region(cr: ?*cairo_t, region: ?*const cairo_region_t) void;
pub extern fn gdk_cairo_region_create_from_surface(surface: ?*cairo_surface_t) ?*cairo_region_t;
pub extern fn gdk_cairo_draw_from_gl(cr: ?*cairo_t, surface: ?*GdkSurface, source: c_int, source_type: c_int, buffer_scale: c_int, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn gdk_cairo_context_get_type() GType;
pub extern fn gdk_cairo_context_cairo_create(self: ?*GdkCairoContext) ?*cairo_t;
pub extern fn gdk_clipboard_get_type() GType;
pub extern fn gdk_clipboard_get_display(clipboard: ?*GdkClipboard) ?*GdkDisplay;
pub extern fn gdk_clipboard_get_formats(clipboard: ?*GdkClipboard) ?*GdkContentFormats;
pub extern fn gdk_clipboard_is_local(clipboard: ?*GdkClipboard) gboolean;
pub extern fn gdk_clipboard_get_content(clipboard: ?*GdkClipboard) [*c]GdkContentProvider;
pub extern fn gdk_clipboard_store_async(clipboard: ?*GdkClipboard, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_clipboard_store_finish(clipboard: ?*GdkClipboard, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_clipboard_read_async(clipboard: ?*GdkClipboard, mime_types: [*c][*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_clipboard_read_finish(clipboard: ?*GdkClipboard, result: ?*GAsyncResult, out_mime_type: [*c][*c]const u8, @"error": [*c][*c]GError) [*c]GInputStream;
pub extern fn gdk_clipboard_read_value_async(clipboard: ?*GdkClipboard, @"type": GType, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_clipboard_read_value_finish(clipboard: ?*GdkClipboard, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]const GValue;
pub extern fn gdk_clipboard_read_texture_async(clipboard: ?*GdkClipboard, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_clipboard_read_texture_finish(clipboard: ?*GdkClipboard, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GdkTexture;
pub extern fn gdk_clipboard_read_text_async(clipboard: ?*GdkClipboard, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_clipboard_read_text_finish(clipboard: ?*GdkClipboard, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]u8;
pub extern fn gdk_clipboard_set_content(clipboard: ?*GdkClipboard, provider: [*c]GdkContentProvider) gboolean;
pub extern fn gdk_clipboard_set(clipboard: ?*GdkClipboard, @"type": GType, ...) void;
pub extern fn gdk_clipboard_set_valist(clipboard: ?*GdkClipboard, @"type": GType, args: [*c]struct___va_list_tag) void;
pub extern fn gdk_clipboard_set_value(clipboard: ?*GdkClipboard, value: [*c]const GValue) void;
pub extern fn gdk_clipboard_set_text(clipboard: ?*GdkClipboard, text: [*c]const u8) void;
pub extern fn gdk_clipboard_set_texture(clipboard: ?*GdkClipboard, texture: ?*GdkTexture) void;
pub const GdkClipboard_autoptr = ?*GdkClipboard;
pub const GdkClipboard_listautoptr = [*c]GList;
pub const GdkClipboard_slistautoptr = [*c]GSList;
pub const GdkClipboard_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkClipboard(arg__ptr: ?*GdkClipboard) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkClipboard(arg__ptr: [*c]?*GdkClipboard) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkClipboard(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkClipboard(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkClipboard(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkClipboard(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkContentDeserializer = opaque {};
pub const GdkContentDeserializer = struct__GdkContentDeserializer;
pub const GdkContentDeserializeFunc = ?*const fn (?*GdkContentDeserializer) callconv(.C) void;
pub extern fn gdk_content_deserializer_get_type() GType;
pub extern fn gdk_content_deserializer_get_mime_type(deserializer: ?*GdkContentDeserializer) [*c]const u8;
pub extern fn gdk_content_deserializer_get_gtype(deserializer: ?*GdkContentDeserializer) GType;
pub extern fn gdk_content_deserializer_get_value(deserializer: ?*GdkContentDeserializer) [*c]GValue;
pub extern fn gdk_content_deserializer_get_input_stream(deserializer: ?*GdkContentDeserializer) [*c]GInputStream;
pub extern fn gdk_content_deserializer_get_priority(deserializer: ?*GdkContentDeserializer) c_int;
pub extern fn gdk_content_deserializer_get_cancellable(deserializer: ?*GdkContentDeserializer) [*c]GCancellable;
pub extern fn gdk_content_deserializer_get_user_data(deserializer: ?*GdkContentDeserializer) gpointer;
pub extern fn gdk_content_deserializer_set_task_data(deserializer: ?*GdkContentDeserializer, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gdk_content_deserializer_get_task_data(deserializer: ?*GdkContentDeserializer) gpointer;
pub extern fn gdk_content_deserializer_return_success(deserializer: ?*GdkContentDeserializer) void;
pub extern fn gdk_content_deserializer_return_error(deserializer: ?*GdkContentDeserializer, @"error": [*c]GError) void;
pub extern fn gdk_content_formats_union_deserialize_gtypes(formats: ?*GdkContentFormats) ?*GdkContentFormats;
pub extern fn gdk_content_formats_union_deserialize_mime_types(formats: ?*GdkContentFormats) ?*GdkContentFormats;
pub extern fn gdk_content_register_deserializer(mime_type: [*c]const u8, @"type": GType, deserialize: GdkContentDeserializeFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gdk_content_deserialize_async(stream: [*c]GInputStream, mime_type: [*c]const u8, @"type": GType, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_content_deserialize_finish(result: ?*GAsyncResult, value: [*c]GValue, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_intern_mime_type(string: [*c]const u8) [*c]const u8;
pub extern fn gdk_content_formats_get_type() GType;
pub extern fn gdk_content_formats_new(mime_types: [*c][*c]const u8, n_mime_types: guint) ?*GdkContentFormats;
pub extern fn gdk_content_formats_new_for_gtype(@"type": GType) ?*GdkContentFormats;
pub extern fn gdk_content_formats_parse(string: [*c]const u8) ?*GdkContentFormats;
pub extern fn gdk_content_formats_ref(formats: ?*GdkContentFormats) ?*GdkContentFormats;
pub extern fn gdk_content_formats_unref(formats: ?*GdkContentFormats) void;
pub extern fn gdk_content_formats_print(formats: ?*GdkContentFormats, string: [*c]GString) void;
pub extern fn gdk_content_formats_to_string(formats: ?*GdkContentFormats) [*c]u8;
pub extern fn gdk_content_formats_get_gtypes(formats: ?*const GdkContentFormats, n_gtypes: [*c]gsize) [*c]const GType;
pub extern fn gdk_content_formats_get_mime_types(formats: ?*const GdkContentFormats, n_mime_types: [*c]gsize) [*c]const [*c]const u8;
pub extern fn gdk_content_formats_union(first: ?*GdkContentFormats, second: ?*const GdkContentFormats) ?*GdkContentFormats;
pub extern fn gdk_content_formats_match(first: ?*const GdkContentFormats, second: ?*const GdkContentFormats) gboolean;
pub extern fn gdk_content_formats_match_gtype(first: ?*const GdkContentFormats, second: ?*const GdkContentFormats) GType;
pub extern fn gdk_content_formats_match_mime_type(first: ?*const GdkContentFormats, second: ?*const GdkContentFormats) [*c]const u8;
pub extern fn gdk_content_formats_contain_gtype(formats: ?*const GdkContentFormats, @"type": GType) gboolean;
pub extern fn gdk_content_formats_contain_mime_type(formats: ?*const GdkContentFormats, mime_type: [*c]const u8) gboolean;
pub const struct__GdkContentFormatsBuilder = opaque {};
pub const GdkContentFormatsBuilder = struct__GdkContentFormatsBuilder;
pub extern fn gdk_content_formats_builder_get_type() GType;
pub extern fn gdk_content_formats_builder_new() ?*GdkContentFormatsBuilder;
pub extern fn gdk_content_formats_builder_ref(builder: ?*GdkContentFormatsBuilder) ?*GdkContentFormatsBuilder;
pub extern fn gdk_content_formats_builder_unref(builder: ?*GdkContentFormatsBuilder) void;
pub extern fn gdk_content_formats_builder_free_to_formats(builder: ?*GdkContentFormatsBuilder) ?*GdkContentFormats;
pub extern fn gdk_content_formats_builder_to_formats(builder: ?*GdkContentFormatsBuilder) ?*GdkContentFormats;
pub extern fn gdk_content_formats_builder_add_formats(builder: ?*GdkContentFormatsBuilder, formats: ?*const GdkContentFormats) void;
pub extern fn gdk_content_formats_builder_add_mime_type(builder: ?*GdkContentFormatsBuilder, mime_type: [*c]const u8) void;
pub extern fn gdk_content_formats_builder_add_gtype(builder: ?*GdkContentFormatsBuilder, @"type": GType) void;
pub const GdkContentFormats_autoptr = ?*GdkContentFormats;
pub const GdkContentFormats_listautoptr = [*c]GList;
pub const GdkContentFormats_slistautoptr = [*c]GSList;
pub const GdkContentFormats_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkContentFormats(arg__ptr: ?*GdkContentFormats) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_content_formats_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkContentFormats(arg__ptr: [*c]?*GdkContentFormats) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkContentFormats(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkContentFormats(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_content_formats_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkContentFormats(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_content_formats_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkContentFormats(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_content_formats_unref)))))));
    }
}
pub extern fn gdk_file_list_get_type() GType;
pub const struct__GdkFileList = opaque {};
pub const GdkFileList = struct__GdkFileList;
pub extern fn gdk_file_list_get_files(file_list: ?*GdkFileList) [*c]GSList;
pub extern fn gdk_file_list_new_from_list(files: [*c]GSList) ?*GdkFileList;
pub extern fn gdk_file_list_new_from_array(files: [*c]?*GFile, n_files: gsize) ?*GdkFileList;
pub const struct__GdkContentProviderClass = extern struct {
    parent_class: GObjectClass,
    content_changed: ?*const fn ([*c]GdkContentProvider) callconv(.C) void,
    attach_clipboard: ?*const fn ([*c]GdkContentProvider, ?*GdkClipboard) callconv(.C) void,
    detach_clipboard: ?*const fn ([*c]GdkContentProvider, ?*GdkClipboard) callconv(.C) void,
    ref_formats: ?*const fn ([*c]GdkContentProvider) callconv(.C) ?*GdkContentFormats,
    ref_storable_formats: ?*const fn ([*c]GdkContentProvider) callconv(.C) ?*GdkContentFormats,
    write_mime_type_async: ?*const fn ([*c]GdkContentProvider, [*c]const u8, [*c]GOutputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) callconv(.C) void,
    write_mime_type_finish: ?*const fn ([*c]GdkContentProvider, ?*GAsyncResult, [*c][*c]GError) callconv(.C) gboolean,
    get_value: ?*const fn ([*c]GdkContentProvider, [*c]GValue, [*c][*c]GError) callconv(.C) gboolean,
    padding: [8]gpointer,
};
pub const GdkContentProviderClass = struct__GdkContentProviderClass;
pub extern fn gdk_content_provider_get_type() GType;
pub extern fn gdk_content_provider_ref_formats(provider: [*c]GdkContentProvider) ?*GdkContentFormats;
pub extern fn gdk_content_provider_ref_storable_formats(provider: [*c]GdkContentProvider) ?*GdkContentFormats;
pub extern fn gdk_content_provider_content_changed(provider: [*c]GdkContentProvider) void;
pub extern fn gdk_content_provider_write_mime_type_async(provider: [*c]GdkContentProvider, mime_type: [*c]const u8, stream: [*c]GOutputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_content_provider_write_mime_type_finish(provider: [*c]GdkContentProvider, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_content_provider_get_value(provider: [*c]GdkContentProvider, value: [*c]GValue, @"error": [*c][*c]GError) gboolean;
pub const GdkContentProvider_autoptr = [*c]GdkContentProvider;
pub const GdkContentProvider_listautoptr = [*c]GList;
pub const GdkContentProvider_slistautoptr = [*c]GSList;
pub const GdkContentProvider_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkContentProvider(arg__ptr: [*c]GdkContentProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkContentProvider(arg__ptr: [*c][*c]GdkContentProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkContentProvider(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkContentProvider(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkContentProvider(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkContentProvider(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_content_provider_new_for_value(value: [*c]const GValue) [*c]GdkContentProvider;
pub extern fn gdk_content_provider_new_typed(@"type": GType, ...) [*c]GdkContentProvider;
pub extern fn gdk_content_provider_new_union(providers: [*c][*c]GdkContentProvider, n_providers: gsize) [*c]GdkContentProvider;
pub extern fn gdk_content_provider_new_for_bytes(mime_type: [*c]const u8, bytes: ?*GBytes) [*c]GdkContentProvider;
pub const struct__GdkContentSerializer = opaque {};
pub const GdkContentSerializer = struct__GdkContentSerializer;
pub const GdkContentSerializeFunc = ?*const fn (?*GdkContentSerializer) callconv(.C) void;
pub extern fn gdk_content_serializer_get_type() GType;
pub extern fn gdk_content_serializer_get_mime_type(serializer: ?*GdkContentSerializer) [*c]const u8;
pub extern fn gdk_content_serializer_get_gtype(serializer: ?*GdkContentSerializer) GType;
pub extern fn gdk_content_serializer_get_value(serializer: ?*GdkContentSerializer) [*c]const GValue;
pub extern fn gdk_content_serializer_get_output_stream(serializer: ?*GdkContentSerializer) [*c]GOutputStream;
pub extern fn gdk_content_serializer_get_priority(serializer: ?*GdkContentSerializer) c_int;
pub extern fn gdk_content_serializer_get_cancellable(serializer: ?*GdkContentSerializer) [*c]GCancellable;
pub extern fn gdk_content_serializer_get_user_data(serializer: ?*GdkContentSerializer) gpointer;
pub extern fn gdk_content_serializer_set_task_data(serializer: ?*GdkContentSerializer, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gdk_content_serializer_get_task_data(serializer: ?*GdkContentSerializer) gpointer;
pub extern fn gdk_content_serializer_return_success(serializer: ?*GdkContentSerializer) void;
pub extern fn gdk_content_serializer_return_error(serializer: ?*GdkContentSerializer, @"error": [*c]GError) void;
pub extern fn gdk_content_formats_union_serialize_gtypes(formats: ?*GdkContentFormats) ?*GdkContentFormats;
pub extern fn gdk_content_formats_union_serialize_mime_types(formats: ?*GdkContentFormats) ?*GdkContentFormats;
pub extern fn gdk_content_register_serializer(@"type": GType, mime_type: [*c]const u8, serialize: GdkContentSerializeFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gdk_content_serialize_async(stream: [*c]GOutputStream, mime_type: [*c]const u8, value: [*c]const GValue, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_content_serialize_finish(result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_cursor_get_type() GType;
pub extern fn gdk_cursor_new_from_texture(texture: ?*GdkTexture, hotspot_x: c_int, hotspot_y: c_int, fallback: ?*GdkCursor) ?*GdkCursor;
pub extern fn gdk_cursor_new_from_name(name: [*c]const u8, fallback: ?*GdkCursor) ?*GdkCursor;
pub extern fn gdk_cursor_get_fallback(cursor: ?*GdkCursor) ?*GdkCursor;
pub extern fn gdk_cursor_get_name(cursor: ?*GdkCursor) [*c]const u8;
pub extern fn gdk_cursor_get_texture(cursor: ?*GdkCursor) ?*GdkTexture;
pub extern fn gdk_cursor_get_hotspot_x(cursor: ?*GdkCursor) c_int;
pub extern fn gdk_cursor_get_hotspot_y(cursor: ?*GdkCursor) c_int;
pub const GdkCursor_autoptr = ?*GdkCursor;
pub const GdkCursor_listautoptr = [*c]GList;
pub const GdkCursor_slistautoptr = [*c]GSList;
pub const GdkCursor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkCursor(arg__ptr: ?*GdkCursor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkCursor(arg__ptr: [*c]?*GdkCursor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkCursor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkCursor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkCursor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkCursor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkDeviceTool = opaque {};
pub const GdkDeviceTool = struct__GdkDeviceTool;
pub const GDK_DEVICE_TOOL_TYPE_UNKNOWN: c_int = 0;
pub const GDK_DEVICE_TOOL_TYPE_PEN: c_int = 1;
pub const GDK_DEVICE_TOOL_TYPE_ERASER: c_int = 2;
pub const GDK_DEVICE_TOOL_TYPE_BRUSH: c_int = 3;
pub const GDK_DEVICE_TOOL_TYPE_PENCIL: c_int = 4;
pub const GDK_DEVICE_TOOL_TYPE_AIRBRUSH: c_int = 5;
pub const GDK_DEVICE_TOOL_TYPE_MOUSE: c_int = 6;
pub const GDK_DEVICE_TOOL_TYPE_LENS: c_int = 7;
pub const GdkDeviceToolType = c_uint;
pub extern fn gdk_device_tool_get_type() GType;
pub extern fn gdk_device_tool_get_serial(tool: ?*GdkDeviceTool) guint64;
pub extern fn gdk_device_tool_get_hardware_id(tool: ?*GdkDeviceTool) guint64;
pub extern fn gdk_device_tool_get_tool_type(tool: ?*GdkDeviceTool) GdkDeviceToolType;
pub extern fn gdk_device_tool_get_axes(tool: ?*GdkDeviceTool) GdkAxisFlags;
pub const struct__GdkTimeCoord = extern struct {
    time: guint32,
    flags: GdkAxisFlags,
    axes: [12]f64,
};
pub const GdkTimeCoord = struct__GdkTimeCoord;
pub const GDK_SOURCE_MOUSE: c_int = 0;
pub const GDK_SOURCE_PEN: c_int = 1;
pub const GDK_SOURCE_KEYBOARD: c_int = 2;
pub const GDK_SOURCE_TOUCHSCREEN: c_int = 3;
pub const GDK_SOURCE_TOUCHPAD: c_int = 4;
pub const GDK_SOURCE_TRACKPOINT: c_int = 5;
pub const GDK_SOURCE_TABLET_PAD: c_int = 6;
pub const GdkInputSource = c_uint;
pub extern fn gdk_device_get_type() GType;
pub extern fn gdk_device_get_name(device: ?*GdkDevice) [*c]const u8;
pub extern fn gdk_device_get_vendor_id(device: ?*GdkDevice) [*c]const u8;
pub extern fn gdk_device_get_product_id(device: ?*GdkDevice) [*c]const u8;
pub extern fn gdk_device_get_display(device: ?*GdkDevice) ?*GdkDisplay;
pub extern fn gdk_device_get_seat(device: ?*GdkDevice) [*c]GdkSeat;
pub extern fn gdk_device_get_device_tool(device: ?*GdkDevice) ?*GdkDeviceTool;
pub extern fn gdk_device_get_source(device: ?*GdkDevice) GdkInputSource;
pub extern fn gdk_device_get_has_cursor(device: ?*GdkDevice) gboolean;
pub extern fn gdk_device_get_num_touches(device: ?*GdkDevice) guint;
pub extern fn gdk_device_get_modifier_state(device: ?*GdkDevice) GdkModifierType;
pub extern fn gdk_device_get_direction(device: ?*GdkDevice) PangoDirection;
pub extern fn gdk_device_has_bidi_layouts(device: ?*GdkDevice) gboolean;
pub extern fn gdk_device_get_caps_lock_state(device: ?*GdkDevice) gboolean;
pub extern fn gdk_device_get_num_lock_state(device: ?*GdkDevice) gboolean;
pub extern fn gdk_device_get_scroll_lock_state(device: ?*GdkDevice) gboolean;
pub extern fn gdk_device_get_surface_at_position(device: ?*GdkDevice, win_x: [*c]f64, win_y: [*c]f64) ?*GdkSurface;
pub extern fn gdk_device_get_timestamp(device: ?*GdkDevice) guint32;
pub const GdkDevice_autoptr = ?*GdkDevice;
pub const GdkDevice_listautoptr = [*c]GList;
pub const GdkDevice_slistautoptr = [*c]GSList;
pub const GdkDevice_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDevice(arg__ptr: ?*GdkDevice) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkDevice(arg__ptr: [*c]?*GdkDevice) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDevice(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDevice(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDevice(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDevice(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkDevicePad = opaque {};
pub const GdkDevicePad = struct__GdkDevicePad;
pub const struct__GdkDevicePadInterface = opaque {};
pub const GdkDevicePadInterface = struct__GdkDevicePadInterface;
pub const GDK_DEVICE_PAD_FEATURE_BUTTON: c_int = 0;
pub const GDK_DEVICE_PAD_FEATURE_RING: c_int = 1;
pub const GDK_DEVICE_PAD_FEATURE_STRIP: c_int = 2;
pub const GdkDevicePadFeature = c_uint;
pub extern fn gdk_device_pad_get_type() GType;
pub extern fn gdk_device_pad_get_n_groups(pad: ?*GdkDevicePad) c_int;
pub extern fn gdk_device_pad_get_group_n_modes(pad: ?*GdkDevicePad, group_idx: c_int) c_int;
pub extern fn gdk_device_pad_get_n_features(pad: ?*GdkDevicePad, feature: GdkDevicePadFeature) c_int;
pub extern fn gdk_device_pad_get_feature_group(pad: ?*GdkDevicePad, feature: GdkDevicePadFeature, feature_idx: c_int) c_int;
pub const GDK_DRAG_CANCEL_NO_TARGET: c_int = 0;
pub const GDK_DRAG_CANCEL_USER_CANCELLED: c_int = 1;
pub const GDK_DRAG_CANCEL_ERROR: c_int = 2;
pub const GdkDragCancelReason = c_uint;
pub extern fn gdk_drag_get_type() GType;
pub extern fn gdk_drag_get_display(drag: ?*GdkDrag) ?*GdkDisplay;
pub extern fn gdk_drag_get_device(drag: ?*GdkDrag) ?*GdkDevice;
pub extern fn gdk_drag_get_formats(drag: ?*GdkDrag) ?*GdkContentFormats;
pub extern fn gdk_drag_get_actions(drag: ?*GdkDrag) GdkDragAction;
pub extern fn gdk_drag_get_selected_action(drag: ?*GdkDrag) GdkDragAction;
pub extern fn gdk_drag_action_is_unique(action: GdkDragAction) gboolean;
pub extern fn gdk_drag_begin(surface: ?*GdkSurface, device: ?*GdkDevice, content: [*c]GdkContentProvider, actions: GdkDragAction, dx: f64, dy: f64) ?*GdkDrag;
pub extern fn gdk_drag_drop_done(drag: ?*GdkDrag, success: gboolean) void;
pub extern fn gdk_drag_get_drag_surface(drag: ?*GdkDrag) ?*GdkSurface;
pub extern fn gdk_drag_set_hotspot(drag: ?*GdkDrag, hot_x: c_int, hot_y: c_int) void;
pub extern fn gdk_drag_get_content(drag: ?*GdkDrag) [*c]GdkContentProvider;
pub extern fn gdk_drag_get_surface(drag: ?*GdkDrag) ?*GdkSurface;
pub const GdkDrag_autoptr = ?*GdkDrag;
pub const GdkDrag_listautoptr = [*c]GList;
pub const GdkDrag_slistautoptr = [*c]GSList;
pub const GdkDrag_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDrag(arg__ptr: ?*GdkDrag) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkDrag(arg__ptr: [*c]?*GdkDrag) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDrag(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDrag(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDrag(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDrag(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkEventSequence = opaque {};
pub const GdkEventSequence = struct__GdkEventSequence;
pub const struct__GdkEvent = opaque {};
pub const GdkEvent = struct__GdkEvent;
pub const struct__GdkButtonEvent = opaque {};
pub const GdkButtonEvent = struct__GdkButtonEvent;
pub const struct__GdkCrossingEvent = opaque {};
pub const GdkCrossingEvent = struct__GdkCrossingEvent;
pub const struct__GdkDeleteEvent = opaque {};
pub const GdkDeleteEvent = struct__GdkDeleteEvent;
pub const struct__GdkDNDEvent = opaque {};
pub const GdkDNDEvent = struct__GdkDNDEvent;
pub const struct__GdkFocusEvent = opaque {};
pub const GdkFocusEvent = struct__GdkFocusEvent;
pub const struct__GdkGrabBrokenEvent = opaque {};
pub const GdkGrabBrokenEvent = struct__GdkGrabBrokenEvent;
pub const struct__GdkKeyEvent = opaque {};
pub const GdkKeyEvent = struct__GdkKeyEvent;
pub const struct__GdkMotionEvent = opaque {};
pub const GdkMotionEvent = struct__GdkMotionEvent;
pub const struct__GdkPadEvent = opaque {};
pub const GdkPadEvent = struct__GdkPadEvent;
pub const struct__GdkProximityEvent = opaque {};
pub const GdkProximityEvent = struct__GdkProximityEvent;
pub const struct__GdkScrollEvent = opaque {};
pub const GdkScrollEvent = struct__GdkScrollEvent;
pub const struct__GdkTouchEvent = opaque {};
pub const GdkTouchEvent = struct__GdkTouchEvent;
pub const struct__GdkTouchpadEvent = opaque {};
pub const GdkTouchpadEvent = struct__GdkTouchpadEvent;
pub const GDK_DELETE: c_int = 0;
pub const GDK_MOTION_NOTIFY: c_int = 1;
pub const GDK_BUTTON_PRESS: c_int = 2;
pub const GDK_BUTTON_RELEASE: c_int = 3;
pub const GDK_KEY_PRESS: c_int = 4;
pub const GDK_KEY_RELEASE: c_int = 5;
pub const GDK_ENTER_NOTIFY: c_int = 6;
pub const GDK_LEAVE_NOTIFY: c_int = 7;
pub const GDK_FOCUS_CHANGE: c_int = 8;
pub const GDK_PROXIMITY_IN: c_int = 9;
pub const GDK_PROXIMITY_OUT: c_int = 10;
pub const GDK_DRAG_ENTER: c_int = 11;
pub const GDK_DRAG_LEAVE: c_int = 12;
pub const GDK_DRAG_MOTION: c_int = 13;
pub const GDK_DROP_START: c_int = 14;
pub const GDK_SCROLL: c_int = 15;
pub const GDK_GRAB_BROKEN: c_int = 16;
pub const GDK_TOUCH_BEGIN: c_int = 17;
pub const GDK_TOUCH_UPDATE: c_int = 18;
pub const GDK_TOUCH_END: c_int = 19;
pub const GDK_TOUCH_CANCEL: c_int = 20;
pub const GDK_TOUCHPAD_SWIPE: c_int = 21;
pub const GDK_TOUCHPAD_PINCH: c_int = 22;
pub const GDK_PAD_BUTTON_PRESS: c_int = 23;
pub const GDK_PAD_BUTTON_RELEASE: c_int = 24;
pub const GDK_PAD_RING: c_int = 25;
pub const GDK_PAD_STRIP: c_int = 26;
pub const GDK_PAD_GROUP_MODE: c_int = 27;
pub const GDK_TOUCHPAD_HOLD: c_int = 28;
pub const GDK_EVENT_LAST: c_int = 29;
pub const GdkEventType = c_uint;
pub const GDK_TOUCHPAD_GESTURE_PHASE_BEGIN: c_int = 0;
pub const GDK_TOUCHPAD_GESTURE_PHASE_UPDATE: c_int = 1;
pub const GDK_TOUCHPAD_GESTURE_PHASE_END: c_int = 2;
pub const GDK_TOUCHPAD_GESTURE_PHASE_CANCEL: c_int = 3;
pub const GdkTouchpadGesturePhase = c_uint;
pub const GDK_SCROLL_UP: c_int = 0;
pub const GDK_SCROLL_DOWN: c_int = 1;
pub const GDK_SCROLL_LEFT: c_int = 2;
pub const GDK_SCROLL_RIGHT: c_int = 3;
pub const GDK_SCROLL_SMOOTH: c_int = 4;
pub const GdkScrollDirection = c_uint;
pub const GDK_SCROLL_UNIT_WHEEL: c_int = 0;
pub const GDK_SCROLL_UNIT_SURFACE: c_int = 1;
pub const GdkScrollUnit = c_uint;
pub const GDK_NOTIFY_ANCESTOR: c_int = 0;
pub const GDK_NOTIFY_VIRTUAL: c_int = 1;
pub const GDK_NOTIFY_INFERIOR: c_int = 2;
pub const GDK_NOTIFY_NONLINEAR: c_int = 3;
pub const GDK_NOTIFY_NONLINEAR_VIRTUAL: c_int = 4;
pub const GDK_NOTIFY_UNKNOWN: c_int = 5;
pub const GdkNotifyType = c_uint;
pub const GDK_CROSSING_NORMAL: c_int = 0;
pub const GDK_CROSSING_GRAB: c_int = 1;
pub const GDK_CROSSING_UNGRAB: c_int = 2;
pub const GDK_CROSSING_GTK_GRAB: c_int = 3;
pub const GDK_CROSSING_GTK_UNGRAB: c_int = 4;
pub const GDK_CROSSING_STATE_CHANGED: c_int = 5;
pub const GDK_CROSSING_TOUCH_BEGIN: c_int = 6;
pub const GDK_CROSSING_TOUCH_END: c_int = 7;
pub const GDK_CROSSING_DEVICE_SWITCH: c_int = 8;
pub const GdkCrossingMode = c_uint;
pub extern fn gdk_event_get_type() GType;
pub extern fn gdk_event_sequence_get_type() GType;
pub extern fn gdk_event_ref(event: ?*GdkEvent) ?*GdkEvent;
pub extern fn gdk_event_unref(event: ?*GdkEvent) void;
pub extern fn gdk_event_get_event_type(event: ?*GdkEvent) GdkEventType;
pub extern fn gdk_event_get_surface(event: ?*GdkEvent) ?*GdkSurface;
pub extern fn gdk_event_get_seat(event: ?*GdkEvent) [*c]GdkSeat;
pub extern fn gdk_event_get_device(event: ?*GdkEvent) ?*GdkDevice;
pub extern fn gdk_event_get_device_tool(event: ?*GdkEvent) ?*GdkDeviceTool;
pub extern fn gdk_event_get_time(event: ?*GdkEvent) guint32;
pub extern fn gdk_event_get_display(event: ?*GdkEvent) ?*GdkDisplay;
pub extern fn gdk_event_get_event_sequence(event: ?*GdkEvent) ?*GdkEventSequence;
pub extern fn gdk_event_get_modifier_state(event: ?*GdkEvent) GdkModifierType;
pub extern fn gdk_event_get_position(event: ?*GdkEvent, x: [*c]f64, y: [*c]f64) gboolean;
pub extern fn gdk_event_get_axes(event: ?*GdkEvent, axes: [*c][*c]f64, n_axes: [*c]guint) gboolean;
pub extern fn gdk_event_get_axis(event: ?*GdkEvent, axis_use: GdkAxisUse, value: [*c]f64) gboolean;
pub extern fn gdk_event_get_history(event: ?*GdkEvent, out_n_coords: [*c]guint) [*c]GdkTimeCoord;
pub extern fn gdk_event_get_pointer_emulated(event: ?*GdkEvent) gboolean;
pub extern fn gdk_button_event_get_type() GType;
pub extern fn gdk_button_event_get_button(event: ?*GdkEvent) guint;
pub extern fn gdk_scroll_event_get_type() GType;
pub extern fn gdk_scroll_event_get_direction(event: ?*GdkEvent) GdkScrollDirection;
pub extern fn gdk_scroll_event_get_deltas(event: ?*GdkEvent, delta_x: [*c]f64, delta_y: [*c]f64) void;
pub extern fn gdk_scroll_event_get_unit(event: ?*GdkEvent) GdkScrollUnit;
pub extern fn gdk_scroll_event_is_stop(event: ?*GdkEvent) gboolean;
pub extern fn gdk_key_event_get_type() GType;
pub extern fn gdk_key_event_get_keyval(event: ?*GdkEvent) guint;
pub extern fn gdk_key_event_get_keycode(event: ?*GdkEvent) guint;
pub extern fn gdk_key_event_get_consumed_modifiers(event: ?*GdkEvent) GdkModifierType;
pub extern fn gdk_key_event_get_layout(event: ?*GdkEvent) guint;
pub extern fn gdk_key_event_get_level(event: ?*GdkEvent) guint;
pub extern fn gdk_key_event_is_modifier(event: ?*GdkEvent) gboolean;
pub extern fn gdk_focus_event_get_type() GType;
pub extern fn gdk_focus_event_get_in(event: ?*GdkEvent) gboolean;
pub extern fn gdk_touch_event_get_type() GType;
pub extern fn gdk_touch_event_get_emulating_pointer(event: ?*GdkEvent) gboolean;
pub extern fn gdk_crossing_event_get_type() GType;
pub extern fn gdk_crossing_event_get_mode(event: ?*GdkEvent) GdkCrossingMode;
pub extern fn gdk_crossing_event_get_detail(event: ?*GdkEvent) GdkNotifyType;
pub extern fn gdk_crossing_event_get_focus(event: ?*GdkEvent) gboolean;
pub extern fn gdk_touchpad_event_get_type() GType;
pub extern fn gdk_touchpad_event_get_gesture_phase(event: ?*GdkEvent) GdkTouchpadGesturePhase;
pub extern fn gdk_touchpad_event_get_n_fingers(event: ?*GdkEvent) guint;
pub extern fn gdk_touchpad_event_get_deltas(event: ?*GdkEvent, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn gdk_touchpad_event_get_pinch_angle_delta(event: ?*GdkEvent) f64;
pub extern fn gdk_touchpad_event_get_pinch_scale(event: ?*GdkEvent) f64;
pub extern fn gdk_pad_event_get_type() GType;
pub extern fn gdk_pad_event_get_button(event: ?*GdkEvent) guint;
pub extern fn gdk_pad_event_get_axis_value(event: ?*GdkEvent, index: [*c]guint, value: [*c]f64) void;
pub extern fn gdk_pad_event_get_group_mode(event: ?*GdkEvent, group: [*c]guint, mode: [*c]guint) void;
pub extern fn gdk_dnd_event_get_type() GType;
pub extern fn gdk_dnd_event_get_drop(event: ?*GdkEvent) ?*GdkDrop;
pub extern fn gdk_grab_broken_event_get_type() GType;
pub extern fn gdk_grab_broken_event_get_grab_surface(event: ?*GdkEvent) ?*GdkSurface;
pub extern fn gdk_grab_broken_event_get_implicit(event: ?*GdkEvent) gboolean;
pub extern fn gdk_motion_event_get_type() GType;
pub extern fn gdk_delete_event_get_type() GType;
pub extern fn gdk_proximity_event_get_type() GType;
pub extern fn gdk_event_triggers_context_menu(event: ?*GdkEvent) gboolean;
pub extern fn gdk_events_get_distance(event1: ?*GdkEvent, event2: ?*GdkEvent, distance: [*c]f64) gboolean;
pub extern fn gdk_events_get_angle(event1: ?*GdkEvent, event2: ?*GdkEvent, angle: [*c]f64) gboolean;
pub extern fn gdk_events_get_center(event1: ?*GdkEvent, event2: ?*GdkEvent, x: [*c]f64, y: [*c]f64) gboolean;
pub const GDK_KEY_MATCH_NONE: c_int = 0;
pub const GDK_KEY_MATCH_PARTIAL: c_int = 1;
pub const GDK_KEY_MATCH_EXACT: c_int = 2;
pub const GdkKeyMatch = c_uint;
pub extern fn gdk_key_event_matches(event: ?*GdkEvent, keyval: guint, modifiers: GdkModifierType) GdkKeyMatch;
pub extern fn gdk_key_event_get_match(event: ?*GdkEvent, keyval: [*c]guint, modifiers: [*c]GdkModifierType) gboolean;
pub const GdkEvent_autoptr = ?*GdkEvent;
pub const GdkEvent_listautoptr = [*c]GList;
pub const GdkEvent_slistautoptr = [*c]GSList;
pub const GdkEvent_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkEvent(arg__ptr: ?*GdkEvent) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_event_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkEvent(arg__ptr: [*c]?*GdkEvent) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkEvent(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkEvent(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_event_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkEvent(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_event_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkEvent(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_event_unref)))))));
    }
}
pub const struct__GdkFrameTimings = opaque {};
pub const GdkFrameTimings = struct__GdkFrameTimings;
pub extern fn gdk_frame_timings_get_type() GType;
pub extern fn gdk_frame_timings_ref(timings: ?*GdkFrameTimings) ?*GdkFrameTimings;
pub extern fn gdk_frame_timings_unref(timings: ?*GdkFrameTimings) void;
pub extern fn gdk_frame_timings_get_frame_counter(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_complete(timings: ?*GdkFrameTimings) gboolean;
pub extern fn gdk_frame_timings_get_frame_time(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_presentation_time(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_refresh_interval(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_predicted_presentation_time(timings: ?*GdkFrameTimings) gint64;
pub const GdkFrameTimings_autoptr = ?*GdkFrameTimings;
pub const GdkFrameTimings_listautoptr = [*c]GList;
pub const GdkFrameTimings_slistautoptr = [*c]GSList;
pub const GdkFrameTimings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkFrameTimings(arg__ptr: ?*GdkFrameTimings) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_frame_timings_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkFrameTimings(arg__ptr: [*c]?*GdkFrameTimings) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkFrameTimings(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkFrameTimings(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_frame_timings_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkFrameTimings(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_frame_timings_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkFrameTimings(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_frame_timings_unref)))))));
    }
}
pub const struct__GdkFrameClock = opaque {};
pub const GdkFrameClock = struct__GdkFrameClock;
pub const struct__GdkFrameClockPrivate = opaque {};
pub const GdkFrameClockPrivate = struct__GdkFrameClockPrivate;
pub const struct__GdkFrameClockClass = opaque {};
pub const GdkFrameClockClass = struct__GdkFrameClockClass;
pub const GDK_FRAME_CLOCK_PHASE_NONE: c_int = 0;
pub const GDK_FRAME_CLOCK_PHASE_FLUSH_EVENTS: c_int = 1;
pub const GDK_FRAME_CLOCK_PHASE_BEFORE_PAINT: c_int = 2;
pub const GDK_FRAME_CLOCK_PHASE_UPDATE: c_int = 4;
pub const GDK_FRAME_CLOCK_PHASE_LAYOUT: c_int = 8;
pub const GDK_FRAME_CLOCK_PHASE_PAINT: c_int = 16;
pub const GDK_FRAME_CLOCK_PHASE_RESUME_EVENTS: c_int = 32;
pub const GDK_FRAME_CLOCK_PHASE_AFTER_PAINT: c_int = 64;
pub const GdkFrameClockPhase = c_uint;
pub extern fn gdk_frame_clock_get_type() GType;
pub extern fn gdk_frame_clock_get_frame_time(frame_clock: ?*GdkFrameClock) gint64;
pub extern fn gdk_frame_clock_request_phase(frame_clock: ?*GdkFrameClock, phase: GdkFrameClockPhase) void;
pub extern fn gdk_frame_clock_begin_updating(frame_clock: ?*GdkFrameClock) void;
pub extern fn gdk_frame_clock_end_updating(frame_clock: ?*GdkFrameClock) void;
pub extern fn gdk_frame_clock_get_frame_counter(frame_clock: ?*GdkFrameClock) gint64;
pub extern fn gdk_frame_clock_get_history_start(frame_clock: ?*GdkFrameClock) gint64;
pub extern fn gdk_frame_clock_get_timings(frame_clock: ?*GdkFrameClock, frame_counter: gint64) ?*GdkFrameTimings;
pub extern fn gdk_frame_clock_get_current_timings(frame_clock: ?*GdkFrameClock) ?*GdkFrameTimings;
pub extern fn gdk_frame_clock_get_refresh_info(frame_clock: ?*GdkFrameClock, base_time: gint64, refresh_interval_return: [*c]gint64, presentation_time_return: [*c]gint64) void;
pub extern fn gdk_frame_clock_get_fps(frame_clock: ?*GdkFrameClock) f64;
pub const GdkFrameClock_autoptr = ?*GdkFrameClock;
pub const GdkFrameClock_listautoptr = [*c]GList;
pub const GdkFrameClock_slistautoptr = [*c]GSList;
pub const GdkFrameClock_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkFrameClock(arg__ptr: ?*GdkFrameClock) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkFrameClock(arg__ptr: [*c]?*GdkFrameClock) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkFrameClock(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkFrameClock(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkFrameClock(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkFrameClock(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkMonitor = opaque {};
pub const GdkMonitor = struct__GdkMonitor;
pub const struct__GdkMonitorClass = opaque {};
pub const GdkMonitorClass = struct__GdkMonitorClass;
pub const GDK_SUBPIXEL_LAYOUT_UNKNOWN: c_int = 0;
pub const GDK_SUBPIXEL_LAYOUT_NONE: c_int = 1;
pub const GDK_SUBPIXEL_LAYOUT_HORIZONTAL_RGB: c_int = 2;
pub const GDK_SUBPIXEL_LAYOUT_HORIZONTAL_BGR: c_int = 3;
pub const GDK_SUBPIXEL_LAYOUT_VERTICAL_RGB: c_int = 4;
pub const GDK_SUBPIXEL_LAYOUT_VERTICAL_BGR: c_int = 5;
pub const GdkSubpixelLayout = c_uint;
pub extern fn gdk_monitor_get_type() GType;
pub extern fn gdk_monitor_get_display(monitor: ?*GdkMonitor) ?*GdkDisplay;
pub extern fn gdk_monitor_get_geometry(monitor: ?*GdkMonitor, geometry: [*c]GdkRectangle) void;
pub extern fn gdk_monitor_get_width_mm(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_height_mm(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_manufacturer(monitor: ?*GdkMonitor) [*c]const u8;
pub extern fn gdk_monitor_get_model(monitor: ?*GdkMonitor) [*c]const u8;
pub extern fn gdk_monitor_get_connector(monitor: ?*GdkMonitor) [*c]const u8;
pub extern fn gdk_monitor_get_scale_factor(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_refresh_rate(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_subpixel_layout(monitor: ?*GdkMonitor) GdkSubpixelLayout;
pub extern fn gdk_monitor_is_valid(monitor: ?*GdkMonitor) gboolean;
pub extern fn gdk_monitor_get_description(monitor: ?*GdkMonitor) [*c]const u8;
pub const GdkMonitor_autoptr = ?*GdkMonitor;
pub const GdkMonitor_listautoptr = [*c]GList;
pub const GdkMonitor_slistautoptr = [*c]GSList;
pub const GdkMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkMonitor(arg__ptr: ?*GdkMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkMonitor(arg__ptr: [*c]?*GdkMonitor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkMonitor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkMonitor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkMonitor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkMonitor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDK_ANCHOR_FLIP_X: c_int = 1;
pub const GDK_ANCHOR_FLIP_Y: c_int = 2;
pub const GDK_ANCHOR_SLIDE_X: c_int = 4;
pub const GDK_ANCHOR_SLIDE_Y: c_int = 8;
pub const GDK_ANCHOR_RESIZE_X: c_int = 16;
pub const GDK_ANCHOR_RESIZE_Y: c_int = 32;
pub const GDK_ANCHOR_FLIP: c_int = 3;
pub const GDK_ANCHOR_SLIDE: c_int = 12;
pub const GDK_ANCHOR_RESIZE: c_int = 48;
pub const GdkAnchorHints = c_uint;
pub const struct__GdkPopupLayout = opaque {};
pub const GdkPopupLayout = struct__GdkPopupLayout;
pub extern fn gdk_popup_layout_get_type() GType;
pub extern fn gdk_popup_layout_new(anchor_rect: [*c]const GdkRectangle, rect_anchor: GdkGravity, surface_anchor: GdkGravity) ?*GdkPopupLayout;
pub extern fn gdk_popup_layout_ref(layout: ?*GdkPopupLayout) ?*GdkPopupLayout;
pub extern fn gdk_popup_layout_unref(layout: ?*GdkPopupLayout) void;
pub extern fn gdk_popup_layout_copy(layout: ?*GdkPopupLayout) ?*GdkPopupLayout;
pub extern fn gdk_popup_layout_equal(layout: ?*GdkPopupLayout, other: ?*GdkPopupLayout) gboolean;
pub extern fn gdk_popup_layout_set_anchor_rect(layout: ?*GdkPopupLayout, anchor_rect: [*c]const GdkRectangle) void;
pub extern fn gdk_popup_layout_get_anchor_rect(layout: ?*GdkPopupLayout) [*c]const GdkRectangle;
pub extern fn gdk_popup_layout_set_rect_anchor(layout: ?*GdkPopupLayout, anchor: GdkGravity) void;
pub extern fn gdk_popup_layout_get_rect_anchor(layout: ?*GdkPopupLayout) GdkGravity;
pub extern fn gdk_popup_layout_set_surface_anchor(layout: ?*GdkPopupLayout, anchor: GdkGravity) void;
pub extern fn gdk_popup_layout_get_surface_anchor(layout: ?*GdkPopupLayout) GdkGravity;
pub extern fn gdk_popup_layout_set_anchor_hints(layout: ?*GdkPopupLayout, anchor_hints: GdkAnchorHints) void;
pub extern fn gdk_popup_layout_get_anchor_hints(layout: ?*GdkPopupLayout) GdkAnchorHints;
pub extern fn gdk_popup_layout_set_offset(layout: ?*GdkPopupLayout, dx: c_int, dy: c_int) void;
pub extern fn gdk_popup_layout_get_offset(layout: ?*GdkPopupLayout, dx: [*c]c_int, dy: [*c]c_int) void;
pub extern fn gdk_popup_layout_set_shadow_width(layout: ?*GdkPopupLayout, left: c_int, right: c_int, top: c_int, bottom: c_int) void;
pub extern fn gdk_popup_layout_get_shadow_width(layout: ?*GdkPopupLayout, left: [*c]c_int, right: [*c]c_int, top: [*c]c_int, bottom: [*c]c_int) void;
pub const GdkPopupLayout_autoptr = ?*GdkPopupLayout;
pub const GdkPopupLayout_listautoptr = [*c]GList;
pub const GdkPopupLayout_slistautoptr = [*c]GSList;
pub const GdkPopupLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPopupLayout(arg__ptr: ?*GdkPopupLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_popup_layout_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkPopupLayout(arg__ptr: [*c]?*GdkPopupLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPopupLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPopupLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_popup_layout_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPopupLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_popup_layout_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPopupLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_popup_layout_unref)))))));
    }
}
pub const struct__GdkSurfaceClass = opaque {};
pub const GdkSurfaceClass = struct__GdkSurfaceClass;
pub extern fn gdk_surface_get_type() GType;
pub extern fn gdk_surface_new_toplevel(display: ?*GdkDisplay) ?*GdkSurface;
pub extern fn gdk_surface_new_popup(parent: ?*GdkSurface, autohide: gboolean) ?*GdkSurface;
pub extern fn gdk_surface_destroy(surface: ?*GdkSurface) void;
pub extern fn gdk_surface_is_destroyed(surface: ?*GdkSurface) gboolean;
pub extern fn gdk_surface_get_display(surface: ?*GdkSurface) ?*GdkDisplay;
pub extern fn gdk_surface_hide(surface: ?*GdkSurface) void;
pub extern fn gdk_surface_set_input_region(surface: ?*GdkSurface, region: ?*cairo_region_t) void;
pub extern fn gdk_surface_get_mapped(surface: ?*GdkSurface) gboolean;
pub extern fn gdk_surface_set_cursor(surface: ?*GdkSurface, cursor: ?*GdkCursor) void;
pub extern fn gdk_surface_get_cursor(surface: ?*GdkSurface) ?*GdkCursor;
pub extern fn gdk_surface_set_device_cursor(surface: ?*GdkSurface, device: ?*GdkDevice, cursor: ?*GdkCursor) void;
pub extern fn gdk_surface_get_device_cursor(surface: ?*GdkSurface, device: ?*GdkDevice) ?*GdkCursor;
pub extern fn gdk_surface_get_width(surface: ?*GdkSurface) c_int;
pub extern fn gdk_surface_get_height(surface: ?*GdkSurface) c_int;
pub extern fn gdk_surface_translate_coordinates(from: ?*GdkSurface, to: ?*GdkSurface, x: [*c]f64, y: [*c]f64) gboolean;
pub extern fn gdk_surface_get_scale_factor(surface: ?*GdkSurface) c_int;
pub extern fn gdk_surface_get_scale(surface: ?*GdkSurface) f64;
pub extern fn gdk_surface_get_device_position(surface: ?*GdkSurface, device: ?*GdkDevice, x: [*c]f64, y: [*c]f64, mask: [*c]GdkModifierType) gboolean;
pub extern fn gdk_surface_create_similar_surface(surface: ?*GdkSurface, content: cairo_content_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn gdk_surface_beep(surface: ?*GdkSurface) void;
pub extern fn gdk_surface_queue_render(surface: ?*GdkSurface) void;
pub extern fn gdk_surface_request_layout(surface: ?*GdkSurface) void;
pub extern fn gdk_surface_get_frame_clock(surface: ?*GdkSurface) ?*GdkFrameClock;
pub extern fn gdk_surface_set_opaque_region(surface: ?*GdkSurface, region: ?*cairo_region_t) void;
pub extern fn gdk_surface_create_cairo_context(surface: ?*GdkSurface) ?*GdkCairoContext;
pub extern fn gdk_surface_create_gl_context(surface: ?*GdkSurface, @"error": [*c][*c]GError) ?*GdkGLContext;
pub extern fn gdk_surface_create_vulkan_context(surface: ?*GdkSurface, @"error": [*c][*c]GError) ?*GdkVulkanContext;
pub const GdkSurface_autoptr = ?*GdkSurface;
pub const GdkSurface_listautoptr = [*c]GList;
pub const GdkSurface_slistautoptr = [*c]GSList;
pub const GdkSurface_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkSurface(arg__ptr: ?*GdkSurface) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkSurface(arg__ptr: [*c]?*GdkSurface) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkSurface(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkSurface(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkSurface(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkSurface(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GDK_SEAT_CAPABILITY_NONE: c_int = 0;
pub const GDK_SEAT_CAPABILITY_POINTER: c_int = 1;
pub const GDK_SEAT_CAPABILITY_TOUCH: c_int = 2;
pub const GDK_SEAT_CAPABILITY_TABLET_STYLUS: c_int = 4;
pub const GDK_SEAT_CAPABILITY_KEYBOARD: c_int = 8;
pub const GDK_SEAT_CAPABILITY_TABLET_PAD: c_int = 16;
pub const GDK_SEAT_CAPABILITY_ALL_POINTING: c_int = 7;
pub const GDK_SEAT_CAPABILITY_ALL: c_int = 31;
pub const GdkSeatCapabilities = c_uint;
pub extern fn gdk_seat_get_type() GType;
pub extern fn gdk_seat_get_display(seat: [*c]GdkSeat) ?*GdkDisplay;
pub extern fn gdk_seat_get_capabilities(seat: [*c]GdkSeat) GdkSeatCapabilities;
pub extern fn gdk_seat_get_devices(seat: [*c]GdkSeat, capabilities: GdkSeatCapabilities) [*c]GList;
pub extern fn gdk_seat_get_tools(seat: [*c]GdkSeat) [*c]GList;
pub extern fn gdk_seat_get_pointer(seat: [*c]GdkSeat) ?*GdkDevice;
pub extern fn gdk_seat_get_keyboard(seat: [*c]GdkSeat) ?*GdkDevice;
pub const GdkSeat_autoptr = [*c]GdkSeat;
pub const GdkSeat_listautoptr = [*c]GList;
pub const GdkSeat_slistautoptr = [*c]GSList;
pub const GdkSeat_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkSeat(arg__ptr: [*c]GdkSeat) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkSeat(arg__ptr: [*c][*c]GdkSeat) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkSeat(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkSeat(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkSeat(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkSeat(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_display_get_type() GType;
pub extern fn gdk_display_open(display_name: [*c]const u8) ?*GdkDisplay;
pub extern fn gdk_display_get_name(display: ?*GdkDisplay) [*c]const u8;
pub extern fn gdk_display_device_is_grabbed(display: ?*GdkDisplay, device: ?*GdkDevice) gboolean;
pub extern fn gdk_display_beep(display: ?*GdkDisplay) void;
pub extern fn gdk_display_sync(display: ?*GdkDisplay) void;
pub extern fn gdk_display_flush(display: ?*GdkDisplay) void;
pub extern fn gdk_display_close(display: ?*GdkDisplay) void;
pub extern fn gdk_display_is_closed(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_is_composited(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_is_rgba(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_supports_input_shapes(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_prepare_gl(self: ?*GdkDisplay, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_display_create_gl_context(self: ?*GdkDisplay, @"error": [*c][*c]GError) ?*GdkGLContext;
pub extern fn gdk_display_get_default() ?*GdkDisplay;
pub extern fn gdk_display_get_clipboard(display: ?*GdkDisplay) ?*GdkClipboard;
pub extern fn gdk_display_get_primary_clipboard(display: ?*GdkDisplay) ?*GdkClipboard;
pub extern fn gdk_display_notify_startup_complete(display: ?*GdkDisplay, startup_id: [*c]const u8) void;
pub extern fn gdk_display_get_startup_notification_id(display: ?*GdkDisplay) [*c]const u8;
pub extern fn gdk_display_get_app_launch_context(display: ?*GdkDisplay) ?*GdkAppLaunchContext;
pub extern fn gdk_display_get_default_seat(display: ?*GdkDisplay) [*c]GdkSeat;
pub extern fn gdk_display_list_seats(display: ?*GdkDisplay) [*c]GList;
pub extern fn gdk_display_get_monitors(self: ?*GdkDisplay) ?*GListModel;
pub extern fn gdk_display_get_monitor_at_surface(display: ?*GdkDisplay, surface: ?*GdkSurface) ?*GdkMonitor;
pub extern fn gdk_display_put_event(display: ?*GdkDisplay, event: ?*GdkEvent) void;
pub extern fn gdk_display_map_keyval(display: ?*GdkDisplay, keyval: guint, keys: [*c][*c]GdkKeymapKey, n_keys: [*c]c_int) gboolean;
pub extern fn gdk_display_map_keycode(display: ?*GdkDisplay, keycode: guint, keys: [*c][*c]GdkKeymapKey, keyvals: [*c][*c]guint, n_entries: [*c]c_int) gboolean;
pub extern fn gdk_display_translate_key(display: ?*GdkDisplay, keycode: guint, state: GdkModifierType, group: c_int, keyval: [*c]guint, effective_group: [*c]c_int, level: [*c]c_int, consumed: [*c]GdkModifierType) gboolean;
pub extern fn gdk_display_get_setting(display: ?*GdkDisplay, name: [*c]const u8, value: [*c]GValue) gboolean;
pub const GdkDisplay_autoptr = ?*GdkDisplay;
pub const GdkDisplay_listautoptr = [*c]GList;
pub const GdkDisplay_slistautoptr = [*c]GSList;
pub const GdkDisplay_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDisplay(arg__ptr: ?*GdkDisplay) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkDisplay(arg__ptr: [*c]?*GdkDisplay) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDisplay(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDisplay(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDisplay(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDisplay(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_display_manager_get_type() GType;
pub extern fn gdk_display_manager_get() ?*GdkDisplayManager;
pub extern fn gdk_display_manager_get_default_display(manager: ?*GdkDisplayManager) ?*GdkDisplay;
pub extern fn gdk_display_manager_set_default_display(manager: ?*GdkDisplayManager, display: ?*GdkDisplay) void;
pub extern fn gdk_display_manager_list_displays(manager: ?*GdkDisplayManager) [*c]GSList;
pub extern fn gdk_display_manager_open_display(manager: ?*GdkDisplayManager, name: [*c]const u8) ?*GdkDisplay;
pub extern fn gdk_set_allowed_backends(backends: [*c]const u8) void;
pub const GdkDisplayManager_autoptr = ?*GdkDisplayManager;
pub const GdkDisplayManager_listautoptr = [*c]GList;
pub const GdkDisplayManager_slistautoptr = [*c]GSList;
pub const GdkDisplayManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDisplayManager(arg__ptr: ?*GdkDisplayManager) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkDisplayManager(arg__ptr: [*c]?*GdkDisplayManager) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDisplayManager(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDisplayManager(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDisplayManager(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDisplayManager(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_drag_surface_get_type() GType;
pub const struct__GdkDragSurface = opaque {};
pub const GdkDragSurface = struct__GdkDragSurface;
pub const struct__GdkDragSurfaceInterface = opaque {};
pub const GdkDragSurfaceInterface = struct__GdkDragSurfaceInterface;
pub const GdkDragSurface_autoptr = ?*GdkDragSurface;
pub const GdkDragSurface_listautoptr = [*c]GList;
pub const GdkDragSurface_slistautoptr = [*c]GSList;
pub const GdkDragSurface_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDragSurface(arg__ptr: ?*GdkDragSurface) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GdkDragSurface(arg__ptr: [*c]?*GdkDragSurface) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDragSurface(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDragSurface(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDragSurface(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDragSurface(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GDK_DRAG_SURFACE(arg_ptr: gpointer) callconv(.C) ?*GdkDragSurface {
    var ptr = arg_ptr;
    return @as(?*GdkDragSurface, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gdk_drag_surface_get_type())))));
}
pub fn GDK_IS_DRAG_SURFACE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gdk_drag_surface_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GDK_DRAG_SURFACE_GET_IFACE(arg_ptr: gpointer) callconv(.C) ?*GdkDragSurfaceInterface {
    var ptr = arg_ptr;
    return @as(?*GdkDragSurfaceInterface, @ptrCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gdk_drag_surface_get_type())));
}
pub extern fn gdk_drag_surface_present(drag_surface: ?*GdkDragSurface, width: c_int, height: c_int) gboolean;
pub const struct__GdkDragSurfaceSize = opaque {};
pub const GdkDragSurfaceSize = struct__GdkDragSurfaceSize;
pub extern fn gdk_drag_surface_size_get_type() GType;
pub extern fn gdk_drag_surface_size_set_size(size: ?*GdkDragSurfaceSize, width: c_int, height: c_int) void;
pub extern fn gdk_draw_context_get_type() GType;
pub extern fn gdk_draw_context_get_display(context: ?*GdkDrawContext) ?*GdkDisplay;
pub extern fn gdk_draw_context_get_surface(context: ?*GdkDrawContext) ?*GdkSurface;
pub extern fn gdk_draw_context_begin_frame(context: ?*GdkDrawContext, region: ?*const cairo_region_t) void;
pub extern fn gdk_draw_context_end_frame(context: ?*GdkDrawContext) void;
pub extern fn gdk_draw_context_is_in_frame(context: ?*GdkDrawContext) gboolean;
pub extern fn gdk_draw_context_get_frame_region(context: ?*GdkDrawContext) ?*const cairo_region_t;
pub const GdkDrawContext_autoptr = ?*GdkDrawContext;
pub const GdkDrawContext_listautoptr = [*c]GList;
pub const GdkDrawContext_slistautoptr = [*c]GSList;
pub const GdkDrawContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDrawContext(arg__ptr: ?*GdkDrawContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkDrawContext(arg__ptr: [*c]?*GdkDrawContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDrawContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDrawContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDrawContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDrawContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_drop_get_type() GType;
pub extern fn gdk_drop_get_display(self: ?*GdkDrop) ?*GdkDisplay;
pub extern fn gdk_drop_get_device(self: ?*GdkDrop) ?*GdkDevice;
pub extern fn gdk_drop_get_surface(self: ?*GdkDrop) ?*GdkSurface;
pub extern fn gdk_drop_get_formats(self: ?*GdkDrop) ?*GdkContentFormats;
pub extern fn gdk_drop_get_actions(self: ?*GdkDrop) GdkDragAction;
pub extern fn gdk_drop_get_drag(self: ?*GdkDrop) ?*GdkDrag;
pub extern fn gdk_drop_status(self: ?*GdkDrop, actions: GdkDragAction, preferred: GdkDragAction) void;
pub extern fn gdk_drop_finish(self: ?*GdkDrop, action: GdkDragAction) void;
pub extern fn gdk_drop_read_async(self: ?*GdkDrop, mime_types: [*c][*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_drop_read_finish(self: ?*GdkDrop, result: ?*GAsyncResult, out_mime_type: [*c][*c]const u8, @"error": [*c][*c]GError) [*c]GInputStream;
pub extern fn gdk_drop_read_value_async(self: ?*GdkDrop, @"type": GType, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_drop_read_value_finish(self: ?*GdkDrop, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]const GValue;
pub const GdkDrop_autoptr = ?*GdkDrop;
pub const GdkDrop_listautoptr = [*c]GList;
pub const GdkDrop_slistautoptr = [*c]GSList;
pub const GdkDrop_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDrop(arg__ptr: ?*GdkDrop) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkDrop(arg__ptr: [*c]?*GdkDrop) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkDrop(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkDrop(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkDrop(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkDrop(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_input_source_get_type() GType;
pub extern fn gdk_device_pad_feature_get_type() GType;
pub extern fn gdk_device_tool_type_get_type() GType;
pub extern fn gdk_drag_cancel_reason_get_type() GType;
pub extern fn gdk_gl_api_get_type() GType;
pub extern fn gdk_gravity_get_type() GType;
pub extern fn gdk_modifier_type_get_type() GType;
pub extern fn gdk_gl_error_get_type() GType;
pub extern fn gdk_vulkan_error_get_type() GType;
pub extern fn gdk_axis_use_get_type() GType;
pub extern fn gdk_axis_flags_get_type() GType;
pub extern fn gdk_drag_action_get_type() GType;
pub extern fn gdk_memory_format_get_type() GType;
pub extern fn gdk_event_type_get_type() GType;
pub extern fn gdk_touchpad_gesture_phase_get_type() GType;
pub extern fn gdk_scroll_direction_get_type() GType;
pub extern fn gdk_scroll_unit_get_type() GType;
pub extern fn gdk_notify_type_get_type() GType;
pub extern fn gdk_crossing_mode_get_type() GType;
pub extern fn gdk_key_match_get_type() GType;
pub extern fn gdk_frame_clock_phase_get_type() GType;
pub extern fn gdk_subpixel_layout_get_type() GType;
pub extern fn gdk_paintable_flags_get_type() GType;
pub extern fn gdk_anchor_hints_get_type() GType;
pub extern fn gdk_seat_capabilities_get_type() GType;
pub extern fn gdk_texture_error_get_type() GType;
pub extern fn gdk_surface_edge_get_type() GType;
pub extern fn gdk_fullscreen_mode_get_type() GType;
pub extern fn gdk_toplevel_state_get_type() GType;
pub extern fn gdk_titlebar_gesture_get_type() GType;
pub extern fn gdk_gl_error_quark() GQuark;
pub extern fn gdk_gl_context_get_type() GType;
pub extern fn gdk_gl_context_get_display(context: ?*GdkGLContext) ?*GdkDisplay;
pub extern fn gdk_gl_context_get_surface(context: ?*GdkGLContext) ?*GdkSurface;
pub extern fn gdk_gl_context_get_shared_context(context: ?*GdkGLContext) ?*GdkGLContext;
pub extern fn gdk_gl_context_get_version(context: ?*GdkGLContext, major: [*c]c_int, minor: [*c]c_int) void;
pub extern fn gdk_gl_context_is_legacy(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_is_shared(self: ?*GdkGLContext, other: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_set_required_version(context: ?*GdkGLContext, major: c_int, minor: c_int) void;
pub extern fn gdk_gl_context_get_required_version(context: ?*GdkGLContext, major: [*c]c_int, minor: [*c]c_int) void;
pub extern fn gdk_gl_context_set_debug_enabled(context: ?*GdkGLContext, enabled: gboolean) void;
pub extern fn gdk_gl_context_get_debug_enabled(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_set_forward_compatible(context: ?*GdkGLContext, compatible: gboolean) void;
pub extern fn gdk_gl_context_get_forward_compatible(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_set_allowed_apis(self: ?*GdkGLContext, apis: GdkGLAPI) void;
pub extern fn gdk_gl_context_get_allowed_apis(self: ?*GdkGLContext) GdkGLAPI;
pub extern fn gdk_gl_context_get_api(self: ?*GdkGLContext) GdkGLAPI;
pub extern fn gdk_gl_context_set_use_es(context: ?*GdkGLContext, use_es: c_int) void;
pub extern fn gdk_gl_context_get_use_es(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_realize(context: ?*GdkGLContext, @"error": [*c][*c]GError) gboolean;
pub extern fn gdk_gl_context_make_current(context: ?*GdkGLContext) void;
pub extern fn gdk_gl_context_get_current() ?*GdkGLContext;
pub extern fn gdk_gl_context_clear_current() void;
pub const GdkGLContext_autoptr = ?*GdkGLContext;
pub const GdkGLContext_listautoptr = [*c]GList;
pub const GdkGLContext_slistautoptr = [*c]GSList;
pub const GdkGLContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkGLContext(arg__ptr: ?*GdkGLContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkGLContext(arg__ptr: [*c]?*GdkGLContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkGLContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkGLContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkGLContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkGLContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkTextureClass = opaque {};
pub const GdkTextureClass = struct__GdkTextureClass;
pub extern fn gdk_texture_error_quark() GQuark;
pub const GDK_TEXTURE_ERROR_TOO_LARGE: c_int = 0;
pub const GDK_TEXTURE_ERROR_CORRUPT_IMAGE: c_int = 1;
pub const GDK_TEXTURE_ERROR_UNSUPPORTED_CONTENT: c_int = 2;
pub const GDK_TEXTURE_ERROR_UNSUPPORTED_FORMAT: c_int = 3;
pub const GdkTextureError = c_uint;
pub extern fn gdk_texture_get_type() GType;
pub extern fn gdk_texture_new_for_pixbuf(pixbuf: ?*GdkPixbuf) ?*GdkTexture;
pub extern fn gdk_texture_new_from_resource(resource_path: [*c]const u8) ?*GdkTexture;
pub extern fn gdk_texture_new_from_file(file: ?*GFile, @"error": [*c][*c]GError) ?*GdkTexture;
pub extern fn gdk_texture_new_from_filename(path: [*c]const u8, @"error": [*c][*c]GError) ?*GdkTexture;
pub extern fn gdk_texture_new_from_bytes(bytes: ?*GBytes, @"error": [*c][*c]GError) ?*GdkTexture;
pub extern fn gdk_texture_get_width(texture: ?*GdkTexture) c_int;
pub extern fn gdk_texture_get_height(texture: ?*GdkTexture) c_int;
pub extern fn gdk_texture_get_format(self: ?*GdkTexture) GdkMemoryFormat;
pub extern fn gdk_texture_download(texture: ?*GdkTexture, data: [*c]guchar, stride: gsize) void;
pub extern fn gdk_texture_save_to_png(texture: ?*GdkTexture, filename: [*c]const u8) gboolean;
pub extern fn gdk_texture_save_to_png_bytes(texture: ?*GdkTexture) ?*GBytes;
pub extern fn gdk_texture_save_to_tiff(texture: ?*GdkTexture, filename: [*c]const u8) gboolean;
pub extern fn gdk_texture_save_to_tiff_bytes(texture: ?*GdkTexture) ?*GBytes;
pub const GdkTexture_autoptr = ?*GdkTexture;
pub const GdkTexture_listautoptr = [*c]GList;
pub const GdkTexture_slistautoptr = [*c]GSList;
pub const GdkTexture_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkTexture(arg__ptr: ?*GdkTexture) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkTexture(arg__ptr: [*c]?*GdkTexture) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkTexture(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkTexture(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkTexture(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkTexture(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GdkGLTexture = opaque {};
pub const GdkGLTexture = struct__GdkGLTexture;
pub const struct__GdkGLTextureClass = opaque {};
pub const GdkGLTextureClass = struct__GdkGLTextureClass;
pub extern fn gdk_gl_texture_get_type() GType;
pub extern fn gdk_gl_texture_new(context: ?*GdkGLContext, id: guint, width: c_int, height: c_int, destroy: GDestroyNotify, data: gpointer) ?*GdkTexture;
pub extern fn gdk_gl_texture_release(self: ?*GdkGLTexture) void;
pub const GdkGLTexture_autoptr = ?*GdkGLTexture;
pub const GdkGLTexture_listautoptr = [*c]GList;
pub const GdkGLTexture_slistautoptr = [*c]GSList;
pub const GdkGLTexture_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkGLTexture(arg__ptr: ?*GdkGLTexture) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkGLTexture(arg__ptr: [*c]?*GdkGLTexture) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkGLTexture(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkGLTexture(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkGLTexture(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkGLTexture(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_gl_texture_builder_get_type() GType;
pub const struct__GdkGLTextureBuilder = opaque {};
pub const GdkGLTextureBuilder = struct__GdkGLTextureBuilder;
pub const struct__GdkGLTextureBuilderClass = opaque {};
pub const GdkGLTextureBuilderClass = struct__GdkGLTextureBuilderClass;
pub const GdkGLTextureBuilder_autoptr = ?*GdkGLTextureBuilder;
pub const GdkGLTextureBuilder_listautoptr = [*c]GList;
pub const GdkGLTextureBuilder_slistautoptr = [*c]GSList;
pub const GdkGLTextureBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkGLTextureBuilder(arg__ptr: ?*GdkGLTextureBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GdkGLTextureBuilder(arg__ptr: [*c]?*GdkGLTextureBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkGLTextureBuilder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkGLTextureBuilder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GdkGLTextureBuilder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GdkGLTextureBuilder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GdkGLTextureBuilderClass_autoptr = ?*GdkGLTextureBuilderClass;
pub const GdkGLTextureBuilderClass_listautoptr = [*c]GList;
pub const GdkGLTextureBuilderClass_slistautoptr = [*c]GSList;
pub const GdkGLTextureBuilderClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkGLTextureBuilderClass(arg__ptr: ?*GdkGLTextureBuilderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkGLTextureBuilderClass(arg__ptr: [*c]?*GdkGLTextureBuilderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkGLTextureBuilderClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkGLTextureBuilderClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkGLTextureBuilderClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkGLTextureBuilderClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GDK_GL_TEXTURE_BUILDER(arg_ptr: gpointer) callconv(.C) ?*GdkGLTextureBuilder {
    var ptr = arg_ptr;
    return @as(?*GdkGLTextureBuilder, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gdk_gl_texture_builder_get_type())))));
}
pub fn GDK_GL_TEXTURE_BUILDER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GdkGLTextureBuilderClass {
    var ptr = arg_ptr;
    return @as(?*GdkGLTextureBuilderClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gdk_gl_texture_builder_get_type())))));
}
pub fn GDK_IS_GL_TEXTURE_BUILDER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gdk_gl_texture_builder_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GDK_IS_GL_TEXTURE_BUILDER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gdk_gl_texture_builder_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GDK_GL_TEXTURE_BUILDER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GdkGLTextureBuilderClass {
    var ptr = arg_ptr;
    return @as(?*GdkGLTextureBuilderClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gdk_gl_texture_builder_new() ?*GdkGLTextureBuilder;
pub extern fn gdk_gl_texture_builder_get_context(self: ?*GdkGLTextureBuilder) ?*GdkGLContext;
pub extern fn gdk_gl_texture_builder_set_context(self: ?*GdkGLTextureBuilder, context: ?*GdkGLContext) void;
pub extern fn gdk_gl_texture_builder_get_id(self: ?*GdkGLTextureBuilder) guint;
pub extern fn gdk_gl_texture_builder_set_id(self: ?*GdkGLTextureBuilder, id: guint) void;
pub extern fn gdk_gl_texture_builder_get_width(self: ?*GdkGLTextureBuilder) c_int;
pub extern fn gdk_gl_texture_builder_set_width(self: ?*GdkGLTextureBuilder, width: c_int) void;
pub extern fn gdk_gl_texture_builder_get_height(self: ?*GdkGLTextureBuilder) c_int;
pub extern fn gdk_gl_texture_builder_set_height(self: ?*GdkGLTextureBuilder, height: c_int) void;
pub extern fn gdk_gl_texture_builder_get_format(self: ?*GdkGLTextureBuilder) GdkMemoryFormat;
pub extern fn gdk_gl_texture_builder_set_format(self: ?*GdkGLTextureBuilder, format: GdkMemoryFormat) void;
pub extern fn gdk_gl_texture_builder_get_has_mipmap(self: ?*GdkGLTextureBuilder) gboolean;
pub extern fn gdk_gl_texture_builder_set_has_mipmap(self: ?*GdkGLTextureBuilder, has_mipmap: gboolean) void;
pub extern fn gdk_gl_texture_builder_get_sync(self: ?*GdkGLTextureBuilder) gpointer;
pub extern fn gdk_gl_texture_builder_set_sync(self: ?*GdkGLTextureBuilder, sync: gpointer) void;
pub extern fn gdk_gl_texture_builder_get_update_texture(self: ?*GdkGLTextureBuilder) ?*GdkTexture;
pub extern fn gdk_gl_texture_builder_set_update_texture(self: ?*GdkGLTextureBuilder, texture: ?*GdkTexture) void;
pub extern fn gdk_gl_texture_builder_get_update_region(self: ?*GdkGLTextureBuilder) ?*cairo_region_t;
pub extern fn gdk_gl_texture_builder_set_update_region(self: ?*GdkGLTextureBuilder, region: ?*cairo_region_t) void;
pub extern fn gdk_gl_texture_builder_build(self: ?*GdkGLTextureBuilder, destroy: GDestroyNotify, data: gpointer) ?*GdkTexture;
pub extern fn gdk_keyval_name(keyval: guint) [*c]const u8;
pub extern fn gdk_keyval_from_name(keyval_name: [*c]const u8) guint;
pub extern fn gdk_keyval_convert_case(symbol: guint, lower: [*c]guint, upper: [*c]guint) void;
pub extern fn gdk_keyval_to_upper(keyval: guint) guint;
pub extern fn gdk_keyval_to_lower(keyval: guint) guint;
pub extern fn gdk_keyval_is_upper(keyval: guint) gboolean;
pub extern fn gdk_keyval_is_lower(keyval: guint) gboolean;
pub extern fn gdk_keyval_to_unicode(keyval: guint) guint32;
pub extern fn gdk_unicode_to_keyval(wc: guint32) guint;
pub const struct__GdkMemoryTexture = opaque {};
pub const GdkMemoryTexture = struct__GdkMemoryTexture;
pub const struct__GdkMemoryTextureClass = opaque {};
pub const GdkMemoryTextureClass = struct__GdkMemoryTextureClass;
pub const GdkMemoryTexture_autoptr = ?*GdkMemoryTexture;
pub const GdkMemoryTexture_listautoptr = [*c]GList;
pub const GdkMemoryTexture_slistautoptr = [*c]GSList;
pub const GdkMemoryTexture_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkMemoryTexture(arg__ptr: ?*GdkMemoryTexture) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkMemoryTexture(arg__ptr: [*c]?*GdkMemoryTexture) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkMemoryTexture(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkMemoryTexture(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkMemoryTexture(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkMemoryTexture(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_memory_texture_get_type() GType;
pub extern fn gdk_memory_texture_new(width: c_int, height: c_int, format: GdkMemoryFormat, bytes: ?*GBytes, stride: gsize) ?*GdkTexture;
pub extern fn gdk_paintable_get_type() GType;
pub const struct__GdkPaintable = opaque {};
pub const GdkPaintable = struct__GdkPaintable;
pub const struct__GdkPaintableInterface = extern struct {
    g_iface: GTypeInterface,
    snapshot: ?*const fn (?*GdkPaintable, ?*GdkSnapshot, f64, f64) callconv(.C) void,
    get_current_image: ?*const fn (?*GdkPaintable) callconv(.C) ?*GdkPaintable,
    get_flags: ?*const fn (?*GdkPaintable) callconv(.C) GdkPaintableFlags,
    get_intrinsic_width: ?*const fn (?*GdkPaintable) callconv(.C) c_int,
    get_intrinsic_height: ?*const fn (?*GdkPaintable) callconv(.C) c_int,
    get_intrinsic_aspect_ratio: ?*const fn (?*GdkPaintable) callconv(.C) f64,
};
pub const GdkPaintableInterface = struct__GdkPaintableInterface;
pub const GdkPaintable_autoptr = ?*GdkPaintable;
pub const GdkPaintable_listautoptr = [*c]GList;
pub const GdkPaintable_slistautoptr = [*c]GSList;
pub const GdkPaintable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPaintable(arg__ptr: ?*GdkPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GdkPaintable(arg__ptr: [*c]?*GdkPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPaintable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPaintable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPaintable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPaintable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GDK_PAINTABLE(arg_ptr: gpointer) callconv(.C) ?*GdkPaintable {
    var ptr = arg_ptr;
    return @as(?*GdkPaintable, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gdk_paintable_get_type())))));
}
pub fn GDK_IS_PAINTABLE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gdk_paintable_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GDK_PAINTABLE_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GdkPaintableInterface {
    var ptr = arg_ptr;
    return @as([*c]GdkPaintableInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gdk_paintable_get_type()))));
}
pub const GDK_PAINTABLE_STATIC_SIZE: c_int = 1;
pub const GDK_PAINTABLE_STATIC_CONTENTS: c_int = 2;
pub const GdkPaintableFlags = c_uint;
pub extern fn gdk_paintable_snapshot(paintable: ?*GdkPaintable, snapshot: ?*GdkSnapshot, width: f64, height: f64) void;
pub extern fn gdk_paintable_get_current_image(paintable: ?*GdkPaintable) ?*GdkPaintable;
pub extern fn gdk_paintable_get_flags(paintable: ?*GdkPaintable) GdkPaintableFlags;
pub extern fn gdk_paintable_get_intrinsic_width(paintable: ?*GdkPaintable) c_int;
pub extern fn gdk_paintable_get_intrinsic_height(paintable: ?*GdkPaintable) c_int;
pub extern fn gdk_paintable_get_intrinsic_aspect_ratio(paintable: ?*GdkPaintable) f64;
pub extern fn gdk_paintable_compute_concrete_size(paintable: ?*GdkPaintable, specified_width: f64, specified_height: f64, default_width: f64, default_height: f64, concrete_width: [*c]f64, concrete_height: [*c]f64) void;
pub extern fn gdk_paintable_invalidate_contents(paintable: ?*GdkPaintable) void;
pub extern fn gdk_paintable_invalidate_size(paintable: ?*GdkPaintable) void;
pub extern fn gdk_paintable_new_empty(intrinsic_width: c_int, intrinsic_height: c_int) ?*GdkPaintable;
pub extern fn gdk_pango_layout_line_get_clip_region(line: ?*PangoLayoutLine, x_origin: c_int, y_origin: c_int, index_ranges: [*c]const c_int, n_ranges: c_int) ?*cairo_region_t;
pub extern fn gdk_pango_layout_get_clip_region(layout: ?*PangoLayout, x_origin: c_int, y_origin: c_int, index_ranges: [*c]const c_int, n_ranges: c_int) ?*cairo_region_t;
pub extern fn gdk_popup_get_type() GType;
pub const struct__GdkPopup = opaque {};
pub const GdkPopup = struct__GdkPopup;
pub const struct__GdkPopupInterface = opaque {};
pub const GdkPopupInterface = struct__GdkPopupInterface;
pub const GdkPopup_autoptr = ?*GdkPopup;
pub const GdkPopup_listautoptr = [*c]GList;
pub const GdkPopup_slistautoptr = [*c]GSList;
pub const GdkPopup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPopup(arg__ptr: ?*GdkPopup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GdkPopup(arg__ptr: [*c]?*GdkPopup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkPopup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkPopup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GdkPopup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GdkPopup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GDK_POPUP(arg_ptr: gpointer) callconv(.C) ?*GdkPopup {
    var ptr = arg_ptr;
    return @as(?*GdkPopup, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gdk_popup_get_type())))));
}
pub fn GDK_IS_POPUP(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gdk_popup_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GDK_POPUP_GET_IFACE(arg_ptr: gpointer) callconv(.C) ?*GdkPopupInterface {
    var ptr = arg_ptr;
    return @as(?*GdkPopupInterface, @ptrCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gdk_popup_get_type())));
}
pub extern fn gdk_popup_present(popup: ?*GdkPopup, width: c_int, height: c_int, layout: ?*GdkPopupLayout) gboolean;
pub extern fn gdk_popup_get_surface_anchor(popup: ?*GdkPopup) GdkGravity;
pub extern fn gdk_popup_get_rect_anchor(popup: ?*GdkPopup) GdkGravity;
pub extern fn gdk_popup_get_parent(popup: ?*GdkPopup) ?*GdkSurface;
pub extern fn gdk_popup_get_position_x(popup: ?*GdkPopup) c_int;
pub extern fn gdk_popup_get_position_y(popup: ?*GdkPopup) c_int;
pub extern fn gdk_popup_get_autohide(popup: ?*GdkPopup) gboolean;
pub extern fn gdk_rectangle_intersect(src1: [*c]const GdkRectangle, src2: [*c]const GdkRectangle, dest: [*c]GdkRectangle) gboolean;
pub extern fn gdk_rectangle_union(src1: [*c]const GdkRectangle, src2: [*c]const GdkRectangle, dest: [*c]GdkRectangle) void;
pub extern fn gdk_rectangle_equal(rect1: [*c]const GdkRectangle, rect2: [*c]const GdkRectangle) gboolean;
pub extern fn gdk_rectangle_contains_point(rect: [*c]const GdkRectangle, x: c_int, y: c_int) gboolean;
pub extern fn gdk_rectangle_get_type() GType;
pub extern fn gdk_rgba_get_type() GType;
pub extern fn gdk_rgba_copy(rgba: [*c]const GdkRGBA) [*c]GdkRGBA;
pub extern fn gdk_rgba_free(rgba: [*c]GdkRGBA) void;
pub extern fn gdk_rgba_is_clear(rgba: [*c]const GdkRGBA) gboolean;
pub extern fn gdk_rgba_is_opaque(rgba: [*c]const GdkRGBA) gboolean;
pub extern fn gdk_rgba_hash(p: gconstpointer) guint;
pub extern fn gdk_rgba_equal(p1: gconstpointer, p2: gconstpointer) gboolean;
pub extern fn gdk_rgba_parse(rgba: [*c]GdkRGBA, spec: [*c]const u8) gboolean;
pub extern fn gdk_rgba_to_string(rgba: [*c]const GdkRGBA) [*c]u8;
pub const GdkRGBA_autoptr = [*c]GdkRGBA;
pub const GdkRGBA_listautoptr = [*c]GList;
pub const GdkRGBA_slistautoptr = [*c]GSList;
pub const GdkRGBA_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkRGBA(arg__ptr: [*c]GdkRGBA) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_rgba_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkRGBA(arg__ptr: [*c][*c]GdkRGBA) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkRGBA(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkRGBA(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_rgba_free)))))));
}
pub fn glib_slistautoptr_cleanup_GdkRGBA(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_rgba_free)))))));
}
pub fn glib_queueautoptr_cleanup_GdkRGBA(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_rgba_free)))))));
    }
}
pub const struct__GdkSnapshotClass = opaque {};
pub const GdkSnapshotClass = struct__GdkSnapshotClass;
pub extern fn gdk_snapshot_get_type() GType;
pub const GdkSnapshot_autoptr = ?*GdkSnapshot;
pub const GdkSnapshot_listautoptr = [*c]GList;
pub const GdkSnapshot_slistautoptr = [*c]GSList;
pub const GdkSnapshot_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkSnapshot(arg__ptr: ?*GdkSnapshot) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkSnapshot(arg__ptr: [*c]?*GdkSnapshot) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkSnapshot(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkSnapshot(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkSnapshot(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkSnapshot(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gdk_texture_downloader_get_type() GType;
pub extern fn gdk_texture_downloader_new(texture: ?*GdkTexture) ?*GdkTextureDownloader;
pub extern fn gdk_texture_downloader_copy(self: ?*const GdkTextureDownloader) ?*GdkTextureDownloader;
pub extern fn gdk_texture_downloader_free(self: ?*GdkTextureDownloader) void;
pub extern fn gdk_texture_downloader_set_texture(self: ?*GdkTextureDownloader, texture: ?*GdkTexture) void;
pub extern fn gdk_texture_downloader_get_texture(self: ?*const GdkTextureDownloader) ?*GdkTexture;
pub extern fn gdk_texture_downloader_set_format(self: ?*GdkTextureDownloader, format: GdkMemoryFormat) void;
pub extern fn gdk_texture_downloader_get_format(self: ?*const GdkTextureDownloader) GdkMemoryFormat;
pub extern fn gdk_texture_downloader_download_into(self: ?*const GdkTextureDownloader, data: [*c]guchar, stride: gsize) void;
pub extern fn gdk_texture_downloader_download_bytes(self: ?*const GdkTextureDownloader, out_stride: [*c]gsize) ?*GBytes;
pub const GdkTextureDownloader_autoptr = ?*GdkTextureDownloader;
pub const GdkTextureDownloader_listautoptr = [*c]GList;
pub const GdkTextureDownloader_slistautoptr = [*c]GSList;
pub const GdkTextureDownloader_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkTextureDownloader(arg__ptr: ?*GdkTextureDownloader) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_texture_downloader_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkTextureDownloader(arg__ptr: [*c]?*GdkTextureDownloader) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkTextureDownloader(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkTextureDownloader(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_texture_downloader_free)))))));
}
pub fn glib_slistautoptr_cleanup_GdkTextureDownloader(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_texture_downloader_free)))))));
}
pub fn glib_queueautoptr_cleanup_GdkTextureDownloader(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_texture_downloader_free)))))));
    }
}
pub const struct__GdkToplevelLayout = opaque {};
pub const GdkToplevelLayout = struct__GdkToplevelLayout;
pub extern fn gdk_toplevel_layout_get_type() GType;
pub extern fn gdk_toplevel_layout_new() ?*GdkToplevelLayout;
pub extern fn gdk_toplevel_layout_ref(layout: ?*GdkToplevelLayout) ?*GdkToplevelLayout;
pub extern fn gdk_toplevel_layout_unref(layout: ?*GdkToplevelLayout) void;
pub extern fn gdk_toplevel_layout_copy(layout: ?*GdkToplevelLayout) ?*GdkToplevelLayout;
pub extern fn gdk_toplevel_layout_equal(layout: ?*GdkToplevelLayout, other: ?*GdkToplevelLayout) gboolean;
pub extern fn gdk_toplevel_layout_set_maximized(layout: ?*GdkToplevelLayout, maximized: gboolean) void;
pub extern fn gdk_toplevel_layout_set_fullscreen(layout: ?*GdkToplevelLayout, fullscreen: gboolean, monitor: ?*GdkMonitor) void;
pub extern fn gdk_toplevel_layout_get_maximized(layout: ?*GdkToplevelLayout, maximized: [*c]gboolean) gboolean;
pub extern fn gdk_toplevel_layout_get_fullscreen(layout: ?*GdkToplevelLayout, fullscreen: [*c]gboolean) gboolean;
pub extern fn gdk_toplevel_layout_get_fullscreen_monitor(layout: ?*GdkToplevelLayout) ?*GdkMonitor;
pub extern fn gdk_toplevel_layout_set_resizable(layout: ?*GdkToplevelLayout, resizable: gboolean) void;
pub extern fn gdk_toplevel_layout_get_resizable(layout: ?*GdkToplevelLayout) gboolean;
pub const GdkToplevelLayout_autoptr = ?*GdkToplevelLayout;
pub const GdkToplevelLayout_listautoptr = [*c]GList;
pub const GdkToplevelLayout_slistautoptr = [*c]GSList;
pub const GdkToplevelLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkToplevelLayout(arg__ptr: ?*GdkToplevelLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gdk_toplevel_layout_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GdkToplevelLayout(arg__ptr: [*c]?*GdkToplevelLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkToplevelLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkToplevelLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_toplevel_layout_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkToplevelLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_toplevel_layout_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkToplevelLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gdk_toplevel_layout_unref)))))));
    }
}
pub const GDK_SURFACE_EDGE_NORTH_WEST: c_int = 0;
pub const GDK_SURFACE_EDGE_NORTH: c_int = 1;
pub const GDK_SURFACE_EDGE_NORTH_EAST: c_int = 2;
pub const GDK_SURFACE_EDGE_WEST: c_int = 3;
pub const GDK_SURFACE_EDGE_EAST: c_int = 4;
pub const GDK_SURFACE_EDGE_SOUTH_WEST: c_int = 5;
pub const GDK_SURFACE_EDGE_SOUTH: c_int = 6;
pub const GDK_SURFACE_EDGE_SOUTH_EAST: c_int = 7;
pub const GdkSurfaceEdge = c_uint;
pub const GDK_FULLSCREEN_ON_CURRENT_MONITOR: c_int = 0;
pub const GDK_FULLSCREEN_ON_ALL_MONITORS: c_int = 1;
pub const GdkFullscreenMode = c_uint;
pub const GDK_TOPLEVEL_STATE_MINIMIZED: c_int = 1;
pub const GDK_TOPLEVEL_STATE_MAXIMIZED: c_int = 2;
pub const GDK_TOPLEVEL_STATE_STICKY: c_int = 4;
pub const GDK_TOPLEVEL_STATE_FULLSCREEN: c_int = 8;
pub const GDK_TOPLEVEL_STATE_ABOVE: c_int = 16;
pub const GDK_TOPLEVEL_STATE_BELOW: c_int = 32;
pub const GDK_TOPLEVEL_STATE_FOCUSED: c_int = 64;
pub const GDK_TOPLEVEL_STATE_TILED: c_int = 128;
pub const GDK_TOPLEVEL_STATE_TOP_TILED: c_int = 256;
pub const GDK_TOPLEVEL_STATE_TOP_RESIZABLE: c_int = 512;
pub const GDK_TOPLEVEL_STATE_RIGHT_TILED: c_int = 1024;
pub const GDK_TOPLEVEL_STATE_RIGHT_RESIZABLE: c_int = 2048;
pub const GDK_TOPLEVEL_STATE_BOTTOM_TILED: c_int = 4096;
pub const GDK_TOPLEVEL_STATE_BOTTOM_RESIZABLE: c_int = 8192;
pub const GDK_TOPLEVEL_STATE_LEFT_TILED: c_int = 16384;
pub const GDK_TOPLEVEL_STATE_LEFT_RESIZABLE: c_int = 32768;
pub const GDK_TOPLEVEL_STATE_SUSPENDED: c_int = 65536;
pub const GdkToplevelState = c_uint;
pub const GDK_TITLEBAR_GESTURE_DOUBLE_CLICK: c_int = 1;
pub const GDK_TITLEBAR_GESTURE_RIGHT_CLICK: c_int = 2;
pub const GDK_TITLEBAR_GESTURE_MIDDLE_CLICK: c_int = 3;
pub const GdkTitlebarGesture = c_uint;
pub extern fn gdk_toplevel_get_type() GType;
pub const struct__GdkToplevel = opaque {};
pub const GdkToplevel = struct__GdkToplevel;
pub const struct__GdkToplevelInterface = opaque {};
pub const GdkToplevelInterface = struct__GdkToplevelInterface;
pub const GdkToplevel_autoptr = ?*GdkToplevel;
pub const GdkToplevel_listautoptr = [*c]GList;
pub const GdkToplevel_slistautoptr = [*c]GSList;
pub const GdkToplevel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkToplevel(arg__ptr: ?*GdkToplevel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GdkToplevel(arg__ptr: [*c]?*GdkToplevel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkToplevel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkToplevel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GdkToplevel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GdkToplevel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GDK_TOPLEVEL(arg_ptr: gpointer) callconv(.C) ?*GdkToplevel {
    var ptr = arg_ptr;
    return @as(?*GdkToplevel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gdk_toplevel_get_type())))));
}
pub fn GDK_IS_TOPLEVEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gdk_toplevel_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GDK_TOPLEVEL_GET_IFACE(arg_ptr: gpointer) callconv(.C) ?*GdkToplevelInterface {
    var ptr = arg_ptr;
    return @as(?*GdkToplevelInterface, @ptrCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gdk_toplevel_get_type())));
}
pub extern fn gdk_toplevel_present(toplevel: ?*GdkToplevel, layout: ?*GdkToplevelLayout) void;
pub extern fn gdk_toplevel_minimize(toplevel: ?*GdkToplevel) gboolean;
pub extern fn gdk_toplevel_lower(toplevel: ?*GdkToplevel) gboolean;
pub extern fn gdk_toplevel_focus(toplevel: ?*GdkToplevel, timestamp: guint32) void;
pub extern fn gdk_toplevel_get_state(toplevel: ?*GdkToplevel) GdkToplevelState;
pub extern fn gdk_toplevel_set_title(toplevel: ?*GdkToplevel, title: [*c]const u8) void;
pub extern fn gdk_toplevel_set_startup_id(toplevel: ?*GdkToplevel, startup_id: [*c]const u8) void;
pub extern fn gdk_toplevel_set_transient_for(toplevel: ?*GdkToplevel, parent: ?*GdkSurface) void;
pub extern fn gdk_toplevel_set_modal(toplevel: ?*GdkToplevel, modal: gboolean) void;
pub extern fn gdk_toplevel_set_icon_list(toplevel: ?*GdkToplevel, surfaces: [*c]GList) void;
pub extern fn gdk_toplevel_show_window_menu(toplevel: ?*GdkToplevel, event: ?*GdkEvent) gboolean;
pub extern fn gdk_toplevel_set_decorated(toplevel: ?*GdkToplevel, decorated: gboolean) void;
pub extern fn gdk_toplevel_set_deletable(toplevel: ?*GdkToplevel, deletable: gboolean) void;
pub extern fn gdk_toplevel_supports_edge_constraints(toplevel: ?*GdkToplevel) gboolean;
pub extern fn gdk_toplevel_inhibit_system_shortcuts(toplevel: ?*GdkToplevel, event: ?*GdkEvent) void;
pub extern fn gdk_toplevel_restore_system_shortcuts(toplevel: ?*GdkToplevel) void;
pub extern fn gdk_toplevel_begin_resize(toplevel: ?*GdkToplevel, edge: GdkSurfaceEdge, device: ?*GdkDevice, button: c_int, x: f64, y: f64, timestamp: guint32) void;
pub extern fn gdk_toplevel_begin_move(toplevel: ?*GdkToplevel, device: ?*GdkDevice, button: c_int, x: f64, y: f64, timestamp: guint32) void;
pub extern fn gdk_toplevel_titlebar_gesture(toplevel: ?*GdkToplevel, gesture: GdkTitlebarGesture) gboolean;
pub const struct__GdkToplevelSize = opaque {};
pub const GdkToplevelSize = struct__GdkToplevelSize;
pub extern fn gdk_toplevel_size_get_type() GType;
pub extern fn gdk_toplevel_size_get_bounds(size: ?*GdkToplevelSize, bounds_width: [*c]c_int, bounds_height: [*c]c_int) void;
pub extern fn gdk_toplevel_size_set_size(size: ?*GdkToplevelSize, width: c_int, height: c_int) void;
pub extern fn gdk_toplevel_size_set_min_size(size: ?*GdkToplevelSize, min_width: c_int, min_height: c_int) void;
pub extern fn gdk_toplevel_size_set_shadow_width(size: ?*GdkToplevelSize, left: c_int, right: c_int, top: c_int, bottom: c_int) void;
pub extern fn gdk_vulkan_error_quark() GQuark;
pub extern fn gdk_vulkan_context_get_type() GType;
pub const GdkVulkanContext_autoptr = ?*GdkVulkanContext;
pub const GdkVulkanContext_listautoptr = [*c]GList;
pub const GdkVulkanContext_slistautoptr = [*c]GSList;
pub const GdkVulkanContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkVulkanContext(arg__ptr: ?*GdkVulkanContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GdkVulkanContext(arg__ptr: [*c]?*GdkVulkanContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GdkVulkanContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GdkVulkanContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GdkVulkanContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GdkVulkanContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GSK_NOT_A_RENDER_NODE: c_int = 0;
pub const GSK_CONTAINER_NODE: c_int = 1;
pub const GSK_CAIRO_NODE: c_int = 2;
pub const GSK_COLOR_NODE: c_int = 3;
pub const GSK_LINEAR_GRADIENT_NODE: c_int = 4;
pub const GSK_REPEATING_LINEAR_GRADIENT_NODE: c_int = 5;
pub const GSK_RADIAL_GRADIENT_NODE: c_int = 6;
pub const GSK_REPEATING_RADIAL_GRADIENT_NODE: c_int = 7;
pub const GSK_CONIC_GRADIENT_NODE: c_int = 8;
pub const GSK_BORDER_NODE: c_int = 9;
pub const GSK_TEXTURE_NODE: c_int = 10;
pub const GSK_INSET_SHADOW_NODE: c_int = 11;
pub const GSK_OUTSET_SHADOW_NODE: c_int = 12;
pub const GSK_TRANSFORM_NODE: c_int = 13;
pub const GSK_OPACITY_NODE: c_int = 14;
pub const GSK_COLOR_MATRIX_NODE: c_int = 15;
pub const GSK_REPEAT_NODE: c_int = 16;
pub const GSK_CLIP_NODE: c_int = 17;
pub const GSK_ROUNDED_CLIP_NODE: c_int = 18;
pub const GSK_SHADOW_NODE: c_int = 19;
pub const GSK_BLEND_NODE: c_int = 20;
pub const GSK_CROSS_FADE_NODE: c_int = 21;
pub const GSK_TEXT_NODE: c_int = 22;
pub const GSK_BLUR_NODE: c_int = 23;
pub const GSK_DEBUG_NODE: c_int = 24;
pub const GSK_GL_SHADER_NODE: c_int = 25;
pub const GSK_TEXTURE_SCALE_NODE: c_int = 26;
pub const GSK_MASK_NODE: c_int = 27;
pub const GskRenderNodeType = c_uint;
pub const GSK_SCALING_FILTER_LINEAR: c_int = 0;
pub const GSK_SCALING_FILTER_NEAREST: c_int = 1;
pub const GSK_SCALING_FILTER_TRILINEAR: c_int = 2;
pub const GskScalingFilter = c_uint;
pub const GSK_BLEND_MODE_DEFAULT: c_int = 0;
pub const GSK_BLEND_MODE_MULTIPLY: c_int = 1;
pub const GSK_BLEND_MODE_SCREEN: c_int = 2;
pub const GSK_BLEND_MODE_OVERLAY: c_int = 3;
pub const GSK_BLEND_MODE_DARKEN: c_int = 4;
pub const GSK_BLEND_MODE_LIGHTEN: c_int = 5;
pub const GSK_BLEND_MODE_COLOR_DODGE: c_int = 6;
pub const GSK_BLEND_MODE_COLOR_BURN: c_int = 7;
pub const GSK_BLEND_MODE_HARD_LIGHT: c_int = 8;
pub const GSK_BLEND_MODE_SOFT_LIGHT: c_int = 9;
pub const GSK_BLEND_MODE_DIFFERENCE: c_int = 10;
pub const GSK_BLEND_MODE_EXCLUSION: c_int = 11;
pub const GSK_BLEND_MODE_COLOR: c_int = 12;
pub const GSK_BLEND_MODE_HUE: c_int = 13;
pub const GSK_BLEND_MODE_SATURATION: c_int = 14;
pub const GSK_BLEND_MODE_LUMINOSITY: c_int = 15;
pub const GskBlendMode = c_uint;
pub const GSK_CORNER_TOP_LEFT: c_int = 0;
pub const GSK_CORNER_TOP_RIGHT: c_int = 1;
pub const GSK_CORNER_BOTTOM_RIGHT: c_int = 2;
pub const GSK_CORNER_BOTTOM_LEFT: c_int = 3;
pub const GskCorner = c_uint;
pub const GSK_SERIALIZATION_UNSUPPORTED_FORMAT: c_int = 0;
pub const GSK_SERIALIZATION_UNSUPPORTED_VERSION: c_int = 1;
pub const GSK_SERIALIZATION_INVALID_DATA: c_int = 2;
pub const GskSerializationError = c_uint;
pub const GSK_TRANSFORM_CATEGORY_UNKNOWN: c_int = 0;
pub const GSK_TRANSFORM_CATEGORY_ANY: c_int = 1;
pub const GSK_TRANSFORM_CATEGORY_3D: c_int = 2;
pub const GSK_TRANSFORM_CATEGORY_2D: c_int = 3;
pub const GSK_TRANSFORM_CATEGORY_2D_AFFINE: c_int = 4;
pub const GSK_TRANSFORM_CATEGORY_2D_TRANSLATE: c_int = 5;
pub const GSK_TRANSFORM_CATEGORY_IDENTITY: c_int = 6;
pub const GskTransformCategory = c_uint;
pub const GSK_GL_UNIFORM_TYPE_NONE: c_int = 0;
pub const GSK_GL_UNIFORM_TYPE_FLOAT: c_int = 1;
pub const GSK_GL_UNIFORM_TYPE_INT: c_int = 2;
pub const GSK_GL_UNIFORM_TYPE_UINT: c_int = 3;
pub const GSK_GL_UNIFORM_TYPE_BOOL: c_int = 4;
pub const GSK_GL_UNIFORM_TYPE_VEC2: c_int = 5;
pub const GSK_GL_UNIFORM_TYPE_VEC3: c_int = 6;
pub const GSK_GL_UNIFORM_TYPE_VEC4: c_int = 7;
pub const GskGLUniformType = c_uint;
pub const GSK_MASK_MODE_ALPHA: c_int = 0;
pub const GSK_MASK_MODE_INVERTED_ALPHA: c_int = 1;
pub const GSK_MASK_MODE_LUMINANCE: c_int = 2;
pub const GSK_MASK_MODE_INVERTED_LUMINANCE: c_int = 3;
pub const GskMaskMode = c_uint;
pub const __m64 = @Vector(1, c_longlong);
pub const __v1di = @Vector(1, c_longlong);
pub const __v2si = @Vector(2, c_int);
pub const __v4hi = @Vector(4, c_short);
pub const __v8qi = @Vector(8, u8); // /usr/lib/zig/include/mmintrin.h:37:5: warning: TODO implement function '__builtin_ia32_emms' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:35:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_empty() void; // /usr/lib/zig/include/mmintrin.h:54:19: warning: TODO implement function '__builtin_ia32_vec_init_v2si' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:52:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtsi32_si64(arg___i: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:71:12: warning: TODO implement function '__builtin_ia32_vec_ext_v2si' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:69:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtsi64_si32(arg___m: __m64) c_int;
pub inline fn _mm_cvtsi64_m64(arg___i: c_longlong) __m64 {
    var __i = arg___i;
    return @as(__m64, @bitCast(__i));
}
pub inline fn _mm_cvtm64_si64(arg___m: __m64) c_longlong {
    var __m = arg___m;
    return @as(c_longlong, @bitCast(__m));
} // /usr/lib/zig/include/mmintrin.h:133:19: warning: TODO implement function '__builtin_ia32_packsswb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:131:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_packs_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:163:19: warning: TODO implement function '__builtin_ia32_packssdw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:161:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_packs_pi32(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:193:19: warning: TODO implement function '__builtin_ia32_packuswb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:191:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_packs_pu16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:220:19: warning: TODO implement function '__builtin_ia32_punpckhbw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:218:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_unpackhi_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:243:19: warning: TODO implement function '__builtin_ia32_punpckhwd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:241:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_unpackhi_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:264:19: warning: TODO implement function '__builtin_ia32_punpckhdq' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:262:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_unpackhi_pi32(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:291:19: warning: TODO implement function '__builtin_ia32_punpcklbw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:289:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_unpacklo_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:314:19: warning: TODO implement function '__builtin_ia32_punpcklwd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:312:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_unpacklo_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:335:19: warning: TODO implement function '__builtin_ia32_punpckldq' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:333:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_unpacklo_pi32(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:356:19: warning: TODO implement function '__builtin_ia32_paddb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:354:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_add_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:377:19: warning: TODO implement function '__builtin_ia32_paddw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:375:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_add_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:398:19: warning: TODO implement function '__builtin_ia32_paddd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:396:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_add_pi32(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:420:19: warning: TODO implement function '__builtin_ia32_paddsb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:418:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:443:19: warning: TODO implement function '__builtin_ia32_paddsw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:441:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:465:19: warning: TODO implement function '__builtin_ia32_paddusb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:463:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_pu8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:487:19: warning: TODO implement function '__builtin_ia32_paddusw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:485:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_pu16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:508:19: warning: TODO implement function '__builtin_ia32_psubb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:506:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sub_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:529:19: warning: TODO implement function '__builtin_ia32_psubw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:527:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sub_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:550:19: warning: TODO implement function '__builtin_ia32_psubd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:548:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sub_pi32(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:573:19: warning: TODO implement function '__builtin_ia32_psubsb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:571:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:596:19: warning: TODO implement function '__builtin_ia32_psubsw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:594:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:620:19: warning: TODO implement function '__builtin_ia32_psubusb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:618:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_pu8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:644:19: warning: TODO implement function '__builtin_ia32_psubusw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:642:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_pu16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:671:19: warning: TODO implement function '__builtin_ia32_pmaddwd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:669:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_madd_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:692:19: warning: TODO implement function '__builtin_ia32_pmulhw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:690:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_mulhi_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:713:19: warning: TODO implement function '__builtin_ia32_pmullw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:711:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_mullo_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:736:19: warning: TODO implement function '__builtin_ia32_psllw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:734:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sll_pi16(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:758:19: warning: TODO implement function '__builtin_ia32_psllwi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:756:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_slli_pi16(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:781:19: warning: TODO implement function '__builtin_ia32_pslld' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:779:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sll_pi32(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:803:19: warning: TODO implement function '__builtin_ia32_pslldi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:801:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_slli_pi32(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:823:19: warning: TODO implement function '__builtin_ia32_psllq' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:821:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sll_si64(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:843:19: warning: TODO implement function '__builtin_ia32_psllqi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:841:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_slli_si64(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:867:19: warning: TODO implement function '__builtin_ia32_psraw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:865:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sra_pi16(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:890:19: warning: TODO implement function '__builtin_ia32_psrawi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:888:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srai_pi16(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:914:19: warning: TODO implement function '__builtin_ia32_psrad' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:912:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sra_pi32(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:937:19: warning: TODO implement function '__builtin_ia32_psradi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:935:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srai_pi32(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:960:19: warning: TODO implement function '__builtin_ia32_psrlw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:958:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srl_pi16(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:982:19: warning: TODO implement function '__builtin_ia32_psrlwi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:980:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srli_pi16(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:1005:19: warning: TODO implement function '__builtin_ia32_psrld' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1003:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srl_pi32(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1027:19: warning: TODO implement function '__builtin_ia32_psrldi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1025:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srli_pi32(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:1047:19: warning: TODO implement function '__builtin_ia32_psrlq' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1045:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srl_si64(arg___m: __m64, arg___count: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1068:19: warning: TODO implement function '__builtin_ia32_psrlqi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1066:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_srli_si64(arg___m: __m64, arg___count: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:1086:12: warning: TODO implement function '__builtin_ia32_pand' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1084:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_and_si64(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1107:12: warning: TODO implement function '__builtin_ia32_pandn' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1105:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_andnot_si64(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1125:12: warning: TODO implement function '__builtin_ia32_por' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1123:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_or_si64(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1143:12: warning: TODO implement function '__builtin_ia32_pxor' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1141:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_xor_si64(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1165:19: warning: TODO implement function '__builtin_ia32_pcmpeqb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1163:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1187:19: warning: TODO implement function '__builtin_ia32_pcmpeqw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1185:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1209:19: warning: TODO implement function '__builtin_ia32_pcmpeqd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1207:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_pi32(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1231:19: warning: TODO implement function '__builtin_ia32_pcmpgtb' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1229:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_pi8(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1253:19: warning: TODO implement function '__builtin_ia32_pcmpgtw' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1251:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_pi16(arg___m1: __m64, arg___m2: __m64) __m64; // /usr/lib/zig/include/mmintrin.h:1275:19: warning: TODO implement function '__builtin_ia32_pcmpgtd' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1273:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_pi32(arg___m1: __m64, arg___m2: __m64) __m64;
pub inline fn _mm_setzero_si64() __m64 {
    return blk: {
        const tmp = @as(c_longlong, 0);
        break :blk __m64{
            tmp,
        };
    };
} // /usr/lib/zig/include/mmintrin.h:1309:19: warning: TODO implement function '__builtin_ia32_vec_init_v2si' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1307:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_set_pi32(arg___i1: c_int, arg___i0: c_int) __m64; // /usr/lib/zig/include/mmintrin.h:1332:19: warning: TODO implement function '__builtin_ia32_vec_init_v4hi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1330:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_set_pi16(arg___s3: c_short, arg___s2: c_short, arg___s1: c_short, arg___s0: c_short) __m64; // /usr/lib/zig/include/mmintrin.h:1364:19: warning: TODO implement function '__builtin_ia32_vec_init_v8qi' in std.zig.c_builtins
// /usr/lib/zig/include/mmintrin.h:1361:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_set_pi8(arg___b7: u8, arg___b6: u8, arg___b5: u8, arg___b4: u8, arg___b3: u8, arg___b2: u8, arg___b1: u8, arg___b0: u8) __m64;
pub inline fn _mm_set1_pi32(arg___i: c_int) __m64 {
    var __i = arg___i;
    return _mm_set_pi32(__i, __i);
}
pub inline fn _mm_set1_pi16(arg___w: c_short) __m64 {
    var __w = arg___w;
    return _mm_set_pi16(__w, __w, __w, __w);
}
pub inline fn _mm_set1_pi8(arg___b: u8) __m64 {
    var __b = arg___b;
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}
pub inline fn _mm_setr_pi32(arg___i0: c_int, arg___i1: c_int) __m64 {
    var __i0 = arg___i0;
    var __i1 = arg___i1;
    return _mm_set_pi32(__i1, __i0);
}
pub inline fn _mm_setr_pi16(arg___w0: c_short, arg___w1: c_short, arg___w2: c_short, arg___w3: c_short) __m64 {
    var __w0 = arg___w0;
    var __w1 = arg___w1;
    var __w2 = arg___w2;
    var __w3 = arg___w3;
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}
pub inline fn _mm_setr_pi8(arg___b0: u8, arg___b1: u8, arg___b2: u8, arg___b3: u8, arg___b4: u8, arg___b5: u8, arg___b6: u8, arg___b7: u8) __m64 {
    var __b0 = arg___b0;
    var __b1 = arg___b1;
    var __b2 = arg___b2;
    var __b3 = arg___b3;
    var __b4 = arg___b4;
    var __b5 = arg___b5;
    var __b6 = arg___b6;
    var __b7 = arg___b7;
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
pub const __v4si = @Vector(4, c_int);
pub const __v4sf = @Vector(4, f32);
pub const __m128 = @Vector(4, f32);
pub const __m128_u = @Vector(4, f32);
pub const __v4su = @Vector(4, c_uint);
pub inline fn _mm_malloc(arg___size: usize, arg___align: usize) ?*anyopaque {
    var __size = arg___size;
    var __align = arg___align;
    if (__align == @as(usize, @bitCast(@as(c_long, @as(c_int, 1))))) {
        return malloc(__size);
    }
    if (!((__align & (__align -% @as(usize, @bitCast(@as(c_long, @as(c_int, 1)))))) != 0) and (__align < @sizeOf(?*anyopaque))) {
        __align = @sizeOf(?*anyopaque);
    }
    var __mallocedMemory: ?*anyopaque = undefined;
    if (posix_memalign(&__mallocedMemory, __align, __size) != 0) return null;
    return __mallocedMemory;
}
pub inline fn _mm_free(arg___p: ?*anyopaque) void {
    var __p = arg___p;
    free(__p);
}
pub inline fn _mm_add_ss(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] += __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_add_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4sf, @bitCast(__a)) + @as(__v4sf, @bitCast(__b))));
}
pub inline fn _mm_sub_ss(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] -= __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_sub_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4sf, @bitCast(__a)) - @as(__v4sf, @bitCast(__b))));
}
pub inline fn _mm_mul_ss(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] *= __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_mul_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4sf, @bitCast(__a)) * @as(__v4sf, @bitCast(__b))));
}
pub inline fn _mm_div_ss(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] /= __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_div_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4sf, @bitCast(__a)) / @as(__v4sf, @bitCast(__b))));
} // /usr/lib/zig/include/xmmintrin.h:220:18: warning: TODO implement function '__builtin_ia32_sqrtss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:218:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sqrt_ss(arg___a: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:237:10: warning: TODO implement function '__builtin_ia32_sqrtps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:235:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sqrt_ps(arg___a: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:255:18: warning: TODO implement function '__builtin_ia32_rcpss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:253:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_rcp_ss(arg___a: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:272:18: warning: TODO implement function '__builtin_ia32_rcpps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:270:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_rcp_ps(arg___a: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:291:10: warning: TODO implement function '__builtin_ia32_rsqrtss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:289:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_rsqrt_ss(arg___a: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:308:10: warning: TODO implement function '__builtin_ia32_rsqrtps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:306:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_rsqrt_ps(arg___a: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:331:10: warning: TODO implement function '__builtin_ia32_minss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:329:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:350:10: warning: TODO implement function '__builtin_ia32_minps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:348:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:373:10: warning: TODO implement function '__builtin_ia32_maxss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:371:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:392:10: warning: TODO implement function '__builtin_ia32_maxps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:390:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_ps(arg___a: __m128, arg___b: __m128) __m128;
pub inline fn _mm_and_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4su, @bitCast(__a)) & @as(__v4su, @bitCast(__b))));
}
pub inline fn _mm_andnot_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(~@as(__v4su, @bitCast(__a)) & @as(__v4su, @bitCast(__b))));
}
pub inline fn _mm_or_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4su, @bitCast(__a)) | @as(__v4su, @bitCast(__b))));
}
pub inline fn _mm_xor_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128, @bitCast(@as(__v4su, @bitCast(__a)) ^ @as(__v4su, @bitCast(__b))));
} // /usr/lib/zig/include/xmmintrin.h:491:18: warning: TODO implement function '__builtin_ia32_cmpeqss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:489:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:509:18: warning: TODO implement function '__builtin_ia32_cmpeqps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:507:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:532:18: warning: TODO implement function '__builtin_ia32_cmpltss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:530:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmplt_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:551:18: warning: TODO implement function '__builtin_ia32_cmpltps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:549:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmplt_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:575:18: warning: TODO implement function '__builtin_ia32_cmpless' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:573:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmple_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:594:18: warning: TODO implement function '__builtin_ia32_cmpleps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:592:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmple_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:618:50: warning: TODO implement function '__builtin_ia32_cmpltss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:615:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:638:18: warning: TODO implement function '__builtin_ia32_cmpltps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:636:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:663:50: warning: TODO implement function '__builtin_ia32_cmpless' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:660:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpge_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:683:18: warning: TODO implement function '__builtin_ia32_cmpleps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:681:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpge_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:706:18: warning: TODO implement function '__builtin_ia32_cmpneqss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:704:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpneq_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:725:18: warning: TODO implement function '__builtin_ia32_cmpneqps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:723:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpneq_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:749:18: warning: TODO implement function '__builtin_ia32_cmpnltss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:747:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnlt_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:769:18: warning: TODO implement function '__builtin_ia32_cmpnltps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:767:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnlt_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:794:18: warning: TODO implement function '__builtin_ia32_cmpnless' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:792:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnle_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:814:18: warning: TODO implement function '__builtin_ia32_cmpnleps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:812:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnle_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:840:50: warning: TODO implement function '__builtin_ia32_cmpnltss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:837:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpngt_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:861:18: warning: TODO implement function '__builtin_ia32_cmpnltps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:859:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpngt_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:887:50: warning: TODO implement function '__builtin_ia32_cmpnless' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:884:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnge_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:908:18: warning: TODO implement function '__builtin_ia32_cmpnleps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:906:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnge_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:933:18: warning: TODO implement function '__builtin_ia32_cmpordss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:931:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpord_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:953:18: warning: TODO implement function '__builtin_ia32_cmpordps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:951:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpord_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:978:18: warning: TODO implement function '__builtin_ia32_cmpunordss' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:976:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpunord_ss(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:998:18: warning: TODO implement function '__builtin_ia32_cmpunordps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:996:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpunord_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/xmmintrin.h:1022:10: warning: TODO implement function '__builtin_ia32_comieq' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1020:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_comieq_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1047:10: warning: TODO implement function '__builtin_ia32_comilt' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1045:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_comilt_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1071:10: warning: TODO implement function '__builtin_ia32_comile' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1069:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_comile_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1095:10: warning: TODO implement function '__builtin_ia32_comigt' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1093:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_comigt_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1119:10: warning: TODO implement function '__builtin_ia32_comige' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1117:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_comige_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1143:10: warning: TODO implement function '__builtin_ia32_comineq' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1141:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_comineq_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1167:10: warning: TODO implement function '__builtin_ia32_ucomieq' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1165:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomieq_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1191:10: warning: TODO implement function '__builtin_ia32_ucomilt' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1189:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomilt_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1216:10: warning: TODO implement function '__builtin_ia32_ucomile' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1214:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomile_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1241:10: warning: TODO implement function '__builtin_ia32_ucomigt' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1239:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomigt_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1266:10: warning: TODO implement function '__builtin_ia32_ucomige' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1264:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomige_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1290:10: warning: TODO implement function '__builtin_ia32_ucomineq' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1288:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomineq_ss(arg___a: __m128, arg___b: __m128) c_int; // /usr/lib/zig/include/xmmintrin.h:1308:10: warning: TODO implement function '__builtin_ia32_cvtss2si' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1306:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtss_si32(arg___a: __m128) c_int;
pub inline fn _mm_cvt_ss2si(arg___a: __m128) c_int {
    var __a = arg___a;
    return _mm_cvtss_si32(__a);
} // /usr/lib/zig/include/xmmintrin.h:1346:10: warning: TODO implement function '__builtin_ia32_cvtss2si64' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1344:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtss_si64(arg___a: __m128) c_longlong; // /usr/lib/zig/include/xmmintrin.h:1364:17: warning: TODO implement function '__builtin_ia32_cvtps2pi' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1362:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtps_pi32(arg___a: __m128) __m64;
pub inline fn _mm_cvt_ps2pi(arg___a: __m128) __m64 {
    var __a = arg___a;
    return _mm_cvtps_pi32(__a);
} // /usr/lib/zig/include/xmmintrin.h:1399:10: warning: TODO implement function '__builtin_ia32_cvttss2si' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1397:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttss_si32(arg___a: __m128) c_int;
pub inline fn _mm_cvtt_ss2si(arg___a: __m128) c_int {
    var __a = arg___a;
    return _mm_cvttss_si32(__a);
} // /usr/lib/zig/include/xmmintrin.h:1438:10: warning: TODO implement function '__builtin_ia32_cvttss2si64' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1436:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttss_si64(arg___a: __m128) c_longlong; // /usr/lib/zig/include/xmmintrin.h:1457:17: warning: TODO implement function '__builtin_ia32_cvttps2pi' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1455:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttps_pi32(arg___a: __m128) __m64;
pub inline fn _mm_cvtt_ps2pi(arg___a: __m128) __m64 {
    var __a = arg___a;
    return _mm_cvttps_pi32(__a);
}
pub inline fn _mm_cvtsi32_ss(arg___a: __m128, arg___b: c_int) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(f32, @floatFromInt(__b));
    return __a;
}
pub inline fn _mm_cvt_si2ss(arg___a: __m128, arg___b: c_int) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return _mm_cvtsi32_ss(__a, __b);
}
pub inline fn _mm_cvtsi64_ss(arg___a: __m128, arg___b: c_longlong) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(f32, @floatFromInt(__b));
    return __a;
} // /usr/lib/zig/include/xmmintrin.h:1569:10: warning: TODO implement function '__builtin_ia32_cvtpi2ps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1567:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtpi32_ps(arg___a: __m128, arg___b: __m64) __m128;
pub inline fn _mm_cvt_pi2ps(arg___a: __m128, arg___b: __m64) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return _mm_cvtpi32_ps(__a, __b);
}
pub inline fn _mm_cvtss_f32(arg___a: __m128) f32 {
    var __a = arg___a;
    return __a[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_loadh_pi(arg___a: __m128, arg___p: [*c]const __m64) __m128 {
    var __a = arg___a;
    var __p = arg___p;
    const __mm_loadh_pi_v2f32 = @Vector(2, f32);
    _ = @TypeOf(__mm_loadh_pi_v2f32);
    const struct___mm_loadh_pi_struct = extern struct {
        __u: __mm_loadh_pi_v2f32 align(1),
    };
    _ = @TypeOf(struct___mm_loadh_pi_struct);
    var __b: __mm_loadh_pi_v2f32 = @as([*c]const struct___mm_loadh_pi_struct, @ptrCast(@alignCast(__p))).*.__u;
    var __bb: __m128 = @shuffle(@typeInfo(@TypeOf(__b)).Vector.child, __b, __b, @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(__b)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(__b)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(__b)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(__b)).Vector.len),
    });
    return @shuffle(@typeInfo(@TypeOf(__a)).Vector.child, __a, __bb, @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(__a)).Vector.len),
    });
}
pub inline fn _mm_loadl_pi(arg___a: __m128, arg___p: [*c]const __m64) __m128 {
    var __a = arg___a;
    var __p = arg___p;
    const __mm_loadl_pi_v2f32 = @Vector(2, f32);
    _ = @TypeOf(__mm_loadl_pi_v2f32);
    const struct___mm_loadl_pi_struct = extern struct {
        __u: __mm_loadl_pi_v2f32 align(1),
    };
    _ = @TypeOf(struct___mm_loadl_pi_struct);
    var __b: __mm_loadl_pi_v2f32 = @as([*c]const struct___mm_loadl_pi_struct, @ptrCast(@alignCast(__p))).*.__u;
    var __bb: __m128 = @shuffle(@typeInfo(@TypeOf(__b)).Vector.child, __b, __b, @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(__b)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(__b)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(__b)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(__b)).Vector.len),
    });
    return @shuffle(@typeInfo(@TypeOf(__a)).Vector.child, __a, __bb, @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(__a)).Vector.len),
    });
}
pub inline fn _mm_load_ss(arg___p: [*c]const f32) __m128 {
    var __p = arg___p;
    const struct___mm_load_ss_struct = extern struct {
        __u: f32 align(1),
    };
    _ = @TypeOf(struct___mm_load_ss_struct);
    var __u: f32 = @as([*c]const struct___mm_load_ss_struct, @ptrCast(@alignCast(__p))).*.__u;
    return blk: {
        const tmp = __u;
        const tmp_1 = @as(f32, @floatFromInt(@as(c_int, 0)));
        const tmp_2 = @as(f32, @floatFromInt(@as(c_int, 0)));
        const tmp_3 = @as(f32, @floatFromInt(@as(c_int, 0)));
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_load1_ps(arg___p: [*c]const f32) __m128 {
    var __p = arg___p;
    const struct___mm_load1_ps_struct = extern struct {
        __u: f32 align(1),
    };
    _ = @TypeOf(struct___mm_load1_ps_struct);
    var __u: f32 = @as([*c]const struct___mm_load1_ps_struct, @ptrCast(@alignCast(__p))).*.__u;
    return blk: {
        const tmp = __u;
        const tmp_1 = __u;
        const tmp_2 = __u;
        const tmp_3 = __u;
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_load_ps(arg___p: [*c]const f32) __m128 {
    var __p = arg___p;
    return @as([*c]const __m128, @ptrCast(@alignCast(__p))).*;
}
pub inline fn _mm_loadu_ps(arg___p: [*c]const f32) __m128 {
    var __p = arg___p;
    const struct___loadu_ps = extern struct {
        __v: __m128_u align(1),
    };
    _ = @TypeOf(struct___loadu_ps);
    return @as([*c]const struct___loadu_ps, @ptrCast(@alignCast(__p))).*.__v;
}
pub inline fn _mm_loadr_ps(arg___p: [*c]const f32) __m128 {
    var __p = arg___p;
    var __a: __m128 = _mm_load_ps(__p);
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
} // /usr/lib/zig/include/xmmintrin.h:1782:18: warning: TODO implement function '__builtin_ia32_undef128' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:1780:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_undefined_ps() __m128;
pub inline fn _mm_set_ss(arg___w: f32) __m128 {
    var __w = arg___w;
    return blk: {
        const tmp = __w;
        const tmp_1 = @as(f32, @floatFromInt(@as(c_int, 0)));
        const tmp_2 = @as(f32, @floatFromInt(@as(c_int, 0)));
        const tmp_3 = @as(f32, @floatFromInt(@as(c_int, 0)));
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_set1_ps(arg___w: f32) __m128 {
    var __w = arg___w;
    return blk: {
        const tmp = __w;
        const tmp_1 = __w;
        const tmp_2 = __w;
        const tmp_3 = __w;
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_set_ps1(arg___w: f32) __m128 {
    var __w = arg___w;
    return _mm_set1_ps(__w);
}
pub inline fn _mm_set_ps(arg___z: f32, arg___y: f32, arg___x: f32, arg___w: f32) __m128 {
    var __z = arg___z;
    var __y = arg___y;
    var __x = arg___x;
    var __w = arg___w;
    return blk: {
        const tmp = __w;
        const tmp_1 = __x;
        const tmp_2 = __y;
        const tmp_3 = __z;
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_setr_ps(arg___z: f32, arg___y: f32, arg___x: f32, arg___w: f32) __m128 {
    var __z = arg___z;
    var __y = arg___y;
    var __x = arg___x;
    var __w = arg___w;
    return blk: {
        const tmp = __z;
        const tmp_1 = __y;
        const tmp_2 = __x;
        const tmp_3 = __w;
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_setzero_ps() __m128 {
    return blk: {
        const tmp = 0.0;
        const tmp_1 = 0.0;
        const tmp_2 = 0.0;
        const tmp_3 = 0.0;
        break :blk __m128{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    };
}
pub inline fn _mm_storeh_pi(arg___p: [*c]__m64, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    const __mm_storeh_pi_v2f32 = @Vector(2, f32);
    _ = @TypeOf(__mm_storeh_pi_v2f32);
    const struct___mm_storeh_pi_struct = extern struct {
        __u: __mm_storeh_pi_v2f32 align(1),
    };
    _ = @TypeOf(struct___mm_storeh_pi_struct);
    @as([*c]struct___mm_storeh_pi_struct, @ptrCast(@alignCast(__p))).*.__u = @shuffle(@typeInfo(@TypeOf(__a)).Vector.child, __a, __a, @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(__a)).Vector.len),
    });
}
pub inline fn _mm_storel_pi(arg___p: [*c]__m64, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    const __mm_storeh_pi_v2f32 = @Vector(2, f32);
    _ = @TypeOf(__mm_storeh_pi_v2f32);
    const struct___mm_storeh_pi_struct = extern struct {
        __u: __mm_storeh_pi_v2f32 align(1),
    };
    _ = @TypeOf(struct___mm_storeh_pi_struct);
    @as([*c]struct___mm_storeh_pi_struct, @ptrCast(@alignCast(__p))).*.__u = @shuffle(@typeInfo(@TypeOf(__a)).Vector.child, __a, __a, @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(__a)).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(__a)).Vector.len),
    });
}
pub inline fn _mm_store_ss(arg___p: [*c]f32, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    const struct___mm_store_ss_struct = extern struct {
        __u: f32 align(1),
    };
    _ = @TypeOf(struct___mm_store_ss_struct);
    @as([*c]struct___mm_store_ss_struct, @ptrCast(@alignCast(__p))).*.__u = __a[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_storeu_ps(arg___p: [*c]f32, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    const struct___storeu_ps = extern struct {
        __v: __m128_u align(1),
    };
    _ = @TypeOf(struct___storeu_ps);
    @as([*c]struct___storeu_ps, @ptrCast(@alignCast(__p))).*.__v = __a;
}
pub inline fn _mm_store_ps(arg___p: [*c]f32, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    @as([*c]__m128, @ptrCast(@alignCast(__p))).* = __a;
}
pub inline fn _mm_store1_ps(arg___p: [*c]f32, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    __a = @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
    _mm_store_ps(__p, __a);
}
pub inline fn _mm_store_ps1(arg___p: [*c]f32, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    _mm_store1_ps(__p, __a);
}
pub inline fn _mm_storer_ps(arg___p: [*c]f32, arg___a: __m128) void {
    var __p = arg___p;
    var __a = arg___a;
    __a = @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
    _mm_store_ps(__p, __a);
} // /usr/lib/zig/include/xmmintrin.h:2126:3: warning: TODO implement function '__builtin_ia32_movntq' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2124:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_pi(arg___p: [*c]__m64, arg___a: __m64) void; // /usr/lib/zig/include/xmmintrin.h:2145:3: warning: TODO implement function '__builtin_nontemporal_store' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2143:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_ps(arg___p: [*c]f32, arg___a: __m128) void;
pub extern fn _mm_sfence() void; // /usr/lib/zig/include/xmmintrin.h:2237:17: warning: TODO implement function '__builtin_ia32_pmaxsw' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2235:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2256:17: warning: TODO implement function '__builtin_ia32_pmaxub' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2254:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_pu8(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2275:17: warning: TODO implement function '__builtin_ia32_pminsw' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2273:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2294:17: warning: TODO implement function '__builtin_ia32_pminub' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2292:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_pu8(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2312:10: warning: TODO implement function '__builtin_ia32_pmovmskb' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2310:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_movemask_pi8(arg___a: __m64) c_int; // /usr/lib/zig/include/xmmintrin.h:2331:17: warning: TODO implement function '__builtin_ia32_pmulhuw' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2329:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_mulhi_pu16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2397:3: warning: TODO implement function '__builtin_ia32_maskmovq' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2395:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_maskmove_si64(arg___d: __m64, arg___n: __m64, arg___p: [*c]u8) void; // /usr/lib/zig/include/xmmintrin.h:2416:17: warning: TODO implement function '__builtin_ia32_pavgb' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2414:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_avg_pu8(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2435:17: warning: TODO implement function '__builtin_ia32_pavgw' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2433:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_avg_pu16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/xmmintrin.h:2457:17: warning: TODO implement function '__builtin_ia32_psadbw' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2455:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sad_pu8(arg___a: __m64, arg___b: __m64) __m64;
pub extern fn _mm_getcsr() c_uint;
pub extern fn _mm_setcsr(__i: c_uint) void;
pub inline fn _mm_unpackhi_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__b)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_unpacklo_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__b)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_move_ss(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_movehl_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__b)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_movelh_ps(arg___a: __m128, arg___b: __m128) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__b)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_cvtpi16_ps(arg___a: __m64) __m128 {
    var __a = arg___a;
    var __b: __m64 = undefined;
    var __c: __m64 = undefined;
    var __r: __m128 = undefined;
    __b = _mm_setzero_si64();
    __b = _mm_cmpgt_pi16(__b, __a);
    __c = _mm_unpackhi_pi16(__a, __b);
    __r = _mm_setzero_ps();
    __r = _mm_cvtpi32_ps(__r, __c);
    __r = _mm_movelh_ps(__r, __r);
    __c = _mm_unpacklo_pi16(__a, __b);
    __r = _mm_cvtpi32_ps(__r, __c);
    return __r;
}
pub inline fn _mm_cvtpu16_ps(arg___a: __m64) __m128 {
    var __a = arg___a;
    var __b: __m64 = undefined;
    var __c: __m64 = undefined;
    var __r: __m128 = undefined;
    __b = _mm_setzero_si64();
    __c = _mm_unpackhi_pi16(__a, __b);
    __r = _mm_setzero_ps();
    __r = _mm_cvtpi32_ps(__r, __c);
    __r = _mm_movelh_ps(__r, __r);
    __c = _mm_unpacklo_pi16(__a, __b);
    __r = _mm_cvtpi32_ps(__r, __c);
    return __r;
}
pub inline fn _mm_cvtpi8_ps(arg___a: __m64) __m128 {
    var __a = arg___a;
    var __b: __m64 = undefined;
    __b = _mm_setzero_si64();
    __b = _mm_cmpgt_pi8(__b, __a);
    __b = _mm_unpacklo_pi8(__a, __b);
    return _mm_cvtpi16_ps(__b);
}
pub inline fn _mm_cvtpu8_ps(arg___a: __m64) __m128 {
    var __a = arg___a;
    var __b: __m64 = undefined;
    __b = _mm_setzero_si64();
    __b = _mm_unpacklo_pi8(__a, __b);
    return _mm_cvtpi16_ps(__b);
}
pub inline fn _mm_cvtpi32x2_ps(arg___a: __m64, arg___b: __m64) __m128 {
    var __a = arg___a;
    var __b = arg___b;
    var __c: __m128 = undefined;
    __c = _mm_setzero_ps();
    __c = _mm_cvtpi32_ps(__c, __b);
    __c = _mm_movelh_ps(__c, __c);
    return _mm_cvtpi32_ps(__c, __a);
}
pub inline fn _mm_cvtps_pi16(arg___a: __m128) __m64 {
    var __a = arg___a;
    var __b: __m64 = undefined;
    var __c: __m64 = undefined;
    __b = _mm_cvtps_pi32(__a);
    __a = _mm_movehl_ps(__a, __a);
    __c = _mm_cvtps_pi32(__a);
    return _mm_packs_pi32(__b, __c);
}
pub inline fn _mm_cvtps_pi8(arg___a: __m128) __m64 {
    var __a = arg___a;
    var __b: __m64 = undefined;
    var __c: __m64 = undefined;
    __b = _mm_cvtps_pi16(__a);
    __c = _mm_setzero_si64();
    return _mm_packs_pi16(__b, __c);
} // /usr/lib/zig/include/xmmintrin.h:2936:10: warning: TODO implement function '__builtin_ia32_movmskps' in std.zig.c_builtins
// /usr/lib/zig/include/xmmintrin.h:2934:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_movemask_ps(arg___a: __m128) c_int;
pub const __m128d = @Vector(2, f64);
pub const __m128i = @Vector(2, c_longlong);
pub const __m128d_u = @Vector(2, f64);
pub const __m128i_u = @Vector(2, c_longlong);
pub const __v2df = @Vector(2, f64);
pub const __v2di = @Vector(2, c_longlong);
pub const __v8hi = @Vector(8, c_short);
pub const __v16qi = @Vector(16, u8);
pub const __v2du = @Vector(2, c_ulonglong);
pub const __v8hu = @Vector(8, c_ushort);
pub const __v16qu = @Vector(16, u8);
pub const __v16qs = @Vector(16, i8);
pub const __v8hf = @Vector(8, f16);
pub const __m128h = @Vector(8, f16);
pub const __m128h_u = @Vector(8, f16); // /usr/lib/zig/include/emmintrin.h:47:16: warning: unsupported builtin type
pub const __v8bf = @compileError("unable to resolve typedef child type"); // /usr/lib/zig/include/emmintrin.h:47:16
// /usr/lib/zig/include/emmintrin.h:48:16: warning: unsupported builtin type
pub const __m128bh = @compileError("unable to resolve typedef child type"); // /usr/lib/zig/include/emmintrin.h:48:16
pub inline fn _mm_add_sd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] += __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_add_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2df, @bitCast(__a)) + @as(__v2df, @bitCast(__b))));
}
pub inline fn _mm_sub_sd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] -= __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_sub_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2df, @bitCast(__a)) - @as(__v2df, @bitCast(__b))));
}
pub inline fn _mm_mul_sd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] *= __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_mul_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2df, @bitCast(__a)) * @as(__v2df, @bitCast(__b))));
}
pub inline fn _mm_div_sd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] /= __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_div_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2df, @bitCast(__a)) / @as(__v2df, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:238:17: warning: TODO implement function '__builtin_ia32_sqrtsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:236:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sqrt_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:254:10: warning: TODO implement function '__builtin_ia32_sqrtpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:253:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sqrt_pd(arg___a: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:277:10: warning: TODO implement function '__builtin_ia32_minsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:275:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:296:10: warning: TODO implement function '__builtin_ia32_minpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:294:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:319:10: warning: TODO implement function '__builtin_ia32_maxsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:317:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:338:10: warning: TODO implement function '__builtin_ia32_maxpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:336:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_pd(arg___a: __m128d, arg___b: __m128d) __m128d;
pub inline fn _mm_and_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2du, @bitCast(__a)) & @as(__v2du, @bitCast(__b))));
}
pub inline fn _mm_andnot_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(~@as(__v2du, @bitCast(__a)) & @as(__v2du, @bitCast(__b))));
}
pub inline fn _mm_or_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2du, @bitCast(__a)) | @as(__v2du, @bitCast(__b))));
}
pub inline fn _mm_xor_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128d, @bitCast(@as(__v2du, @bitCast(__a)) ^ @as(__v2du, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:427:19: warning: TODO implement function '__builtin_ia32_cmpeqpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:425:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:446:19: warning: TODO implement function '__builtin_ia32_cmpltpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:444:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmplt_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:466:19: warning: TODO implement function '__builtin_ia32_cmplepd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:464:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmple_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:486:19: warning: TODO implement function '__builtin_ia32_cmpltpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:484:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:506:19: warning: TODO implement function '__builtin_ia32_cmplepd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:504:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpge_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:528:19: warning: TODO implement function '__builtin_ia32_cmpordpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:526:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpord_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:551:19: warning: TODO implement function '__builtin_ia32_cmpunordpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:549:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpunord_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:571:19: warning: TODO implement function '__builtin_ia32_cmpneqpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:569:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpneq_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:591:19: warning: TODO implement function '__builtin_ia32_cmpnltpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:589:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnlt_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:611:19: warning: TODO implement function '__builtin_ia32_cmpnlepd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:609:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnle_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:631:19: warning: TODO implement function '__builtin_ia32_cmpnltpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:629:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpngt_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:651:19: warning: TODO implement function '__builtin_ia32_cmpnlepd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:649:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnge_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:673:19: warning: TODO implement function '__builtin_ia32_cmpeqsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:671:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpeq_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:697:19: warning: TODO implement function '__builtin_ia32_cmpltsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:695:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmplt_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:721:19: warning: TODO implement function '__builtin_ia32_cmplesd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:719:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmple_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:745:17: warning: TODO implement function '__builtin_ia32_cmpltsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:743:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpgt_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:770:17: warning: TODO implement function '__builtin_ia32_cmplesd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:768:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpge_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:797:19: warning: TODO implement function '__builtin_ia32_cmpordsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:795:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpord_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:824:19: warning: TODO implement function '__builtin_ia32_cmpunordsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:822:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpunord_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:848:19: warning: TODO implement function '__builtin_ia32_cmpneqsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:846:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpneq_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:872:19: warning: TODO implement function '__builtin_ia32_cmpnltsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:870:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnlt_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:896:19: warning: TODO implement function '__builtin_ia32_cmpnlesd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:894:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnle_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:920:17: warning: TODO implement function '__builtin_ia32_cmpnltsd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:918:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpngt_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:945:17: warning: TODO implement function '__builtin_ia32_cmpnlesd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:943:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cmpnge_sd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/emmintrin.h:969:10: warning: TODO implement function '__builtin_ia32_comisdeq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:967:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_comieq_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:994:10: warning: TODO implement function '__builtin_ia32_comisdlt' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:992:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_comilt_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1019:10: warning: TODO implement function '__builtin_ia32_comisdle' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1017:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_comile_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1044:10: warning: TODO implement function '__builtin_ia32_comisdgt' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1042:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_comigt_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1069:10: warning: TODO implement function '__builtin_ia32_comisdge' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1067:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_comige_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1094:10: warning: TODO implement function '__builtin_ia32_comisdneq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1092:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_comineq_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1117:10: warning: TODO implement function '__builtin_ia32_ucomisdeq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1115:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomieq_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1142:10: warning: TODO implement function '__builtin_ia32_ucomisdlt' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1140:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomilt_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1167:10: warning: TODO implement function '__builtin_ia32_ucomisdle' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1165:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomile_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1192:10: warning: TODO implement function '__builtin_ia32_ucomisdgt' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1190:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomigt_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1217:10: warning: TODO implement function '__builtin_ia32_ucomisdge' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1215:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomige_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1242:10: warning: TODO implement function '__builtin_ia32_ucomisdneq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1240:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_ucomineq_sd(arg___a: __m128d, arg___b: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1259:10: warning: TODO implement function '__builtin_ia32_cvtpd2ps' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1258:45: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtpd_ps(arg___a: __m128d) __m128;
pub inline fn _mm_cvtps_pd(arg___a: __m128) __m128d {
    var __a = arg___a;
    return @as(__m128d, @bitCast(blk: {
        const tmp = @as(f64, @floatCast(@shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        })[0]));
        const tmp_1 = @as(f64, @floatCast(@shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        })[1]));
        break :blk __v2df{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtepi32_pd(arg___a: __m128i) __m128d {
    var __a = arg___a;
    return @as(__m128d, @bitCast(blk: {
        const tmp = @as(f64, @floatFromInt(@shuffle(@typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.child, @as(__v4si, @bitCast(__a)), @as(__v4si, @bitCast(__a)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        })[0]));
        const tmp_1 = @as(f64, @floatFromInt(@shuffle(@typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.child, @as(__v4si, @bitCast(__a)), @as(__v4si, @bitCast(__a)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        })[1]));
        break :blk __v2df{
            tmp,
            tmp_1,
        };
    }));
} // /usr/lib/zig/include/emmintrin.h:1316:10: warning: TODO implement function '__builtin_ia32_cvtpd2dq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1315:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtpd_epi32(arg___a: __m128d) __m128i; // /usr/lib/zig/include/emmintrin.h:1331:10: warning: TODO implement function '__builtin_ia32_cvtsd2si' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1330:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtsd_si32(arg___a: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1355:18: warning: TODO implement function '__builtin_ia32_cvtsd2ss' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1353:45: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtsd_ss(arg___a: __m128, arg___b: __m128d) __m128;
pub inline fn _mm_cvtsi32_sd(arg___a: __m128d, arg___b: c_int) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(f64, @floatFromInt(__b));
    return __a;
}
pub inline fn _mm_cvtss_sd(arg___a: __m128d, arg___b: __m128) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(f64, @floatCast(__b[@as(c_uint, @intCast(@as(c_int, 0)))]));
    return __a;
} // /usr/lib/zig/include/emmintrin.h:1424:19: warning: TODO implement function '__builtin_ia32_cvttpd2dq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1423:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttpd_epi32(arg___a: __m128d) __m128i; // /usr/lib/zig/include/emmintrin.h:1440:10: warning: TODO implement function '__builtin_ia32_cvttsd2si' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1439:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttsd_si32(arg___a: __m128d) c_int; // /usr/lib/zig/include/emmintrin.h:1455:17: warning: TODO implement function '__builtin_ia32_cvtpd2pi' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1454:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtpd_pi32(arg___a: __m128d) __m64; // /usr/lib/zig/include/emmintrin.h:1473:17: warning: TODO implement function '__builtin_ia32_cvttpd2pi' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1472:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttpd_pi32(arg___a: __m128d) __m64; // /usr/lib/zig/include/emmintrin.h:1488:10: warning: TODO implement function '__builtin_ia32_cvtpi2pd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1487:50: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtpi32_pd(arg___a: __m64) __m128d;
pub inline fn _mm_cvtsd_f64(arg___a: __m128d) f64 {
    var __a = arg___a;
    return __a[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_load_pd(arg___dp: [*c]const f64) __m128d {
    var __dp = arg___dp;
    return @as([*c]const __m128d, @ptrCast(@alignCast(__dp))).*;
}
pub inline fn _mm_load1_pd(arg___dp: [*c]const f64) __m128d {
    var __dp = arg___dp;
    const struct___mm_load1_pd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_load1_pd_struct);
    var __u: f64 = @as([*c]const struct___mm_load1_pd_struct, @ptrCast(@alignCast(__dp))).*.__u;
    return blk: {
        const tmp = __u;
        const tmp_1 = __u;
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_loadr_pd(arg___dp: [*c]const f64) __m128d {
    var __dp = arg___dp;
    var __u: __m128d = @as([*c]const __m128d, @ptrCast(@alignCast(__dp))).*;
    return @shuffle(@typeInfo(@TypeOf(@as(__v2df, @bitCast(__u)))).Vector.child, @as(__v2df, @bitCast(__u)), @as(__v2df, @bitCast(__u)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__u)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__u)))).Vector.len),
    });
}
pub inline fn _mm_loadu_pd(arg___dp: [*c]const f64) __m128d {
    var __dp = arg___dp;
    const struct___loadu_pd = extern struct {
        __v: __m128d_u align(1),
    };
    _ = @TypeOf(struct___loadu_pd);
    return @as([*c]const struct___loadu_pd, @ptrCast(@alignCast(__dp))).*.__v;
}
pub inline fn _mm_loadu_si64(arg___a: ?*const anyopaque) __m128i {
    var __a = arg___a;
    const struct___loadu_si64 = extern struct {
        __v: c_longlong align(1),
    };
    _ = @TypeOf(struct___loadu_si64);
    var __u: c_longlong = @as([*c]const struct___loadu_si64, @ptrCast(@alignCast(__a))).*.__v;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __u;
        const tmp_1 = @as(c_longlong, 0);
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_loadu_si32(arg___a: ?*const anyopaque) __m128i {
    var __a = arg___a;
    const struct___loadu_si32 = extern struct {
        __v: c_int align(1),
    };
    _ = @TypeOf(struct___loadu_si32);
    var __u: c_int = @as([*c]const struct___loadu_si32, @ptrCast(@alignCast(__a))).*.__v;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __u;
        const tmp_1 = @as(c_int, 0);
        const tmp_2 = @as(c_int, 0);
        const tmp_3 = @as(c_int, 0);
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_loadu_si16(arg___a: ?*const anyopaque) __m128i {
    var __a = arg___a;
    const struct___loadu_si16 = extern struct {
        __v: c_short align(1),
    };
    _ = @TypeOf(struct___loadu_si16);
    var __u: c_short = @as([*c]const struct___loadu_si16, @ptrCast(@alignCast(__a))).*.__v;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __u;
        const tmp_1 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        const tmp_2 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        const tmp_3 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        const tmp_4 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        const tmp_5 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        const tmp_6 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        const tmp_7 = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 0)))));
        break :blk __v8hi{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
            tmp_4,
            tmp_5,
            tmp_6,
            tmp_7,
        };
    }));
}
pub inline fn _mm_load_sd(arg___dp: [*c]const f64) __m128d {
    var __dp = arg___dp;
    const struct___mm_load_sd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_load_sd_struct);
    var __u: f64 = @as([*c]const struct___mm_load_sd_struct, @ptrCast(@alignCast(__dp))).*.__u;
    return blk: {
        const tmp = __u;
        const tmp_1 = @as(f64, @floatFromInt(@as(c_int, 0)));
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_loadh_pd(arg___a: __m128d, arg___dp: [*c]const f64) __m128d {
    var __a = arg___a;
    var __dp = arg___dp;
    const struct___mm_loadh_pd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_loadh_pd_struct);
    var __u: f64 = @as([*c]const struct___mm_loadh_pd_struct, @ptrCast(@alignCast(__dp))).*.__u;
    return blk: {
        const tmp = __a[@as(c_uint, @intCast(@as(c_int, 0)))];
        const tmp_1 = __u;
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_loadl_pd(arg___a: __m128d, arg___dp: [*c]const f64) __m128d {
    var __a = arg___a;
    var __dp = arg___dp;
    const struct___mm_loadl_pd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_loadl_pd_struct);
    var __u: f64 = @as([*c]const struct___mm_loadl_pd_struct, @ptrCast(@alignCast(__dp))).*.__u;
    return blk: {
        const tmp = __u;
        const tmp_1 = __a[@as(c_uint, @intCast(@as(c_int, 1)))];
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
} // /usr/lib/zig/include/emmintrin.h:1720:19: warning: TODO implement function '__builtin_ia32_undef128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:1719:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_undefined_pd() __m128d;
pub inline fn _mm_set_sd(arg___w: f64) __m128d {
    var __w = arg___w;
    return blk: {
        const tmp = __w;
        const tmp_1 = @as(f64, @floatFromInt(@as(c_int, 0)));
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_set1_pd(arg___w: f64) __m128d {
    var __w = arg___w;
    return blk: {
        const tmp = __w;
        const tmp_1 = __w;
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_set_pd1(arg___w: f64) __m128d {
    var __w = arg___w;
    return _mm_set1_pd(__w);
}
pub inline fn _mm_set_pd(arg___w: f64, arg___x: f64) __m128d {
    var __w = arg___w;
    var __x = arg___x;
    return blk: {
        const tmp = __x;
        const tmp_1 = __w;
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_setr_pd(arg___w: f64, arg___x: f64) __m128d {
    var __w = arg___w;
    var __x = arg___x;
    return blk: {
        const tmp = __w;
        const tmp_1 = __x;
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_setzero_pd() __m128d {
    return blk: {
        const tmp = 0.0;
        const tmp_1 = 0.0;
        break :blk __m128d{
            tmp,
            tmp_1,
        };
    };
}
pub inline fn _mm_move_sd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = __b[@as(c_uint, @intCast(@as(c_int, 0)))];
    return __a;
}
pub inline fn _mm_store_sd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    const struct___mm_store_sd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_store_sd_struct);
    @as([*c]struct___mm_store_sd_struct, @ptrCast(@alignCast(__dp))).*.__u = __a[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_store_pd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    @as([*c]__m128d, @ptrCast(@alignCast(__dp))).* = __a;
}
pub inline fn _mm_store1_pd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    __a = @shuffle(@typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.child, @as(__v2df, @bitCast(__a)), @as(__v2df, @bitCast(__a)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
    });
    _mm_store_pd(__dp, __a);
}
pub inline fn _mm_store_pd1(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    _mm_store1_pd(__dp, __a);
}
pub inline fn _mm_storeu_pd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    const struct___storeu_pd = extern struct {
        __v: __m128d_u align(1),
    };
    _ = @TypeOf(struct___storeu_pd);
    @as([*c]struct___storeu_pd, @ptrCast(@alignCast(__dp))).*.__v = __a;
}
pub inline fn _mm_storer_pd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    __a = @shuffle(@typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.child, @as(__v2df, @bitCast(__a)), @as(__v2df, @bitCast(__a)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
    });
    @as([*c]__m128d, @ptrCast(@alignCast(__dp))).* = __a;
}
pub inline fn _mm_storeh_pd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    const struct___mm_storeh_pd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_storeh_pd_struct);
    @as([*c]struct___mm_storeh_pd_struct, @ptrCast(@alignCast(__dp))).*.__u = __a[@as(c_uint, @intCast(@as(c_int, 1)))];
}
pub inline fn _mm_storel_pd(arg___dp: [*c]f64, arg___a: __m128d) void {
    var __dp = arg___dp;
    var __a = arg___a;
    const struct___mm_storeh_pd_struct = extern struct {
        __u: f64 align(1),
    };
    _ = @TypeOf(struct___mm_storeh_pd_struct);
    @as([*c]struct___mm_storeh_pd_struct, @ptrCast(@alignCast(__dp))).*.__u = __a[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_add_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v16qu, @bitCast(__a)) + @as(__v16qu, @bitCast(__b))));
}
pub inline fn _mm_add_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v8hu, @bitCast(__a)) + @as(__v8hu, @bitCast(__b))));
}
pub inline fn _mm_add_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v4su, @bitCast(__a)) + @as(__v4su, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:2077:17: warning: TODO implement function '__builtin_ia32_paddq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2075:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_add_si64(arg___a: __m64, arg___b: __m64) __m64;
pub inline fn _mm_add_epi64(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v2du, @bitCast(__a)) + @as(__v2du, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:2118:19: warning: TODO implement function '__builtin_elementwise_add_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2116:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_epi8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2139:19: warning: TODO implement function '__builtin_elementwise_add_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2137:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2159:19: warning: TODO implement function '__builtin_elementwise_add_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2157:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_epu8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2179:19: warning: TODO implement function '__builtin_elementwise_add_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2177:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_adds_epu16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2198:19: warning: TODO implement function '__builtin_ia32_pavgb128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2196:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_avg_epu8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2217:19: warning: TODO implement function '__builtin_ia32_pavgw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2215:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_avg_epu16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2242:19: warning: TODO implement function '__builtin_ia32_pmaddwd128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2240:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_madd_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2261:19: warning: TODO implement function '__builtin_elementwise_max' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2259:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2280:19: warning: TODO implement function '__builtin_elementwise_max' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2278:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_epu8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2299:19: warning: TODO implement function '__builtin_elementwise_min' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2297:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2318:19: warning: TODO implement function '__builtin_elementwise_min' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2316:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_epu8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2337:19: warning: TODO implement function '__builtin_ia32_pmulhw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2335:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_mulhi_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2356:19: warning: TODO implement function '__builtin_ia32_pmulhuw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2354:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_mulhi_epu16(arg___a: __m128i, arg___b: __m128i) __m128i;
pub inline fn _mm_mullo_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v8hu, @bitCast(__a)) * @as(__v8hu, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:2393:10: warning: TODO implement function '__builtin_ia32_pmuludq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2391:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_mul_su32(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/emmintrin.h:2411:10: warning: TODO implement function '__builtin_ia32_pmuludq128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2409:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_mul_epu32(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2432:10: warning: TODO implement function '__builtin_ia32_psadbw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2430:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sad_epu8(arg___a: __m128i, arg___b: __m128i) __m128i;
pub inline fn _mm_sub_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v16qu, @bitCast(__a)) - @as(__v16qu, @bitCast(__b))));
}
pub inline fn _mm_sub_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v8hu, @bitCast(__a)) - @as(__v8hu, @bitCast(__b))));
}
pub inline fn _mm_sub_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v4su, @bitCast(__a)) - @as(__v4su, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:2501:17: warning: TODO implement function '__builtin_ia32_psubq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2499:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_sub_si64(arg___a: __m64, arg___b: __m64) __m64;
pub inline fn _mm_sub_epi64(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v2du, @bitCast(__a)) - @as(__v2du, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:2538:19: warning: TODO implement function '__builtin_elementwise_sub_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2536:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_epi8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2558:19: warning: TODO implement function '__builtin_elementwise_sub_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2556:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2577:19: warning: TODO implement function '__builtin_elementwise_sub_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2575:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_epu8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2596:19: warning: TODO implement function '__builtin_elementwise_sub_sat' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2594:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_subs_epu16(arg___a: __m128i, arg___b: __m128i) __m128i;
pub inline fn _mm_and_si128(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v2du, @bitCast(__a)) & @as(__v2du, @bitCast(__b))));
}
pub inline fn _mm_andnot_si128(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(~@as(__v2du, @bitCast(__a)) & @as(__v2du, @bitCast(__b))));
}
pub inline fn _mm_or_si128(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v2du, @bitCast(__a)) | @as(__v2du, @bitCast(__b))));
}
pub inline fn _mm_xor_si128(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v2du, @bitCast(__a)) ^ @as(__v2du, @bitCast(__b))));
} // /usr/lib/zig/include/emmintrin.h:2708:19: warning: TODO implement function '__builtin_ia32_psllwi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2706:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_slli_epi16(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2726:19: warning: TODO implement function '__builtin_ia32_psllw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2724:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sll_epi16(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2744:19: warning: TODO implement function '__builtin_ia32_pslldi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2742:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_slli_epi32(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2762:19: warning: TODO implement function '__builtin_ia32_pslld128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2760:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sll_epi32(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2780:10: warning: TODO implement function '__builtin_ia32_psllqi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2778:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_slli_epi64(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2798:10: warning: TODO implement function '__builtin_ia32_psllq128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2796:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sll_epi64(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2817:19: warning: TODO implement function '__builtin_ia32_psrawi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2815:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srai_epi16(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2836:19: warning: TODO implement function '__builtin_ia32_psraw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2834:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sra_epi16(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2855:19: warning: TODO implement function '__builtin_ia32_psradi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2853:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srai_epi32(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2874:19: warning: TODO implement function '__builtin_ia32_psrad128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2872:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_sra_epi32(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2917:19: warning: TODO implement function '__builtin_ia32_psrlwi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2915:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srli_epi16(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2935:19: warning: TODO implement function '__builtin_ia32_psrlw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2933:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srl_epi16(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2953:19: warning: TODO implement function '__builtin_ia32_psrldi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2951:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srli_epi32(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:2971:19: warning: TODO implement function '__builtin_ia32_psrld128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2969:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srl_epi32(arg___a: __m128i, arg___count: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:2989:10: warning: TODO implement function '__builtin_ia32_psrlqi128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:2987:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srli_epi64(arg___a: __m128i, arg___count: c_int) __m128i; // /usr/lib/zig/include/emmintrin.h:3007:10: warning: TODO implement function '__builtin_ia32_psrlq128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3005:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_srl_epi64(arg___a: __m128i, arg___count: __m128i) __m128i;
pub inline fn _mm_cmpeq_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v16qi, @bitCast(__a)) == @as(__v16qi, @bitCast(__b))));
}
pub inline fn _mm_cmpeq_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v8hi, @bitCast(__a)) == @as(__v8hi, @bitCast(__b))));
}
pub inline fn _mm_cmpeq_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v4si, @bitCast(__a)) == @as(__v4si, @bitCast(__b))));
}
pub inline fn _mm_cmpgt_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v16qs, @bitCast(__a)) > @as(__v16qs, @bitCast(__b))));
}
pub inline fn _mm_cmpgt_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v8hi, @bitCast(__a)) > @as(__v8hi, @bitCast(__b))));
}
pub inline fn _mm_cmpgt_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@as(__v4si, @bitCast(__a)) > @as(__v4si, @bitCast(__b))));
}
pub inline fn _mm_cmplt_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return _mm_cmpgt_epi8(__b, __a);
}
pub inline fn _mm_cmplt_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return _mm_cmpgt_epi16(__b, __a);
}
pub inline fn _mm_cmplt_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return _mm_cmpgt_epi32(__b, __a);
}
pub inline fn _mm_cvtsi64_sd(arg___a: __m128d, arg___b: c_longlong) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    __a[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(f64, @floatFromInt(__b));
    return __a;
} // /usr/lib/zig/include/emmintrin.h:3221:10: warning: TODO implement function '__builtin_ia32_cvtsd2si64' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3220:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtsd_si64(arg___a: __m128d) c_longlong; // /usr/lib/zig/include/emmintrin.h:3237:10: warning: TODO implement function '__builtin_ia32_cvttsd2si64' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3236:48: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttsd_si64(arg___a: __m128d) c_longlong;
pub inline fn _mm_cvtepi32_ps(arg___a: __m128i) __m128 {
    var __a = arg___a;
    return @as(__m128, @bitCast(blk: {
        const tmp = @as(f32, @floatFromInt(@as(__v4si, @bitCast(__a))[0]));
        const tmp_1 = @as(f32, @floatFromInt(@as(__v4si, @bitCast(__a))[1]));
        const tmp_2 = @as(f32, @floatFromInt(@as(__v4si, @bitCast(__a))[2]));
        const tmp_3 = @as(f32, @floatFromInt(@as(__v4si, @bitCast(__a))[3]));
        break :blk __v4sf{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
} // /usr/lib/zig/include/emmintrin.h:3265:19: warning: TODO implement function '__builtin_ia32_cvtps2dq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3264:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvtps_epi32(arg___a: __m128) __m128i; // /usr/lib/zig/include/emmintrin.h:3280:19: warning: TODO implement function '__builtin_ia32_cvttps2dq' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3279:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_cvttps_epi32(arg___a: __m128) __m128i;
pub inline fn _mm_cvtsi32_si128(arg___a: c_int) __m128i {
    var __a = arg___a;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __a;
        const tmp_1 = @as(c_int, 0);
        const tmp_2 = @as(c_int, 0);
        const tmp_3 = @as(c_int, 0);
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_cvtsi64_si128(arg___a: c_longlong) __m128i {
    var __a = arg___a;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __a;
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_longlong, @as(c_int, 0))));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtsi128_si32(arg___a: __m128i) c_int {
    var __a = arg___a;
    var __b: __v4si = @as(__v4si, @bitCast(__a));
    return __b[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_cvtsi128_si64(arg___a: __m128i) c_longlong {
    var __a = arg___a;
    return __a[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_load_si128(arg___p: [*c]const __m128i) __m128i {
    var __p = arg___p;
    return __p.*;
}
pub inline fn _mm_loadu_si128(arg___p: [*c]const __m128i_u) __m128i {
    var __p = arg___p;
    const struct___loadu_si128 = extern struct {
        __v: __m128i_u align(1),
    };
    _ = @TypeOf(struct___loadu_si128);
    return @as([*c]const struct___loadu_si128, @ptrCast(@alignCast(__p))).*.__v;
}
pub inline fn _mm_loadl_epi64(arg___p: [*c]const __m128i_u) __m128i {
    var __p = arg___p;
    const struct___mm_loadl_epi64_struct = extern struct {
        __u: c_longlong align(1),
    };
    _ = @TypeOf(struct___mm_loadl_epi64_struct);
    return blk: {
        const tmp = @as([*c]const struct___mm_loadl_epi64_struct, @ptrCast(@alignCast(__p))).*.__u;
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_longlong, @as(c_int, 0))));
        break :blk __m128i{
            tmp,
            tmp_1,
        };
    };
} // /usr/lib/zig/include/emmintrin.h:3407:19: warning: TODO implement function '__builtin_ia32_undef128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3406:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_undefined_si128() __m128i;
pub inline fn _mm_set_epi64x(arg___q1: c_longlong, arg___q0: c_longlong) __m128i {
    var __q1 = arg___q1;
    var __q0 = arg___q0;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __q0;
        const tmp_1 = __q1;
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_set_epi64(arg___q1: __m64, arg___q0: __m64) __m128i {
    var __q1 = arg___q1;
    var __q0 = arg___q0;
    return _mm_set_epi64x(@as(c_longlong, @bitCast(__q1)), @as(c_longlong, @bitCast(__q0)));
}
pub inline fn _mm_set_epi32(arg___i3: c_int, arg___i2: c_int, arg___i1: c_int, arg___i0: c_int) __m128i {
    var __i3 = arg___i3;
    var __i2 = arg___i2;
    var __i1 = arg___i1;
    var __i0 = arg___i0;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __i0;
        const tmp_1 = __i1;
        const tmp_2 = __i2;
        const tmp_3 = __i3;
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_set_epi16(arg___w7: c_short, arg___w6: c_short, arg___w5: c_short, arg___w4: c_short, arg___w3: c_short, arg___w2: c_short, arg___w1: c_short, arg___w0: c_short) __m128i {
    var __w7 = arg___w7;
    var __w6 = arg___w6;
    var __w5 = arg___w5;
    var __w4 = arg___w4;
    var __w3 = arg___w3;
    var __w2 = arg___w2;
    var __w1 = arg___w1;
    var __w0 = arg___w0;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __w0;
        const tmp_1 = __w1;
        const tmp_2 = __w2;
        const tmp_3 = __w3;
        const tmp_4 = __w4;
        const tmp_5 = __w5;
        const tmp_6 = __w6;
        const tmp_7 = __w7;
        break :blk __v8hi{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
            tmp_4,
            tmp_5,
            tmp_6,
            tmp_7,
        };
    }));
}
pub inline fn _mm_set_epi8(arg___b15: u8, arg___b14: u8, arg___b13: u8, arg___b12: u8, arg___b11: u8, arg___b10: u8, arg___b9: u8, arg___b8: u8, arg___b7: u8, arg___b6: u8, arg___b5: u8, arg___b4: u8, arg___b3: u8, arg___b2: u8, arg___b1: u8, arg___b0: u8) __m128i {
    var __b15 = arg___b15;
    var __b14 = arg___b14;
    var __b13 = arg___b13;
    var __b12 = arg___b12;
    var __b11 = arg___b11;
    var __b10 = arg___b10;
    var __b9 = arg___b9;
    var __b8 = arg___b8;
    var __b7 = arg___b7;
    var __b6 = arg___b6;
    var __b5 = arg___b5;
    var __b4 = arg___b4;
    var __b3 = arg___b3;
    var __b2 = arg___b2;
    var __b1 = arg___b1;
    var __b0 = arg___b0;
    return @as(__m128i, @bitCast(blk: {
        const tmp = __b0;
        const tmp_1 = __b1;
        const tmp_2 = __b2;
        const tmp_3 = __b3;
        const tmp_4 = __b4;
        const tmp_5 = __b5;
        const tmp_6 = __b6;
        const tmp_7 = __b7;
        const tmp_8 = __b8;
        const tmp_9 = __b9;
        const tmp_10 = __b10;
        const tmp_11 = __b11;
        const tmp_12 = __b12;
        const tmp_13 = __b13;
        const tmp_14 = __b14;
        const tmp_15 = __b15;
        break :blk __v16qi{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
            tmp_4,
            tmp_5,
            tmp_6,
            tmp_7,
            tmp_8,
            tmp_9,
            tmp_10,
            tmp_11,
            tmp_12,
            tmp_13,
            tmp_14,
            tmp_15,
        };
    }));
}
pub inline fn _mm_set1_epi64x(arg___q: c_longlong) __m128i {
    var __q = arg___q;
    return _mm_set_epi64x(__q, __q);
}
pub inline fn _mm_set1_epi64(arg___q: __m64) __m128i {
    var __q = arg___q;
    return _mm_set_epi64(__q, __q);
}
pub inline fn _mm_set1_epi32(arg___i: c_int) __m128i {
    var __i = arg___i;
    return _mm_set_epi32(__i, __i, __i, __i);
}
pub inline fn _mm_set1_epi16(arg___w: c_short) __m128i {
    var __w = arg___w;
    return _mm_set_epi16(__w, __w, __w, __w, __w, __w, __w, __w);
}
pub inline fn _mm_set1_epi8(arg___b: u8) __m128i {
    var __b = arg___b;
    return _mm_set_epi8(__b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b, __b);
}
pub inline fn _mm_setr_epi64(arg___q0: __m64, arg___q1: __m64) __m128i {
    var __q0 = arg___q0;
    var __q1 = arg___q1;
    return _mm_set_epi64(__q1, __q0);
}
pub inline fn _mm_setr_epi32(arg___i0: c_int, arg___i1: c_int, arg___i2: c_int, arg___i3: c_int) __m128i {
    var __i0 = arg___i0;
    var __i1 = arg___i1;
    var __i2 = arg___i2;
    var __i3 = arg___i3;
    return _mm_set_epi32(__i3, __i2, __i1, __i0);
}
pub inline fn _mm_setr_epi16(arg___w0: c_short, arg___w1: c_short, arg___w2: c_short, arg___w3: c_short, arg___w4: c_short, arg___w5: c_short, arg___w6: c_short, arg___w7: c_short) __m128i {
    var __w0 = arg___w0;
    var __w1 = arg___w1;
    var __w2 = arg___w2;
    var __w3 = arg___w3;
    var __w4 = arg___w4;
    var __w5 = arg___w5;
    var __w6 = arg___w6;
    var __w7 = arg___w7;
    return _mm_set_epi16(__w7, __w6, __w5, __w4, __w3, __w2, __w1, __w0);
}
pub inline fn _mm_setr_epi8(arg___b0: u8, arg___b1: u8, arg___b2: u8, arg___b3: u8, arg___b4: u8, arg___b5: u8, arg___b6: u8, arg___b7: u8, arg___b8: u8, arg___b9: u8, arg___b10: u8, arg___b11: u8, arg___b12: u8, arg___b13: u8, arg___b14: u8, arg___b15: u8) __m128i {
    var __b0 = arg___b0;
    var __b1 = arg___b1;
    var __b2 = arg___b2;
    var __b3 = arg___b3;
    var __b4 = arg___b4;
    var __b5 = arg___b5;
    var __b6 = arg___b6;
    var __b7 = arg___b7;
    var __b8 = arg___b8;
    var __b9 = arg___b9;
    var __b10 = arg___b10;
    var __b11 = arg___b11;
    var __b12 = arg___b12;
    var __b13 = arg___b13;
    var __b14 = arg___b14;
    var __b15 = arg___b15;
    return _mm_set_epi8(__b15, __b14, __b13, __b12, __b11, __b10, __b9, __b8, __b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}
pub inline fn _mm_setzero_si128() __m128i {
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, 0);
        const tmp_1 = @as(c_longlong, 0);
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_store_si128(arg___p: [*c]__m128i, arg___b: __m128i) void {
    var __p = arg___p;
    var __b = arg___b;
    __p.* = __b;
}
pub inline fn _mm_storeu_si128(arg___p: [*c]__m128i_u, arg___b: __m128i) void {
    var __p = arg___p;
    var __b = arg___b;
    const struct___storeu_si128 = extern struct {
        __v: __m128i_u align(1),
    };
    _ = @TypeOf(struct___storeu_si128);
    @as([*c]struct___storeu_si128, @ptrCast(@alignCast(__p))).*.__v = __b;
}
pub inline fn _mm_storeu_si64(arg___p: ?*anyopaque, arg___b: __m128i) void {
    var __p = arg___p;
    var __b = arg___b;
    const struct___storeu_si64 = extern struct {
        __v: c_longlong align(1),
    };
    _ = @TypeOf(struct___storeu_si64);
    @as([*c]struct___storeu_si64, @ptrCast(@alignCast(__p))).*.__v = @as(__v2di, @bitCast(__b))[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_storeu_si32(arg___p: ?*anyopaque, arg___b: __m128i) void {
    var __p = arg___p;
    var __b = arg___b;
    const struct___storeu_si32 = extern struct {
        __v: c_int align(1),
    };
    _ = @TypeOf(struct___storeu_si32);
    @as([*c]struct___storeu_si32, @ptrCast(@alignCast(__p))).*.__v = @as(__v4si, @bitCast(__b))[@as(c_uint, @intCast(@as(c_int, 0)))];
}
pub inline fn _mm_storeu_si16(arg___p: ?*anyopaque, arg___b: __m128i) void {
    var __p = arg___p;
    var __b = arg___b;
    const struct___storeu_si16 = extern struct {
        __v: c_short align(1),
    };
    _ = @TypeOf(struct___storeu_si16);
    @as([*c]struct___storeu_si16, @ptrCast(@alignCast(__p))).*.__v = @as(__v8hi, @bitCast(__b))[@as(c_uint, @intCast(@as(c_int, 0)))];
} // /usr/lib/zig/include/emmintrin.h:3910:3: warning: TODO implement function '__builtin_ia32_maskmovdqu' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3907:43: warning: unable to translate function, demoted to extern
pub extern fn _mm_maskmoveu_si128(arg___d: __m128i, arg___n: __m128i, arg___p: [*c]u8) void;
pub inline fn _mm_storel_epi64(arg___p: [*c]__m128i_u, arg___a: __m128i) void {
    var __p = arg___p;
    var __a = arg___a;
    const struct___mm_storel_epi64_struct = extern struct {
        __u: c_longlong align(1),
    };
    _ = @TypeOf(struct___mm_storel_epi64_struct);
    @as([*c]struct___mm_storel_epi64_struct, @ptrCast(@alignCast(__p))).*.__u = __a[@as(c_uint, @intCast(@as(c_int, 0)))];
} // /usr/lib/zig/include/emmintrin.h:3950:3: warning: TODO implement function '__builtin_nontemporal_store' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3948:43: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_pd(arg___p: [*c]f64, arg___a: __m128d) void; // /usr/lib/zig/include/emmintrin.h:3968:3: warning: TODO implement function '__builtin_nontemporal_store' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3966:43: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_si128(arg___p: [*c]__m128i, arg___a: __m128i) void; // /usr/lib/zig/include/emmintrin.h:3987:3: warning: TODO implement function '__builtin_ia32_movnti' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:3986:5: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_si32(arg___p: [*c]c_int, arg___a: c_int) void; // /usr/lib/zig/include/emmintrin.h:4007:3: warning: TODO implement function '__builtin_ia32_movnti64' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:4006:5: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_si64(arg___p: [*c]c_longlong, arg___a: c_longlong) void;
pub extern fn _mm_clflush(__p: ?*const anyopaque) void;
pub extern fn _mm_lfence() void;
pub extern fn _mm_mfence() void; // /usr/lib/zig/include/emmintrin.h:4077:19: warning: TODO implement function '__builtin_ia32_packsswb128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:4075:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_packs_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:4104:19: warning: TODO implement function '__builtin_ia32_packssdw128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:4102:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_packs_epi32(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:4131:19: warning: TODO implement function '__builtin_ia32_packuswb128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:4129:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_packus_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/emmintrin.h:4205:10: warning: TODO implement function '__builtin_ia32_pmovmskb128' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:4204:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_movemask_epi8(arg___a: __m128i) c_int;
pub inline fn _mm_unpackhi_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.child, @as(__v16qi, @bitCast(__a)), @as(__v16qi, @bitCast(__b)), @Vector(16, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(8, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 8), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(9, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 9), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(10, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 10), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(11, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 11), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(12, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 12), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(13, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 13), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(14, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 14), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(15, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 15), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpackhi_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.child, @as(__v8hi, @bitCast(__a)), @as(__v8hi, @bitCast(__b)), @Vector(8, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 4), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 5), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 6), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 7), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpackhi_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.child, @as(__v4si, @bitCast(__a)), @as(__v4si, @bitCast(__b)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 4) + @as(c_int, 2), @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 4) + @as(c_int, 3), @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpackhi_epi64(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.child, @as(__v2di, @bitCast(__a)), @as(__v2di, @bitCast(__b)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 2) + @as(c_int, 1), @typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpacklo_epi8(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.child, @as(__v16qi, @bitCast(__a)), @as(__v16qi, @bitCast(__b)), @Vector(16, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 0), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 1), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 2), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 3), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 4), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 5), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 6), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 16) + @as(c_int, 7), @typeInfo(@TypeOf(@as(__v16qi, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpacklo_epi16(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.child, @as(__v8hi, @bitCast(__a)), @as(__v8hi, @bitCast(__b)), @Vector(8, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 0), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 1), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 2), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 8) + @as(c_int, 3), @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpacklo_epi32(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.child, @as(__v4si, @bitCast(__a)), @as(__v4si, @bitCast(__b)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 4) + @as(c_int, 0), @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 4) + @as(c_int, 1), @typeInfo(@TypeOf(@as(__v4si, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_unpacklo_epi64(arg___a: __m128i, arg___b: __m128i) __m128i {
    var __a = arg___a;
    var __b = arg___b;
    return @as(__m128i, @bitCast(@shuffle(@typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.child, @as(__v2di, @bitCast(__a)), @as(__v2di, @bitCast(__b)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 2) + @as(c_int, 0), @typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.len),
    })));
}
pub inline fn _mm_movepi64_pi64(arg___a: __m128i) __m64 {
    var __a = arg___a;
    return @as(__m64, @bitCast(__a[@as(c_uint, @intCast(@as(c_int, 0)))]));
}
pub inline fn _mm_movpi64_epi64(arg___a: __m64) __m128i {
    var __a = arg___a;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(__a));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_longlong, @as(c_int, 0))));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_move_epi64(arg___a: __m128i) __m128i {
    var __a = arg___a;
    return @shuffle(@typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.child, @as(__v2di, @bitCast(__a)), _mm_setzero_si128(), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v2di, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_unpackhi_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @shuffle(@typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.child, @as(__v2df, @bitCast(__a)), @as(__v2df, @bitCast(__b)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 2) + @as(c_int, 1), @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_unpacklo_pd(arg___a: __m128d, arg___b: __m128d) __m128d {
    var __a = arg___a;
    var __b = arg___b;
    return @shuffle(@typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.child, @as(__v2df, @bitCast(__a)), @as(__v2df, @bitCast(__b)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(@as(c_int, 2) + @as(c_int, 0), @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
    });
} // /usr/lib/zig/include/emmintrin.h:4621:10: warning: TODO implement function '__builtin_ia32_movmskpd' in std.zig.c_builtins
// /usr/lib/zig/include/emmintrin.h:4620:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_movemask_pd(arg___a: __m128d) c_int;
pub inline fn _mm_castpd_ps(arg___a: __m128d) __m128 {
    var __a = arg___a;
    return @as(__m128, @bitCast(__a));
}
pub inline fn _mm_castpd_si128(arg___a: __m128d) __m128i {
    var __a = arg___a;
    return @as(__m128i, @bitCast(__a));
}
pub inline fn _mm_castps_pd(arg___a: __m128) __m128d {
    var __a = arg___a;
    return @as(__m128d, @bitCast(__a));
}
pub inline fn _mm_castps_si128(arg___a: __m128) __m128i {
    var __a = arg___a;
    return @as(__m128i, @bitCast(__a));
}
pub inline fn _mm_castsi128_ps(arg___a: __m128i) __m128 {
    var __a = arg___a;
    return @as(__m128, @bitCast(__a));
}
pub inline fn _mm_castsi128_pd(arg___a: __m128i) __m128d {
    var __a = arg___a;
    return @as(__m128d, @bitCast(__a));
}
pub extern fn _mm_pause() void; // /usr/lib/zig/include/pmmintrin.h:40:19: warning: TODO implement function '__builtin_ia32_lddqu' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:38:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_lddqu_si128(arg___p: [*c]const __m128i_u) __m128i; // /usr/lib/zig/include/pmmintrin.h:59:10: warning: TODO implement function '__builtin_ia32_addsubps' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:57:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_addsub_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/pmmintrin.h:82:10: warning: TODO implement function '__builtin_ia32_haddps' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:80:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadd_ps(arg___a: __m128, arg___b: __m128) __m128; // /usr/lib/zig/include/pmmintrin.h:105:10: warning: TODO implement function '__builtin_ia32_hsubps' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:103:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsub_ps(arg___a: __m128, arg___b: __m128) __m128;
pub inline fn _mm_movehdup_ps(arg___a: __m128) __m128 {
    var __a = arg___a;
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
}
pub inline fn _mm_moveldup_ps(arg___a: __m128) __m128 {
    var __a = arg___a;
    return @shuffle(@typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.child, @as(__v4sf, @bitCast(__a)), @as(__v4sf, @bitCast(__a)), @Vector(4, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v4sf, @bitCast(__a)))).Vector.len),
    });
} // /usr/lib/zig/include/pmmintrin.h:167:10: warning: TODO implement function '__builtin_ia32_addsubpd' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:165:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_addsub_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/pmmintrin.h:190:10: warning: TODO implement function '__builtin_ia32_haddpd' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:188:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadd_pd(arg___a: __m128d, arg___b: __m128d) __m128d; // /usr/lib/zig/include/pmmintrin.h:213:10: warning: TODO implement function '__builtin_ia32_hsubpd' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:211:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsub_pd(arg___a: __m128d, arg___b: __m128d) __m128d;
pub inline fn _mm_movedup_pd(arg___a: __m128d) __m128d {
    var __a = arg___a;
    return @shuffle(@typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.child, @as(__v2df, @bitCast(__a)), @as(__v2df, @bitCast(__a)), @Vector(2, i32){
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
        @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v2df, @bitCast(__a)))).Vector.len),
    });
} // /usr/lib/zig/include/pmmintrin.h:270:3: warning: TODO implement function '__builtin_ia32_monitor' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:268:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_monitor(arg___p: ?*const anyopaque, arg___extensions: c_uint, arg___hints: c_uint) void; // /usr/lib/zig/include/pmmintrin.h:289:3: warning: TODO implement function '__builtin_ia32_mwait' in std.zig.c_builtins
// /usr/lib/zig/include/pmmintrin.h:287:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_mwait(arg___extensions: c_uint, arg___hints: c_uint) void; // /usr/lib/zig/include/tmmintrin.h:38:19: warning: TODO implement function '__builtin_ia32_pabsb' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:36:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_abs_pi8(arg___a: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:56:21: warning: TODO implement function '__builtin_elementwise_abs' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:54:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_abs_epi8(arg___a: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:74:19: warning: TODO implement function '__builtin_ia32_pabsw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:72:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_abs_pi16(arg___a: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:92:21: warning: TODO implement function '__builtin_elementwise_abs' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:90:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_abs_epi16(arg___a: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:110:19: warning: TODO implement function '__builtin_ia32_pabsd' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:108:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_abs_pi32(arg___a: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:128:21: warning: TODO implement function '__builtin_elementwise_abs' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:126:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_abs_epi32(arg___a: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:197:21: warning: TODO implement function '__builtin_ia32_phaddw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:195:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadd_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:220:21: warning: TODO implement function '__builtin_ia32_phaddd128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:218:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadd_epi32(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:243:19: warning: TODO implement function '__builtin_ia32_phaddw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:241:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadd_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:266:19: warning: TODO implement function '__builtin_ia32_phaddd' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:264:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadd_pi32(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:291:21: warning: TODO implement function '__builtin_ia32_phaddsw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:289:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadds_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:316:19: warning: TODO implement function '__builtin_ia32_phaddsw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:314:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hadds_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:339:21: warning: TODO implement function '__builtin_ia32_phsubw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:337:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsub_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:362:21: warning: TODO implement function '__builtin_ia32_phsubd128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:360:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsub_epi32(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:385:19: warning: TODO implement function '__builtin_ia32_phsubw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:383:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsub_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:408:19: warning: TODO implement function '__builtin_ia32_phsubd' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:406:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsub_pi32(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:433:21: warning: TODO implement function '__builtin_ia32_phsubsw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:431:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsubs_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:458:19: warning: TODO implement function '__builtin_ia32_phsubsw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:456:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_hsubs_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:492:21: warning: TODO implement function '__builtin_ia32_pmaddubsw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:490:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_maddubs_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:522:19: warning: TODO implement function '__builtin_ia32_pmaddubsw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:520:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_maddubs_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:542:21: warning: TODO implement function '__builtin_ia32_pmulhrsw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:540:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_mulhrs_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:562:19: warning: TODO implement function '__builtin_ia32_pmulhrsw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:560:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_mulhrs_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:588:21: warning: TODO implement function '__builtin_ia32_pshufb128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:586:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_shuffle_epi8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:613:19: warning: TODO implement function '__builtin_ia32_pshufb' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:611:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_shuffle_pi8(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:639:21: warning: TODO implement function '__builtin_ia32_psignb128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:637:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sign_epi8(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:665:21: warning: TODO implement function '__builtin_ia32_psignw128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:663:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sign_epi16(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:691:21: warning: TODO implement function '__builtin_ia32_psignd128' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:689:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sign_epi32(arg___a: __m128i, arg___b: __m128i) __m128i; // /usr/lib/zig/include/tmmintrin.h:717:19: warning: TODO implement function '__builtin_ia32_psignb' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:715:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sign_pi8(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:743:19: warning: TODO implement function '__builtin_ia32_psignw' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:741:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sign_pi16(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/tmmintrin.h:769:19: warning: TODO implement function '__builtin_ia32_psignd' in std.zig.c_builtins
// /usr/lib/zig/include/tmmintrin.h:767:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_sign_pi32(arg___a: __m64, arg___b: __m64) __m64; // /usr/lib/zig/include/smmintrin.h:439:19: warning: TODO implement function '__builtin_ia32_blendvpd' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:436:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_blendv_pd(arg___V1: __m128d, arg___V2: __m128d, arg___M: __m128d) __m128d; // /usr/lib/zig/include/smmintrin.h:466:18: warning: TODO implement function '__builtin_ia32_blendvps' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:463:45: warning: unable to translate function, demoted to extern
pub extern fn _mm_blendv_ps(arg___V1: __m128, arg___V2: __m128, arg___M: __m128) __m128; // /usr/lib/zig/include/smmintrin.h:493:19: warning: TODO implement function '__builtin_ia32_pblendvb128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:490:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_blendv_epi8(arg___V1: __m128i, arg___V2: __m128i, arg___M: __m128i) __m128i;
pub inline fn _mm_mullo_epi32(arg___V1: __m128i, arg___V2: __m128i) __m128i {
    var __V1 = arg___V1;
    var __V2 = arg___V2;
    return @as(__m128i, @bitCast(@as(__v4su, @bitCast(__V1)) * @as(__v4su, @bitCast(__V2))));
} // /usr/lib/zig/include/smmintrin.h:560:19: warning: TODO implement function '__builtin_ia32_pmuldq128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:558:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_mul_epi32(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:649:19: warning: TODO implement function '__builtin_nontemporal_load' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:648:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_stream_load_si128(arg___V: [*c]const __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:668:19: warning: TODO implement function '__builtin_elementwise_min' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:666:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_epi8(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:686:19: warning: TODO implement function '__builtin_elementwise_max' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:684:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_epi8(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:704:19: warning: TODO implement function '__builtin_elementwise_min' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:702:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_epu16(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:722:19: warning: TODO implement function '__builtin_elementwise_max' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:720:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_epu16(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:740:19: warning: TODO implement function '__builtin_elementwise_min' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:738:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_epi32(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:758:19: warning: TODO implement function '__builtin_elementwise_max' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:756:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_epi32(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:776:19: warning: TODO implement function '__builtin_elementwise_min' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:774:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_min_epu32(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:794:19: warning: TODO implement function '__builtin_elementwise_max' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:792:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_max_epu32(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:1095:10: warning: TODO implement function '__builtin_ia32_ptestz128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:1093:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_testz_si128(arg___M: __m128i, arg___V: __m128i) c_int; // /usr/lib/zig/include/smmintrin.h:1112:10: warning: TODO implement function '__builtin_ia32_ptestc128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:1110:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_testc_si128(arg___M: __m128i, arg___V: __m128i) c_int; // /usr/lib/zig/include/smmintrin.h:1130:10: warning: TODO implement function '__builtin_ia32_ptestnzc128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:1128:42: warning: unable to translate function, demoted to extern
pub extern fn _mm_testnzc_si128(arg___M: __m128i, arg___V: __m128i) c_int;
pub inline fn _mm_cmpeq_epi64(arg___V1: __m128i, arg___V2: __m128i) __m128i {
    var __V1 = arg___V1;
    var __V2 = arg___V2;
    return @as(__m128i, @bitCast(@as(__v2di, @bitCast(__V1)) == @as(__v2di, @bitCast(__V2))));
}
pub inline fn _mm_cvtepi8_epi16(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[1])));
        const tmp_2 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[2])));
        const tmp_3 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[3])));
        const tmp_4 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[4])));
        const tmp_5 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[5])));
        const tmp_6 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[6])));
        const tmp_7 = @as(c_short, @bitCast(@as(c_short, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[7])));
        break :blk __v8hi{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
            tmp_4,
            tmp_5,
            tmp_6,
            tmp_7,
        };
    }));
}
pub inline fn _mm_cvtepi8_epi32(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[1])));
        const tmp_2 = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[2])));
        const tmp_3 = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[3])));
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_cvtepi8_epi64(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(@as(c_longlong, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_longlong, @shuffle(@typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.child, @as(__v16qs, @bitCast(__V)), @as(__v16qs, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qs, @bitCast(__V)))).Vector.len),
        })[1])));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtepi16_epi32(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.child, @as(__v8hi, @bitCast(__V)), @as(__v8hi, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.child, @as(__v8hi, @bitCast(__V)), @as(__v8hi, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
        })[1])));
        const tmp_2 = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.child, @as(__v8hi, @bitCast(__V)), @as(__v8hi, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
        })[2])));
        const tmp_3 = @as(c_int, @bitCast(@as(c_int, @shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.child, @as(__v8hi, @bitCast(__V)), @as(__v8hi, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
        })[3])));
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_cvtepi16_epi64(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(@as(c_longlong, @shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.child, @as(__v8hi, @bitCast(__V)), @as(__v8hi, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_longlong, @shuffle(@typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.child, @as(__v8hi, @bitCast(__V)), @as(__v8hi, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hi, @bitCast(__V)))).Vector.len),
        })[1])));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtepi32_epi64(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(@as(c_longlong, @shuffle(@typeInfo(@TypeOf(@as(__v4si, @bitCast(__V)))).Vector.child, @as(__v4si, @bitCast(__V)), @as(__v4si, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_longlong, @shuffle(@typeInfo(@TypeOf(@as(__v4si, @bitCast(__V)))).Vector.child, @as(__v4si, @bitCast(__V)), @as(__v4si, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4si, @bitCast(__V)))).Vector.len),
        })[1])));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtepu8_epi16(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[1])));
        const tmp_2 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[2])));
        const tmp_3 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[3])));
        const tmp_4 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[4])));
        const tmp_5 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[5])));
        const tmp_6 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[6])));
        const tmp_7 = @as(c_short, @bitCast(@as(c_ushort, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(8, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(4, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(5, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(6, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(7, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[7])));
        break :blk __v8hi{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
            tmp_4,
            tmp_5,
            tmp_6,
            tmp_7,
        };
    }));
}
pub inline fn _mm_cvtepu8_epi32(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[1])));
        const tmp_2 = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[2])));
        const tmp_3 = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[3])));
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_cvtepu8_epi64(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(@as(c_ulonglong, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_ulonglong, @shuffle(@typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.child, @as(__v16qu, @bitCast(__V)), @as(__v16qu, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v16qu, @bitCast(__V)))).Vector.len),
        })[1])));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtepu16_epi32(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.child, @as(__v8hu, @bitCast(__V)), @as(__v8hu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.child, @as(__v8hu, @bitCast(__V)), @as(__v8hu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
        })[1])));
        const tmp_2 = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.child, @as(__v8hu, @bitCast(__V)), @as(__v8hu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
        })[2])));
        const tmp_3 = @as(c_int, @bitCast(@as(c_uint, @shuffle(@typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.child, @as(__v8hu, @bitCast(__V)), @as(__v8hu, @bitCast(__V)), @Vector(4, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(2, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(3, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
        })[3])));
        break :blk __v4si{
            tmp,
            tmp_1,
            tmp_2,
            tmp_3,
        };
    }));
}
pub inline fn _mm_cvtepu16_epi64(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(@as(c_ulonglong, @shuffle(@typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.child, @as(__v8hu, @bitCast(__V)), @as(__v8hu, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_ulonglong, @shuffle(@typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.child, @as(__v8hu, @bitCast(__V)), @as(__v8hu, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v8hu, @bitCast(__V)))).Vector.len),
        })[1])));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
}
pub inline fn _mm_cvtepu32_epi64(arg___V: __m128i) __m128i {
    var __V = arg___V;
    return @as(__m128i, @bitCast(blk: {
        const tmp = @as(c_longlong, @bitCast(@as(c_ulonglong, @shuffle(@typeInfo(@TypeOf(@as(__v4su, @bitCast(__V)))).Vector.child, @as(__v4su, @bitCast(__V)), @as(__v4su, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4su, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4su, @bitCast(__V)))).Vector.len),
        })[0])));
        const tmp_1 = @as(c_longlong, @bitCast(@as(c_ulonglong, @shuffle(@typeInfo(@TypeOf(@as(__v4su, @bitCast(__V)))).Vector.child, @as(__v4su, @bitCast(__V)), @as(__v4su, @bitCast(__V)), @Vector(2, i32){
            @import("std").zig.c_translation.shuffleVectorIndex(0, @typeInfo(@TypeOf(@as(__v4su, @bitCast(__V)))).Vector.len),
            @import("std").zig.c_translation.shuffleVectorIndex(1, @typeInfo(@TypeOf(@as(__v4su, @bitCast(__V)))).Vector.len),
        })[1])));
        break :blk __v2di{
            tmp,
            tmp_1,
        };
    }));
} // /usr/lib/zig/include/smmintrin.h:1458:19: warning: TODO implement function '__builtin_ia32_packusdw128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:1456:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_packus_epi32(arg___V1: __m128i, arg___V2: __m128i) __m128i; // /usr/lib/zig/include/smmintrin.h:1515:19: warning: TODO implement function '__builtin_ia32_phminposuw128' in std.zig.c_builtins
// /usr/lib/zig/include/smmintrin.h:1514:46: warning: unable to translate function, demoted to extern
pub extern fn _mm_minpos_epu16(arg___V: __m128i) __m128i;
pub inline fn _mm_cmpgt_epi64(arg___V1: __m128i, arg___V2: __m128i) __m128i {
    var __V1 = arg___V1;
    var __V2 = arg___V2;
    return @as(__m128i, @bitCast(@as(__v2di, @bitCast(__V1)) > @as(__v2di, @bitCast(__V2))));
}
pub inline fn _mm_popcnt_u32(arg___A: c_uint) c_int {
    var __A = arg___A;
    return __builtin_popcount(__A);
} // /usr/lib/zig/include/popcntintrin.h:52:10: warning: TODO implement function '__builtin_popcountll' in std.zig.c_builtins
// /usr/lib/zig/include/popcntintrin.h:50:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_popcnt_u64(arg___A: c_ulonglong) c_longlong; // /usr/lib/zig/include/crc32intrin.h:33:10: warning: TODO implement function '__builtin_ia32_crc32qi' in std.zig.c_builtins
// /usr/lib/zig/include/crc32intrin.h:31:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_crc32_u8(arg___C: c_uint, arg___D: u8) c_uint; // /usr/lib/zig/include/crc32intrin.h:53:10: warning: TODO implement function '__builtin_ia32_crc32hi' in std.zig.c_builtins
// /usr/lib/zig/include/crc32intrin.h:51:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_crc32_u16(arg___C: c_uint, arg___D: c_ushort) c_uint; // /usr/lib/zig/include/crc32intrin.h:73:10: warning: TODO implement function '__builtin_ia32_crc32si' in std.zig.c_builtins
// /usr/lib/zig/include/crc32intrin.h:71:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_crc32_u32(arg___C: c_uint, arg___D: c_uint) c_uint; // /usr/lib/zig/include/crc32intrin.h:94:10: warning: TODO implement function '__builtin_ia32_crc32di' in std.zig.c_builtins
// /usr/lib/zig/include/crc32intrin.h:92:1: warning: unable to translate function, demoted to extern
pub extern fn _mm_crc32_u64(arg___C: c_ulonglong, arg___D: c_ulonglong) c_ulonglong;
pub const graphene_simd4f_t = __m128;
pub const graphene_simd4x4f_t = extern struct {
    x: graphene_simd4f_t,
    y: graphene_simd4f_t,
    z: graphene_simd4f_t,
    w: graphene_simd4f_t,
};
pub const struct__graphene_vec2_t = extern struct {
    __graphene_private_value: graphene_simd4f_t align(16),
};
pub const graphene_vec2_t = struct__graphene_vec2_t;
pub const struct__graphene_vec3_t = extern struct {
    __graphene_private_value: graphene_simd4f_t align(16),
};
pub const graphene_vec3_t = struct__graphene_vec3_t;
pub const struct__graphene_vec4_t = extern struct {
    __graphene_private_value: graphene_simd4f_t align(16),
};
pub const graphene_vec4_t = struct__graphene_vec4_t;
pub const struct__graphene_matrix_t = extern struct {
    __graphene_private_value: graphene_simd4x4f_t align(16),
};
pub const graphene_matrix_t = struct__graphene_matrix_t;
pub const struct__graphene_point_t = extern struct {
    x: f32,
    y: f32,
};
pub const graphene_point_t = struct__graphene_point_t;
pub const struct__graphene_size_t = extern struct {
    width: f32,
    height: f32,
};
pub const graphene_size_t = struct__graphene_size_t;
pub const struct__graphene_rect_t = extern struct {
    origin: graphene_point_t,
    size: graphene_size_t,
};
pub const graphene_rect_t = struct__graphene_rect_t;
pub const struct__graphene_point3d_t = extern struct {
    x: f32,
    y: f32,
    z: f32,
};
pub const graphene_point3d_t = struct__graphene_point3d_t;
pub const struct__graphene_quad_t = extern struct {
    __graphene_private_points: [4]graphene_point_t,
};
pub const graphene_quad_t = struct__graphene_quad_t;
pub const struct__graphene_quaternion_t = extern struct {
    __graphene_private_x: f32,
    __graphene_private_y: f32,
    __graphene_private_z: f32,
    __graphene_private_w: f32,
};
pub const graphene_quaternion_t = struct__graphene_quaternion_t;
pub const struct__graphene_euler_t = extern struct {
    __graphene_private_angles: graphene_vec3_t,
    __graphene_private_order: graphene_euler_order_t,
};
pub const graphene_euler_t = struct__graphene_euler_t;
pub const struct__graphene_plane_t = extern struct {
    __graphene_private_normal: graphene_vec3_t,
    __graphene_private_constant: f32,
};
pub const graphene_plane_t = struct__graphene_plane_t;
pub const struct__graphene_frustum_t = extern struct {
    __graphene_private_planes: [6]graphene_plane_t,
};
pub const graphene_frustum_t = struct__graphene_frustum_t;
pub const struct__graphene_sphere_t = extern struct {
    __graphene_private_center: graphene_vec3_t,
    __graphene_private_radius: f32,
};
pub const graphene_sphere_t = struct__graphene_sphere_t;
pub const struct__graphene_box_t = extern struct {
    __graphene_private_min: graphene_vec3_t,
    __graphene_private_max: graphene_vec3_t,
};
pub const graphene_box_t = struct__graphene_box_t;
pub const struct__graphene_triangle_t = extern struct {
    __graphene_private_a: graphene_vec3_t,
    __graphene_private_b: graphene_vec3_t,
    __graphene_private_c: graphene_vec3_t,
};
pub const graphene_triangle_t = struct__graphene_triangle_t;
pub const struct__graphene_ray_t = extern struct {
    __graphene_private_origin: graphene_vec3_t,
    __graphene_private_direction: graphene_vec3_t,
};
pub const graphene_ray_t = struct__graphene_ray_t;
pub const float_t = f32;
pub const double_t = f64;
pub extern fn __fpclassify(__value: f64) c_int;
pub extern fn __signbit(__value: f64) c_int;
pub extern fn __isinf(__value: f64) c_int;
pub extern fn __finite(__value: f64) c_int;
pub extern fn __isnan(__value: f64) c_int;
pub extern fn __iseqsig(__x: f64, __y: f64) c_int;
pub extern fn __issignaling(__value: f64) c_int;
pub extern fn acos(__x: f64) f64;
pub extern fn __acos(__x: f64) f64;
pub extern fn asin(__x: f64) f64;
pub extern fn __asin(__x: f64) f64;
pub extern fn atan(__x: f64) f64;
pub extern fn __atan(__x: f64) f64;
pub extern fn atan2(__y: f64, __x: f64) f64;
pub extern fn __atan2(__y: f64, __x: f64) f64;
pub extern fn cos(__x: f64) f64;
pub extern fn __cos(__x: f64) f64;
pub extern fn sin(__x: f64) f64;
pub extern fn __sin(__x: f64) f64;
pub extern fn tan(__x: f64) f64;
pub extern fn __tan(__x: f64) f64;
pub extern fn cosh(__x: f64) f64;
pub extern fn __cosh(__x: f64) f64;
pub extern fn sinh(__x: f64) f64;
pub extern fn __sinh(__x: f64) f64;
pub extern fn tanh(__x: f64) f64;
pub extern fn __tanh(__x: f64) f64;
pub extern fn acosh(__x: f64) f64;
pub extern fn __acosh(__x: f64) f64;
pub extern fn asinh(__x: f64) f64;
pub extern fn __asinh(__x: f64) f64;
pub extern fn atanh(__x: f64) f64;
pub extern fn __atanh(__x: f64) f64;
pub extern fn exp(__x: f64) f64;
pub extern fn __exp(__x: f64) f64;
pub extern fn frexp(__x: f64, __exponent: [*c]c_int) f64;
pub extern fn __frexp(__x: f64, __exponent: [*c]c_int) f64;
pub extern fn ldexp(__x: f64, __exponent: c_int) f64;
pub extern fn __ldexp(__x: f64, __exponent: c_int) f64;
pub extern fn log(__x: f64) f64;
pub extern fn __log(__x: f64) f64;
pub extern fn log10(__x: f64) f64;
pub extern fn __log10(__x: f64) f64;
pub extern fn modf(__x: f64, __iptr: [*c]f64) f64;
pub extern fn __modf(__x: f64, __iptr: [*c]f64) f64;
pub extern fn expm1(__x: f64) f64;
pub extern fn __expm1(__x: f64) f64;
pub extern fn log1p(__x: f64) f64;
pub extern fn __log1p(__x: f64) f64;
pub extern fn logb(__x: f64) f64;
pub extern fn __logb(__x: f64) f64;
pub extern fn exp2(__x: f64) f64;
pub extern fn __exp2(__x: f64) f64;
pub extern fn log2(__x: f64) f64;
pub extern fn __log2(__x: f64) f64;
pub extern fn pow(__x: f64, __y: f64) f64;
pub extern fn __pow(__x: f64, __y: f64) f64;
pub extern fn sqrt(__x: f64) f64;
pub extern fn __sqrt(__x: f64) f64;
pub extern fn hypot(__x: f64, __y: f64) f64;
pub extern fn __hypot(__x: f64, __y: f64) f64;
pub extern fn cbrt(__x: f64) f64;
pub extern fn __cbrt(__x: f64) f64;
pub extern fn ceil(__x: f64) f64;
pub extern fn __ceil(__x: f64) f64;
pub extern fn fabs(__x: f64) f64;
pub extern fn __fabs(__x: f64) f64;
pub extern fn floor(__x: f64) f64;
pub extern fn __floor(__x: f64) f64;
pub extern fn fmod(__x: f64, __y: f64) f64;
pub extern fn __fmod(__x: f64, __y: f64) f64;
pub extern fn isinf(__value: f64) c_int;
pub extern fn finite(__value: f64) c_int;
pub extern fn drem(__x: f64, __y: f64) f64;
pub extern fn __drem(__x: f64, __y: f64) f64;
pub extern fn significand(__x: f64) f64;
pub extern fn __significand(__x: f64) f64;
pub extern fn copysign(__x: f64, __y: f64) f64;
pub extern fn __copysign(__x: f64, __y: f64) f64;
pub extern fn nan(__tagb: [*c]const u8) f64;
pub extern fn __nan(__tagb: [*c]const u8) f64;
pub extern fn isnan(__value: f64) c_int;
pub extern fn j0(f64) f64;
pub extern fn __j0(f64) f64;
pub extern fn j1(f64) f64;
pub extern fn __j1(f64) f64;
pub extern fn jn(c_int, f64) f64;
pub extern fn __jn(c_int, f64) f64;
pub extern fn y0(f64) f64;
pub extern fn __y0(f64) f64;
pub extern fn y1(f64) f64;
pub extern fn __y1(f64) f64;
pub extern fn yn(c_int, f64) f64;
pub extern fn __yn(c_int, f64) f64;
pub extern fn erf(f64) f64;
pub extern fn __erf(f64) f64;
pub extern fn erfc(f64) f64;
pub extern fn __erfc(f64) f64;
pub extern fn lgamma(f64) f64;
pub extern fn __lgamma(f64) f64;
pub extern fn tgamma(f64) f64;
pub extern fn __tgamma(f64) f64;
pub extern fn gamma(f64) f64;
pub extern fn __gamma(f64) f64;
pub extern fn lgamma_r(f64, __signgamp: [*c]c_int) f64;
pub extern fn __lgamma_r(f64, __signgamp: [*c]c_int) f64;
pub extern fn rint(__x: f64) f64;
pub extern fn __rint(__x: f64) f64;
pub extern fn nextafter(__x: f64, __y: f64) f64;
pub extern fn __nextafter(__x: f64, __y: f64) f64;
pub extern fn nexttoward(__x: f64, __y: c_longdouble) f64;
pub extern fn __nexttoward(__x: f64, __y: c_longdouble) f64;
pub extern fn remainder(__x: f64, __y: f64) f64;
pub extern fn __remainder(__x: f64, __y: f64) f64;
pub extern fn scalbn(__x: f64, __n: c_int) f64;
pub extern fn __scalbn(__x: f64, __n: c_int) f64;
pub extern fn ilogb(__x: f64) c_int;
pub extern fn __ilogb(__x: f64) c_int;
pub extern fn scalbln(__x: f64, __n: c_long) f64;
pub extern fn __scalbln(__x: f64, __n: c_long) f64;
pub extern fn nearbyint(__x: f64) f64;
pub extern fn __nearbyint(__x: f64) f64;
pub extern fn round(__x: f64) f64;
pub extern fn __round(__x: f64) f64;
pub extern fn trunc(__x: f64) f64;
pub extern fn __trunc(__x: f64) f64;
pub extern fn remquo(__x: f64, __y: f64, __quo: [*c]c_int) f64;
pub extern fn __remquo(__x: f64, __y: f64, __quo: [*c]c_int) f64;
pub extern fn lrint(__x: f64) c_long;
pub extern fn __lrint(__x: f64) c_long;
pub extern fn llrint(__x: f64) c_longlong;
pub extern fn __llrint(__x: f64) c_longlong;
pub extern fn lround(__x: f64) c_long;
pub extern fn __lround(__x: f64) c_long;
pub extern fn llround(__x: f64) c_longlong;
pub extern fn __llround(__x: f64) c_longlong;
pub extern fn fdim(__x: f64, __y: f64) f64;
pub extern fn __fdim(__x: f64, __y: f64) f64;
pub extern fn fmax(__x: f64, __y: f64) f64;
pub extern fn __fmax(__x: f64, __y: f64) f64;
pub extern fn fmin(__x: f64, __y: f64) f64;
pub extern fn __fmin(__x: f64, __y: f64) f64;
pub extern fn fma(__x: f64, __y: f64, __z: f64) f64;
pub extern fn __fma(__x: f64, __y: f64, __z: f64) f64;
pub extern fn scalb(__x: f64, __n: f64) f64;
pub extern fn __scalb(__x: f64, __n: f64) f64;
pub extern fn __fpclassifyf(__value: f32) c_int;
pub extern fn __signbitf(__value: f32) c_int;
pub extern fn __isinff(__value: f32) c_int;
pub extern fn __finitef(__value: f32) c_int;
pub extern fn __isnanf(__value: f32) c_int;
pub extern fn __iseqsigf(__x: f32, __y: f32) c_int;
pub extern fn __issignalingf(__value: f32) c_int;
pub extern fn acosf(__x: f32) f32;
pub extern fn __acosf(__x: f32) f32;
pub extern fn asinf(__x: f32) f32;
pub extern fn __asinf(__x: f32) f32;
pub extern fn atanf(__x: f32) f32;
pub extern fn __atanf(__x: f32) f32;
pub extern fn atan2f(__y: f32, __x: f32) f32;
pub extern fn __atan2f(__y: f32, __x: f32) f32;
pub extern fn cosf(__x: f32) f32;
pub extern fn __cosf(__x: f32) f32;
pub extern fn sinf(__x: f32) f32;
pub extern fn __sinf(__x: f32) f32;
pub extern fn tanf(__x: f32) f32;
pub extern fn __tanf(__x: f32) f32;
pub extern fn coshf(__x: f32) f32;
pub extern fn __coshf(__x: f32) f32;
pub extern fn sinhf(__x: f32) f32;
pub extern fn __sinhf(__x: f32) f32;
pub extern fn tanhf(__x: f32) f32;
pub extern fn __tanhf(__x: f32) f32;
pub extern fn acoshf(__x: f32) f32;
pub extern fn __acoshf(__x: f32) f32;
pub extern fn asinhf(__x: f32) f32;
pub extern fn __asinhf(__x: f32) f32;
pub extern fn atanhf(__x: f32) f32;
pub extern fn __atanhf(__x: f32) f32;
pub extern fn expf(__x: f32) f32;
pub extern fn __expf(__x: f32) f32;
pub extern fn frexpf(__x: f32, __exponent: [*c]c_int) f32;
pub extern fn __frexpf(__x: f32, __exponent: [*c]c_int) f32;
pub extern fn ldexpf(__x: f32, __exponent: c_int) f32;
pub extern fn __ldexpf(__x: f32, __exponent: c_int) f32;
pub extern fn logf(__x: f32) f32;
pub extern fn __logf(__x: f32) f32;
pub extern fn log10f(__x: f32) f32;
pub extern fn __log10f(__x: f32) f32;
pub extern fn modff(__x: f32, __iptr: [*c]f32) f32;
pub extern fn __modff(__x: f32, __iptr: [*c]f32) f32;
pub extern fn expm1f(__x: f32) f32;
pub extern fn __expm1f(__x: f32) f32;
pub extern fn log1pf(__x: f32) f32;
pub extern fn __log1pf(__x: f32) f32;
pub extern fn logbf(__x: f32) f32;
pub extern fn __logbf(__x: f32) f32;
pub extern fn exp2f(__x: f32) f32;
pub extern fn __exp2f(__x: f32) f32;
pub extern fn log2f(__x: f32) f32;
pub extern fn __log2f(__x: f32) f32;
pub extern fn powf(__x: f32, __y: f32) f32;
pub extern fn __powf(__x: f32, __y: f32) f32;
pub extern fn sqrtf(__x: f32) f32;
pub extern fn __sqrtf(__x: f32) f32;
pub extern fn hypotf(__x: f32, __y: f32) f32;
pub extern fn __hypotf(__x: f32, __y: f32) f32;
pub extern fn cbrtf(__x: f32) f32;
pub extern fn __cbrtf(__x: f32) f32;
pub extern fn ceilf(__x: f32) f32;
pub extern fn __ceilf(__x: f32) f32;
pub extern fn fabsf(__x: f32) f32;
pub extern fn __fabsf(__x: f32) f32;
pub extern fn floorf(__x: f32) f32;
pub extern fn __floorf(__x: f32) f32;
pub extern fn fmodf(__x: f32, __y: f32) f32;
pub extern fn __fmodf(__x: f32, __y: f32) f32;
pub extern fn isinff(__value: f32) c_int;
pub extern fn finitef(__value: f32) c_int;
pub extern fn dremf(__x: f32, __y: f32) f32;
pub extern fn __dremf(__x: f32, __y: f32) f32;
pub extern fn significandf(__x: f32) f32;
pub extern fn __significandf(__x: f32) f32;
pub extern fn copysignf(__x: f32, __y: f32) f32;
pub extern fn __copysignf(__x: f32, __y: f32) f32;
pub extern fn nanf(__tagb: [*c]const u8) f32;
pub extern fn __nanf(__tagb: [*c]const u8) f32;
pub extern fn isnanf(__value: f32) c_int;
pub extern fn j0f(f32) f32;
pub extern fn __j0f(f32) f32;
pub extern fn j1f(f32) f32;
pub extern fn __j1f(f32) f32;
pub extern fn jnf(c_int, f32) f32;
pub extern fn __jnf(c_int, f32) f32;
pub extern fn y0f(f32) f32;
pub extern fn __y0f(f32) f32;
pub extern fn y1f(f32) f32;
pub extern fn __y1f(f32) f32;
pub extern fn ynf(c_int, f32) f32;
pub extern fn __ynf(c_int, f32) f32;
pub extern fn erff(f32) f32;
pub extern fn __erff(f32) f32;
pub extern fn erfcf(f32) f32;
pub extern fn __erfcf(f32) f32;
pub extern fn lgammaf(f32) f32;
pub extern fn __lgammaf(f32) f32;
pub extern fn tgammaf(f32) f32;
pub extern fn __tgammaf(f32) f32;
pub extern fn gammaf(f32) f32;
pub extern fn __gammaf(f32) f32;
pub extern fn lgammaf_r(f32, __signgamp: [*c]c_int) f32;
pub extern fn __lgammaf_r(f32, __signgamp: [*c]c_int) f32;
pub extern fn rintf(__x: f32) f32;
pub extern fn __rintf(__x: f32) f32;
pub extern fn nextafterf(__x: f32, __y: f32) f32;
pub extern fn __nextafterf(__x: f32, __y: f32) f32;
pub extern fn nexttowardf(__x: f32, __y: c_longdouble) f32;
pub extern fn __nexttowardf(__x: f32, __y: c_longdouble) f32;
pub extern fn remainderf(__x: f32, __y: f32) f32;
pub extern fn __remainderf(__x: f32, __y: f32) f32;
pub extern fn scalbnf(__x: f32, __n: c_int) f32;
pub extern fn __scalbnf(__x: f32, __n: c_int) f32;
pub extern fn ilogbf(__x: f32) c_int;
pub extern fn __ilogbf(__x: f32) c_int;
pub extern fn scalblnf(__x: f32, __n: c_long) f32;
pub extern fn __scalblnf(__x: f32, __n: c_long) f32;
pub extern fn nearbyintf(__x: f32) f32;
pub extern fn __nearbyintf(__x: f32) f32;
pub extern fn roundf(__x: f32) f32;
pub extern fn __roundf(__x: f32) f32;
pub extern fn truncf(__x: f32) f32;
pub extern fn __truncf(__x: f32) f32;
pub extern fn remquof(__x: f32, __y: f32, __quo: [*c]c_int) f32;
pub extern fn __remquof(__x: f32, __y: f32, __quo: [*c]c_int) f32;
pub extern fn lrintf(__x: f32) c_long;
pub extern fn __lrintf(__x: f32) c_long;
pub extern fn llrintf(__x: f32) c_longlong;
pub extern fn __llrintf(__x: f32) c_longlong;
pub extern fn lroundf(__x: f32) c_long;
pub extern fn __lroundf(__x: f32) c_long;
pub extern fn llroundf(__x: f32) c_longlong;
pub extern fn __llroundf(__x: f32) c_longlong;
pub extern fn fdimf(__x: f32, __y: f32) f32;
pub extern fn __fdimf(__x: f32, __y: f32) f32;
pub extern fn fmaxf(__x: f32, __y: f32) f32;
pub extern fn __fmaxf(__x: f32, __y: f32) f32;
pub extern fn fminf(__x: f32, __y: f32) f32;
pub extern fn __fminf(__x: f32, __y: f32) f32;
pub extern fn fmaf(__x: f32, __y: f32, __z: f32) f32;
pub extern fn __fmaf(__x: f32, __y: f32, __z: f32) f32;
pub extern fn scalbf(__x: f32, __n: f32) f32;
pub extern fn __scalbf(__x: f32, __n: f32) f32;
pub extern fn __fpclassifyl(__value: c_longdouble) c_int;
pub extern fn __signbitl(__value: c_longdouble) c_int;
pub extern fn __isinfl(__value: c_longdouble) c_int;
pub extern fn __finitel(__value: c_longdouble) c_int;
pub extern fn __isnanl(__value: c_longdouble) c_int;
pub extern fn __iseqsigl(__x: c_longdouble, __y: c_longdouble) c_int;
pub extern fn __issignalingl(__value: c_longdouble) c_int;
pub extern fn acosl(__x: c_longdouble) c_longdouble;
pub extern fn __acosl(__x: c_longdouble) c_longdouble;
pub extern fn asinl(__x: c_longdouble) c_longdouble;
pub extern fn __asinl(__x: c_longdouble) c_longdouble;
pub extern fn atanl(__x: c_longdouble) c_longdouble;
pub extern fn __atanl(__x: c_longdouble) c_longdouble;
pub extern fn atan2l(__y: c_longdouble, __x: c_longdouble) c_longdouble;
pub extern fn __atan2l(__y: c_longdouble, __x: c_longdouble) c_longdouble;
pub extern fn cosl(__x: c_longdouble) c_longdouble;
pub extern fn __cosl(__x: c_longdouble) c_longdouble;
pub extern fn sinl(__x: c_longdouble) c_longdouble;
pub extern fn __sinl(__x: c_longdouble) c_longdouble;
pub extern fn tanl(__x: c_longdouble) c_longdouble;
pub extern fn __tanl(__x: c_longdouble) c_longdouble;
pub extern fn coshl(__x: c_longdouble) c_longdouble;
pub extern fn __coshl(__x: c_longdouble) c_longdouble;
pub extern fn sinhl(__x: c_longdouble) c_longdouble;
pub extern fn __sinhl(__x: c_longdouble) c_longdouble;
pub extern fn tanhl(__x: c_longdouble) c_longdouble;
pub extern fn __tanhl(__x: c_longdouble) c_longdouble;
pub extern fn acoshl(__x: c_longdouble) c_longdouble;
pub extern fn __acoshl(__x: c_longdouble) c_longdouble;
pub extern fn asinhl(__x: c_longdouble) c_longdouble;
pub extern fn __asinhl(__x: c_longdouble) c_longdouble;
pub extern fn atanhl(__x: c_longdouble) c_longdouble;
pub extern fn __atanhl(__x: c_longdouble) c_longdouble;
pub extern fn expl(__x: c_longdouble) c_longdouble;
pub extern fn __expl(__x: c_longdouble) c_longdouble;
pub extern fn frexpl(__x: c_longdouble, __exponent: [*c]c_int) c_longdouble;
pub extern fn __frexpl(__x: c_longdouble, __exponent: [*c]c_int) c_longdouble;
pub extern fn ldexpl(__x: c_longdouble, __exponent: c_int) c_longdouble;
pub extern fn __ldexpl(__x: c_longdouble, __exponent: c_int) c_longdouble;
pub extern fn logl(__x: c_longdouble) c_longdouble;
pub extern fn __logl(__x: c_longdouble) c_longdouble;
pub extern fn log10l(__x: c_longdouble) c_longdouble;
pub extern fn __log10l(__x: c_longdouble) c_longdouble;
pub extern fn modfl(__x: c_longdouble, __iptr: [*c]c_longdouble) c_longdouble;
pub extern fn __modfl(__x: c_longdouble, __iptr: [*c]c_longdouble) c_longdouble;
pub extern fn expm1l(__x: c_longdouble) c_longdouble;
pub extern fn __expm1l(__x: c_longdouble) c_longdouble;
pub extern fn log1pl(__x: c_longdouble) c_longdouble;
pub extern fn __log1pl(__x: c_longdouble) c_longdouble;
pub extern fn logbl(__x: c_longdouble) c_longdouble;
pub extern fn __logbl(__x: c_longdouble) c_longdouble;
pub extern fn exp2l(__x: c_longdouble) c_longdouble;
pub extern fn __exp2l(__x: c_longdouble) c_longdouble;
pub extern fn log2l(__x: c_longdouble) c_longdouble;
pub extern fn __log2l(__x: c_longdouble) c_longdouble;
pub extern fn powl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __powl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn sqrtl(__x: c_longdouble) c_longdouble;
pub extern fn __sqrtl(__x: c_longdouble) c_longdouble;
pub extern fn hypotl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __hypotl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn cbrtl(__x: c_longdouble) c_longdouble;
pub extern fn __cbrtl(__x: c_longdouble) c_longdouble;
pub extern fn ceill(__x: c_longdouble) c_longdouble;
pub extern fn __ceill(__x: c_longdouble) c_longdouble;
pub extern fn fabsl(__x: c_longdouble) c_longdouble;
pub extern fn __fabsl(__x: c_longdouble) c_longdouble;
pub extern fn floorl(__x: c_longdouble) c_longdouble;
pub extern fn __floorl(__x: c_longdouble) c_longdouble;
pub extern fn fmodl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fmodl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn isinfl(__value: c_longdouble) c_int;
pub extern fn finitel(__value: c_longdouble) c_int;
pub extern fn dreml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __dreml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn significandl(__x: c_longdouble) c_longdouble;
pub extern fn __significandl(__x: c_longdouble) c_longdouble;
pub extern fn copysignl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __copysignl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn nanl(__tagb: [*c]const u8) c_longdouble;
pub extern fn __nanl(__tagb: [*c]const u8) c_longdouble;
pub extern fn isnanl(__value: c_longdouble) c_int;
pub extern fn j0l(c_longdouble) c_longdouble;
pub extern fn __j0l(c_longdouble) c_longdouble;
pub extern fn j1l(c_longdouble) c_longdouble;
pub extern fn __j1l(c_longdouble) c_longdouble;
pub extern fn jnl(c_int, c_longdouble) c_longdouble;
pub extern fn __jnl(c_int, c_longdouble) c_longdouble;
pub extern fn y0l(c_longdouble) c_longdouble;
pub extern fn __y0l(c_longdouble) c_longdouble;
pub extern fn y1l(c_longdouble) c_longdouble;
pub extern fn __y1l(c_longdouble) c_longdouble;
pub extern fn ynl(c_int, c_longdouble) c_longdouble;
pub extern fn __ynl(c_int, c_longdouble) c_longdouble;
pub extern fn erfl(c_longdouble) c_longdouble;
pub extern fn __erfl(c_longdouble) c_longdouble;
pub extern fn erfcl(c_longdouble) c_longdouble;
pub extern fn __erfcl(c_longdouble) c_longdouble;
pub extern fn lgammal(c_longdouble) c_longdouble;
pub extern fn __lgammal(c_longdouble) c_longdouble;
pub extern fn tgammal(c_longdouble) c_longdouble;
pub extern fn __tgammal(c_longdouble) c_longdouble;
pub extern fn gammal(c_longdouble) c_longdouble;
pub extern fn __gammal(c_longdouble) c_longdouble;
pub extern fn lgammal_r(c_longdouble, __signgamp: [*c]c_int) c_longdouble;
pub extern fn __lgammal_r(c_longdouble, __signgamp: [*c]c_int) c_longdouble;
pub extern fn rintl(__x: c_longdouble) c_longdouble;
pub extern fn __rintl(__x: c_longdouble) c_longdouble;
pub extern fn nextafterl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __nextafterl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn nexttowardl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __nexttowardl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn remainderl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __remainderl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn scalbnl(__x: c_longdouble, __n: c_int) c_longdouble;
pub extern fn __scalbnl(__x: c_longdouble, __n: c_int) c_longdouble;
pub extern fn ilogbl(__x: c_longdouble) c_int;
pub extern fn __ilogbl(__x: c_longdouble) c_int;
pub extern fn scalblnl(__x: c_longdouble, __n: c_long) c_longdouble;
pub extern fn __scalblnl(__x: c_longdouble, __n: c_long) c_longdouble;
pub extern fn nearbyintl(__x: c_longdouble) c_longdouble;
pub extern fn __nearbyintl(__x: c_longdouble) c_longdouble;
pub extern fn roundl(__x: c_longdouble) c_longdouble;
pub extern fn __roundl(__x: c_longdouble) c_longdouble;
pub extern fn truncl(__x: c_longdouble) c_longdouble;
pub extern fn __truncl(__x: c_longdouble) c_longdouble;
pub extern fn remquol(__x: c_longdouble, __y: c_longdouble, __quo: [*c]c_int) c_longdouble;
pub extern fn __remquol(__x: c_longdouble, __y: c_longdouble, __quo: [*c]c_int) c_longdouble;
pub extern fn lrintl(__x: c_longdouble) c_long;
pub extern fn __lrintl(__x: c_longdouble) c_long;
pub extern fn llrintl(__x: c_longdouble) c_longlong;
pub extern fn __llrintl(__x: c_longdouble) c_longlong;
pub extern fn lroundl(__x: c_longdouble) c_long;
pub extern fn __lroundl(__x: c_longdouble) c_long;
pub extern fn llroundl(__x: c_longdouble) c_longlong;
pub extern fn __llroundl(__x: c_longdouble) c_longlong;
pub extern fn fdiml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fdiml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn fmaxl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fmaxl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn fminl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fminl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn fmal(__x: c_longdouble, __y: c_longdouble, __z: c_longdouble) c_longdouble;
pub extern fn __fmal(__x: c_longdouble, __y: c_longdouble, __z: c_longdouble) c_longdouble;
pub extern fn scalbl(__x: c_longdouble, __n: c_longdouble) c_longdouble;
pub extern fn __scalbl(__x: c_longdouble, __n: c_longdouble) c_longdouble;
pub extern var signgam: c_int;
pub const FP_NAN: c_int = 0;
pub const FP_INFINITE: c_int = 1;
pub const FP_ZERO: c_int = 2;
pub const FP_SUBNORMAL: c_int = 3;
pub const FP_NORMAL: c_int = 4;
const enum_unnamed_51 = c_uint;
pub extern fn graphene_simd4f_init(x: f32, y: f32, z: f32, w: f32) graphene_simd4f_t;
pub extern fn graphene_simd4f_init_zero() graphene_simd4f_t;
pub extern fn graphene_simd4f_init_4f(v: [*c]const f32) graphene_simd4f_t;
pub extern fn graphene_simd4f_init_3f(v: [*c]const f32) graphene_simd4f_t;
pub extern fn graphene_simd4f_init_2f(v: [*c]const f32) graphene_simd4f_t;
pub extern fn graphene_simd4f_dup_4f(s: graphene_simd4f_t, v: [*c]f32) void;
pub extern fn graphene_simd4f_dup_3f(s: graphene_simd4f_t, v: [*c]f32) void;
pub extern fn graphene_simd4f_dup_2f(s: graphene_simd4f_t, v: [*c]f32) void;
pub extern fn graphene_simd4f_get(s: graphene_simd4f_t, i: c_uint) f32;
pub extern fn graphene_simd4f_get_x(s: graphene_simd4f_t) f32;
pub extern fn graphene_simd4f_get_y(s: graphene_simd4f_t) f32;
pub extern fn graphene_simd4f_get_z(s: graphene_simd4f_t) f32;
pub extern fn graphene_simd4f_get_w(s: graphene_simd4f_t) f32;
pub extern fn graphene_simd4f_splat(v: f32) graphene_simd4f_t;
pub extern fn graphene_simd4f_splat_x(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_splat_y(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_splat_z(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_splat_w(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_add(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_sub(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_mul(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_div(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_sqrt(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_reciprocal(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_rsqrt(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_cross3(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_dot3(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_dot3_scalar(a: graphene_simd4f_t, b: graphene_simd4f_t) f32;
pub extern fn graphene_simd4f_min(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_max(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_shuffle_wxyz(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_shuffle_zwxy(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_shuffle_yzwx(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_zero_w(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_zero_zw(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_merge_high(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_merge_low(a: graphene_simd4f_t, b: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_merge_w(s: graphene_simd4f_t, v: f32) graphene_simd4f_t;
pub extern fn graphene_simd4f_flip_sign_0101(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_flip_sign_1010(s: graphene_simd4f_t) graphene_simd4f_t;
pub extern fn graphene_simd4f_cmp_eq(a: graphene_simd4f_t, b: graphene_simd4f_t) bool;
pub extern fn graphene_simd4f_cmp_neq(a: graphene_simd4f_t, b: graphene_simd4f_t) bool;
pub extern fn graphene_simd4f_cmp_lt(a: graphene_simd4f_t, b: graphene_simd4f_t) bool;
pub extern fn graphene_simd4f_cmp_le(a: graphene_simd4f_t, b: graphene_simd4f_t) bool;
pub extern fn graphene_simd4f_cmp_ge(a: graphene_simd4f_t, b: graphene_simd4f_t) bool;
pub extern fn graphene_simd4f_cmp_gt(a: graphene_simd4f_t, b: graphene_simd4f_t) bool;
pub extern fn graphene_simd4f_neg(s: graphene_simd4f_t) graphene_simd4f_t;
pub const graphene_simd4f_union_t = extern union {
    s: graphene_simd4f_t,
    f: [4]f32,
};
pub const graphene_simd4f_uif_t = extern union {
    ui: [4]c_uint,
    f: [4]f32,
};
pub fn graphene_simd4f_madd(m1: graphene_simd4f_t, m2: graphene_simd4f_t, a: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(m1, m2)));
        }, a)));
    };
} // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4f.h:1871:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4f_sum(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t;
pub fn graphene_simd4f_sum_scalar(v: graphene_simd4f_t) callconv(.C) f32 {
    return blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = graphene_simd4f_sum(v),
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 0)))];
    };
}
pub fn graphene_simd4f_dot4(a: graphene_simd4f_t, b: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    return graphene_simd4f_sum(blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(a, b)));
    });
} // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4f.h:1933:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4f_dot2(a: graphene_simd4f_t, b: graphene_simd4f_t) callconv(.C) graphene_simd4f_t;
pub fn graphene_simd4f_length4(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sqrt_ps(graphene_simd4f_dot4(v, v))));
    };
} // /usr/lib/zig/include/smmintrin.h:597:12: warning: TODO implement function '__builtin_ia32_dpps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4f.h:1972:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4f_length3(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t;
pub fn graphene_simd4f_length2(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sqrt_ps(graphene_simd4f_dot2(v, v))));
    };
}
pub fn graphene_simd4f_normalize4(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    var invlen: graphene_simd4f_t = blk: {
        const __half: graphene_simd4f_t = blk_1: {
            break :blk_1 blk_2: {
                const tmp = 0.5;
                const tmp_3 = 0.5;
                const tmp_4 = 0.5;
                const tmp_5 = 0.5;
                break :blk_2 graphene_simd4f_t{
                    tmp,
                    tmp_3,
                    tmp_4,
                    tmp_5,
                };
            };
        };
        const __three: graphene_simd4f_t = blk_1: {
            break :blk_1 blk_2: {
                const tmp = 3.0;
                const tmp_3 = 3.0;
                const tmp_4 = 3.0;
                const tmp_5 = 3.0;
                break :blk_2 graphene_simd4f_t{
                    tmp,
                    tmp_3,
                    tmp_4,
                    tmp_5,
                };
            };
        };
        var __s: graphene_simd4f_t = _mm_rsqrt_ps(graphene_simd4f_dot4(v, v));
        break :blk blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(blk_2: {
                break :blk_2 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(__s, __half)));
            }, blk_2: {
                break :blk_2 @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(__three, blk_3: {
                    break :blk_3 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(__s, blk_4: {
                        break :blk_4 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(graphene_simd4f_dot4(v, v), __s)));
                    })));
                })));
            })));
        };
    };
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(v, invlen)));
    };
} // /usr/lib/zig/include/smmintrin.h:597:12: warning: TODO implement function '__builtin_ia32_dpps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4f.h:2024:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4f_normalize3(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t;
pub fn graphene_simd4f_normalize2(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    var invlen: graphene_simd4f_t = blk: {
        const __half: graphene_simd4f_t = blk_1: {
            break :blk_1 blk_2: {
                const tmp = 0.5;
                const tmp_3 = 0.5;
                const tmp_4 = 0.5;
                const tmp_5 = 0.5;
                break :blk_2 graphene_simd4f_t{
                    tmp,
                    tmp_3,
                    tmp_4,
                    tmp_5,
                };
            };
        };
        const __three: graphene_simd4f_t = blk_1: {
            break :blk_1 blk_2: {
                const tmp = 3.0;
                const tmp_3 = 3.0;
                const tmp_4 = 3.0;
                const tmp_5 = 3.0;
                break :blk_2 graphene_simd4f_t{
                    tmp,
                    tmp_3,
                    tmp_4,
                    tmp_5,
                };
            };
        };
        var __s: graphene_simd4f_t = _mm_rsqrt_ps(graphene_simd4f_dot2(v, v));
        break :blk blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(blk_2: {
                break :blk_2 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(__s, __half)));
            }, blk_2: {
                break :blk_2 @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(__three, blk_3: {
                    break :blk_3 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(__s, blk_4: {
                        break :blk_4 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(graphene_simd4f_dot2(v, v), __s)));
                    })));
                })));
            })));
        };
    };
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(v, invlen)));
    };
}
pub fn graphene_simd4f_is_zero4(v: graphene_simd4f_t) callconv(.C) bool {
    var zero: graphene_simd4f_t = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_setzero_ps()));
    };
    return blk: {
        var __res: __m128i = @as(__m128i, @bitCast(_mm_cmpneq_ps(v, zero)));
        break :blk @as(bool, _mm_movemask_epi8(__res) == @as(c_int, 0));
    };
}
pub fn graphene_simd4f_is_zero3(v: graphene_simd4f_t) callconv(.C) bool {
    return ((fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = v,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 0)))];
    }) <= 0.00000011920928955078125) and (fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = v,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 1)))];
    }) <= 0.00000011920928955078125)) and (fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = v,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) <= 0.00000011920928955078125);
}
pub fn graphene_simd4f_is_zero2(v: graphene_simd4f_t) callconv(.C) bool {
    return (fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = v,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 0)))];
    }) <= 0.00000011920928955078125) and (fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = v,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 1)))];
    }) <= 0.00000011920928955078125);
}
pub fn graphene_simd4f_interpolate(a: graphene_simd4f_t, b: graphene_simd4f_t, arg_f: f32) callconv(.C) graphene_simd4f_t {
    var f = arg_f;
    const one_minus_f: graphene_simd4f_t = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_set1_ps(1.0)));
        }, blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_set1_ps(f)));
        })));
    };
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(one_minus_f, a)));
        }, blk_1: {
            break :blk_1 @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(blk_2: {
                break :blk_2 @as(graphene_simd4f_t, @bitCast(_mm_set1_ps(f)));
            }, b)));
        })));
    };
}
pub fn graphene_simd4f_clamp(v: graphene_simd4f_t, min: graphene_simd4f_t, max: graphene_simd4f_t) callconv(.C) graphene_simd4f_t {
    const tmp: graphene_simd4f_t = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_max_ps(min, v)));
    };
    return blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_min_ps(tmp, max)));
    };
}
pub fn graphene_simd4f_clamp_scalar(v: graphene_simd4f_t, arg_min: f32, arg_max: f32) callconv(.C) graphene_simd4f_t {
    var min = arg_min;
    var max = arg_max;
    return graphene_simd4f_clamp(v, blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_set1_ps(min)));
    }, blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_set1_ps(max)));
    });
} // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4f.h:2186:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4f_min_val(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t; // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4f.h:2208:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4f_max_val(v: graphene_simd4f_t) callconv(.C) graphene_simd4f_t;
pub fn graphene_simd4x4f_init(arg_x: graphene_simd4f_t, arg_y: graphene_simd4f_t, arg_z: graphene_simd4f_t, arg_w: graphene_simd4f_t) callconv(.C) graphene_simd4x4f_t {
    var x = arg_x;
    var y = arg_y;
    var z = arg_z;
    var w = arg_w;
    var s: graphene_simd4x4f_t = undefined;
    s.x = x;
    s.y = y;
    s.z = z;
    s.w = w;
    return s;
}
pub fn graphene_simd4x4f_init_identity(arg_m: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var m = arg_m;
    m.* = graphene_simd4x4f_init(blk: {
        break :blk blk_1: {
            const tmp = 1.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 1.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 1.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    });
}
pub fn graphene_simd4x4f_init_from_float(arg_m: [*c]graphene_simd4x4f_t, arg_f: [*c]const f32) callconv(.C) void {
    var m = arg_m;
    var f = arg_f;
    m.*.x = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_loadu_ps(f + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))))));
    };
    m.*.y = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_loadu_ps(f + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))))));
    };
    m.*.z = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_loadu_ps(f + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))))));
    };
    m.*.w = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_loadu_ps(f + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))))));
    };
}
pub fn graphene_simd4x4f_to_float(arg_m: [*c]const graphene_simd4x4f_t, arg_v: [*c]f32) callconv(.C) void {
    var m = arg_m;
    var v = arg_v;
    _ = blk: {
        break :blk _mm_storeu_ps(v + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 0))))), m.*.x);
    };
    _ = blk: {
        break :blk _mm_storeu_ps(v + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))), m.*.y);
    };
    _ = blk: {
        break :blk _mm_storeu_ps(v + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 8))))), m.*.z);
    };
    _ = blk: {
        break :blk _mm_storeu_ps(v + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 12))))), m.*.w);
    };
}
pub extern fn graphene_simd4x4f_transpose_in_place(s: [*c]graphene_simd4x4f_t) void;
pub fn graphene_simd4x4f_sum(arg_a: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4f_t) callconv(.C) void {
    var a = arg_a;
    var res = arg_res;
    var s: graphene_simd4f_t = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(a.*.x, a.*.y)));
    };
    s = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(s, a.*.z)));
    };
    s = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(s, a.*.w)));
    };
    res.* = s;
} // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4x4f.h:270:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4x4f_vec4_mul(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4f_t, arg_res: [*c]graphene_simd4f_t) callconv(.C) void; // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4x4f.h:321:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4x4f_vec3_mul(arg_m: [*c]const graphene_simd4x4f_t, arg_v: [*c]const graphene_simd4f_t, arg_res: [*c]graphene_simd4f_t) callconv(.C) void; // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4x4f.h:373:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4x4f_point3_mul(arg_m: [*c]const graphene_simd4x4f_t, arg_p: [*c]const graphene_simd4f_t, arg_res: [*c]graphene_simd4f_t) callconv(.C) void;
pub fn graphene_simd4x4f_transpose(arg_s: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var s = arg_s;
    var res = arg_res;
    res.* = s.*;
    _ = blk: {
        break :blk while (true) {
            var tmp3: __m128 = undefined;
            var tmp2: __m128 = undefined;
            var tmp1: __m128 = undefined;
            var tmp0: __m128 = undefined;
            tmp0 = _mm_unpacklo_ps(res.*.x, res.*.y);
            tmp2 = _mm_unpacklo_ps(res.*.z, res.*.w);
            tmp1 = _mm_unpackhi_ps(res.*.x, res.*.y);
            tmp3 = _mm_unpackhi_ps(res.*.z, res.*.w);
            res.*.x = _mm_movelh_ps(tmp0, tmp2);
            res.*.y = _mm_movehl_ps(tmp2, tmp0);
            res.*.z = _mm_movelh_ps(tmp1, tmp3);
            res.*.w = _mm_movehl_ps(tmp3, tmp1);
            if (!false) break;
        };
    };
}
pub fn graphene_simd4x4f_inv_ortho_vec3_mul(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4f_t, arg_res: [*c]graphene_simd4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    var transpose: graphene_simd4x4f_t = a.*;
    var translation: graphene_simd4f_t = b.*;
    transpose.w = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    _ = blk: {
        break :blk while (true) {
            var tmp3: __m128 = undefined;
            var tmp2: __m128 = undefined;
            var tmp1: __m128 = undefined;
            var tmp0: __m128 = undefined;
            tmp0 = _mm_unpacklo_ps((&transpose).*.x, (&transpose).*.y);
            tmp2 = _mm_unpacklo_ps((&transpose).*.z, (&transpose).*.w);
            tmp1 = _mm_unpackhi_ps((&transpose).*.x, (&transpose).*.y);
            tmp3 = _mm_unpackhi_ps((&transpose).*.z, (&transpose).*.w);
            (&transpose).*.x = _mm_movelh_ps(tmp0, tmp2);
            (&transpose).*.y = _mm_movehl_ps(tmp2, tmp0);
            (&transpose).*.z = _mm_movelh_ps(tmp1, tmp3);
            (&transpose).*.w = _mm_movehl_ps(tmp3, tmp1);
            if (!false) break;
        };
    };
    graphene_simd4x4f_vec3_mul(&transpose, &translation, res);
}
pub fn graphene_simd4x4f_inv_ortho_point3_mul(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4f_t, arg_res: [*c]graphene_simd4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    var translation: graphene_simd4f_t = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(b.*, a.*.w)));
    };
    var transpose: graphene_simd4x4f_t = a.*;
    transpose.w = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    _ = blk: {
        break :blk while (true) {
            var tmp3: __m128 = undefined;
            var tmp2: __m128 = undefined;
            var tmp1: __m128 = undefined;
            var tmp0: __m128 = undefined;
            tmp0 = _mm_unpacklo_ps((&transpose).*.x, (&transpose).*.y);
            tmp2 = _mm_unpacklo_ps((&transpose).*.z, (&transpose).*.w);
            tmp1 = _mm_unpackhi_ps((&transpose).*.x, (&transpose).*.y);
            tmp3 = _mm_unpackhi_ps((&transpose).*.z, (&transpose).*.w);
            (&transpose).*.x = _mm_movelh_ps(tmp0, tmp2);
            (&transpose).*.y = _mm_movehl_ps(tmp2, tmp0);
            (&transpose).*.z = _mm_movelh_ps(tmp1, tmp3);
            (&transpose).*.w = _mm_movehl_ps(tmp3, tmp1);
            if (!false) break;
        };
    };
    graphene_simd4x4f_point3_mul(&transpose, &translation, res);
}
pub fn graphene_simd4x4f_matrix_mul(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    var x: graphene_simd4f_t = undefined;
    var y: graphene_simd4f_t = undefined;
    var z: graphene_simd4f_t = undefined;
    var w: graphene_simd4f_t = undefined;
    graphene_simd4x4f_vec4_mul(b, &a.*.x, &x);
    graphene_simd4x4f_vec4_mul(b, &a.*.y, &y);
    graphene_simd4x4f_vec4_mul(b, &a.*.z, &z);
    graphene_simd4x4f_vec4_mul(b, &a.*.w, &w);
    res.* = graphene_simd4x4f_init(x, y, z, w);
}
pub fn graphene_simd4x4f_init_perspective(arg_m: [*c]graphene_simd4x4f_t, arg_fovy_rad: f32, arg_aspect: f32, arg_z_near: f32, arg_z_far: f32) callconv(.C) void {
    var m = arg_m;
    var fovy_rad = arg_fovy_rad;
    var aspect = arg_aspect;
    var z_near = arg_z_near;
    var z_far = arg_z_far;
    var delta_z: f32 = z_far - z_near;
    var cotangent: f32 = tanf(1.5707963705062866 - (fovy_rad * 0.5));
    var a: f32 = cotangent / aspect;
    var b: f32 = cotangent;
    var c: f32 = -(z_far + z_near) / delta_z;
    var d: f32 = ((@as(f32, @floatFromInt(-@as(c_int, 2))) * z_near) * z_far) / delta_z;
    m.*.x = blk: {
        break :blk blk_1: {
            const tmp = a;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.y = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = b;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.z = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = c;
            const tmp_4 = -1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.w = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = d;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
}
pub fn graphene_simd4x4f_init_ortho(arg_m: [*c]graphene_simd4x4f_t, arg_left: f32, arg_right: f32, arg_bottom: f32, arg_top: f32, arg_z_near: f32, arg_z_far: f32) callconv(.C) void {
    var m = arg_m;
    var left = arg_left;
    var right = arg_right;
    var bottom = arg_bottom;
    var top = arg_top;
    var z_near = arg_z_near;
    var z_far = arg_z_far;
    var delta_x: f32 = right - left;
    var delta_y: f32 = top - bottom;
    var delta_z: f32 = z_far - z_near;
    var a: f32 = 2.0 / delta_x;
    var b: f32 = -(right + left) / delta_x;
    var c: f32 = 2.0 / delta_y;
    var d: f32 = -(top + bottom) / delta_y;
    var e: f32 = -2.0 / delta_z;
    var f: f32 = -(z_far + z_near) / delta_z;
    m.*.x = blk: {
        break :blk blk_1: {
            const tmp = a;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.y = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = c;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.z = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = e;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.w = blk: {
        break :blk blk_1: {
            const tmp = b;
            const tmp_2 = d;
            const tmp_3 = f;
            const tmp_4 = 1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
} // /usr/lib/zig/include/smmintrin.h:597:12: warning: TODO implement function '__builtin_ia32_dpps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4x4f.h:635:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4x4f_init_look_at(arg_m: [*c]graphene_simd4x4f_t, arg_eye: graphene_simd4f_t, arg_center: graphene_simd4f_t, arg_up: graphene_simd4f_t) callconv(.C) void;
pub fn graphene_simd4x4f_init_frustum(arg_m: [*c]graphene_simd4x4f_t, arg_left: f32, arg_right: f32, arg_bottom: f32, arg_top: f32, arg_z_near: f32, arg_z_far: f32) callconv(.C) void {
    var m = arg_m;
    var left = arg_left;
    var right = arg_right;
    var bottom = arg_bottom;
    var top = arg_top;
    var z_near = arg_z_near;
    var z_far = arg_z_far;
    var x: f32 = (2.0 * z_near) / (right - left);
    var y: f32 = (2.0 * z_near) / (top - bottom);
    var a: f32 = (right + left) / (right - left);
    var b: f32 = (top + bottom) / (top - bottom);
    var c: f32 = (-1.0 * (z_far + z_near)) / (z_far - z_near);
    var d: f32 = ((-2.0 * z_far) * z_near) / (z_far - z_near);
    m.*.x = blk: {
        break :blk blk_1: {
            const tmp = x;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.y = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = y;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.z = blk: {
        break :blk blk_1: {
            const tmp = a;
            const tmp_2 = b;
            const tmp_3 = c;
            const tmp_4 = -1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.*.w = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = d;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
}
pub fn graphene_simd4x4f_perspective(arg_m: [*c]graphene_simd4x4f_t, arg_depth: f32) callconv(.C) void {
    var m = arg_m;
    var depth = arg_depth;
    const m_xw: f32 = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.x,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    };
    const m_yw: f32 = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.y,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    };
    const m_zw: f32 = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.z,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    };
    const m_ww: f32 = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.w,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    };
    const p0: f32 = (blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.x,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) + ((-1.0 / depth) * m_xw);
    const p1: f32 = (blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.y,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) + ((-1.0 / depth) * m_yw);
    const p2: f32 = (blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.z,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) + ((-1.0 / depth) * m_zw);
    const p3: f32 = (blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.w,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) + ((-1.0 / depth) * m_ww);
    const p_x: graphene_simd4f_t = blk: {
        var __s: graphene_simd4f_t = _mm_unpackhi_ps(m.*.x, _mm_set1_ps(m_xw + p0));
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_movelh_ps(m.*.x, __s)));
    };
    const p_y: graphene_simd4f_t = blk: {
        var __s: graphene_simd4f_t = _mm_unpackhi_ps(m.*.y, _mm_set1_ps(m_yw + p1));
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_movelh_ps(m.*.y, __s)));
    };
    const p_z: graphene_simd4f_t = blk: {
        var __s: graphene_simd4f_t = _mm_unpackhi_ps(m.*.z, _mm_set1_ps(m_zw + p2));
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_movelh_ps(m.*.z, __s)));
    };
    const p_w: graphene_simd4f_t = blk: {
        var __s: graphene_simd4f_t = _mm_unpackhi_ps(m.*.w, _mm_set1_ps(m_ww + p3));
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_movelh_ps(m.*.w, __s)));
    };
    m.* = graphene_simd4x4f_init(p_x, p_y, p_z, p_w);
}
pub fn graphene_simd4x4f_translation(arg_m: [*c]graphene_simd4x4f_t, arg_x: f32, arg_y: f32, arg_z: f32) callconv(.C) void {
    var m = arg_m;
    var x = arg_x;
    var y = arg_y;
    var z = arg_z;
    m.* = graphene_simd4x4f_init(blk: {
        break :blk blk_1: {
            const tmp = 1.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 1.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 1.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = x;
            const tmp_2 = y;
            const tmp_3 = z;
            const tmp_4 = 1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    });
}
pub fn graphene_simd4x4f_scale(arg_m: [*c]graphene_simd4x4f_t, arg_x: f32, arg_y: f32, arg_z: f32) callconv(.C) void {
    var m = arg_m;
    var x = arg_x;
    var y = arg_y;
    var z = arg_z;
    m.* = graphene_simd4x4f_init(blk: {
        break :blk blk_1: {
            const tmp = x;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = y;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = z;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    }, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    });
}
pub fn graphene_simd4x4f_rotation(arg_m: [*c]graphene_simd4x4f_t, arg_rad: f32, arg_axis: graphene_simd4f_t) callconv(.C) void {
    var m = arg_m;
    var rad = arg_rad;
    var axis = arg_axis;
    var sine: f32 = undefined;
    var cosine: f32 = undefined;
    var x: f32 = undefined;
    var y: f32 = undefined;
    var z: f32 = undefined;
    var ab: f32 = undefined;
    var bc: f32 = undefined;
    var ca: f32 = undefined;
    var tx: f32 = undefined;
    var ty: f32 = undefined;
    var tz: f32 = undefined;
    var i: graphene_simd4f_t = undefined;
    var j: graphene_simd4f_t = undefined;
    var k: graphene_simd4f_t = undefined;
    rad = -rad;
    axis = graphene_simd4f_normalize3(axis);
    sine = sinf(rad);
    cosine = cosf(rad);
    x = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = axis,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 0)))];
    };
    y = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = axis,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 1)))];
    };
    z = blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = axis,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    };
    ab = (x * y) * (1.0 - cosine);
    bc = (y * z) * (1.0 - cosine);
    ca = (z * x) * (1.0 - cosine);
    tx = x * x;
    ty = y * y;
    tz = z * z;
    i = blk: {
        break :blk blk_1: {
            const tmp = tx + (cosine * (1.0 - tx));
            const tmp_2 = ab - (z * sine);
            const tmp_3 = ca + (y * sine);
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    j = blk: {
        break :blk blk_1: {
            const tmp = ab + (z * sine);
            const tmp_2 = ty + (cosine * (1.0 - ty));
            const tmp_3 = bc - (x * sine);
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    k = blk: {
        break :blk blk_1: {
            const tmp = ca - (y * sine);
            const tmp_2 = bc + (x * sine);
            const tmp_3 = tz + (cosine * (1.0 - tz));
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    m.* = graphene_simd4x4f_init(i, j, k, blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    });
}
pub fn graphene_simd4x4f_add(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    res.*.x = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(a.*.x, b.*.x)));
    };
    res.*.y = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(a.*.y, b.*.y)));
    };
    res.*.z = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(a.*.z, b.*.z)));
    };
    res.*.w = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_add_ps(a.*.w, b.*.w)));
    };
}
pub fn graphene_simd4x4f_sub(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    res.*.x = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(a.*.x, b.*.x)));
    };
    res.*.y = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(a.*.y, b.*.y)));
    };
    res.*.z = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(a.*.z, b.*.z)));
    };
    res.*.w = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_sub_ps(a.*.w, b.*.w)));
    };
}
pub fn graphene_simd4x4f_mul(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    res.*.x = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(a.*.x, b.*.x)));
    };
    res.*.y = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(a.*.y, b.*.y)));
    };
    res.*.z = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(a.*.z, b.*.z)));
    };
    res.*.w = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_mul_ps(a.*.w, b.*.w)));
    };
}
pub fn graphene_simd4x4f_div(arg_a: [*c]const graphene_simd4x4f_t, arg_b: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) void {
    var a = arg_a;
    var b = arg_b;
    var res = arg_res;
    res.*.x = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_div_ps(a.*.x, b.*.x)));
    };
    res.*.y = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_div_ps(a.*.y, b.*.y)));
    };
    res.*.z = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_div_ps(a.*.z, b.*.z)));
    };
    res.*.w = blk: {
        break :blk @as(graphene_simd4f_t, @bitCast(_mm_div_ps(a.*.w, b.*.w)));
    };
} // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4x4f.h:967:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4x4f_inverse(arg_m: [*c]const graphene_simd4x4f_t, arg_res: [*c]graphene_simd4x4f_t) callconv(.C) bool; // /usr/lib/zig/include/xmmintrin.h:2614:12: warning: TODO implement function '__builtin_ia32_shufps' in std.zig.c_builtins
// /usr/include/graphene-1.0/graphene-simd4x4f.h:1068:1: warning: unable to translate function, demoted to extern
pub extern fn graphene_simd4x4f_determinant(arg_m: [*c]const graphene_simd4x4f_t, arg_det_r: [*c]graphene_simd4f_t, arg_invdet_r: [*c]graphene_simd4f_t) callconv(.C) void;
pub fn graphene_simd4x4f_is_identity(arg_m: [*c]const graphene_simd4x4f_t) callconv(.C) bool {
    var m = arg_m;
    const r0: graphene_simd4f_t = blk: {
        break :blk blk_1: {
            const tmp = 1.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    const r1: graphene_simd4f_t = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 1.0;
            const tmp_3 = 0.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    const r2: graphene_simd4f_t = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 1.0;
            const tmp_4 = 0.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    const r3: graphene_simd4f_t = blk: {
        break :blk blk_1: {
            const tmp = 0.0;
            const tmp_2 = 0.0;
            const tmp_3 = 0.0;
            const tmp_4 = 1.0;
            break :blk_1 graphene_simd4f_t{
                tmp,
                tmp_2,
                tmp_3,
                tmp_4,
            };
        };
    };
    return (((@as(c_int, @intFromBool(blk: {
        var __res: __m128i = @as(__m128i, @bitCast(_mm_cmpneq_ps(m.*.x, r0)));
        break :blk @as(bool, _mm_movemask_epi8(__res) == @as(c_int, 0));
    })) != 0) and (@as(c_int, @intFromBool(blk: {
        var __res: __m128i = @as(__m128i, @bitCast(_mm_cmpneq_ps(m.*.y, r1)));
        break :blk @as(bool, _mm_movemask_epi8(__res) == @as(c_int, 0));
    })) != 0)) and (@as(c_int, @intFromBool(blk: {
        var __res: __m128i = @as(__m128i, @bitCast(_mm_cmpneq_ps(m.*.z, r2)));
        break :blk @as(bool, _mm_movemask_epi8(__res) == @as(c_int, 0));
    })) != 0)) and (@as(c_int, @intFromBool(blk: {
        var __res: __m128i = @as(__m128i, @bitCast(_mm_cmpneq_ps(m.*.w, r3)));
        break :blk @as(bool, _mm_movemask_epi8(__res) == @as(c_int, 0));
    })) != 0);
}
pub fn graphene_simd4x4f_is_2d(arg_m: [*c]const graphene_simd4x4f_t) callconv(.C) bool {
    var m = arg_m;
    var f: [4]f32 = undefined;
    if (!((fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.x,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) < 0.00000011920928955078125) and (fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.x,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    }) < 0.00000011920928955078125))) return @as(c_int, 0) != 0;
    if (!((fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.y,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) < 0.00000011920928955078125) and (fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.y,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    }) < 0.00000011920928955078125))) return @as(c_int, 0) != 0;
    _ = blk: {
        break :blk _mm_storeu_ps(@as([*c]f32, @ptrCast(@alignCast(&f))), m.*.z);
    };
    if (!((((fabsf(f[@as(c_uint, @intCast(@as(c_int, 0)))]) < 0.00000011920928955078125) and (fabsf(f[@as(c_uint, @intCast(@as(c_int, 1)))]) < 0.00000011920928955078125)) and ((1.0 - fabsf(f[@as(c_uint, @intCast(@as(c_int, 2)))])) < 0.00000011920928955078125)) and (fabsf(f[@as(c_uint, @intCast(@as(c_int, 3)))]) < 0.00000011920928955078125))) return @as(c_int, 0) != 0;
    if (!((fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.w,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 2)))];
    }) < 0.00000011920928955078125) and ((1.0 - fabsf(blk: {
        var __u: graphene_simd4f_union_t = graphene_simd4f_union_t{
            .s = m.*.w,
        };
        break :blk __u.f[@as(c_uint, @intCast(@as(c_int, 3)))];
    })) < 0.00000011920928955078125))) return @as(c_int, 0) != 0;
    return @as(c_int, 1) != 0;
}
pub extern fn graphene_vec2_alloc() [*c]graphene_vec2_t;
pub extern fn graphene_vec2_free(v: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_init(v: [*c]graphene_vec2_t, x: f32, y: f32) [*c]graphene_vec2_t;
pub extern fn graphene_vec2_init_from_vec2(v: [*c]graphene_vec2_t, src: [*c]const graphene_vec2_t) [*c]graphene_vec2_t;
pub extern fn graphene_vec2_init_from_float(v: [*c]graphene_vec2_t, src: [*c]const f32) [*c]graphene_vec2_t;
pub extern fn graphene_vec2_to_float(v: [*c]const graphene_vec2_t, dest: [*c]f32) void;
pub extern fn graphene_vec2_add(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_subtract(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_multiply(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_divide(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_dot(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t) f32;
pub extern fn graphene_vec2_length(v: [*c]const graphene_vec2_t) f32;
pub extern fn graphene_vec2_normalize(v: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_scale(v: [*c]const graphene_vec2_t, factor: f32, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_negate(v: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_near(v1: [*c]const graphene_vec2_t, v2: [*c]const graphene_vec2_t, epsilon: f32) bool;
pub extern fn graphene_vec2_equal(v1: [*c]const graphene_vec2_t, v2: [*c]const graphene_vec2_t) bool;
pub extern fn graphene_vec2_min(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_max(a: [*c]const graphene_vec2_t, b: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_interpolate(v1: [*c]const graphene_vec2_t, v2: [*c]const graphene_vec2_t, factor: f64, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec2_get_x(v: [*c]const graphene_vec2_t) f32;
pub extern fn graphene_vec2_get_y(v: [*c]const graphene_vec2_t) f32;
pub extern fn graphene_vec2_zero() [*c]const graphene_vec2_t;
pub extern fn graphene_vec2_one() [*c]const graphene_vec2_t;
pub extern fn graphene_vec2_x_axis() [*c]const graphene_vec2_t;
pub extern fn graphene_vec2_y_axis() [*c]const graphene_vec2_t;
pub extern fn graphene_vec3_alloc() [*c]graphene_vec3_t;
pub extern fn graphene_vec3_free(v: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_init(v: [*c]graphene_vec3_t, x: f32, y: f32, z: f32) [*c]graphene_vec3_t;
pub extern fn graphene_vec3_init_from_vec3(v: [*c]graphene_vec3_t, src: [*c]const graphene_vec3_t) [*c]graphene_vec3_t;
pub extern fn graphene_vec3_init_from_float(v: [*c]graphene_vec3_t, src: [*c]const f32) [*c]graphene_vec3_t;
pub extern fn graphene_vec3_to_float(v: [*c]const graphene_vec3_t, dest: [*c]f32) void;
pub extern fn graphene_vec3_add(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_subtract(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_multiply(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_divide(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_cross(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_dot(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t) f32;
pub extern fn graphene_vec3_length(v: [*c]const graphene_vec3_t) f32;
pub extern fn graphene_vec3_normalize(v: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_scale(v: [*c]const graphene_vec3_t, factor: f32, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_negate(v: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_equal(v1: [*c]const graphene_vec3_t, v2: [*c]const graphene_vec3_t) bool;
pub extern fn graphene_vec3_near(v1: [*c]const graphene_vec3_t, v2: [*c]const graphene_vec3_t, epsilon: f32) bool;
pub extern fn graphene_vec3_min(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_max(a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_interpolate(v1: [*c]const graphene_vec3_t, v2: [*c]const graphene_vec3_t, factor: f64, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_get_x(v: [*c]const graphene_vec3_t) f32;
pub extern fn graphene_vec3_get_y(v: [*c]const graphene_vec3_t) f32;
pub extern fn graphene_vec3_get_z(v: [*c]const graphene_vec3_t) f32;
pub extern fn graphene_vec3_get_xy(v: [*c]const graphene_vec3_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec3_get_xy0(v: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec3_get_xyz0(v: [*c]const graphene_vec3_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec3_get_xyz1(v: [*c]const graphene_vec3_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec3_get_xyzw(v: [*c]const graphene_vec3_t, w: f32, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec3_zero() [*c]const graphene_vec3_t;
pub extern fn graphene_vec3_one() [*c]const graphene_vec3_t;
pub extern fn graphene_vec3_x_axis() [*c]const graphene_vec3_t;
pub extern fn graphene_vec3_y_axis() [*c]const graphene_vec3_t;
pub extern fn graphene_vec3_z_axis() [*c]const graphene_vec3_t;
pub extern fn graphene_vec4_alloc() [*c]graphene_vec4_t;
pub extern fn graphene_vec4_free(v: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_init(v: [*c]graphene_vec4_t, x: f32, y: f32, z: f32, w: f32) [*c]graphene_vec4_t;
pub extern fn graphene_vec4_init_from_vec4(v: [*c]graphene_vec4_t, src: [*c]const graphene_vec4_t) [*c]graphene_vec4_t;
pub extern fn graphene_vec4_init_from_vec3(v: [*c]graphene_vec4_t, src: [*c]const graphene_vec3_t, w: f32) [*c]graphene_vec4_t;
pub extern fn graphene_vec4_init_from_vec2(v: [*c]graphene_vec4_t, src: [*c]const graphene_vec2_t, z: f32, w: f32) [*c]graphene_vec4_t;
pub extern fn graphene_vec4_init_from_float(v: [*c]graphene_vec4_t, src: [*c]const f32) [*c]graphene_vec4_t;
pub extern fn graphene_vec4_to_float(v: [*c]const graphene_vec4_t, dest: [*c]f32) void;
pub extern fn graphene_vec4_add(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_subtract(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_multiply(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_divide(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_dot(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t) f32;
pub extern fn graphene_vec4_length(v: [*c]const graphene_vec4_t) f32;
pub extern fn graphene_vec4_normalize(v: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_scale(v: [*c]const graphene_vec4_t, factor: f32, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_negate(v: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_equal(v1: [*c]const graphene_vec4_t, v2: [*c]const graphene_vec4_t) bool;
pub extern fn graphene_vec4_near(v1: [*c]const graphene_vec4_t, v2: [*c]const graphene_vec4_t, epsilon: f32) bool;
pub extern fn graphene_vec4_min(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_max(a: [*c]const graphene_vec4_t, b: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_interpolate(v1: [*c]const graphene_vec4_t, v2: [*c]const graphene_vec4_t, factor: f64, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_vec4_get_x(v: [*c]const graphene_vec4_t) f32;
pub extern fn graphene_vec4_get_y(v: [*c]const graphene_vec4_t) f32;
pub extern fn graphene_vec4_get_z(v: [*c]const graphene_vec4_t) f32;
pub extern fn graphene_vec4_get_w(v: [*c]const graphene_vec4_t) f32;
pub extern fn graphene_vec4_get_xy(v: [*c]const graphene_vec4_t, res: [*c]graphene_vec2_t) void;
pub extern fn graphene_vec4_get_xyz(v: [*c]const graphene_vec4_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_vec4_zero() [*c]const graphene_vec4_t;
pub extern fn graphene_vec4_one() [*c]const graphene_vec4_t;
pub extern fn graphene_vec4_x_axis() [*c]const graphene_vec4_t;
pub extern fn graphene_vec4_y_axis() [*c]const graphene_vec4_t;
pub extern fn graphene_vec4_z_axis() [*c]const graphene_vec4_t;
pub extern fn graphene_vec4_w_axis() [*c]const graphene_vec4_t;
pub extern fn graphene_matrix_alloc() [*c]graphene_matrix_t;
pub extern fn graphene_matrix_free(m: [*c]graphene_matrix_t) void;
pub extern fn graphene_matrix_init_identity(m: [*c]graphene_matrix_t) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_from_float(m: [*c]graphene_matrix_t, v: [*c]const f32) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_from_vec4(m: [*c]graphene_matrix_t, v0: [*c]const graphene_vec4_t, v1: [*c]const graphene_vec4_t, v2: [*c]const graphene_vec4_t, v3: [*c]const graphene_vec4_t) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_from_matrix(m: [*c]graphene_matrix_t, src: [*c]const graphene_matrix_t) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_perspective(m: [*c]graphene_matrix_t, fovy: f32, aspect: f32, z_near: f32, z_far: f32) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_ortho(m: [*c]graphene_matrix_t, left: f32, right: f32, top: f32, bottom: f32, z_near: f32, z_far: f32) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_look_at(m: [*c]graphene_matrix_t, eye: [*c]const graphene_vec3_t, center: [*c]const graphene_vec3_t, up: [*c]const graphene_vec3_t) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_frustum(m: [*c]graphene_matrix_t, left: f32, right: f32, bottom: f32, top: f32, z_near: f32, z_far: f32) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_scale(m: [*c]graphene_matrix_t, x: f32, y: f32, z: f32) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_translate(m: [*c]graphene_matrix_t, p: [*c]const graphene_point3d_t) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_rotate(m: [*c]graphene_matrix_t, angle: f32, axis: [*c]const graphene_vec3_t) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_skew(m: [*c]graphene_matrix_t, x_skew: f32, y_skew: f32) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_init_from_2d(m: [*c]graphene_matrix_t, xx: f64, yx: f64, xy: f64, yy: f64, x_0: f64, y_0: f64) [*c]graphene_matrix_t;
pub extern fn graphene_matrix_is_identity(m: [*c]const graphene_matrix_t) bool;
pub extern fn graphene_matrix_is_2d(m: [*c]const graphene_matrix_t) bool;
pub extern fn graphene_matrix_is_backface_visible(m: [*c]const graphene_matrix_t) bool;
pub extern fn graphene_matrix_is_singular(m: [*c]const graphene_matrix_t) bool;
pub extern fn graphene_matrix_to_float(m: [*c]const graphene_matrix_t, v: [*c]f32) void;
pub extern fn graphene_matrix_to_2d(m: [*c]const graphene_matrix_t, xx: [*c]f64, yx: [*c]f64, xy: [*c]f64, yy: [*c]f64, x_0: [*c]f64, y_0: [*c]f64) bool;
pub extern fn graphene_matrix_get_row(m: [*c]const graphene_matrix_t, index_: c_uint, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_matrix_get_value(m: [*c]const graphene_matrix_t, row: c_uint, col: c_uint) f32;
pub extern fn graphene_matrix_multiply(a: [*c]const graphene_matrix_t, b: [*c]const graphene_matrix_t, res: [*c]graphene_matrix_t) void;
pub extern fn graphene_matrix_determinant(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_transform_vec4(m: [*c]const graphene_matrix_t, v: [*c]const graphene_vec4_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_matrix_transform_vec3(m: [*c]const graphene_matrix_t, v: [*c]const graphene_vec3_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_matrix_transform_point(m: [*c]const graphene_matrix_t, p: [*c]const graphene_point_t, res: [*c]graphene_point_t) void;
pub extern fn graphene_matrix_transform_point3d(m: [*c]const graphene_matrix_t, p: [*c]const graphene_point3d_t, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_matrix_transform_rect(m: [*c]const graphene_matrix_t, r: [*c]const graphene_rect_t, res: [*c]graphene_quad_t) void;
pub extern fn graphene_matrix_transform_bounds(m: [*c]const graphene_matrix_t, r: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_matrix_transform_sphere(m: [*c]const graphene_matrix_t, s: [*c]const graphene_sphere_t, res: [*c]graphene_sphere_t) void;
pub extern fn graphene_matrix_transform_box(m: [*c]const graphene_matrix_t, b: [*c]const graphene_box_t, res: [*c]graphene_box_t) void;
pub extern fn graphene_matrix_transform_ray(m: [*c]const graphene_matrix_t, r: [*c]const graphene_ray_t, res: [*c]graphene_ray_t) void;
pub extern fn graphene_matrix_project_point(m: [*c]const graphene_matrix_t, p: [*c]const graphene_point_t, res: [*c]graphene_point_t) void;
pub extern fn graphene_matrix_project_rect_bounds(m: [*c]const graphene_matrix_t, r: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_matrix_project_rect(m: [*c]const graphene_matrix_t, r: [*c]const graphene_rect_t, res: [*c]graphene_quad_t) void;
pub extern fn graphene_matrix_untransform_point(m: [*c]const graphene_matrix_t, p: [*c]const graphene_point_t, bounds: [*c]const graphene_rect_t, res: [*c]graphene_point_t) bool;
pub extern fn graphene_matrix_untransform_bounds(m: [*c]const graphene_matrix_t, r: [*c]const graphene_rect_t, bounds: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_matrix_unproject_point3d(projection: [*c]const graphene_matrix_t, modelview: [*c]const graphene_matrix_t, point: [*c]const graphene_point3d_t, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_matrix_translate(m: [*c]graphene_matrix_t, pos: [*c]const graphene_point3d_t) void;
pub extern fn graphene_matrix_rotate(m: [*c]graphene_matrix_t, angle: f32, axis: [*c]const graphene_vec3_t) void;
pub extern fn graphene_matrix_rotate_x(m: [*c]graphene_matrix_t, angle: f32) void;
pub extern fn graphene_matrix_rotate_y(m: [*c]graphene_matrix_t, angle: f32) void;
pub extern fn graphene_matrix_rotate_z(m: [*c]graphene_matrix_t, angle: f32) void;
pub extern fn graphene_matrix_rotate_quaternion(m: [*c]graphene_matrix_t, q: [*c]const graphene_quaternion_t) void;
pub extern fn graphene_matrix_rotate_euler(m: [*c]graphene_matrix_t, e: [*c]const graphene_euler_t) void;
pub extern fn graphene_matrix_scale(m: [*c]graphene_matrix_t, factor_x: f32, factor_y: f32, factor_z: f32) void;
pub extern fn graphene_matrix_skew_xy(m: [*c]graphene_matrix_t, factor: f32) void;
pub extern fn graphene_matrix_skew_xz(m: [*c]graphene_matrix_t, factor: f32) void;
pub extern fn graphene_matrix_skew_yz(m: [*c]graphene_matrix_t, factor: f32) void;
pub extern fn graphene_matrix_transpose(m: [*c]const graphene_matrix_t, res: [*c]graphene_matrix_t) void;
pub extern fn graphene_matrix_inverse(m: [*c]const graphene_matrix_t, res: [*c]graphene_matrix_t) bool;
pub extern fn graphene_matrix_perspective(m: [*c]const graphene_matrix_t, depth: f32, res: [*c]graphene_matrix_t) void;
pub extern fn graphene_matrix_normalize(m: [*c]const graphene_matrix_t, res: [*c]graphene_matrix_t) void;
pub extern fn graphene_matrix_get_x_translation(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_get_y_translation(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_get_z_translation(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_get_x_scale(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_get_y_scale(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_get_z_scale(m: [*c]const graphene_matrix_t) f32;
pub extern fn graphene_matrix_interpolate(a: [*c]const graphene_matrix_t, b: [*c]const graphene_matrix_t, factor: f64, res: [*c]graphene_matrix_t) void;
pub extern fn graphene_matrix_near(a: [*c]const graphene_matrix_t, b: [*c]const graphene_matrix_t, epsilon: f32) bool;
pub extern fn graphene_matrix_equal(a: [*c]const graphene_matrix_t, b: [*c]const graphene_matrix_t) bool;
pub extern fn graphene_matrix_equal_fast(a: [*c]const graphene_matrix_t, b: [*c]const graphene_matrix_t) bool;
pub extern fn graphene_matrix_print(m: [*c]const graphene_matrix_t) void;
pub extern fn graphene_matrix_decompose(m: [*c]const graphene_matrix_t, translate: [*c]graphene_vec3_t, scale: [*c]graphene_vec3_t, rotate: [*c]graphene_quaternion_t, shear: [*c]graphene_vec3_t, perspective: [*c]graphene_vec4_t) bool;
pub extern fn graphene_point_alloc() [*c]graphene_point_t;
pub extern fn graphene_point_free(p: [*c]graphene_point_t) void;
pub extern fn graphene_point_init(p: [*c]graphene_point_t, x: f32, y: f32) [*c]graphene_point_t;
pub extern fn graphene_point_init_from_point(p: [*c]graphene_point_t, src: [*c]const graphene_point_t) [*c]graphene_point_t;
pub extern fn graphene_point_init_from_vec2(p: [*c]graphene_point_t, src: [*c]const graphene_vec2_t) [*c]graphene_point_t;
pub extern fn graphene_point_equal(a: [*c]const graphene_point_t, b: [*c]const graphene_point_t) bool;
pub extern fn graphene_point_distance(a: [*c]const graphene_point_t, b: [*c]const graphene_point_t, d_x: [*c]f32, d_y: [*c]f32) f32;
pub extern fn graphene_point_near(a: [*c]const graphene_point_t, b: [*c]const graphene_point_t, epsilon: f32) bool;
pub extern fn graphene_point_interpolate(a: [*c]const graphene_point_t, b: [*c]const graphene_point_t, factor: f64, res: [*c]graphene_point_t) void;
pub extern fn graphene_point_to_vec2(p: [*c]const graphene_point_t, v: [*c]graphene_vec2_t) void;
pub extern fn graphene_point_zero() [*c]const graphene_point_t;
pub extern fn graphene_size_alloc() [*c]graphene_size_t;
pub extern fn graphene_size_free(s: [*c]graphene_size_t) void;
pub extern fn graphene_size_init(s: [*c]graphene_size_t, width: f32, height: f32) [*c]graphene_size_t;
pub extern fn graphene_size_init_from_size(s: [*c]graphene_size_t, src: [*c]const graphene_size_t) [*c]graphene_size_t;
pub extern fn graphene_size_equal(a: [*c]const graphene_size_t, b: [*c]const graphene_size_t) bool;
pub extern fn graphene_size_scale(s: [*c]const graphene_size_t, factor: f32, res: [*c]graphene_size_t) void;
pub extern fn graphene_size_interpolate(a: [*c]const graphene_size_t, b: [*c]const graphene_size_t, factor: f64, res: [*c]graphene_size_t) void;
pub extern fn graphene_size_zero() [*c]const graphene_size_t;
pub extern fn graphene_rect_alloc() [*c]graphene_rect_t;
pub extern fn graphene_rect_free(r: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_init(r: [*c]graphene_rect_t, x: f32, y: f32, width: f32, height: f32) [*c]graphene_rect_t;
pub extern fn graphene_rect_init_from_rect(r: [*c]graphene_rect_t, src: [*c]const graphene_rect_t) [*c]graphene_rect_t;
pub extern fn graphene_rect_equal(a: [*c]const graphene_rect_t, b: [*c]const graphene_rect_t) bool;
pub extern fn graphene_rect_normalize(r: [*c]graphene_rect_t) [*c]graphene_rect_t;
pub extern fn graphene_rect_normalize_r(r: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_get_center(r: [*c]const graphene_rect_t, p: [*c]graphene_point_t) void;
pub extern fn graphene_rect_get_top_left(r: [*c]const graphene_rect_t, p: [*c]graphene_point_t) void;
pub extern fn graphene_rect_get_top_right(r: [*c]const graphene_rect_t, p: [*c]graphene_point_t) void;
pub extern fn graphene_rect_get_bottom_right(r: [*c]const graphene_rect_t, p: [*c]graphene_point_t) void;
pub extern fn graphene_rect_get_bottom_left(r: [*c]const graphene_rect_t, p: [*c]graphene_point_t) void;
pub extern fn graphene_rect_get_vertices(r: [*c]const graphene_rect_t, vertices: [*c]graphene_vec2_t) void;
pub extern fn graphene_rect_get_x(r: [*c]const graphene_rect_t) f32;
pub extern fn graphene_rect_get_y(r: [*c]const graphene_rect_t) f32;
pub extern fn graphene_rect_get_width(r: [*c]const graphene_rect_t) f32;
pub extern fn graphene_rect_get_height(r: [*c]const graphene_rect_t) f32;
pub extern fn graphene_rect_get_area(r: [*c]const graphene_rect_t) f32;
pub extern fn graphene_rect_union(a: [*c]const graphene_rect_t, b: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_intersection(a: [*c]const graphene_rect_t, b: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) bool;
pub extern fn graphene_rect_contains_point(r: [*c]const graphene_rect_t, p: [*c]const graphene_point_t) bool;
pub extern fn graphene_rect_contains_rect(a: [*c]const graphene_rect_t, b: [*c]const graphene_rect_t) bool;
pub extern fn graphene_rect_offset(r: [*c]graphene_rect_t, d_x: f32, d_y: f32) [*c]graphene_rect_t;
pub extern fn graphene_rect_offset_r(r: [*c]const graphene_rect_t, d_x: f32, d_y: f32, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_inset(r: [*c]graphene_rect_t, d_x: f32, d_y: f32) [*c]graphene_rect_t;
pub extern fn graphene_rect_inset_r(r: [*c]const graphene_rect_t, d_x: f32, d_y: f32, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_round_to_pixel(r: [*c]graphene_rect_t) [*c]graphene_rect_t;
pub extern fn graphene_rect_round(r: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_round_extents(r: [*c]const graphene_rect_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_interpolate(a: [*c]const graphene_rect_t, b: [*c]const graphene_rect_t, factor: f64, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_expand(r: [*c]const graphene_rect_t, p: [*c]const graphene_point_t, res: [*c]graphene_rect_t) void;
pub extern fn graphene_rect_zero() [*c]const graphene_rect_t;
pub extern fn graphene_rect_scale(r: [*c]const graphene_rect_t, s_h: f32, s_v: f32, res: [*c]graphene_rect_t) void;
pub extern fn graphene_point3d_alloc() [*c]graphene_point3d_t;
pub extern fn graphene_point3d_free(p: [*c]graphene_point3d_t) void;
pub extern fn graphene_point3d_init(p: [*c]graphene_point3d_t, x: f32, y: f32, z: f32) [*c]graphene_point3d_t;
pub extern fn graphene_point3d_init_from_point(p: [*c]graphene_point3d_t, src: [*c]const graphene_point3d_t) [*c]graphene_point3d_t;
pub extern fn graphene_point3d_init_from_vec3(p: [*c]graphene_point3d_t, v: [*c]const graphene_vec3_t) [*c]graphene_point3d_t;
pub extern fn graphene_point3d_to_vec3(p: [*c]const graphene_point3d_t, v: [*c]graphene_vec3_t) void;
pub extern fn graphene_point3d_equal(a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t) bool;
pub extern fn graphene_point3d_near(a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t, epsilon: f32) bool;
pub extern fn graphene_point3d_scale(p: [*c]const graphene_point3d_t, factor: f32, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_point3d_cross(a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_point3d_dot(a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t) f32;
pub extern fn graphene_point3d_length(p: [*c]const graphene_point3d_t) f32;
pub extern fn graphene_point3d_normalize(p: [*c]const graphene_point3d_t, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_point3d_distance(a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t, delta: [*c]graphene_vec3_t) f32;
pub extern fn graphene_point3d_interpolate(a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t, factor: f64, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_point3d_normalize_viewport(p: [*c]const graphene_point3d_t, viewport: [*c]const graphene_rect_t, z_near: f32, z_far: f32, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_point3d_zero() [*c]const graphene_point3d_t;
pub extern fn graphene_quad_alloc() [*c]graphene_quad_t;
pub extern fn graphene_quad_free(q: [*c]graphene_quad_t) void;
pub extern fn graphene_quad_init(q: [*c]graphene_quad_t, p1: [*c]const graphene_point_t, p2: [*c]const graphene_point_t, p3: [*c]const graphene_point_t, p4: [*c]const graphene_point_t) [*c]graphene_quad_t;
pub extern fn graphene_quad_init_from_rect(q: [*c]graphene_quad_t, r: [*c]const graphene_rect_t) [*c]graphene_quad_t;
pub extern fn graphene_quad_init_from_points(q: [*c]graphene_quad_t, points: [*c]const graphene_point_t) [*c]graphene_quad_t;
pub extern fn graphene_quad_contains(q: [*c]const graphene_quad_t, p: [*c]const graphene_point_t) bool;
pub extern fn graphene_quad_bounds(q: [*c]const graphene_quad_t, r: [*c]graphene_rect_t) void;
pub extern fn graphene_quad_get_point(q: [*c]const graphene_quad_t, index_: c_uint) [*c]const graphene_point_t;
pub extern fn graphene_quaternion_alloc() [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_free(q: [*c]graphene_quaternion_t) void;
pub extern fn graphene_quaternion_init(q: [*c]graphene_quaternion_t, x: f32, y: f32, z: f32, w: f32) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_identity(q: [*c]graphene_quaternion_t) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_quaternion(q: [*c]graphene_quaternion_t, src: [*c]const graphene_quaternion_t) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_vec4(q: [*c]graphene_quaternion_t, src: [*c]const graphene_vec4_t) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_matrix(q: [*c]graphene_quaternion_t, m: [*c]const graphene_matrix_t) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_angles(q: [*c]graphene_quaternion_t, deg_x: f32, deg_y: f32, deg_z: f32) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_radians(q: [*c]graphene_quaternion_t, rad_x: f32, rad_y: f32, rad_z: f32) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_angle_vec3(q: [*c]graphene_quaternion_t, angle: f32, axis: [*c]const graphene_vec3_t) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_init_from_euler(q: [*c]graphene_quaternion_t, e: [*c]const graphene_euler_t) [*c]graphene_quaternion_t;
pub extern fn graphene_quaternion_to_vec4(q: [*c]const graphene_quaternion_t, res: [*c]graphene_vec4_t) void;
pub extern fn graphene_quaternion_to_matrix(q: [*c]const graphene_quaternion_t, m: [*c]graphene_matrix_t) void;
pub extern fn graphene_quaternion_to_angles(q: [*c]const graphene_quaternion_t, deg_x: [*c]f32, deg_y: [*c]f32, deg_z: [*c]f32) void;
pub extern fn graphene_quaternion_to_radians(q: [*c]const graphene_quaternion_t, rad_x: [*c]f32, rad_y: [*c]f32, rad_z: [*c]f32) void;
pub extern fn graphene_quaternion_to_angle_vec3(q: [*c]const graphene_quaternion_t, angle: [*c]f32, axis: [*c]graphene_vec3_t) void;
pub extern fn graphene_quaternion_equal(a: [*c]const graphene_quaternion_t, b: [*c]const graphene_quaternion_t) bool;
pub extern fn graphene_quaternion_dot(a: [*c]const graphene_quaternion_t, b: [*c]const graphene_quaternion_t) f32;
pub extern fn graphene_quaternion_invert(q: [*c]const graphene_quaternion_t, res: [*c]graphene_quaternion_t) void;
pub extern fn graphene_quaternion_normalize(q: [*c]const graphene_quaternion_t, res: [*c]graphene_quaternion_t) void;
pub extern fn graphene_quaternion_slerp(a: [*c]const graphene_quaternion_t, b: [*c]const graphene_quaternion_t, factor: f32, res: [*c]graphene_quaternion_t) void;
pub extern fn graphene_quaternion_multiply(a: [*c]const graphene_quaternion_t, b: [*c]const graphene_quaternion_t, res: [*c]graphene_quaternion_t) void;
pub extern fn graphene_quaternion_scale(q: [*c]const graphene_quaternion_t, factor: f32, res: [*c]graphene_quaternion_t) void;
pub extern fn graphene_quaternion_add(a: [*c]const graphene_quaternion_t, b: [*c]const graphene_quaternion_t, res: [*c]graphene_quaternion_t) void;
pub const GRAPHENE_EULER_ORDER_DEFAULT: c_int = -1;
pub const GRAPHENE_EULER_ORDER_XYZ: c_int = 0;
pub const GRAPHENE_EULER_ORDER_YZX: c_int = 1;
pub const GRAPHENE_EULER_ORDER_ZXY: c_int = 2;
pub const GRAPHENE_EULER_ORDER_XZY: c_int = 3;
pub const GRAPHENE_EULER_ORDER_YXZ: c_int = 4;
pub const GRAPHENE_EULER_ORDER_ZYX: c_int = 5;
pub const GRAPHENE_EULER_ORDER_SXYZ: c_int = 6;
pub const GRAPHENE_EULER_ORDER_SXYX: c_int = 7;
pub const GRAPHENE_EULER_ORDER_SXZY: c_int = 8;
pub const GRAPHENE_EULER_ORDER_SXZX: c_int = 9;
pub const GRAPHENE_EULER_ORDER_SYZX: c_int = 10;
pub const GRAPHENE_EULER_ORDER_SYZY: c_int = 11;
pub const GRAPHENE_EULER_ORDER_SYXZ: c_int = 12;
pub const GRAPHENE_EULER_ORDER_SYXY: c_int = 13;
pub const GRAPHENE_EULER_ORDER_SZXY: c_int = 14;
pub const GRAPHENE_EULER_ORDER_SZXZ: c_int = 15;
pub const GRAPHENE_EULER_ORDER_SZYX: c_int = 16;
pub const GRAPHENE_EULER_ORDER_SZYZ: c_int = 17;
pub const GRAPHENE_EULER_ORDER_RZYX: c_int = 18;
pub const GRAPHENE_EULER_ORDER_RXYX: c_int = 19;
pub const GRAPHENE_EULER_ORDER_RYZX: c_int = 20;
pub const GRAPHENE_EULER_ORDER_RXZX: c_int = 21;
pub const GRAPHENE_EULER_ORDER_RXZY: c_int = 22;
pub const GRAPHENE_EULER_ORDER_RYZY: c_int = 23;
pub const GRAPHENE_EULER_ORDER_RZXY: c_int = 24;
pub const GRAPHENE_EULER_ORDER_RYXY: c_int = 25;
pub const GRAPHENE_EULER_ORDER_RYXZ: c_int = 26;
pub const GRAPHENE_EULER_ORDER_RZXZ: c_int = 27;
pub const GRAPHENE_EULER_ORDER_RXYZ: c_int = 28;
pub const GRAPHENE_EULER_ORDER_RZYZ: c_int = 29;
pub const graphene_euler_order_t = c_int;
pub extern fn graphene_euler_alloc() [*c]graphene_euler_t;
pub extern fn graphene_euler_free(e: [*c]graphene_euler_t) void;
pub extern fn graphene_euler_init(e: [*c]graphene_euler_t, x: f32, y: f32, z: f32) [*c]graphene_euler_t;
pub extern fn graphene_euler_init_with_order(e: [*c]graphene_euler_t, x: f32, y: f32, z: f32, order: graphene_euler_order_t) [*c]graphene_euler_t;
pub extern fn graphene_euler_init_from_matrix(e: [*c]graphene_euler_t, m: [*c]const graphene_matrix_t, order: graphene_euler_order_t) [*c]graphene_euler_t;
pub extern fn graphene_euler_init_from_quaternion(e: [*c]graphene_euler_t, q: [*c]const graphene_quaternion_t, order: graphene_euler_order_t) [*c]graphene_euler_t;
pub extern fn graphene_euler_init_from_vec3(e: [*c]graphene_euler_t, v: [*c]const graphene_vec3_t, order: graphene_euler_order_t) [*c]graphene_euler_t;
pub extern fn graphene_euler_init_from_euler(e: [*c]graphene_euler_t, src: [*c]const graphene_euler_t) [*c]graphene_euler_t;
pub extern fn graphene_euler_init_from_radians(e: [*c]graphene_euler_t, x: f32, y: f32, z: f32, order: graphene_euler_order_t) [*c]graphene_euler_t;
pub extern fn graphene_euler_equal(a: [*c]const graphene_euler_t, b: [*c]const graphene_euler_t) bool;
pub extern fn graphene_euler_get_x(e: [*c]const graphene_euler_t) f32;
pub extern fn graphene_euler_get_y(e: [*c]const graphene_euler_t) f32;
pub extern fn graphene_euler_get_z(e: [*c]const graphene_euler_t) f32;
pub extern fn graphene_euler_get_order(e: [*c]const graphene_euler_t) graphene_euler_order_t;
pub extern fn graphene_euler_get_alpha(e: [*c]const graphene_euler_t) f32;
pub extern fn graphene_euler_get_beta(e: [*c]const graphene_euler_t) f32;
pub extern fn graphene_euler_get_gamma(e: [*c]const graphene_euler_t) f32;
pub extern fn graphene_euler_to_vec3(e: [*c]const graphene_euler_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_euler_to_matrix(e: [*c]const graphene_euler_t, res: [*c]graphene_matrix_t) void;
pub extern fn graphene_euler_to_quaternion(e: [*c]const graphene_euler_t, res: [*c]graphene_quaternion_t) void;
pub extern fn graphene_euler_reorder(e: [*c]const graphene_euler_t, order: graphene_euler_order_t, res: [*c]graphene_euler_t) void;
pub extern fn graphene_plane_alloc() [*c]graphene_plane_t;
pub extern fn graphene_plane_free(p: [*c]graphene_plane_t) void;
pub extern fn graphene_plane_init(p: [*c]graphene_plane_t, normal: [*c]const graphene_vec3_t, constant: f32) [*c]graphene_plane_t;
pub extern fn graphene_plane_init_from_vec4(p: [*c]graphene_plane_t, src: [*c]const graphene_vec4_t) [*c]graphene_plane_t;
pub extern fn graphene_plane_init_from_plane(p: [*c]graphene_plane_t, src: [*c]const graphene_plane_t) [*c]graphene_plane_t;
pub extern fn graphene_plane_init_from_point(p: [*c]graphene_plane_t, normal: [*c]const graphene_vec3_t, point: [*c]const graphene_point3d_t) [*c]graphene_plane_t;
pub extern fn graphene_plane_init_from_points(p: [*c]graphene_plane_t, a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t, c: [*c]const graphene_point3d_t) [*c]graphene_plane_t;
pub extern fn graphene_plane_normalize(p: [*c]const graphene_plane_t, res: [*c]graphene_plane_t) void;
pub extern fn graphene_plane_negate(p: [*c]const graphene_plane_t, res: [*c]graphene_plane_t) void;
pub extern fn graphene_plane_equal(a: [*c]const graphene_plane_t, b: [*c]const graphene_plane_t) bool;
pub extern fn graphene_plane_distance(p: [*c]const graphene_plane_t, point: [*c]const graphene_point3d_t) f32;
pub extern fn graphene_plane_get_normal(p: [*c]const graphene_plane_t, normal: [*c]graphene_vec3_t) void;
pub extern fn graphene_plane_get_constant(p: [*c]const graphene_plane_t) f32;
pub extern fn graphene_plane_transform(p: [*c]const graphene_plane_t, matrix: [*c]const graphene_matrix_t, normal_matrix: [*c]const graphene_matrix_t, res: [*c]graphene_plane_t) void;
pub extern fn graphene_frustum_alloc() [*c]graphene_frustum_t;
pub extern fn graphene_frustum_free(f: [*c]graphene_frustum_t) void;
pub extern fn graphene_frustum_init(f: [*c]graphene_frustum_t, p0: [*c]const graphene_plane_t, p1: [*c]const graphene_plane_t, p2: [*c]const graphene_plane_t, p3: [*c]const graphene_plane_t, p4: [*c]const graphene_plane_t, p5: [*c]const graphene_plane_t) [*c]graphene_frustum_t;
pub extern fn graphene_frustum_init_from_frustum(f: [*c]graphene_frustum_t, src: [*c]const graphene_frustum_t) [*c]graphene_frustum_t;
pub extern fn graphene_frustum_init_from_matrix(f: [*c]graphene_frustum_t, matrix: [*c]const graphene_matrix_t) [*c]graphene_frustum_t;
pub extern fn graphene_frustum_contains_point(f: [*c]const graphene_frustum_t, point: [*c]const graphene_point3d_t) bool;
pub extern fn graphene_frustum_intersects_sphere(f: [*c]const graphene_frustum_t, sphere: [*c]const graphene_sphere_t) bool;
pub extern fn graphene_frustum_intersects_box(f: [*c]const graphene_frustum_t, box: [*c]const graphene_box_t) bool;
pub extern fn graphene_frustum_get_planes(f: [*c]const graphene_frustum_t, planes: [*c]graphene_plane_t) void;
pub extern fn graphene_frustum_equal(a: [*c]const graphene_frustum_t, b: [*c]const graphene_frustum_t) bool;
pub extern fn graphene_sphere_alloc() [*c]graphene_sphere_t;
pub extern fn graphene_sphere_free(s: [*c]graphene_sphere_t) void;
pub extern fn graphene_sphere_init(s: [*c]graphene_sphere_t, center: [*c]const graphene_point3d_t, radius: f32) [*c]graphene_sphere_t;
pub extern fn graphene_sphere_init_from_points(s: [*c]graphene_sphere_t, n_points: c_uint, points: [*c]const graphene_point3d_t, center: [*c]const graphene_point3d_t) [*c]graphene_sphere_t;
pub extern fn graphene_sphere_init_from_vectors(s: [*c]graphene_sphere_t, n_vectors: c_uint, vectors: [*c]const graphene_vec3_t, center: [*c]const graphene_point3d_t) [*c]graphene_sphere_t;
pub extern fn graphene_sphere_get_center(s: [*c]const graphene_sphere_t, center: [*c]graphene_point3d_t) void;
pub extern fn graphene_sphere_get_radius(s: [*c]const graphene_sphere_t) f32;
pub extern fn graphene_sphere_is_empty(s: [*c]const graphene_sphere_t) bool;
pub extern fn graphene_sphere_equal(a: [*c]const graphene_sphere_t, b: [*c]const graphene_sphere_t) bool;
pub extern fn graphene_sphere_contains_point(s: [*c]const graphene_sphere_t, point: [*c]const graphene_point3d_t) bool;
pub extern fn graphene_sphere_distance(s: [*c]const graphene_sphere_t, point: [*c]const graphene_point3d_t) f32;
pub extern fn graphene_sphere_get_bounding_box(s: [*c]const graphene_sphere_t, box: [*c]graphene_box_t) void;
pub extern fn graphene_sphere_translate(s: [*c]const graphene_sphere_t, point: [*c]const graphene_point3d_t, res: [*c]graphene_sphere_t) void;
pub extern fn graphene_box_alloc() [*c]graphene_box_t;
pub extern fn graphene_box_free(box: [*c]graphene_box_t) void;
pub extern fn graphene_box_init(box: [*c]graphene_box_t, min: [*c]const graphene_point3d_t, max: [*c]const graphene_point3d_t) [*c]graphene_box_t;
pub extern fn graphene_box_init_from_points(box: [*c]graphene_box_t, n_points: c_uint, points: [*c]const graphene_point3d_t) [*c]graphene_box_t;
pub extern fn graphene_box_init_from_vectors(box: [*c]graphene_box_t, n_vectors: c_uint, vectors: [*c]const graphene_vec3_t) [*c]graphene_box_t;
pub extern fn graphene_box_init_from_box(box: [*c]graphene_box_t, src: [*c]const graphene_box_t) [*c]graphene_box_t;
pub extern fn graphene_box_init_from_vec3(box: [*c]graphene_box_t, min: [*c]const graphene_vec3_t, max: [*c]const graphene_vec3_t) [*c]graphene_box_t;
pub extern fn graphene_box_expand(box: [*c]const graphene_box_t, point: [*c]const graphene_point3d_t, res: [*c]graphene_box_t) void;
pub extern fn graphene_box_expand_vec3(box: [*c]const graphene_box_t, vec: [*c]const graphene_vec3_t, res: [*c]graphene_box_t) void;
pub extern fn graphene_box_expand_scalar(box: [*c]const graphene_box_t, scalar: f32, res: [*c]graphene_box_t) void;
pub extern fn graphene_box_union(a: [*c]const graphene_box_t, b: [*c]const graphene_box_t, res: [*c]graphene_box_t) void;
pub extern fn graphene_box_intersection(a: [*c]const graphene_box_t, b: [*c]const graphene_box_t, res: [*c]graphene_box_t) bool;
pub extern fn graphene_box_get_width(box: [*c]const graphene_box_t) f32;
pub extern fn graphene_box_get_height(box: [*c]const graphene_box_t) f32;
pub extern fn graphene_box_get_depth(box: [*c]const graphene_box_t) f32;
pub extern fn graphene_box_get_size(box: [*c]const graphene_box_t, size: [*c]graphene_vec3_t) void;
pub extern fn graphene_box_get_center(box: [*c]const graphene_box_t, center: [*c]graphene_point3d_t) void;
pub extern fn graphene_box_get_min(box: [*c]const graphene_box_t, min: [*c]graphene_point3d_t) void;
pub extern fn graphene_box_get_max(box: [*c]const graphene_box_t, max: [*c]graphene_point3d_t) void;
pub extern fn graphene_box_get_vertices(box: [*c]const graphene_box_t, vertices: [*c]graphene_vec3_t) void;
pub extern fn graphene_box_get_bounding_sphere(box: [*c]const graphene_box_t, sphere: [*c]graphene_sphere_t) void;
pub extern fn graphene_box_contains_point(box: [*c]const graphene_box_t, point: [*c]const graphene_point3d_t) bool;
pub extern fn graphene_box_contains_box(a: [*c]const graphene_box_t, b: [*c]const graphene_box_t) bool;
pub extern fn graphene_box_equal(a: [*c]const graphene_box_t, b: [*c]const graphene_box_t) bool;
pub extern fn graphene_box_zero() [*c]const graphene_box_t;
pub extern fn graphene_box_one() [*c]const graphene_box_t;
pub extern fn graphene_box_minus_one() [*c]const graphene_box_t;
pub extern fn graphene_box_one_minus_one() [*c]const graphene_box_t;
pub extern fn graphene_box_infinite() [*c]const graphene_box_t;
pub extern fn graphene_box_empty() [*c]const graphene_box_t;
pub extern fn graphene_triangle_alloc() [*c]graphene_triangle_t;
pub extern fn graphene_triangle_free(t: [*c]graphene_triangle_t) void;
pub extern fn graphene_triangle_init_from_point3d(t: [*c]graphene_triangle_t, a: [*c]const graphene_point3d_t, b: [*c]const graphene_point3d_t, c: [*c]const graphene_point3d_t) [*c]graphene_triangle_t;
pub extern fn graphene_triangle_init_from_vec3(t: [*c]graphene_triangle_t, a: [*c]const graphene_vec3_t, b: [*c]const graphene_vec3_t, c: [*c]const graphene_vec3_t) [*c]graphene_triangle_t;
pub extern fn graphene_triangle_init_from_float(t: [*c]graphene_triangle_t, a: [*c]const f32, b: [*c]const f32, c: [*c]const f32) [*c]graphene_triangle_t;
pub extern fn graphene_triangle_get_points(t: [*c]const graphene_triangle_t, a: [*c]graphene_point3d_t, b: [*c]graphene_point3d_t, c: [*c]graphene_point3d_t) void;
pub extern fn graphene_triangle_get_vertices(t: [*c]const graphene_triangle_t, a: [*c]graphene_vec3_t, b: [*c]graphene_vec3_t, c: [*c]graphene_vec3_t) void;
pub extern fn graphene_triangle_get_area(t: [*c]const graphene_triangle_t) f32;
pub extern fn graphene_triangle_get_midpoint(t: [*c]const graphene_triangle_t, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_triangle_get_normal(t: [*c]const graphene_triangle_t, res: [*c]graphene_vec3_t) void;
pub extern fn graphene_triangle_get_plane(t: [*c]const graphene_triangle_t, res: [*c]graphene_plane_t) void;
pub extern fn graphene_triangle_get_bounding_box(t: [*c]const graphene_triangle_t, res: [*c]graphene_box_t) void;
pub extern fn graphene_triangle_get_barycoords(t: [*c]const graphene_triangle_t, p: [*c]const graphene_point3d_t, res: [*c]graphene_vec2_t) bool;
pub extern fn graphene_triangle_get_uv(t: [*c]const graphene_triangle_t, p: [*c]const graphene_point3d_t, uv_a: [*c]const graphene_vec2_t, uv_b: [*c]const graphene_vec2_t, uv_c: [*c]const graphene_vec2_t, res: [*c]graphene_vec2_t) bool;
pub extern fn graphene_triangle_contains_point(t: [*c]const graphene_triangle_t, p: [*c]const graphene_point3d_t) bool;
pub extern fn graphene_triangle_equal(a: [*c]const graphene_triangle_t, b: [*c]const graphene_triangle_t) bool;
pub const GRAPHENE_RAY_INTERSECTION_KIND_NONE: c_int = 0;
pub const GRAPHENE_RAY_INTERSECTION_KIND_ENTER: c_int = 1;
pub const GRAPHENE_RAY_INTERSECTION_KIND_LEAVE: c_int = 2;
pub const graphene_ray_intersection_kind_t = c_uint;
pub extern fn graphene_ray_alloc() [*c]graphene_ray_t;
pub extern fn graphene_ray_free(r: [*c]graphene_ray_t) void;
pub extern fn graphene_ray_init(r: [*c]graphene_ray_t, origin: [*c]const graphene_point3d_t, direction: [*c]const graphene_vec3_t) [*c]graphene_ray_t;
pub extern fn graphene_ray_init_from_ray(r: [*c]graphene_ray_t, src: [*c]const graphene_ray_t) [*c]graphene_ray_t;
pub extern fn graphene_ray_init_from_vec3(r: [*c]graphene_ray_t, origin: [*c]const graphene_vec3_t, direction: [*c]const graphene_vec3_t) [*c]graphene_ray_t;
pub extern fn graphene_ray_get_origin(r: [*c]const graphene_ray_t, origin: [*c]graphene_point3d_t) void;
pub extern fn graphene_ray_get_direction(r: [*c]const graphene_ray_t, direction: [*c]graphene_vec3_t) void;
pub extern fn graphene_ray_get_position_at(r: [*c]const graphene_ray_t, t: f32, position: [*c]graphene_point3d_t) void;
pub extern fn graphene_ray_get_distance_to_point(r: [*c]const graphene_ray_t, p: [*c]const graphene_point3d_t) f32;
pub extern fn graphene_ray_get_distance_to_plane(r: [*c]const graphene_ray_t, p: [*c]const graphene_plane_t) f32;
pub extern fn graphene_ray_equal(a: [*c]const graphene_ray_t, b: [*c]const graphene_ray_t) bool;
pub extern fn graphene_ray_get_closest_point_to_point(r: [*c]const graphene_ray_t, p: [*c]const graphene_point3d_t, res: [*c]graphene_point3d_t) void;
pub extern fn graphene_ray_intersect_sphere(r: [*c]const graphene_ray_t, s: [*c]const graphene_sphere_t, t_out: [*c]f32) graphene_ray_intersection_kind_t;
pub extern fn graphene_ray_intersects_sphere(r: [*c]const graphene_ray_t, s: [*c]const graphene_sphere_t) bool;
pub extern fn graphene_ray_intersect_box(r: [*c]const graphene_ray_t, b: [*c]const graphene_box_t, t_out: [*c]f32) graphene_ray_intersection_kind_t;
pub extern fn graphene_ray_intersects_box(r: [*c]const graphene_ray_t, b: [*c]const graphene_box_t) bool;
pub extern fn graphene_ray_intersect_triangle(r: [*c]const graphene_ray_t, t: [*c]const graphene_triangle_t, t_out: [*c]f32) graphene_ray_intersection_kind_t;
pub extern fn graphene_ray_intersects_triangle(r: [*c]const graphene_ray_t, t: [*c]const graphene_triangle_t) bool;
pub const struct__GskRenderer = opaque {};
pub const GskRenderer = struct__GskRenderer;
pub const struct__GskTransform = opaque {};
pub const GskTransform = struct__GskTransform;
pub const struct__GskRoundedRect = extern struct {
    bounds: graphene_rect_t,
    corner: [4]graphene_size_t,
};
pub const GskRoundedRect = struct__GskRoundedRect;
pub extern fn gsk_rounded_rect_init(self: [*c]GskRoundedRect, bounds: [*c]const graphene_rect_t, top_left: [*c]const graphene_size_t, top_right: [*c]const graphene_size_t, bottom_right: [*c]const graphene_size_t, bottom_left: [*c]const graphene_size_t) [*c]GskRoundedRect;
pub extern fn gsk_rounded_rect_init_copy(self: [*c]GskRoundedRect, src: [*c]const GskRoundedRect) [*c]GskRoundedRect;
pub extern fn gsk_rounded_rect_init_from_rect(self: [*c]GskRoundedRect, bounds: [*c]const graphene_rect_t, radius: f32) [*c]GskRoundedRect;
pub extern fn gsk_rounded_rect_normalize(self: [*c]GskRoundedRect) [*c]GskRoundedRect;
pub extern fn gsk_rounded_rect_offset(self: [*c]GskRoundedRect, dx: f32, dy: f32) [*c]GskRoundedRect;
pub extern fn gsk_rounded_rect_shrink(self: [*c]GskRoundedRect, top: f32, right: f32, bottom: f32, left: f32) [*c]GskRoundedRect;
pub extern fn gsk_rounded_rect_is_rectilinear(self: [*c]const GskRoundedRect) gboolean;
pub extern fn gsk_rounded_rect_contains_point(self: [*c]const GskRoundedRect, point: [*c]const graphene_point_t) gboolean;
pub extern fn gsk_rounded_rect_contains_rect(self: [*c]const GskRoundedRect, rect: [*c]const graphene_rect_t) gboolean;
pub extern fn gsk_rounded_rect_intersects_rect(self: [*c]const GskRoundedRect, rect: [*c]const graphene_rect_t) gboolean;
pub const struct__GskShaderArgsBuilder = opaque {};
pub const GskShaderArgsBuilder = struct__GskShaderArgsBuilder;
pub extern fn gsk_gl_shader_get_type() GType;
pub const struct__GskGLShader = opaque {};
pub const GskGLShader = struct__GskGLShader;
pub const GskGLShaderClass = extern struct {
    parent_class: GObjectClass,
};
pub const GskGLShader_autoptr = ?*GskGLShader;
pub const GskGLShader_listautoptr = [*c]GList;
pub const GskGLShader_slistautoptr = [*c]GSList;
pub const GskGLShader_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GskGLShader(arg__ptr: ?*GskGLShader) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GskGLShader(arg__ptr: [*c]?*GskGLShader) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GskGLShader(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GskGLShader(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GskGLShader(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GskGLShader(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GskGLShaderClass_autoptr = [*c]GskGLShaderClass;
pub const GskGLShaderClass_listautoptr = [*c]GList;
pub const GskGLShaderClass_slistautoptr = [*c]GSList;
pub const GskGLShaderClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GskGLShaderClass(arg__ptr: [*c]GskGLShaderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GskGLShaderClass(arg__ptr: [*c][*c]GskGLShaderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GskGLShaderClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GskGLShaderClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GskGLShaderClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GskGLShaderClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GSK_GL_SHADER(arg_ptr: gpointer) callconv(.C) ?*GskGLShader {
    var ptr = arg_ptr;
    return @as(?*GskGLShader, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gsk_gl_shader_get_type())))));
}
pub fn GSK_IS_GL_SHADER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gsk_gl_shader_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gsk_gl_shader_new_from_bytes(sourcecode: ?*GBytes) ?*GskGLShader;
pub extern fn gsk_gl_shader_new_from_resource(resource_path: [*c]const u8) ?*GskGLShader;
pub extern fn gsk_gl_shader_compile(shader: ?*GskGLShader, renderer: ?*GskRenderer, @"error": [*c][*c]GError) gboolean;
pub extern fn gsk_gl_shader_get_source(shader: ?*GskGLShader) ?*GBytes;
pub extern fn gsk_gl_shader_get_resource(shader: ?*GskGLShader) [*c]const u8;
pub extern fn gsk_gl_shader_get_n_textures(shader: ?*GskGLShader) c_int;
pub extern fn gsk_gl_shader_get_n_uniforms(shader: ?*GskGLShader) c_int;
pub extern fn gsk_gl_shader_get_uniform_name(shader: ?*GskGLShader, idx: c_int) [*c]const u8;
pub extern fn gsk_gl_shader_find_uniform_by_name(shader: ?*GskGLShader, name: [*c]const u8) c_int;
pub extern fn gsk_gl_shader_get_uniform_type(shader: ?*GskGLShader, idx: c_int) GskGLUniformType;
pub extern fn gsk_gl_shader_get_uniform_offset(shader: ?*GskGLShader, idx: c_int) c_int;
pub extern fn gsk_gl_shader_get_args_size(shader: ?*GskGLShader) gsize;
pub extern fn gsk_gl_shader_format_args_va(shader: ?*GskGLShader, uniforms: [*c]struct___va_list_tag) ?*GBytes;
pub extern fn gsk_gl_shader_format_args(shader: ?*GskGLShader, ...) ?*GBytes;
pub extern fn gsk_gl_shader_get_arg_float(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int) f32;
pub extern fn gsk_gl_shader_get_arg_int(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int) gint32;
pub extern fn gsk_gl_shader_get_arg_uint(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int) guint32;
pub extern fn gsk_gl_shader_get_arg_bool(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int) gboolean;
pub extern fn gsk_gl_shader_get_arg_vec2(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int, out_value: [*c]graphene_vec2_t) void;
pub extern fn gsk_gl_shader_get_arg_vec3(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int, out_value: [*c]graphene_vec3_t) void;
pub extern fn gsk_gl_shader_get_arg_vec4(shader: ?*GskGLShader, args: ?*GBytes, idx: c_int, out_value: [*c]graphene_vec4_t) void;
pub extern fn gsk_shader_args_builder_get_type() GType;
pub extern fn gsk_shader_args_builder_new(shader: ?*GskGLShader, initial_values: ?*GBytes) ?*GskShaderArgsBuilder;
pub extern fn gsk_shader_args_builder_to_args(builder: ?*GskShaderArgsBuilder) ?*GBytes;
pub extern fn gsk_shader_args_builder_free_to_args(builder: ?*GskShaderArgsBuilder) ?*GBytes;
pub extern fn gsk_shader_args_builder_ref(builder: ?*GskShaderArgsBuilder) ?*GskShaderArgsBuilder;
pub extern fn gsk_shader_args_builder_unref(builder: ?*GskShaderArgsBuilder) void;
pub extern fn gsk_shader_args_builder_set_float(builder: ?*GskShaderArgsBuilder, idx: c_int, value: f32) void;
pub extern fn gsk_shader_args_builder_set_int(builder: ?*GskShaderArgsBuilder, idx: c_int, value: gint32) void;
pub extern fn gsk_shader_args_builder_set_uint(builder: ?*GskShaderArgsBuilder, idx: c_int, value: guint32) void;
pub extern fn gsk_shader_args_builder_set_bool(builder: ?*GskShaderArgsBuilder, idx: c_int, value: gboolean) void;
pub extern fn gsk_shader_args_builder_set_vec2(builder: ?*GskShaderArgsBuilder, idx: c_int, value: [*c]const graphene_vec2_t) void;
pub extern fn gsk_shader_args_builder_set_vec3(builder: ?*GskShaderArgsBuilder, idx: c_int, value: [*c]const graphene_vec3_t) void;
pub extern fn gsk_shader_args_builder_set_vec4(builder: ?*GskShaderArgsBuilder, idx: c_int, value: [*c]const graphene_vec4_t) void;
pub const struct__GskRenderNode = opaque {};
pub const GskRenderNode = struct__GskRenderNode;
pub const struct__GskColorStop = extern struct {
    offset: f32,
    color: GdkRGBA,
};
pub const GskColorStop = struct__GskColorStop;
pub const struct__GskShadow = extern struct {
    color: GdkRGBA,
    dx: f32,
    dy: f32,
    radius: f32,
};
pub const GskShadow = struct__GskShadow;
pub const struct__GskParseLocation = extern struct {
    bytes: gsize,
    chars: gsize,
    lines: gsize,
    line_bytes: gsize,
    line_chars: gsize,
};
pub const GskParseLocation = struct__GskParseLocation;
pub const GskParseErrorFunc = ?*const fn ([*c]const GskParseLocation, [*c]const GskParseLocation, [*c]const GError, gpointer) callconv(.C) void;
pub extern fn gsk_render_node_get_type() GType;
pub extern fn gsk_serialization_error_quark() GQuark;
pub extern fn gsk_render_node_ref(node: ?*GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_render_node_unref(node: ?*GskRenderNode) void;
pub extern fn gsk_render_node_get_node_type(node: ?*const GskRenderNode) GskRenderNodeType;
pub extern fn gsk_render_node_get_bounds(node: ?*GskRenderNode, bounds: [*c]graphene_rect_t) void;
pub extern fn gsk_render_node_draw(node: ?*GskRenderNode, cr: ?*cairo_t) void;
pub extern fn gsk_render_node_serialize(node: ?*GskRenderNode) ?*GBytes;
pub extern fn gsk_render_node_write_to_file(node: ?*GskRenderNode, filename: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gsk_render_node_deserialize(bytes: ?*GBytes, error_func: GskParseErrorFunc, user_data: gpointer) ?*GskRenderNode;
pub const struct__GskDebugNode = opaque {};
pub const GskDebugNode = struct__GskDebugNode;
pub const struct__GskColorNode = opaque {};
pub const GskColorNode = struct__GskColorNode;
pub const struct__GskTextureNode = opaque {};
pub const GskTextureNode = struct__GskTextureNode;
pub const struct__GskTextureScaleNode = opaque {};
pub const GskTextureScaleNode = struct__GskTextureScaleNode;
pub const struct__GskLinearGradientNode = opaque {};
pub const GskLinearGradientNode = struct__GskLinearGradientNode;
pub const struct__GskRepeatingLinearGradientNode = opaque {};
pub const GskRepeatingLinearGradientNode = struct__GskRepeatingLinearGradientNode;
pub const struct__GskRadialGradientNode = opaque {};
pub const GskRadialGradientNode = struct__GskRadialGradientNode;
pub const struct__GskRepeatingRadialGradientNode = opaque {};
pub const GskRepeatingRadialGradientNode = struct__GskRepeatingRadialGradientNode;
pub const struct__GskConicGradientNode = opaque {};
pub const GskConicGradientNode = struct__GskConicGradientNode;
pub const struct__GskBorderNode = opaque {};
pub const GskBorderNode = struct__GskBorderNode;
pub const struct__GskInsetShadowNode = opaque {};
pub const GskInsetShadowNode = struct__GskInsetShadowNode;
pub const struct__GskOutsetShadowNode = opaque {};
pub const GskOutsetShadowNode = struct__GskOutsetShadowNode;
pub const struct__GskCairoNode = opaque {};
pub const GskCairoNode = struct__GskCairoNode;
pub const struct__GskContainerNode = opaque {};
pub const GskContainerNode = struct__GskContainerNode;
pub const struct__GskTransformNode = opaque {};
pub const GskTransformNode = struct__GskTransformNode;
pub const struct__GskOpacityNode = opaque {};
pub const GskOpacityNode = struct__GskOpacityNode;
pub const struct__GskColorMatrixNode = opaque {};
pub const GskColorMatrixNode = struct__GskColorMatrixNode;
pub const struct__GskRepeatNode = opaque {};
pub const GskRepeatNode = struct__GskRepeatNode;
pub const struct__GskClipNode = opaque {};
pub const GskClipNode = struct__GskClipNode;
pub const struct__GskRoundedClipNode = opaque {};
pub const GskRoundedClipNode = struct__GskRoundedClipNode;
pub const struct__GskShadowNode = opaque {};
pub const GskShadowNode = struct__GskShadowNode;
pub const struct__GskBlendNode = opaque {};
pub const GskBlendNode = struct__GskBlendNode;
pub const struct__GskCrossFadeNode = opaque {};
pub const GskCrossFadeNode = struct__GskCrossFadeNode;
pub const struct__GskTextNode = opaque {};
pub const GskTextNode = struct__GskTextNode;
pub const struct__GskBlurNode = opaque {};
pub const GskBlurNode = struct__GskBlurNode;
pub const struct__GskMaskNode = opaque {};
pub const GskMaskNode = struct__GskMaskNode;
pub const struct__GskGLShaderNode = opaque {};
pub const GskGLShaderNode = struct__GskGLShaderNode;
pub extern fn gsk_debug_node_get_type() GType;
pub extern fn gsk_debug_node_new(child: ?*GskRenderNode, message: [*c]u8) ?*GskRenderNode;
pub extern fn gsk_debug_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_debug_node_get_message(node: ?*const GskRenderNode) [*c]const u8;
pub extern fn gsk_color_node_get_type() GType;
pub extern fn gsk_color_node_new(rgba: [*c]const GdkRGBA, bounds: [*c]const graphene_rect_t) ?*GskRenderNode;
pub extern fn gsk_color_node_get_color(node: ?*const GskRenderNode) [*c]const GdkRGBA;
pub extern fn gsk_texture_node_get_type() GType;
pub extern fn gsk_texture_node_new(texture: ?*GdkTexture, bounds: [*c]const graphene_rect_t) ?*GskRenderNode;
pub extern fn gsk_texture_node_get_texture(node: ?*const GskRenderNode) ?*GdkTexture;
pub extern fn gsk_texture_scale_node_get_type() GType;
pub extern fn gsk_texture_scale_node_new(texture: ?*GdkTexture, bounds: [*c]const graphene_rect_t, filter: GskScalingFilter) ?*GskRenderNode;
pub extern fn gsk_texture_scale_node_get_texture(node: ?*const GskRenderNode) ?*GdkTexture;
pub extern fn gsk_texture_scale_node_get_filter(node: ?*const GskRenderNode) GskScalingFilter;
pub extern fn gsk_linear_gradient_node_get_type() GType;
pub extern fn gsk_linear_gradient_node_new(bounds: [*c]const graphene_rect_t, start: [*c]const graphene_point_t, end: [*c]const graphene_point_t, color_stops: [*c]const GskColorStop, n_color_stops: gsize) ?*GskRenderNode;
pub extern fn gsk_linear_gradient_node_get_start(node: ?*const GskRenderNode) [*c]const graphene_point_t;
pub extern fn gsk_linear_gradient_node_get_end(node: ?*const GskRenderNode) [*c]const graphene_point_t;
pub extern fn gsk_linear_gradient_node_get_n_color_stops(node: ?*const GskRenderNode) gsize;
pub extern fn gsk_linear_gradient_node_get_color_stops(node: ?*const GskRenderNode, n_stops: [*c]gsize) [*c]const GskColorStop;
pub extern fn gsk_repeating_linear_gradient_node_get_type() GType;
pub extern fn gsk_repeating_linear_gradient_node_new(bounds: [*c]const graphene_rect_t, start: [*c]const graphene_point_t, end: [*c]const graphene_point_t, color_stops: [*c]const GskColorStop, n_color_stops: gsize) ?*GskRenderNode;
pub extern fn gsk_conic_gradient_node_get_type() GType;
pub extern fn gsk_conic_gradient_node_new(bounds: [*c]const graphene_rect_t, center: [*c]const graphene_point_t, rotation: f32, color_stops: [*c]const GskColorStop, n_color_stops: gsize) ?*GskRenderNode;
pub extern fn gsk_conic_gradient_node_get_center(node: ?*const GskRenderNode) [*c]const graphene_point_t;
pub extern fn gsk_conic_gradient_node_get_rotation(node: ?*const GskRenderNode) f32;
pub extern fn gsk_conic_gradient_node_get_angle(node: ?*const GskRenderNode) f32;
pub extern fn gsk_conic_gradient_node_get_n_color_stops(node: ?*const GskRenderNode) gsize;
pub extern fn gsk_conic_gradient_node_get_color_stops(node: ?*const GskRenderNode, n_stops: [*c]gsize) [*c]const GskColorStop;
pub extern fn gsk_radial_gradient_node_get_type() GType;
pub extern fn gsk_radial_gradient_node_new(bounds: [*c]const graphene_rect_t, center: [*c]const graphene_point_t, hradius: f32, vradius: f32, start: f32, end: f32, color_stops: [*c]const GskColorStop, n_color_stops: gsize) ?*GskRenderNode;
pub extern fn gsk_radial_gradient_node_get_n_color_stops(node: ?*const GskRenderNode) gsize;
pub extern fn gsk_radial_gradient_node_get_color_stops(node: ?*const GskRenderNode, n_stops: [*c]gsize) [*c]const GskColorStop;
pub extern fn gsk_radial_gradient_node_get_center(node: ?*const GskRenderNode) [*c]const graphene_point_t;
pub extern fn gsk_radial_gradient_node_get_hradius(node: ?*const GskRenderNode) f32;
pub extern fn gsk_radial_gradient_node_get_vradius(node: ?*const GskRenderNode) f32;
pub extern fn gsk_radial_gradient_node_get_start(node: ?*const GskRenderNode) f32;
pub extern fn gsk_radial_gradient_node_get_end(node: ?*const GskRenderNode) f32;
pub extern fn gsk_repeating_radial_gradient_node_get_type() GType;
pub extern fn gsk_repeating_radial_gradient_node_new(bounds: [*c]const graphene_rect_t, center: [*c]const graphene_point_t, hradius: f32, vradius: f32, start: f32, end: f32, color_stops: [*c]const GskColorStop, n_color_stops: gsize) ?*GskRenderNode;
pub extern fn gsk_border_node_get_type() GType;
pub extern fn gsk_border_node_new(outline: [*c]const GskRoundedRect, border_width: [*c]const f32, border_color: [*c]const GdkRGBA) ?*GskRenderNode;
pub extern fn gsk_border_node_get_outline(node: ?*const GskRenderNode) [*c]const GskRoundedRect;
pub extern fn gsk_border_node_get_widths(node: ?*const GskRenderNode) [*c]const f32;
pub extern fn gsk_border_node_get_colors(node: ?*const GskRenderNode) [*c]const GdkRGBA;
pub extern fn gsk_inset_shadow_node_get_type() GType;
pub extern fn gsk_inset_shadow_node_new(outline: [*c]const GskRoundedRect, color: [*c]const GdkRGBA, dx: f32, dy: f32, spread: f32, blur_radius: f32) ?*GskRenderNode;
pub extern fn gsk_inset_shadow_node_get_outline(node: ?*const GskRenderNode) [*c]const GskRoundedRect;
pub extern fn gsk_inset_shadow_node_get_color(node: ?*const GskRenderNode) [*c]const GdkRGBA;
pub extern fn gsk_inset_shadow_node_get_dx(node: ?*const GskRenderNode) f32;
pub extern fn gsk_inset_shadow_node_get_dy(node: ?*const GskRenderNode) f32;
pub extern fn gsk_inset_shadow_node_get_spread(node: ?*const GskRenderNode) f32;
pub extern fn gsk_inset_shadow_node_get_blur_radius(node: ?*const GskRenderNode) f32;
pub extern fn gsk_outset_shadow_node_get_type() GType;
pub extern fn gsk_outset_shadow_node_new(outline: [*c]const GskRoundedRect, color: [*c]const GdkRGBA, dx: f32, dy: f32, spread: f32, blur_radius: f32) ?*GskRenderNode;
pub extern fn gsk_outset_shadow_node_get_outline(node: ?*const GskRenderNode) [*c]const GskRoundedRect;
pub extern fn gsk_outset_shadow_node_get_color(node: ?*const GskRenderNode) [*c]const GdkRGBA;
pub extern fn gsk_outset_shadow_node_get_dx(node: ?*const GskRenderNode) f32;
pub extern fn gsk_outset_shadow_node_get_dy(node: ?*const GskRenderNode) f32;
pub extern fn gsk_outset_shadow_node_get_spread(node: ?*const GskRenderNode) f32;
pub extern fn gsk_outset_shadow_node_get_blur_radius(node: ?*const GskRenderNode) f32;
pub extern fn gsk_cairo_node_get_type() GType;
pub extern fn gsk_cairo_node_new(bounds: [*c]const graphene_rect_t) ?*GskRenderNode;
pub extern fn gsk_cairo_node_get_draw_context(node: ?*GskRenderNode) ?*cairo_t;
pub extern fn gsk_cairo_node_get_surface(node: ?*GskRenderNode) ?*cairo_surface_t;
pub extern fn gsk_container_node_get_type() GType;
pub extern fn gsk_container_node_new(children: [*c]?*GskRenderNode, n_children: guint) ?*GskRenderNode;
pub extern fn gsk_container_node_get_n_children(node: ?*const GskRenderNode) guint;
pub extern fn gsk_container_node_get_child(node: ?*const GskRenderNode, idx: guint) ?*GskRenderNode;
pub extern fn gsk_transform_node_get_type() GType;
pub extern fn gsk_transform_node_new(child: ?*GskRenderNode, transform: ?*GskTransform) ?*GskRenderNode;
pub extern fn gsk_transform_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_transform_node_get_transform(node: ?*const GskRenderNode) ?*GskTransform;
pub extern fn gsk_opacity_node_get_type() GType;
pub extern fn gsk_opacity_node_new(child: ?*GskRenderNode, opacity: f32) ?*GskRenderNode;
pub extern fn gsk_opacity_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_opacity_node_get_opacity(node: ?*const GskRenderNode) f32;
pub extern fn gsk_color_matrix_node_get_type() GType;
pub extern fn gsk_color_matrix_node_new(child: ?*GskRenderNode, color_matrix: [*c]const graphene_matrix_t, color_offset: [*c]const graphene_vec4_t) ?*GskRenderNode;
pub extern fn gsk_color_matrix_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_color_matrix_node_get_color_matrix(node: ?*const GskRenderNode) [*c]const graphene_matrix_t;
pub extern fn gsk_color_matrix_node_get_color_offset(node: ?*const GskRenderNode) [*c]const graphene_vec4_t;
pub extern fn gsk_repeat_node_get_type() GType;
pub extern fn gsk_repeat_node_new(bounds: [*c]const graphene_rect_t, child: ?*GskRenderNode, child_bounds: [*c]const graphene_rect_t) ?*GskRenderNode;
pub extern fn gsk_repeat_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_repeat_node_get_child_bounds(node: ?*const GskRenderNode) [*c]const graphene_rect_t;
pub extern fn gsk_clip_node_get_type() GType;
pub extern fn gsk_clip_node_new(child: ?*GskRenderNode, clip: [*c]const graphene_rect_t) ?*GskRenderNode;
pub extern fn gsk_clip_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_clip_node_get_clip(node: ?*const GskRenderNode) [*c]const graphene_rect_t;
pub extern fn gsk_rounded_clip_node_get_type() GType;
pub extern fn gsk_rounded_clip_node_new(child: ?*GskRenderNode, clip: [*c]const GskRoundedRect) ?*GskRenderNode;
pub extern fn gsk_rounded_clip_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_rounded_clip_node_get_clip(node: ?*const GskRenderNode) [*c]const GskRoundedRect;
pub extern fn gsk_shadow_node_get_type() GType;
pub extern fn gsk_shadow_node_new(child: ?*GskRenderNode, shadows: [*c]const GskShadow, n_shadows: gsize) ?*GskRenderNode;
pub extern fn gsk_shadow_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_shadow_node_get_shadow(node: ?*const GskRenderNode, i: gsize) [*c]const GskShadow;
pub extern fn gsk_shadow_node_get_n_shadows(node: ?*const GskRenderNode) gsize;
pub extern fn gsk_blend_node_get_type() GType;
pub extern fn gsk_blend_node_new(bottom: ?*GskRenderNode, top: ?*GskRenderNode, blend_mode: GskBlendMode) ?*GskRenderNode;
pub extern fn gsk_blend_node_get_bottom_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_blend_node_get_top_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_blend_node_get_blend_mode(node: ?*const GskRenderNode) GskBlendMode;
pub extern fn gsk_cross_fade_node_get_type() GType;
pub extern fn gsk_cross_fade_node_new(start: ?*GskRenderNode, end: ?*GskRenderNode, progress: f32) ?*GskRenderNode;
pub extern fn gsk_cross_fade_node_get_start_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_cross_fade_node_get_end_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_cross_fade_node_get_progress(node: ?*const GskRenderNode) f32;
pub extern fn gsk_text_node_get_type() GType;
pub extern fn gsk_text_node_new(font: [*c]PangoFont, glyphs: [*c]PangoGlyphString, color: [*c]const GdkRGBA, offset: [*c]const graphene_point_t) ?*GskRenderNode;
pub extern fn gsk_text_node_get_font(node: ?*const GskRenderNode) [*c]PangoFont;
pub extern fn gsk_text_node_has_color_glyphs(node: ?*const GskRenderNode) gboolean;
pub extern fn gsk_text_node_get_num_glyphs(node: ?*const GskRenderNode) guint;
pub extern fn gsk_text_node_get_glyphs(node: ?*const GskRenderNode, n_glyphs: [*c]guint) ?*const PangoGlyphInfo;
pub extern fn gsk_text_node_get_color(node: ?*const GskRenderNode) [*c]const GdkRGBA;
pub extern fn gsk_text_node_get_offset(node: ?*const GskRenderNode) [*c]const graphene_point_t;
pub extern fn gsk_blur_node_get_type() GType;
pub extern fn gsk_blur_node_new(child: ?*GskRenderNode, radius: f32) ?*GskRenderNode;
pub extern fn gsk_blur_node_get_child(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_blur_node_get_radius(node: ?*const GskRenderNode) f32;
pub extern fn gsk_mask_node_get_type() GType;
pub extern fn gsk_mask_node_new(source: ?*GskRenderNode, mask: ?*GskRenderNode, mask_mode: GskMaskMode) ?*GskRenderNode;
pub extern fn gsk_mask_node_get_source(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_mask_node_get_mask(node: ?*const GskRenderNode) ?*GskRenderNode;
pub extern fn gsk_mask_node_get_mask_mode(node: ?*const GskRenderNode) GskMaskMode;
pub extern fn gsk_gl_shader_node_get_type() GType;
pub extern fn gsk_gl_shader_node_new(shader: ?*GskGLShader, bounds: [*c]const graphene_rect_t, args: ?*GBytes, children: [*c]?*GskRenderNode, n_children: guint) ?*GskRenderNode;
pub extern fn gsk_gl_shader_node_get_n_children(node: ?*const GskRenderNode) guint;
pub extern fn gsk_gl_shader_node_get_child(node: ?*const GskRenderNode, idx: guint) ?*GskRenderNode;
pub extern fn gsk_gl_shader_node_get_args(node: ?*const GskRenderNode) ?*GBytes;
pub extern fn gsk_gl_shader_node_get_shader(node: ?*const GskRenderNode) ?*GskGLShader;
pub extern fn gsk_value_set_render_node(value: [*c]GValue, node: ?*GskRenderNode) void;
pub extern fn gsk_value_take_render_node(value: [*c]GValue, node: ?*GskRenderNode) void;
pub extern fn gsk_value_get_render_node(value: [*c]const GValue) ?*GskRenderNode;
pub extern fn gsk_value_dup_render_node(value: [*c]const GValue) ?*GskRenderNode;
pub const GskRenderNode_autoptr = ?*GskRenderNode;
pub const GskRenderNode_listautoptr = [*c]GList;
pub const GskRenderNode_slistautoptr = [*c]GSList;
pub const GskRenderNode_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GskRenderNode(arg__ptr: ?*GskRenderNode) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gsk_render_node_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GskRenderNode(arg__ptr: [*c]?*GskRenderNode) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GskRenderNode(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GskRenderNode(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gsk_render_node_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GskRenderNode(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gsk_render_node_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GskRenderNode(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gsk_render_node_unref)))))));
    }
}
pub const struct__GskRendererClass = opaque {};
pub const GskRendererClass = struct__GskRendererClass;
pub extern fn gsk_renderer_get_type() GType;
pub extern fn gsk_renderer_new_for_surface(surface: ?*GdkSurface) ?*GskRenderer;
pub extern fn gsk_renderer_get_surface(renderer: ?*GskRenderer) ?*GdkSurface;
pub extern fn gsk_renderer_realize(renderer: ?*GskRenderer, surface: ?*GdkSurface, @"error": [*c][*c]GError) gboolean;
pub extern fn gsk_renderer_unrealize(renderer: ?*GskRenderer) void;
pub extern fn gsk_renderer_is_realized(renderer: ?*GskRenderer) gboolean;
pub extern fn gsk_renderer_render_texture(renderer: ?*GskRenderer, root: ?*GskRenderNode, viewport: [*c]const graphene_rect_t) ?*GdkTexture;
pub extern fn gsk_renderer_render(renderer: ?*GskRenderer, root: ?*GskRenderNode, region: ?*const cairo_region_t) void;
pub const GskRenderer_autoptr = ?*GskRenderer;
pub const GskRenderer_listautoptr = [*c]GList;
pub const GskRenderer_slistautoptr = [*c]GSList;
pub const GskRenderer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GskRenderer(arg__ptr: ?*GskRenderer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GskRenderer(arg__ptr: [*c]?*GskRenderer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GskRenderer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GskRenderer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GskRenderer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GskRenderer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gsk_transform_get_type() GType;
pub extern fn gsk_transform_ref(self: ?*GskTransform) ?*GskTransform;
pub extern fn gsk_transform_unref(self: ?*GskTransform) void;
pub extern fn gsk_transform_print(self: ?*GskTransform, string: [*c]GString) void;
pub extern fn gsk_transform_to_string(self: ?*GskTransform) [*c]u8;
pub extern fn gsk_transform_parse(string: [*c]const u8, out_transform: [*c]?*GskTransform) gboolean;
pub extern fn gsk_transform_to_matrix(self: ?*GskTransform, out_matrix: [*c]graphene_matrix_t) void;
pub extern fn gsk_transform_to_2d(self: ?*GskTransform, out_xx: [*c]f32, out_yx: [*c]f32, out_xy: [*c]f32, out_yy: [*c]f32, out_dx: [*c]f32, out_dy: [*c]f32) void;
pub extern fn gsk_transform_to_2d_components(self: ?*GskTransform, out_skew_x: [*c]f32, out_skew_y: [*c]f32, out_scale_x: [*c]f32, out_scale_y: [*c]f32, out_angle: [*c]f32, out_dx: [*c]f32, out_dy: [*c]f32) void;
pub extern fn gsk_transform_to_affine(self: ?*GskTransform, out_scale_x: [*c]f32, out_scale_y: [*c]f32, out_dx: [*c]f32, out_dy: [*c]f32) void;
pub extern fn gsk_transform_to_translate(self: ?*GskTransform, out_dx: [*c]f32, out_dy: [*c]f32) void;
pub extern fn gsk_transform_get_category(self: ?*GskTransform) GskTransformCategory;
pub extern fn gsk_transform_equal(first: ?*GskTransform, second: ?*GskTransform) gboolean;
pub extern fn gsk_transform_new() ?*GskTransform;
pub extern fn gsk_transform_transform(next: ?*GskTransform, other: ?*GskTransform) ?*GskTransform;
pub extern fn gsk_transform_invert(self: ?*GskTransform) ?*GskTransform;
pub extern fn gsk_transform_matrix(next: ?*GskTransform, matrix: [*c]const graphene_matrix_t) ?*GskTransform;
pub extern fn gsk_transform_translate(next: ?*GskTransform, point: [*c]const graphene_point_t) ?*GskTransform;
pub extern fn gsk_transform_translate_3d(next: ?*GskTransform, point: [*c]const graphene_point3d_t) ?*GskTransform;
pub extern fn gsk_transform_skew(next: ?*GskTransform, skew_x: f32, skew_y: f32) ?*GskTransform;
pub extern fn gsk_transform_rotate(next: ?*GskTransform, angle: f32) ?*GskTransform;
pub extern fn gsk_transform_rotate_3d(next: ?*GskTransform, angle: f32, axis: [*c]const graphene_vec3_t) ?*GskTransform;
pub extern fn gsk_transform_scale(next: ?*GskTransform, factor_x: f32, factor_y: f32) ?*GskTransform;
pub extern fn gsk_transform_scale_3d(next: ?*GskTransform, factor_x: f32, factor_y: f32, factor_z: f32) ?*GskTransform;
pub extern fn gsk_transform_perspective(next: ?*GskTransform, depth: f32) ?*GskTransform;
pub extern fn gsk_transform_transform_bounds(self: ?*GskTransform, rect: [*c]const graphene_rect_t, out_rect: [*c]graphene_rect_t) void;
pub extern fn gsk_transform_transform_point(self: ?*GskTransform, point: [*c]const graphene_point_t, out_point: [*c]graphene_point_t) void;
pub const GskTransform_autoptr = ?*GskTransform;
pub const GskTransform_listautoptr = [*c]GList;
pub const GskTransform_slistautoptr = [*c]GSList;
pub const GskTransform_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GskTransform(arg__ptr: ?*GskTransform) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gsk_transform_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GskTransform(arg__ptr: [*c]?*GskTransform) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GskTransform(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GskTransform(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gsk_transform_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GskTransform(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gsk_transform_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GskTransform(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gsk_transform_unref)))))));
    }
}
pub const struct__GskCairoRenderer = opaque {};
pub const GskCairoRenderer = struct__GskCairoRenderer;
pub const struct__GskCairoRendererClass = opaque {};
pub const GskCairoRendererClass = struct__GskCairoRendererClass;
pub extern fn gsk_cairo_renderer_get_type() GType;
pub extern fn gsk_cairo_renderer_new() ?*GskRenderer;
pub extern fn gsk_render_node_type_get_type() GType;
pub extern fn gsk_scaling_filter_get_type() GType;
pub extern fn gsk_blend_mode_get_type() GType;
pub extern fn gsk_corner_get_type() GType;
pub extern fn gsk_serialization_error_get_type() GType;
pub extern fn gsk_transform_category_get_type() GType;
pub extern fn gsk_gl_uniform_type_get_type() GType;
pub extern fn gsk_mask_mode_get_type() GType;
pub const GTK_ALIGN_FILL: c_int = 0;
pub const GTK_ALIGN_START: c_int = 1;
pub const GTK_ALIGN_END: c_int = 2;
pub const GTK_ALIGN_CENTER: c_int = 3;
pub const GTK_ALIGN_BASELINE_FILL: c_int = 4;
pub const GTK_ALIGN_BASELINE: c_int = 4;
pub const GTK_ALIGN_BASELINE_CENTER: c_int = 5;
pub const GtkAlign = c_uint;
pub const GTK_ARROW_UP: c_int = 0;
pub const GTK_ARROW_DOWN: c_int = 1;
pub const GTK_ARROW_LEFT: c_int = 2;
pub const GTK_ARROW_RIGHT: c_int = 3;
pub const GTK_ARROW_NONE: c_int = 4;
pub const GtkArrowType = c_uint;
pub const GTK_BASELINE_POSITION_TOP: c_int = 0;
pub const GTK_BASELINE_POSITION_CENTER: c_int = 1;
pub const GTK_BASELINE_POSITION_BOTTOM: c_int = 2;
pub const GtkBaselinePosition = c_uint;
pub const GTK_CONTENT_FIT_FILL: c_int = 0;
pub const GTK_CONTENT_FIT_CONTAIN: c_int = 1;
pub const GTK_CONTENT_FIT_COVER: c_int = 2;
pub const GTK_CONTENT_FIT_SCALE_DOWN: c_int = 3;
pub const GtkContentFit = c_uint;
pub const GTK_DELETE_CHARS: c_int = 0;
pub const GTK_DELETE_WORD_ENDS: c_int = 1;
pub const GTK_DELETE_WORDS: c_int = 2;
pub const GTK_DELETE_DISPLAY_LINES: c_int = 3;
pub const GTK_DELETE_DISPLAY_LINE_ENDS: c_int = 4;
pub const GTK_DELETE_PARAGRAPH_ENDS: c_int = 5;
pub const GTK_DELETE_PARAGRAPHS: c_int = 6;
pub const GTK_DELETE_WHITESPACE: c_int = 7;
pub const GtkDeleteType = c_uint;
pub const GTK_DIR_TAB_FORWARD: c_int = 0;
pub const GTK_DIR_TAB_BACKWARD: c_int = 1;
pub const GTK_DIR_UP: c_int = 2;
pub const GTK_DIR_DOWN: c_int = 3;
pub const GTK_DIR_LEFT: c_int = 4;
pub const GTK_DIR_RIGHT: c_int = 5;
pub const GtkDirectionType = c_uint;
pub const GTK_ICON_SIZE_INHERIT: c_int = 0;
pub const GTK_ICON_SIZE_NORMAL: c_int = 1;
pub const GTK_ICON_SIZE_LARGE: c_int = 2;
pub const GtkIconSize = c_uint;
pub const GTK_SENSITIVITY_AUTO: c_int = 0;
pub const GTK_SENSITIVITY_ON: c_int = 1;
pub const GTK_SENSITIVITY_OFF: c_int = 2;
pub const GtkSensitivityType = c_uint;
pub const GTK_TEXT_DIR_NONE: c_int = 0;
pub const GTK_TEXT_DIR_LTR: c_int = 1;
pub const GTK_TEXT_DIR_RTL: c_int = 2;
pub const GtkTextDirection = c_uint;
pub const GTK_JUSTIFY_LEFT: c_int = 0;
pub const GTK_JUSTIFY_RIGHT: c_int = 1;
pub const GTK_JUSTIFY_CENTER: c_int = 2;
pub const GTK_JUSTIFY_FILL: c_int = 3;
pub const GtkJustification = c_uint;
pub const GTK_LIST_TAB_ALL: c_int = 0;
pub const GTK_LIST_TAB_ITEM: c_int = 1;
pub const GTK_LIST_TAB_CELL: c_int = 2;
pub const GtkListTabBehavior = c_uint;
pub const GTK_LIST_SCROLL_NONE: c_int = 0;
pub const GTK_LIST_SCROLL_FOCUS: c_int = 1;
pub const GTK_LIST_SCROLL_SELECT: c_int = 2;
pub const GtkListScrollFlags = c_uint;
pub const GTK_MESSAGE_INFO: c_int = 0;
pub const GTK_MESSAGE_WARNING: c_int = 1;
pub const GTK_MESSAGE_QUESTION: c_int = 2;
pub const GTK_MESSAGE_ERROR: c_int = 3;
pub const GTK_MESSAGE_OTHER: c_int = 4;
pub const GtkMessageType = c_uint;
pub const GTK_MOVEMENT_LOGICAL_POSITIONS: c_int = 0;
pub const GTK_MOVEMENT_VISUAL_POSITIONS: c_int = 1;
pub const GTK_MOVEMENT_WORDS: c_int = 2;
pub const GTK_MOVEMENT_DISPLAY_LINES: c_int = 3;
pub const GTK_MOVEMENT_DISPLAY_LINE_ENDS: c_int = 4;
pub const GTK_MOVEMENT_PARAGRAPHS: c_int = 5;
pub const GTK_MOVEMENT_PARAGRAPH_ENDS: c_int = 6;
pub const GTK_MOVEMENT_PAGES: c_int = 7;
pub const GTK_MOVEMENT_BUFFER_ENDS: c_int = 8;
pub const GTK_MOVEMENT_HORIZONTAL_PAGES: c_int = 9;
pub const GtkMovementStep = c_uint;
pub const GTK_NATURAL_WRAP_INHERIT: c_int = 0;
pub const GTK_NATURAL_WRAP_NONE: c_int = 1;
pub const GTK_NATURAL_WRAP_WORD: c_int = 2;
pub const GtkNaturalWrapMode = c_uint;
pub const GTK_SCROLL_STEPS: c_int = 0;
pub const GTK_SCROLL_PAGES: c_int = 1;
pub const GTK_SCROLL_ENDS: c_int = 2;
pub const GTK_SCROLL_HORIZONTAL_STEPS: c_int = 3;
pub const GTK_SCROLL_HORIZONTAL_PAGES: c_int = 4;
pub const GTK_SCROLL_HORIZONTAL_ENDS: c_int = 5;
pub const GtkScrollStep = c_uint;
pub const GTK_ORIENTATION_HORIZONTAL: c_int = 0;
pub const GTK_ORIENTATION_VERTICAL: c_int = 1;
pub const GtkOrientation = c_uint;
pub const GTK_OVERFLOW_VISIBLE: c_int = 0;
pub const GTK_OVERFLOW_HIDDEN: c_int = 1;
pub const GtkOverflow = c_uint;
pub const GTK_PACK_START: c_int = 0;
pub const GTK_PACK_END: c_int = 1;
pub const GtkPackType = c_uint;
pub const GTK_POS_LEFT: c_int = 0;
pub const GTK_POS_RIGHT: c_int = 1;
pub const GTK_POS_TOP: c_int = 2;
pub const GTK_POS_BOTTOM: c_int = 3;
pub const GtkPositionType = c_uint;
pub const GTK_SCROLL_NONE: c_int = 0;
pub const GTK_SCROLL_JUMP: c_int = 1;
pub const GTK_SCROLL_STEP_BACKWARD: c_int = 2;
pub const GTK_SCROLL_STEP_FORWARD: c_int = 3;
pub const GTK_SCROLL_PAGE_BACKWARD: c_int = 4;
pub const GTK_SCROLL_PAGE_FORWARD: c_int = 5;
pub const GTK_SCROLL_STEP_UP: c_int = 6;
pub const GTK_SCROLL_STEP_DOWN: c_int = 7;
pub const GTK_SCROLL_PAGE_UP: c_int = 8;
pub const GTK_SCROLL_PAGE_DOWN: c_int = 9;
pub const GTK_SCROLL_STEP_LEFT: c_int = 10;
pub const GTK_SCROLL_STEP_RIGHT: c_int = 11;
pub const GTK_SCROLL_PAGE_LEFT: c_int = 12;
pub const GTK_SCROLL_PAGE_RIGHT: c_int = 13;
pub const GTK_SCROLL_START: c_int = 14;
pub const GTK_SCROLL_END: c_int = 15;
pub const GtkScrollType = c_uint;
pub const GTK_SELECTION_NONE: c_int = 0;
pub const GTK_SELECTION_SINGLE: c_int = 1;
pub const GTK_SELECTION_BROWSE: c_int = 2;
pub const GTK_SELECTION_MULTIPLE: c_int = 3;
pub const GtkSelectionMode = c_uint;
pub const GTK_WRAP_NONE: c_int = 0;
pub const GTK_WRAP_CHAR: c_int = 1;
pub const GTK_WRAP_WORD: c_int = 2;
pub const GTK_WRAP_WORD_CHAR: c_int = 3;
pub const GtkWrapMode = c_uint;
pub const GTK_SORT_ASCENDING: c_int = 0;
pub const GTK_SORT_DESCENDING: c_int = 1;
pub const GtkSortType = c_uint;
pub const GTK_PRINT_PAGES_ALL: c_int = 0;
pub const GTK_PRINT_PAGES_CURRENT: c_int = 1;
pub const GTK_PRINT_PAGES_RANGES: c_int = 2;
pub const GTK_PRINT_PAGES_SELECTION: c_int = 3;
pub const GtkPrintPages = c_uint;
pub const GTK_PAGE_SET_ALL: c_int = 0;
pub const GTK_PAGE_SET_EVEN: c_int = 1;
pub const GTK_PAGE_SET_ODD: c_int = 2;
pub const GtkPageSet = c_uint;
pub const GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM: c_int = 0;
pub const GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP: c_int = 1;
pub const GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM: c_int = 2;
pub const GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP: c_int = 3;
pub const GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT: c_int = 4;
pub const GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT: c_int = 5;
pub const GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT: c_int = 6;
pub const GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT: c_int = 7;
pub const GtkNumberUpLayout = c_uint;
pub const GTK_ORDERING_SMALLER: c_int = -1;
pub const GTK_ORDERING_EQUAL: c_int = 0;
pub const GTK_ORDERING_LARGER: c_int = 1;
pub const GtkOrdering = c_int;
pub fn gtk_ordering_from_cmpfunc(arg_cmpfunc_result: c_int) callconv(.C) GtkOrdering {
    var cmpfunc_result = arg_cmpfunc_result;
    return @intFromBool(cmpfunc_result > @as(c_int, 0)) - @intFromBool(cmpfunc_result < @as(c_int, 0));
}
pub const GTK_PAGE_ORIENTATION_PORTRAIT: c_int = 0;
pub const GTK_PAGE_ORIENTATION_LANDSCAPE: c_int = 1;
pub const GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT: c_int = 2;
pub const GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE: c_int = 3;
pub const GtkPageOrientation = c_uint;
pub const GTK_PRINT_QUALITY_LOW: c_int = 0;
pub const GTK_PRINT_QUALITY_NORMAL: c_int = 1;
pub const GTK_PRINT_QUALITY_HIGH: c_int = 2;
pub const GTK_PRINT_QUALITY_DRAFT: c_int = 3;
pub const GtkPrintQuality = c_uint;
pub const GTK_PRINT_DUPLEX_SIMPLEX: c_int = 0;
pub const GTK_PRINT_DUPLEX_HORIZONTAL: c_int = 1;
pub const GTK_PRINT_DUPLEX_VERTICAL: c_int = 2;
pub const GtkPrintDuplex = c_uint;
pub const GTK_UNIT_NONE: c_int = 0;
pub const GTK_UNIT_POINTS: c_int = 1;
pub const GTK_UNIT_INCH: c_int = 2;
pub const GTK_UNIT_MM: c_int = 3;
pub const GtkUnit = c_uint;
pub const GTK_TREE_VIEW_GRID_LINES_NONE: c_int = 0;
pub const GTK_TREE_VIEW_GRID_LINES_HORIZONTAL: c_int = 1;
pub const GTK_TREE_VIEW_GRID_LINES_VERTICAL: c_int = 2;
pub const GTK_TREE_VIEW_GRID_LINES_BOTH: c_int = 3;
pub const GtkTreeViewGridLines = c_uint;
pub const GTK_SIZE_GROUP_NONE: c_int = 0;
pub const GTK_SIZE_GROUP_HORIZONTAL: c_int = 1;
pub const GTK_SIZE_GROUP_VERTICAL: c_int = 2;
pub const GTK_SIZE_GROUP_BOTH: c_int = 3;
pub const GtkSizeGroupMode = c_uint;
pub const GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH: c_int = 0;
pub const GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT: c_int = 1;
pub const GTK_SIZE_REQUEST_CONSTANT_SIZE: c_int = 2;
pub const GtkSizeRequestMode = c_uint;
pub const GTK_SCROLL_MINIMUM: c_int = 0;
pub const GTK_SCROLL_NATURAL: c_int = 1;
pub const GtkScrollablePolicy = c_uint;
pub const GTK_STATE_FLAG_NORMAL: c_int = 0;
pub const GTK_STATE_FLAG_ACTIVE: c_int = 1;
pub const GTK_STATE_FLAG_PRELIGHT: c_int = 2;
pub const GTK_STATE_FLAG_SELECTED: c_int = 4;
pub const GTK_STATE_FLAG_INSENSITIVE: c_int = 8;
pub const GTK_STATE_FLAG_INCONSISTENT: c_int = 16;
pub const GTK_STATE_FLAG_FOCUSED: c_int = 32;
pub const GTK_STATE_FLAG_BACKDROP: c_int = 64;
pub const GTK_STATE_FLAG_DIR_LTR: c_int = 128;
pub const GTK_STATE_FLAG_DIR_RTL: c_int = 256;
pub const GTK_STATE_FLAG_LINK: c_int = 512;
pub const GTK_STATE_FLAG_VISITED: c_int = 1024;
pub const GTK_STATE_FLAG_CHECKED: c_int = 2048;
pub const GTK_STATE_FLAG_DROP_ACTIVE: c_int = 4096;
pub const GTK_STATE_FLAG_FOCUS_VISIBLE: c_int = 8192;
pub const GTK_STATE_FLAG_FOCUS_WITHIN: c_int = 16384;
pub const GtkStateFlags = c_uint;
pub const GTK_BORDER_STYLE_NONE: c_int = 0;
pub const GTK_BORDER_STYLE_HIDDEN: c_int = 1;
pub const GTK_BORDER_STYLE_SOLID: c_int = 2;
pub const GTK_BORDER_STYLE_INSET: c_int = 3;
pub const GTK_BORDER_STYLE_OUTSET: c_int = 4;
pub const GTK_BORDER_STYLE_DOTTED: c_int = 5;
pub const GTK_BORDER_STYLE_DASHED: c_int = 6;
pub const GTK_BORDER_STYLE_DOUBLE: c_int = 7;
pub const GTK_BORDER_STYLE_GROOVE: c_int = 8;
pub const GTK_BORDER_STYLE_RIDGE: c_int = 9;
pub const GtkBorderStyle = c_uint;
pub const GTK_LEVEL_BAR_MODE_CONTINUOUS: c_int = 0;
pub const GTK_LEVEL_BAR_MODE_DISCRETE: c_int = 1;
pub const GtkLevelBarMode = c_uint;
pub const GTK_INPUT_PURPOSE_FREE_FORM: c_int = 0;
pub const GTK_INPUT_PURPOSE_ALPHA: c_int = 1;
pub const GTK_INPUT_PURPOSE_DIGITS: c_int = 2;
pub const GTK_INPUT_PURPOSE_NUMBER: c_int = 3;
pub const GTK_INPUT_PURPOSE_PHONE: c_int = 4;
pub const GTK_INPUT_PURPOSE_URL: c_int = 5;
pub const GTK_INPUT_PURPOSE_EMAIL: c_int = 6;
pub const GTK_INPUT_PURPOSE_NAME: c_int = 7;
pub const GTK_INPUT_PURPOSE_PASSWORD: c_int = 8;
pub const GTK_INPUT_PURPOSE_PIN: c_int = 9;
pub const GTK_INPUT_PURPOSE_TERMINAL: c_int = 10;
pub const GtkInputPurpose = c_uint;
pub const GTK_INPUT_HINT_NONE: c_int = 0;
pub const GTK_INPUT_HINT_SPELLCHECK: c_int = 1;
pub const GTK_INPUT_HINT_NO_SPELLCHECK: c_int = 2;
pub const GTK_INPUT_HINT_WORD_COMPLETION: c_int = 4;
pub const GTK_INPUT_HINT_LOWERCASE: c_int = 8;
pub const GTK_INPUT_HINT_UPPERCASE_CHARS: c_int = 16;
pub const GTK_INPUT_HINT_UPPERCASE_WORDS: c_int = 32;
pub const GTK_INPUT_HINT_UPPERCASE_SENTENCES: c_int = 64;
pub const GTK_INPUT_HINT_INHIBIT_OSK: c_int = 128;
pub const GTK_INPUT_HINT_VERTICAL_WRITING: c_int = 256;
pub const GTK_INPUT_HINT_EMOJI: c_int = 512;
pub const GTK_INPUT_HINT_NO_EMOJI: c_int = 1024;
pub const GTK_INPUT_HINT_PRIVATE: c_int = 2048;
pub const GtkInputHints = c_uint;
pub const GTK_PHASE_NONE: c_int = 0;
pub const GTK_PHASE_CAPTURE: c_int = 1;
pub const GTK_PHASE_BUBBLE: c_int = 2;
pub const GTK_PHASE_TARGET: c_int = 3;
pub const GtkPropagationPhase = c_uint;
pub const GTK_LIMIT_NONE: c_int = 0;
pub const GTK_LIMIT_SAME_NATIVE: c_int = 1;
pub const GtkPropagationLimit = c_uint;
pub const GTK_EVENT_SEQUENCE_NONE: c_int = 0;
pub const GTK_EVENT_SEQUENCE_CLAIMED: c_int = 1;
pub const GTK_EVENT_SEQUENCE_DENIED: c_int = 2;
pub const GtkEventSequenceState = c_uint;
pub const GTK_PAN_DIRECTION_LEFT: c_int = 0;
pub const GTK_PAN_DIRECTION_RIGHT: c_int = 1;
pub const GTK_PAN_DIRECTION_UP: c_int = 2;
pub const GTK_PAN_DIRECTION_DOWN: c_int = 3;
pub const GtkPanDirection = c_uint;
pub const GTK_SHORTCUT_SCOPE_LOCAL: c_int = 0;
pub const GTK_SHORTCUT_SCOPE_MANAGED: c_int = 1;
pub const GTK_SHORTCUT_SCOPE_GLOBAL: c_int = 2;
pub const GtkShortcutScope = c_uint;
pub const GTK_PICK_DEFAULT: c_int = 0;
pub const GTK_PICK_INSENSITIVE: c_int = 1;
pub const GTK_PICK_NON_TARGETABLE: c_int = 2;
pub const GtkPickFlags = c_uint;
pub const GTK_CONSTRAINT_RELATION_LE: c_int = -1;
pub const GTK_CONSTRAINT_RELATION_EQ: c_int = 0;
pub const GTK_CONSTRAINT_RELATION_GE: c_int = 1;
pub const GtkConstraintRelation = c_int;
pub const GTK_CONSTRAINT_STRENGTH_REQUIRED: c_int = 1001001000;
pub const GTK_CONSTRAINT_STRENGTH_STRONG: c_int = 1000000000;
pub const GTK_CONSTRAINT_STRENGTH_MEDIUM: c_int = 1000;
pub const GTK_CONSTRAINT_STRENGTH_WEAK: c_int = 1;
pub const GtkConstraintStrength = c_uint;
pub const GTK_CONSTRAINT_ATTRIBUTE_NONE: c_int = 0;
pub const GTK_CONSTRAINT_ATTRIBUTE_LEFT: c_int = 1;
pub const GTK_CONSTRAINT_ATTRIBUTE_RIGHT: c_int = 2;
pub const GTK_CONSTRAINT_ATTRIBUTE_TOP: c_int = 3;
pub const GTK_CONSTRAINT_ATTRIBUTE_BOTTOM: c_int = 4;
pub const GTK_CONSTRAINT_ATTRIBUTE_START: c_int = 5;
pub const GTK_CONSTRAINT_ATTRIBUTE_END: c_int = 6;
pub const GTK_CONSTRAINT_ATTRIBUTE_WIDTH: c_int = 7;
pub const GTK_CONSTRAINT_ATTRIBUTE_HEIGHT: c_int = 8;
pub const GTK_CONSTRAINT_ATTRIBUTE_CENTER_X: c_int = 9;
pub const GTK_CONSTRAINT_ATTRIBUTE_CENTER_Y: c_int = 10;
pub const GTK_CONSTRAINT_ATTRIBUTE_BASELINE: c_int = 11;
pub const GtkConstraintAttribute = c_uint;
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_SYMBOL: c_int = 0;
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_ATTRIBUTE: c_int = 1;
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_VIEW: c_int = 2;
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_METRIC: c_int = 3;
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_PRIORITY: c_int = 4;
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR_INVALID_RELATION: c_int = 5;
pub const GtkConstraintVflParserError = c_uint;
pub const GTK_SYSTEM_SETTING_DPI: c_int = 0;
pub const GTK_SYSTEM_SETTING_FONT_NAME: c_int = 1;
pub const GTK_SYSTEM_SETTING_FONT_CONFIG: c_int = 2;
pub const GTK_SYSTEM_SETTING_DISPLAY: c_int = 3;
pub const GTK_SYSTEM_SETTING_ICON_THEME: c_int = 4;
pub const GtkSystemSetting = c_uint;
pub const GTK_SYMBOLIC_COLOR_FOREGROUND: c_int = 0;
pub const GTK_SYMBOLIC_COLOR_ERROR: c_int = 1;
pub const GTK_SYMBOLIC_COLOR_WARNING: c_int = 2;
pub const GTK_SYMBOLIC_COLOR_SUCCESS: c_int = 3;
pub const GtkSymbolicColor = c_uint;
pub const GTK_ACCESSIBLE_ROLE_ALERT: c_int = 0;
pub const GTK_ACCESSIBLE_ROLE_ALERT_DIALOG: c_int = 1;
pub const GTK_ACCESSIBLE_ROLE_BANNER: c_int = 2;
pub const GTK_ACCESSIBLE_ROLE_BUTTON: c_int = 3;
pub const GTK_ACCESSIBLE_ROLE_CAPTION: c_int = 4;
pub const GTK_ACCESSIBLE_ROLE_CELL: c_int = 5;
pub const GTK_ACCESSIBLE_ROLE_CHECKBOX: c_int = 6;
pub const GTK_ACCESSIBLE_ROLE_COLUMN_HEADER: c_int = 7;
pub const GTK_ACCESSIBLE_ROLE_COMBO_BOX: c_int = 8;
pub const GTK_ACCESSIBLE_ROLE_COMMAND: c_int = 9;
pub const GTK_ACCESSIBLE_ROLE_COMPOSITE: c_int = 10;
pub const GTK_ACCESSIBLE_ROLE_DIALOG: c_int = 11;
pub const GTK_ACCESSIBLE_ROLE_DOCUMENT: c_int = 12;
pub const GTK_ACCESSIBLE_ROLE_FEED: c_int = 13;
pub const GTK_ACCESSIBLE_ROLE_FORM: c_int = 14;
pub const GTK_ACCESSIBLE_ROLE_GENERIC: c_int = 15;
pub const GTK_ACCESSIBLE_ROLE_GRID: c_int = 16;
pub const GTK_ACCESSIBLE_ROLE_GRID_CELL: c_int = 17;
pub const GTK_ACCESSIBLE_ROLE_GROUP: c_int = 18;
pub const GTK_ACCESSIBLE_ROLE_HEADING: c_int = 19;
pub const GTK_ACCESSIBLE_ROLE_IMG: c_int = 20;
pub const GTK_ACCESSIBLE_ROLE_INPUT: c_int = 21;
pub const GTK_ACCESSIBLE_ROLE_LABEL: c_int = 22;
pub const GTK_ACCESSIBLE_ROLE_LANDMARK: c_int = 23;
pub const GTK_ACCESSIBLE_ROLE_LEGEND: c_int = 24;
pub const GTK_ACCESSIBLE_ROLE_LINK: c_int = 25;
pub const GTK_ACCESSIBLE_ROLE_LIST: c_int = 26;
pub const GTK_ACCESSIBLE_ROLE_LIST_BOX: c_int = 27;
pub const GTK_ACCESSIBLE_ROLE_LIST_ITEM: c_int = 28;
pub const GTK_ACCESSIBLE_ROLE_LOG: c_int = 29;
pub const GTK_ACCESSIBLE_ROLE_MAIN: c_int = 30;
pub const GTK_ACCESSIBLE_ROLE_MARQUEE: c_int = 31;
pub const GTK_ACCESSIBLE_ROLE_MATH: c_int = 32;
pub const GTK_ACCESSIBLE_ROLE_METER: c_int = 33;
pub const GTK_ACCESSIBLE_ROLE_MENU: c_int = 34;
pub const GTK_ACCESSIBLE_ROLE_MENU_BAR: c_int = 35;
pub const GTK_ACCESSIBLE_ROLE_MENU_ITEM: c_int = 36;
pub const GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX: c_int = 37;
pub const GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO: c_int = 38;
pub const GTK_ACCESSIBLE_ROLE_NAVIGATION: c_int = 39;
pub const GTK_ACCESSIBLE_ROLE_NONE: c_int = 40;
pub const GTK_ACCESSIBLE_ROLE_NOTE: c_int = 41;
pub const GTK_ACCESSIBLE_ROLE_OPTION: c_int = 42;
pub const GTK_ACCESSIBLE_ROLE_PRESENTATION: c_int = 43;
pub const GTK_ACCESSIBLE_ROLE_PROGRESS_BAR: c_int = 44;
pub const GTK_ACCESSIBLE_ROLE_RADIO: c_int = 45;
pub const GTK_ACCESSIBLE_ROLE_RADIO_GROUP: c_int = 46;
pub const GTK_ACCESSIBLE_ROLE_RANGE: c_int = 47;
pub const GTK_ACCESSIBLE_ROLE_REGION: c_int = 48;
pub const GTK_ACCESSIBLE_ROLE_ROW: c_int = 49;
pub const GTK_ACCESSIBLE_ROLE_ROW_GROUP: c_int = 50;
pub const GTK_ACCESSIBLE_ROLE_ROW_HEADER: c_int = 51;
pub const GTK_ACCESSIBLE_ROLE_SCROLLBAR: c_int = 52;
pub const GTK_ACCESSIBLE_ROLE_SEARCH: c_int = 53;
pub const GTK_ACCESSIBLE_ROLE_SEARCH_BOX: c_int = 54;
pub const GTK_ACCESSIBLE_ROLE_SECTION: c_int = 55;
pub const GTK_ACCESSIBLE_ROLE_SECTION_HEAD: c_int = 56;
pub const GTK_ACCESSIBLE_ROLE_SELECT: c_int = 57;
pub const GTK_ACCESSIBLE_ROLE_SEPARATOR: c_int = 58;
pub const GTK_ACCESSIBLE_ROLE_SLIDER: c_int = 59;
pub const GTK_ACCESSIBLE_ROLE_SPIN_BUTTON: c_int = 60;
pub const GTK_ACCESSIBLE_ROLE_STATUS: c_int = 61;
pub const GTK_ACCESSIBLE_ROLE_STRUCTURE: c_int = 62;
pub const GTK_ACCESSIBLE_ROLE_SWITCH: c_int = 63;
pub const GTK_ACCESSIBLE_ROLE_TAB: c_int = 64;
pub const GTK_ACCESSIBLE_ROLE_TABLE: c_int = 65;
pub const GTK_ACCESSIBLE_ROLE_TAB_LIST: c_int = 66;
pub const GTK_ACCESSIBLE_ROLE_TAB_PANEL: c_int = 67;
pub const GTK_ACCESSIBLE_ROLE_TEXT_BOX: c_int = 68;
pub const GTK_ACCESSIBLE_ROLE_TIME: c_int = 69;
pub const GTK_ACCESSIBLE_ROLE_TIMER: c_int = 70;
pub const GTK_ACCESSIBLE_ROLE_TOOLBAR: c_int = 71;
pub const GTK_ACCESSIBLE_ROLE_TOOLTIP: c_int = 72;
pub const GTK_ACCESSIBLE_ROLE_TREE: c_int = 73;
pub const GTK_ACCESSIBLE_ROLE_TREE_GRID: c_int = 74;
pub const GTK_ACCESSIBLE_ROLE_TREE_ITEM: c_int = 75;
pub const GTK_ACCESSIBLE_ROLE_WIDGET: c_int = 76;
pub const GTK_ACCESSIBLE_ROLE_WINDOW: c_int = 77;
pub const GTK_ACCESSIBLE_ROLE_TOGGLE_BUTTON: c_int = 78;
pub const GTK_ACCESSIBLE_ROLE_APPLICATION: c_int = 79;
pub const GtkAccessibleRole = c_uint;
pub const GTK_ACCESSIBLE_STATE_BUSY: c_int = 0;
pub const GTK_ACCESSIBLE_STATE_CHECKED: c_int = 1;
pub const GTK_ACCESSIBLE_STATE_DISABLED: c_int = 2;
pub const GTK_ACCESSIBLE_STATE_EXPANDED: c_int = 3;
pub const GTK_ACCESSIBLE_STATE_HIDDEN: c_int = 4;
pub const GTK_ACCESSIBLE_STATE_INVALID: c_int = 5;
pub const GTK_ACCESSIBLE_STATE_PRESSED: c_int = 6;
pub const GTK_ACCESSIBLE_STATE_SELECTED: c_int = 7;
pub const GTK_ACCESSIBLE_STATE_VISITED: c_int = 8;
pub const GtkAccessibleState = c_uint;
pub const GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE: c_int = 0;
pub const GTK_ACCESSIBLE_PROPERTY_DESCRIPTION: c_int = 1;
pub const GTK_ACCESSIBLE_PROPERTY_HAS_POPUP: c_int = 2;
pub const GTK_ACCESSIBLE_PROPERTY_KEY_SHORTCUTS: c_int = 3;
pub const GTK_ACCESSIBLE_PROPERTY_LABEL: c_int = 4;
pub const GTK_ACCESSIBLE_PROPERTY_LEVEL: c_int = 5;
pub const GTK_ACCESSIBLE_PROPERTY_MODAL: c_int = 6;
pub const GTK_ACCESSIBLE_PROPERTY_MULTI_LINE: c_int = 7;
pub const GTK_ACCESSIBLE_PROPERTY_MULTI_SELECTABLE: c_int = 8;
pub const GTK_ACCESSIBLE_PROPERTY_ORIENTATION: c_int = 9;
pub const GTK_ACCESSIBLE_PROPERTY_PLACEHOLDER: c_int = 10;
pub const GTK_ACCESSIBLE_PROPERTY_READ_ONLY: c_int = 11;
pub const GTK_ACCESSIBLE_PROPERTY_REQUIRED: c_int = 12;
pub const GTK_ACCESSIBLE_PROPERTY_ROLE_DESCRIPTION: c_int = 13;
pub const GTK_ACCESSIBLE_PROPERTY_SORT: c_int = 14;
pub const GTK_ACCESSIBLE_PROPERTY_VALUE_MAX: c_int = 15;
pub const GTK_ACCESSIBLE_PROPERTY_VALUE_MIN: c_int = 16;
pub const GTK_ACCESSIBLE_PROPERTY_VALUE_NOW: c_int = 17;
pub const GTK_ACCESSIBLE_PROPERTY_VALUE_TEXT: c_int = 18;
pub const GtkAccessibleProperty = c_uint;
pub const GTK_ACCESSIBLE_RELATION_ACTIVE_DESCENDANT: c_int = 0;
pub const GTK_ACCESSIBLE_RELATION_COL_COUNT: c_int = 1;
pub const GTK_ACCESSIBLE_RELATION_COL_INDEX: c_int = 2;
pub const GTK_ACCESSIBLE_RELATION_COL_INDEX_TEXT: c_int = 3;
pub const GTK_ACCESSIBLE_RELATION_COL_SPAN: c_int = 4;
pub const GTK_ACCESSIBLE_RELATION_CONTROLS: c_int = 5;
pub const GTK_ACCESSIBLE_RELATION_DESCRIBED_BY: c_int = 6;
pub const GTK_ACCESSIBLE_RELATION_DETAILS: c_int = 7;
pub const GTK_ACCESSIBLE_RELATION_ERROR_MESSAGE: c_int = 8;
pub const GTK_ACCESSIBLE_RELATION_FLOW_TO: c_int = 9;
pub const GTK_ACCESSIBLE_RELATION_LABELLED_BY: c_int = 10;
pub const GTK_ACCESSIBLE_RELATION_OWNS: c_int = 11;
pub const GTK_ACCESSIBLE_RELATION_POS_IN_SET: c_int = 12;
pub const GTK_ACCESSIBLE_RELATION_ROW_COUNT: c_int = 13;
pub const GTK_ACCESSIBLE_RELATION_ROW_INDEX: c_int = 14;
pub const GTK_ACCESSIBLE_RELATION_ROW_INDEX_TEXT: c_int = 15;
pub const GTK_ACCESSIBLE_RELATION_ROW_SPAN: c_int = 16;
pub const GTK_ACCESSIBLE_RELATION_SET_SIZE: c_int = 17;
pub const GtkAccessibleRelation = c_uint;
pub const GTK_ACCESSIBLE_TRISTATE_FALSE: c_int = 0;
pub const GTK_ACCESSIBLE_TRISTATE_TRUE: c_int = 1;
pub const GTK_ACCESSIBLE_TRISTATE_MIXED: c_int = 2;
pub const GtkAccessibleTristate = c_uint;
pub const GTK_ACCESSIBLE_INVALID_FALSE: c_int = 0;
pub const GTK_ACCESSIBLE_INVALID_TRUE: c_int = 1;
pub const GTK_ACCESSIBLE_INVALID_GRAMMAR: c_int = 2;
pub const GTK_ACCESSIBLE_INVALID_SPELLING: c_int = 3;
pub const GtkAccessibleInvalidState = c_uint;
pub const GTK_ACCESSIBLE_AUTOCOMPLETE_NONE: c_int = 0;
pub const GTK_ACCESSIBLE_AUTOCOMPLETE_INLINE: c_int = 1;
pub const GTK_ACCESSIBLE_AUTOCOMPLETE_LIST: c_int = 2;
pub const GTK_ACCESSIBLE_AUTOCOMPLETE_BOTH: c_int = 3;
pub const GtkAccessibleAutocomplete = c_uint;
pub const GTK_ACCESSIBLE_SORT_NONE: c_int = 0;
pub const GTK_ACCESSIBLE_SORT_ASCENDING: c_int = 1;
pub const GTK_ACCESSIBLE_SORT_DESCENDING: c_int = 2;
pub const GTK_ACCESSIBLE_SORT_OTHER: c_int = 3;
pub const GtkAccessibleSort = c_uint;
pub const struct__GtkAdjustment = extern struct {
    parent_instance: GInitiallyUnowned,
};
pub const GtkAdjustment = struct__GtkAdjustment;
pub const struct__GtkATContext = opaque {};
pub const GtkATContext = struct__GtkATContext;
pub const struct__GtkBitset = opaque {};
pub const GtkBitset = struct__GtkBitset;
pub const struct__GtkBuilder = opaque {};
pub const GtkBuilder = struct__GtkBuilder;
pub const struct__GtkBuilderScope = opaque {};
pub const GtkBuilderScope = struct__GtkBuilderScope;
pub const struct__GtkCssStyleChange = opaque {};
pub const GtkCssStyleChange = struct__GtkCssStyleChange;
pub const struct__GtkEventController = opaque {};
pub const GtkEventController = struct__GtkEventController;
pub const struct__GtkGesture = opaque {};
pub const GtkGesture = struct__GtkGesture;
pub const struct__GtkLayoutManager = extern struct {
    parent_instance: GObject,
};
pub const GtkLayoutManager = struct__GtkLayoutManager;
pub const struct__GtkListItem = opaque {};
pub const GtkListItem = struct__GtkListItem;
pub const struct__GtkListItemFactory = opaque {};
pub const GtkListItemFactory = struct__GtkListItemFactory;
pub const struct__GtkNative = opaque {};
pub const GtkNative = struct__GtkNative;
pub const struct__GtkRequisition = extern struct {
    width: c_int,
    height: c_int,
};
pub const GtkRequisition = struct__GtkRequisition;
pub const struct__GtkRoot = opaque {};
pub const GtkRoot = struct__GtkRoot;
pub const struct__GtkScrollInfo = opaque {};
pub const GtkScrollInfo = struct__GtkScrollInfo;
pub const struct__GtkSettings = opaque {};
pub const GtkSettings = struct__GtkSettings;
pub const struct__GtkShortcut = opaque {};
pub const GtkShortcut = struct__GtkShortcut;
pub const struct__GtkShortcutAction = opaque {};
pub const GtkShortcutAction = struct__GtkShortcutAction;
pub const struct__GtkShortcutTrigger = opaque {};
pub const GtkShortcutTrigger = struct__GtkShortcutTrigger;
pub const GtkSnapshot = GdkSnapshot;
pub const struct__GtkStyleContext = extern struct {
    parent_object: GObject,
};
pub const GtkStyleContext = struct__GtkStyleContext;
pub const struct__GtkTooltip = opaque {};
pub const GtkTooltip = struct__GtkTooltip;
pub const struct__GtkWidgetPrivate = opaque {};
pub const GtkWidgetPrivate = struct__GtkWidgetPrivate;
pub const struct__GtkWidget = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkWidgetPrivate,
};
pub const GtkWidget = struct__GtkWidget;
pub const struct__GtkWindow = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkWindow = struct__GtkWindow;
pub extern fn gtk_shortcut_get_type() GType;
pub const GtkShortcutClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkShortcut_autoptr = ?*GtkShortcut;
pub const GtkShortcut_listautoptr = [*c]GList;
pub const GtkShortcut_slistautoptr = [*c]GSList;
pub const GtkShortcut_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcut(arg__ptr: ?*GtkShortcut) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcut(arg__ptr: [*c]?*GtkShortcut) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcut(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcut(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcut(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcut(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkShortcutClass_autoptr = [*c]GtkShortcutClass;
pub const GtkShortcutClass_listautoptr = [*c]GList;
pub const GtkShortcutClass_slistautoptr = [*c]GSList;
pub const GtkShortcutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutClass(arg__ptr: [*c]GtkShortcutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutClass(arg__ptr: [*c][*c]GtkShortcutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SHORTCUT(arg_ptr: gpointer) callconv(.C) ?*GtkShortcut {
    var ptr = arg_ptr;
    return @as(?*GtkShortcut, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_shortcut_get_type())))));
}
pub fn GTK_IS_SHORTCUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_shortcut_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_shortcut_new(trigger: ?*GtkShortcutTrigger, action: ?*GtkShortcutAction) ?*GtkShortcut;
pub extern fn gtk_shortcut_new_with_arguments(trigger: ?*GtkShortcutTrigger, action: ?*GtkShortcutAction, format_string: [*c]const u8, ...) ?*GtkShortcut;
pub extern fn gtk_shortcut_get_trigger(self: ?*GtkShortcut) ?*GtkShortcutTrigger;
pub extern fn gtk_shortcut_set_trigger(self: ?*GtkShortcut, trigger: ?*GtkShortcutTrigger) void;
pub extern fn gtk_shortcut_get_action(self: ?*GtkShortcut) ?*GtkShortcutAction;
pub extern fn gtk_shortcut_set_action(self: ?*GtkShortcut, action: ?*GtkShortcutAction) void;
pub extern fn gtk_shortcut_get_arguments(self: ?*GtkShortcut) ?*GVariant;
pub extern fn gtk_shortcut_set_arguments(self: ?*GtkShortcut, args: ?*GVariant) void;
pub const GtkShortcutFunc = ?*const fn ([*c]GtkWidget, ?*GVariant, gpointer) callconv(.C) gboolean;
pub const GTK_SHORTCUT_ACTION_EXCLUSIVE: c_int = 1;
pub const GtkShortcutActionFlags = c_uint;
pub extern fn gtk_shortcut_action_get_type() GType;
pub const struct__GtkShortcutActionClass = opaque {};
pub const GtkShortcutActionClass = struct__GtkShortcutActionClass;
pub const GtkShortcutAction_autoptr = ?*GtkShortcutAction;
pub const GtkShortcutAction_listautoptr = [*c]GList;
pub const GtkShortcutAction_slistautoptr = [*c]GSList;
pub const GtkShortcutAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutAction(arg__ptr: ?*GtkShortcutAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutAction(arg__ptr: [*c]?*GtkShortcutAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkShortcutActionClass_autoptr = ?*GtkShortcutActionClass;
pub const GtkShortcutActionClass_listautoptr = [*c]GList;
pub const GtkShortcutActionClass_slistautoptr = [*c]GSList;
pub const GtkShortcutActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutActionClass(arg__ptr: ?*GtkShortcutActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutActionClass(arg__ptr: [*c]?*GtkShortcutActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SHORTCUT_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutAction {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_shortcut_action_get_type())))));
}
pub fn GTK_SHORTCUT_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_shortcut_action_get_type())))));
}
pub fn GTK_IS_SHORTCUT_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_shortcut_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_SHORTCUT_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_shortcut_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SHORTCUT_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_shortcut_action_to_string(self: ?*GtkShortcutAction) [*c]u8;
pub extern fn gtk_shortcut_action_parse_string(string: [*c]const u8) ?*GtkShortcutAction;
pub extern fn gtk_shortcut_action_print(self: ?*GtkShortcutAction, string: [*c]GString) void;
pub extern fn gtk_shortcut_action_activate(self: ?*GtkShortcutAction, flags: GtkShortcutActionFlags, widget: [*c]GtkWidget, args: ?*GVariant) gboolean;
pub extern fn gtk_nothing_action_get_type() GType;
pub const struct__GtkNothingAction = opaque {};
pub const GtkNothingAction = struct__GtkNothingAction;
pub const struct__GtkNothingActionClass = opaque {};
pub const GtkNothingActionClass = struct__GtkNothingActionClass;
pub const GtkNothingAction_autoptr = ?*GtkNothingAction;
pub const GtkNothingAction_listautoptr = [*c]GList;
pub const GtkNothingAction_slistautoptr = [*c]GSList;
pub const GtkNothingAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNothingAction(arg__ptr: ?*GtkNothingAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutAction(@as(?*GtkShortcutAction, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNothingAction(arg__ptr: [*c]?*GtkNothingAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNothingAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNothingAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNothingAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNothingAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
    }
}
pub const GtkNothingActionClass_autoptr = ?*GtkNothingActionClass;
pub const GtkNothingActionClass_listautoptr = [*c]GList;
pub const GtkNothingActionClass_slistautoptr = [*c]GSList;
pub const GtkNothingActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNothingActionClass(arg__ptr: ?*GtkNothingActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNothingActionClass(arg__ptr: [*c]?*GtkNothingActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNothingActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNothingActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNothingActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNothingActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_NOTHING_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkNothingAction {
    var ptr = arg_ptr;
    return @as(?*GtkNothingAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_nothing_action_get_type())))));
}
pub fn GTK_NOTHING_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkNothingActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkNothingActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_nothing_action_get_type())))));
}
pub fn GTK_IS_NOTHING_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_nothing_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_NOTHING_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_nothing_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_NOTHING_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkNothingActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkNothingActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_nothing_action_get() ?*GtkShortcutAction;
pub extern fn gtk_callback_action_get_type() GType;
pub const struct__GtkCallbackAction = opaque {};
pub const GtkCallbackAction = struct__GtkCallbackAction;
pub const struct__GtkCallbackActionClass = opaque {};
pub const GtkCallbackActionClass = struct__GtkCallbackActionClass;
pub const GtkCallbackAction_autoptr = ?*GtkCallbackAction;
pub const GtkCallbackAction_listautoptr = [*c]GList;
pub const GtkCallbackAction_slistautoptr = [*c]GSList;
pub const GtkCallbackAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCallbackAction(arg__ptr: ?*GtkCallbackAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutAction(@as(?*GtkShortcutAction, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCallbackAction(arg__ptr: [*c]?*GtkCallbackAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCallbackAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCallbackAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCallbackAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCallbackAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
    }
}
pub const GtkCallbackActionClass_autoptr = ?*GtkCallbackActionClass;
pub const GtkCallbackActionClass_listautoptr = [*c]GList;
pub const GtkCallbackActionClass_slistautoptr = [*c]GSList;
pub const GtkCallbackActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCallbackActionClass(arg__ptr: ?*GtkCallbackActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCallbackActionClass(arg__ptr: [*c]?*GtkCallbackActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCallbackActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCallbackActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCallbackActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCallbackActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CALLBACK_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkCallbackAction {
    var ptr = arg_ptr;
    return @as(?*GtkCallbackAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_callback_action_get_type())))));
}
pub fn GTK_CALLBACK_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkCallbackActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkCallbackActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_callback_action_get_type())))));
}
pub fn GTK_IS_CALLBACK_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_callback_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_CALLBACK_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_callback_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_CALLBACK_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkCallbackActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkCallbackActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_callback_action_new(callback: GtkShortcutFunc, data: gpointer, destroy: GDestroyNotify) ?*GtkShortcutAction;
pub extern fn gtk_mnemonic_action_get_type() GType;
pub const struct__GtkMnemonicAction = opaque {};
pub const GtkMnemonicAction = struct__GtkMnemonicAction;
pub const struct__GtkMnemonicActionClass = opaque {};
pub const GtkMnemonicActionClass = struct__GtkMnemonicActionClass;
pub const GtkMnemonicAction_autoptr = ?*GtkMnemonicAction;
pub const GtkMnemonicAction_listautoptr = [*c]GList;
pub const GtkMnemonicAction_slistautoptr = [*c]GSList;
pub const GtkMnemonicAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMnemonicAction(arg__ptr: ?*GtkMnemonicAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutAction(@as(?*GtkShortcutAction, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMnemonicAction(arg__ptr: [*c]?*GtkMnemonicAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMnemonicAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMnemonicAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMnemonicAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMnemonicAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
    }
}
pub const GtkMnemonicActionClass_autoptr = ?*GtkMnemonicActionClass;
pub const GtkMnemonicActionClass_listautoptr = [*c]GList;
pub const GtkMnemonicActionClass_slistautoptr = [*c]GSList;
pub const GtkMnemonicActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMnemonicActionClass(arg__ptr: ?*GtkMnemonicActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMnemonicActionClass(arg__ptr: [*c]?*GtkMnemonicActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMnemonicActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMnemonicActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMnemonicActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMnemonicActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MNEMONIC_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkMnemonicAction {
    var ptr = arg_ptr;
    return @as(?*GtkMnemonicAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_mnemonic_action_get_type())))));
}
pub fn GTK_MNEMONIC_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkMnemonicActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkMnemonicActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_mnemonic_action_get_type())))));
}
pub fn GTK_IS_MNEMONIC_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_mnemonic_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_MNEMONIC_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_mnemonic_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_MNEMONIC_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkMnemonicActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkMnemonicActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_mnemonic_action_get() ?*GtkShortcutAction;
pub extern fn gtk_activate_action_get_type() GType;
pub const struct__GtkActivateAction = opaque {};
pub const GtkActivateAction = struct__GtkActivateAction;
pub const struct__GtkActivateActionClass = opaque {};
pub const GtkActivateActionClass = struct__GtkActivateActionClass;
pub const GtkActivateAction_autoptr = ?*GtkActivateAction;
pub const GtkActivateAction_listautoptr = [*c]GList;
pub const GtkActivateAction_slistautoptr = [*c]GSList;
pub const GtkActivateAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkActivateAction(arg__ptr: ?*GtkActivateAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutAction(@as(?*GtkShortcutAction, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkActivateAction(arg__ptr: [*c]?*GtkActivateAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkActivateAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkActivateAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_slistautoptr_cleanup_GtkActivateAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_queueautoptr_cleanup_GtkActivateAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
    }
}
pub const GtkActivateActionClass_autoptr = ?*GtkActivateActionClass;
pub const GtkActivateActionClass_listautoptr = [*c]GList;
pub const GtkActivateActionClass_slistautoptr = [*c]GSList;
pub const GtkActivateActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkActivateActionClass(arg__ptr: ?*GtkActivateActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkActivateActionClass(arg__ptr: [*c]?*GtkActivateActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkActivateActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkActivateActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkActivateActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkActivateActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_ACTIVATE_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkActivateAction {
    var ptr = arg_ptr;
    return @as(?*GtkActivateAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_activate_action_get_type())))));
}
pub fn GTK_ACTIVATE_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkActivateActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkActivateActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_activate_action_get_type())))));
}
pub fn GTK_IS_ACTIVATE_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_activate_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_ACTIVATE_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_activate_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_ACTIVATE_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkActivateActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkActivateActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_activate_action_get() ?*GtkShortcutAction;
pub extern fn gtk_signal_action_get_type() GType;
pub const struct__GtkSignalAction = opaque {};
pub const GtkSignalAction = struct__GtkSignalAction;
pub const struct__GtkSignalActionClass = opaque {};
pub const GtkSignalActionClass = struct__GtkSignalActionClass;
pub const GtkSignalAction_autoptr = ?*GtkSignalAction;
pub const GtkSignalAction_listautoptr = [*c]GList;
pub const GtkSignalAction_slistautoptr = [*c]GSList;
pub const GtkSignalAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSignalAction(arg__ptr: ?*GtkSignalAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutAction(@as(?*GtkShortcutAction, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSignalAction(arg__ptr: [*c]?*GtkSignalAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSignalAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSignalAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSignalAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSignalAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
    }
}
pub const GtkSignalActionClass_autoptr = ?*GtkSignalActionClass;
pub const GtkSignalActionClass_listautoptr = [*c]GList;
pub const GtkSignalActionClass_slistautoptr = [*c]GSList;
pub const GtkSignalActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSignalActionClass(arg__ptr: ?*GtkSignalActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSignalActionClass(arg__ptr: [*c]?*GtkSignalActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSignalActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSignalActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSignalActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSignalActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SIGNAL_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkSignalAction {
    var ptr = arg_ptr;
    return @as(?*GtkSignalAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_signal_action_get_type())))));
}
pub fn GTK_SIGNAL_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkSignalActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkSignalActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_signal_action_get_type())))));
}
pub fn GTK_IS_SIGNAL_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_signal_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_SIGNAL_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_signal_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SIGNAL_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkSignalActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkSignalActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_signal_action_new(signal_name: [*c]const u8) ?*GtkShortcutAction;
pub extern fn gtk_signal_action_get_signal_name(self: ?*GtkSignalAction) [*c]const u8;
pub extern fn gtk_named_action_get_type() GType;
pub const struct__GtkNamedAction = opaque {};
pub const GtkNamedAction = struct__GtkNamedAction;
pub const struct__GtkNamedActionClass = opaque {};
pub const GtkNamedActionClass = struct__GtkNamedActionClass;
pub const GtkNamedAction_autoptr = ?*GtkNamedAction;
pub const GtkNamedAction_listautoptr = [*c]GList;
pub const GtkNamedAction_slistautoptr = [*c]GSList;
pub const GtkNamedAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNamedAction(arg__ptr: ?*GtkNamedAction) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutAction(@as(?*GtkShortcutAction, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNamedAction(arg__ptr: [*c]?*GtkNamedAction) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNamedAction(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNamedAction(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNamedAction(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNamedAction(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutAction)))))));
    }
}
pub const GtkNamedActionClass_autoptr = ?*GtkNamedActionClass;
pub const GtkNamedActionClass_listautoptr = [*c]GList;
pub const GtkNamedActionClass_slistautoptr = [*c]GSList;
pub const GtkNamedActionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNamedActionClass(arg__ptr: ?*GtkNamedActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNamedActionClass(arg__ptr: [*c]?*GtkNamedActionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNamedActionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNamedActionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNamedActionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNamedActionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_NAMED_ACTION(arg_ptr: gpointer) callconv(.C) ?*GtkNamedAction {
    var ptr = arg_ptr;
    return @as(?*GtkNamedAction, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_named_action_get_type())))));
}
pub fn GTK_NAMED_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkNamedActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkNamedActionClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_named_action_get_type())))));
}
pub fn GTK_IS_NAMED_ACTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_named_action_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_NAMED_ACTION_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_named_action_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_NAMED_ACTION_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkNamedActionClass {
    var ptr = arg_ptr;
    return @as(?*GtkNamedActionClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_named_action_new(name: [*c]const u8) ?*GtkShortcutAction;
pub extern fn gtk_named_action_get_action_name(self: ?*GtkNamedAction) [*c]const u8;
pub const struct__GtkWidgetClassPrivate = opaque {};
pub const GtkWidgetClassPrivate = struct__GtkWidgetClassPrivate;
pub const struct__GtkWidgetClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    show: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    hide: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    map: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    unmap: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    realize: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    unrealize: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    root: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    unroot: ?*const fn ([*c]GtkWidget) callconv(.C) void,
    size_allocate: ?*const fn ([*c]GtkWidget, c_int, c_int, c_int) callconv(.C) void,
    state_flags_changed: ?*const fn ([*c]GtkWidget, GtkStateFlags) callconv(.C) void,
    direction_changed: ?*const fn ([*c]GtkWidget, GtkTextDirection) callconv(.C) void,
    get_request_mode: ?*const fn ([*c]GtkWidget) callconv(.C) GtkSizeRequestMode,
    measure: ?*const fn ([*c]GtkWidget, GtkOrientation, c_int, [*c]c_int, [*c]c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    mnemonic_activate: ?*const fn ([*c]GtkWidget, gboolean) callconv(.C) gboolean,
    grab_focus: ?*const fn ([*c]GtkWidget) callconv(.C) gboolean,
    focus: ?*const fn ([*c]GtkWidget, GtkDirectionType) callconv(.C) gboolean,
    set_focus_child: ?*const fn ([*c]GtkWidget, [*c]GtkWidget) callconv(.C) void,
    move_focus: ?*const fn ([*c]GtkWidget, GtkDirectionType) callconv(.C) void,
    keynav_failed: ?*const fn ([*c]GtkWidget, GtkDirectionType) callconv(.C) gboolean,
    query_tooltip: ?*const fn ([*c]GtkWidget, c_int, c_int, gboolean, ?*GtkTooltip) callconv(.C) gboolean,
    compute_expand: ?*const fn ([*c]GtkWidget, [*c]gboolean, [*c]gboolean) callconv(.C) void,
    css_changed: ?*const fn ([*c]GtkWidget, ?*GtkCssStyleChange) callconv(.C) void,
    system_setting_changed: ?*const fn ([*c]GtkWidget, GtkSystemSetting) callconv(.C) void,
    snapshot: ?*const fn ([*c]GtkWidget, ?*GtkSnapshot) callconv(.C) void,
    contains: ?*const fn ([*c]GtkWidget, f64, f64) callconv(.C) gboolean,
    priv: ?*GtkWidgetClassPrivate,
    padding: [8]gpointer,
};
pub const GtkWidgetClass = struct__GtkWidgetClass;
pub const GtkAllocation = GdkRectangle;
pub const GtkTickCallback = ?*const fn ([*c]GtkWidget, ?*GdkFrameClock, gpointer) callconv(.C) gboolean;
pub extern fn gtk_widget_get_type() GType;
pub extern fn gtk_widget_unparent(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_show(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_hide(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_map(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_unmap(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_realize(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_unrealize(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_queue_draw(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_queue_resize(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_queue_allocate(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_frame_clock(widget: [*c]GtkWidget) ?*GdkFrameClock;
pub extern fn gtk_widget_size_allocate(widget: [*c]GtkWidget, allocation: [*c]const GtkAllocation, baseline: c_int) void;
pub extern fn gtk_widget_allocate(widget: [*c]GtkWidget, width: c_int, height: c_int, baseline: c_int, transform: ?*GskTransform) void;
pub extern fn gtk_widget_get_request_mode(widget: [*c]GtkWidget) GtkSizeRequestMode;
pub extern fn gtk_widget_measure(widget: [*c]GtkWidget, orientation: GtkOrientation, for_size: c_int, minimum: [*c]c_int, natural: [*c]c_int, minimum_baseline: [*c]c_int, natural_baseline: [*c]c_int) void;
pub extern fn gtk_widget_get_preferred_size(widget: [*c]GtkWidget, minimum_size: [*c]GtkRequisition, natural_size: [*c]GtkRequisition) void;
pub extern fn gtk_widget_set_layout_manager(widget: [*c]GtkWidget, layout_manager: [*c]GtkLayoutManager) void;
pub extern fn gtk_widget_get_layout_manager(widget: [*c]GtkWidget) [*c]GtkLayoutManager;
pub extern fn gtk_widget_class_set_layout_manager_type(widget_class: [*c]GtkWidgetClass, @"type": GType) void;
pub extern fn gtk_widget_class_get_layout_manager_type(widget_class: [*c]GtkWidgetClass) GType;
pub extern fn gtk_widget_class_add_binding(widget_class: [*c]GtkWidgetClass, keyval: guint, mods: GdkModifierType, callback: GtkShortcutFunc, format_string: [*c]const u8, ...) void;
pub extern fn gtk_widget_class_add_binding_signal(widget_class: [*c]GtkWidgetClass, keyval: guint, mods: GdkModifierType, signal: [*c]const u8, format_string: [*c]const u8, ...) void;
pub extern fn gtk_widget_class_add_binding_action(widget_class: [*c]GtkWidgetClass, keyval: guint, mods: GdkModifierType, action_name: [*c]const u8, format_string: [*c]const u8, ...) void;
pub extern fn gtk_widget_class_add_shortcut(widget_class: [*c]GtkWidgetClass, shortcut: ?*GtkShortcut) void;
pub extern fn gtk_widget_class_set_activate_signal(widget_class: [*c]GtkWidgetClass, signal_id: guint) void;
pub extern fn gtk_widget_class_set_activate_signal_from_name(widget_class: [*c]GtkWidgetClass, signal_name: [*c]const u8) void;
pub extern fn gtk_widget_class_get_activate_signal(widget_class: [*c]GtkWidgetClass) guint;
pub extern fn gtk_widget_mnemonic_activate(widget: [*c]GtkWidget, group_cycling: gboolean) gboolean;
pub extern fn gtk_widget_activate(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_can_focus(widget: [*c]GtkWidget, can_focus: gboolean) void;
pub extern fn gtk_widget_get_can_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_focusable(widget: [*c]GtkWidget, focusable: gboolean) void;
pub extern fn gtk_widget_get_focusable(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_visible_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_grab_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_focus_on_click(widget: [*c]GtkWidget, focus_on_click: gboolean) void;
pub extern fn gtk_widget_get_focus_on_click(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_can_target(widget: [*c]GtkWidget, can_target: gboolean) void;
pub extern fn gtk_widget_get_can_target(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_default(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_receives_default(widget: [*c]GtkWidget, receives_default: gboolean) void;
pub extern fn gtk_widget_get_receives_default(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_name(widget: [*c]GtkWidget, name: [*c]const u8) void;
pub extern fn gtk_widget_get_name(widget: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_widget_set_state_flags(widget: [*c]GtkWidget, flags: GtkStateFlags, clear: gboolean) void;
pub extern fn gtk_widget_unset_state_flags(widget: [*c]GtkWidget, flags: GtkStateFlags) void;
pub extern fn gtk_widget_get_state_flags(widget: [*c]GtkWidget) GtkStateFlags;
pub extern fn gtk_widget_set_sensitive(widget: [*c]GtkWidget, sensitive: gboolean) void;
pub extern fn gtk_widget_get_sensitive(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_sensitive(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_visible(widget: [*c]GtkWidget, visible: gboolean) void;
pub extern fn gtk_widget_get_visible(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_visible(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_drawable(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_realized(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_mapped(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_parent(widget: [*c]GtkWidget, parent: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_parent(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_get_root(widget: [*c]GtkWidget) ?*GtkRoot;
pub extern fn gtk_widget_get_native(widget: [*c]GtkWidget) ?*GtkNative;
pub extern fn gtk_widget_set_child_visible(widget: [*c]GtkWidget, child_visible: gboolean) void;
pub extern fn gtk_widget_get_child_visible(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_allocated_width(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_allocated_height(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_allocated_baseline(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_allocation(widget: [*c]GtkWidget, allocation: [*c]GtkAllocation) void;
pub extern fn gtk_widget_compute_transform(widget: [*c]GtkWidget, target: [*c]GtkWidget, out_transform: [*c]graphene_matrix_t) gboolean;
pub extern fn gtk_widget_compute_bounds(widget: [*c]GtkWidget, target: [*c]GtkWidget, out_bounds: [*c]graphene_rect_t) gboolean;
pub extern fn gtk_widget_compute_point(widget: [*c]GtkWidget, target: [*c]GtkWidget, point: [*c]const graphene_point_t, out_point: [*c]graphene_point_t) gboolean;
pub extern fn gtk_widget_get_width(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_height(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_baseline(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_size(widget: [*c]GtkWidget, orientation: GtkOrientation) c_int;
pub extern fn gtk_widget_child_focus(widget: [*c]GtkWidget, direction: GtkDirectionType) gboolean;
pub extern fn gtk_widget_keynav_failed(widget: [*c]GtkWidget, direction: GtkDirectionType) gboolean;
pub extern fn gtk_widget_error_bell(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_size_request(widget: [*c]GtkWidget, width: c_int, height: c_int) void;
pub extern fn gtk_widget_get_size_request(widget: [*c]GtkWidget, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_widget_set_opacity(widget: [*c]GtkWidget, opacity: f64) void;
pub extern fn gtk_widget_get_opacity(widget: [*c]GtkWidget) f64;
pub extern fn gtk_widget_set_overflow(widget: [*c]GtkWidget, overflow: GtkOverflow) void;
pub extern fn gtk_widget_get_overflow(widget: [*c]GtkWidget) GtkOverflow;
pub extern fn gtk_widget_get_ancestor(widget: [*c]GtkWidget, widget_type: GType) [*c]GtkWidget;
pub extern fn gtk_widget_get_scale_factor(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_display(widget: [*c]GtkWidget) ?*GdkDisplay;
pub extern fn gtk_widget_get_settings(widget: [*c]GtkWidget) ?*GtkSettings;
pub extern fn gtk_widget_get_clipboard(widget: [*c]GtkWidget) ?*GdkClipboard;
pub extern fn gtk_widget_get_primary_clipboard(widget: [*c]GtkWidget) ?*GdkClipboard;
pub extern fn gtk_widget_get_hexpand(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_hexpand(widget: [*c]GtkWidget, expand: gboolean) void;
pub extern fn gtk_widget_get_hexpand_set(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_hexpand_set(widget: [*c]GtkWidget, set: gboolean) void;
pub extern fn gtk_widget_get_vexpand(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_vexpand(widget: [*c]GtkWidget, expand: gboolean) void;
pub extern fn gtk_widget_get_vexpand_set(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_vexpand_set(widget: [*c]GtkWidget, set: gboolean) void;
pub extern fn gtk_widget_compute_expand(widget: [*c]GtkWidget, orientation: GtkOrientation) gboolean;
pub extern fn gtk_widget_get_halign(widget: [*c]GtkWidget) GtkAlign;
pub extern fn gtk_widget_set_halign(widget: [*c]GtkWidget, @"align": GtkAlign) void;
pub extern fn gtk_widget_get_valign(widget: [*c]GtkWidget) GtkAlign;
pub extern fn gtk_widget_set_valign(widget: [*c]GtkWidget, @"align": GtkAlign) void;
pub extern fn gtk_widget_get_margin_start(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_set_margin_start(widget: [*c]GtkWidget, margin: c_int) void;
pub extern fn gtk_widget_get_margin_end(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_set_margin_end(widget: [*c]GtkWidget, margin: c_int) void;
pub extern fn gtk_widget_get_margin_top(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_set_margin_top(widget: [*c]GtkWidget, margin: c_int) void;
pub extern fn gtk_widget_get_margin_bottom(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_set_margin_bottom(widget: [*c]GtkWidget, margin: c_int) void;
pub extern fn gtk_widget_is_ancestor(widget: [*c]GtkWidget, ancestor: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_translate_coordinates(src_widget: [*c]GtkWidget, dest_widget: [*c]GtkWidget, src_x: f64, src_y: f64, dest_x: [*c]f64, dest_y: [*c]f64) gboolean;
pub extern fn gtk_widget_contains(widget: [*c]GtkWidget, x: f64, y: f64) gboolean;
pub extern fn gtk_widget_pick(widget: [*c]GtkWidget, x: f64, y: f64, flags: GtkPickFlags) [*c]GtkWidget;
pub extern fn gtk_widget_add_controller(widget: [*c]GtkWidget, controller: ?*GtkEventController) void;
pub extern fn gtk_widget_remove_controller(widget: [*c]GtkWidget, controller: ?*GtkEventController) void;
pub extern fn gtk_widget_create_pango_context(widget: [*c]GtkWidget) ?*PangoContext;
pub extern fn gtk_widget_get_pango_context(widget: [*c]GtkWidget) ?*PangoContext;
pub extern fn gtk_widget_set_font_options(widget: [*c]GtkWidget, options: ?*const cairo_font_options_t) void;
pub extern fn gtk_widget_get_font_options(widget: [*c]GtkWidget) ?*const cairo_font_options_t;
pub extern fn gtk_widget_create_pango_layout(widget: [*c]GtkWidget, text: [*c]const u8) ?*PangoLayout;
pub extern fn gtk_widget_set_direction(widget: [*c]GtkWidget, dir: GtkTextDirection) void;
pub extern fn gtk_widget_get_direction(widget: [*c]GtkWidget) GtkTextDirection;
pub extern fn gtk_widget_set_default_direction(dir: GtkTextDirection) void;
pub extern fn gtk_widget_get_default_direction() GtkTextDirection;
pub extern fn gtk_widget_set_cursor(widget: [*c]GtkWidget, cursor: ?*GdkCursor) void;
pub extern fn gtk_widget_set_cursor_from_name(widget: [*c]GtkWidget, name: [*c]const u8) void;
pub extern fn gtk_widget_get_cursor(widget: [*c]GtkWidget) ?*GdkCursor;
pub extern fn gtk_widget_list_mnemonic_labels(widget: [*c]GtkWidget) [*c]GList;
pub extern fn gtk_widget_add_mnemonic_label(widget: [*c]GtkWidget, label: [*c]GtkWidget) void;
pub extern fn gtk_widget_remove_mnemonic_label(widget: [*c]GtkWidget, label: [*c]GtkWidget) void;
pub extern fn gtk_widget_trigger_tooltip_query(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_tooltip_text(widget: [*c]GtkWidget, text: [*c]const u8) void;
pub extern fn gtk_widget_get_tooltip_text(widget: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_widget_set_tooltip_markup(widget: [*c]GtkWidget, markup: [*c]const u8) void;
pub extern fn gtk_widget_get_tooltip_markup(widget: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_widget_set_has_tooltip(widget: [*c]GtkWidget, has_tooltip: gboolean) void;
pub extern fn gtk_widget_get_has_tooltip(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_requisition_get_type() GType;
pub extern fn gtk_requisition_new() [*c]GtkRequisition;
pub extern fn gtk_requisition_copy(requisition: [*c]const GtkRequisition) [*c]GtkRequisition;
pub extern fn gtk_requisition_free(requisition: [*c]GtkRequisition) void;
pub extern fn gtk_widget_in_destruction(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_style_context(widget: [*c]GtkWidget) [*c]GtkStyleContext;
pub extern fn gtk_widget_class_set_css_name(widget_class: [*c]GtkWidgetClass, name: [*c]const u8) void;
pub extern fn gtk_widget_class_get_css_name(widget_class: [*c]GtkWidgetClass) [*c]const u8;
pub extern fn gtk_widget_add_tick_callback(widget: [*c]GtkWidget, callback: GtkTickCallback, user_data: gpointer, notify: GDestroyNotify) guint;
pub extern fn gtk_widget_remove_tick_callback(widget: [*c]GtkWidget, id: guint) void;
pub extern fn gtk_widget_init_template(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_template_child(widget: [*c]GtkWidget, widget_type: GType, name: [*c]const u8) [*c]GObject;
pub extern fn gtk_widget_dispose_template(widget: [*c]GtkWidget, widget_type: GType) void;
pub extern fn gtk_widget_class_set_template(widget_class: [*c]GtkWidgetClass, template_bytes: ?*GBytes) void;
pub extern fn gtk_widget_class_set_template_from_resource(widget_class: [*c]GtkWidgetClass, resource_name: [*c]const u8) void;
pub extern fn gtk_widget_class_bind_template_callback_full(widget_class: [*c]GtkWidgetClass, callback_name: [*c]const u8, callback_symbol: GCallback) void;
pub extern fn gtk_widget_class_set_template_scope(widget_class: [*c]GtkWidgetClass, scope: ?*GtkBuilderScope) void;
pub extern fn gtk_widget_class_bind_template_child_full(widget_class: [*c]GtkWidgetClass, name: [*c]const u8, internal_child: gboolean, struct_offset: gssize) void;
pub extern fn gtk_widget_insert_action_group(widget: [*c]GtkWidget, name: [*c]const u8, group: ?*GActionGroup) void;
pub extern fn gtk_widget_activate_action(widget: [*c]GtkWidget, name: [*c]const u8, format_string: [*c]const u8, ...) gboolean;
pub extern fn gtk_widget_activate_action_variant(widget: [*c]GtkWidget, name: [*c]const u8, args: ?*GVariant) gboolean;
pub extern fn gtk_widget_activate_default(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_font_map(widget: [*c]GtkWidget, font_map: [*c]PangoFontMap) void;
pub extern fn gtk_widget_get_font_map(widget: [*c]GtkWidget) [*c]PangoFontMap;
pub extern fn gtk_widget_get_first_child(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_get_last_child(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_get_next_sibling(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_get_prev_sibling(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_observe_children(widget: [*c]GtkWidget) ?*GListModel;
pub extern fn gtk_widget_observe_controllers(widget: [*c]GtkWidget) ?*GListModel;
pub extern fn gtk_widget_insert_after(widget: [*c]GtkWidget, parent: [*c]GtkWidget, previous_sibling: [*c]GtkWidget) void;
pub extern fn gtk_widget_insert_before(widget: [*c]GtkWidget, parent: [*c]GtkWidget, next_sibling: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_focus_child(widget: [*c]GtkWidget, child: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_focus_child(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_snapshot_child(widget: [*c]GtkWidget, child: [*c]GtkWidget, snapshot: ?*GtkSnapshot) void;
pub extern fn gtk_widget_should_layout(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_css_name(self: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_widget_add_css_class(widget: [*c]GtkWidget, css_class: [*c]const u8) void;
pub extern fn gtk_widget_remove_css_class(widget: [*c]GtkWidget, css_class: [*c]const u8) void;
pub extern fn gtk_widget_has_css_class(widget: [*c]GtkWidget, css_class: [*c]const u8) gboolean;
pub extern fn gtk_widget_get_css_classes(widget: [*c]GtkWidget) [*c][*c]u8;
pub extern fn gtk_widget_set_css_classes(widget: [*c]GtkWidget, classes: [*c][*c]const u8) void;
pub extern fn gtk_widget_get_color(widget: [*c]GtkWidget, color: [*c]GdkRGBA) void;
pub const GtkWidgetActionActivateFunc = ?*const fn ([*c]GtkWidget, [*c]const u8, ?*GVariant) callconv(.C) void;
pub extern fn gtk_widget_class_install_action(widget_class: [*c]GtkWidgetClass, action_name: [*c]const u8, parameter_type: [*c]const u8, activate: GtkWidgetActionActivateFunc) void;
pub extern fn gtk_widget_class_install_property_action(widget_class: [*c]GtkWidgetClass, action_name: [*c]const u8, property_name: [*c]const u8) void;
pub extern fn gtk_widget_class_query_action(widget_class: [*c]GtkWidgetClass, index_: guint, owner: [*c]GType, action_name: [*c][*c]const u8, parameter_type: [*c]?*const GVariantType, property_name: [*c][*c]const u8) gboolean;
pub extern fn gtk_widget_action_set_enabled(widget: [*c]GtkWidget, action_name: [*c]const u8, enabled: gboolean) void;
pub extern fn gtk_widget_class_set_accessible_role(widget_class: [*c]GtkWidgetClass, accessible_role: GtkAccessibleRole) void;
pub extern fn gtk_widget_class_get_accessible_role(widget_class: [*c]GtkWidgetClass) GtkAccessibleRole;
pub const GtkWidget_autoptr = [*c]GtkWidget;
pub const GtkWidget_listautoptr = [*c]GList;
pub const GtkWidget_slistautoptr = [*c]GSList;
pub const GtkWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWidget(arg__ptr: [*c]GtkWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkWidget(arg__ptr: [*c][*c]GtkWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWidget(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWidget(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWidget(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWidget(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkRequisition_autoptr = [*c]GtkRequisition;
pub const GtkRequisition_listautoptr = [*c]GList;
pub const GtkRequisition_slistautoptr = [*c]GSList;
pub const GtkRequisition_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRequisition(arg__ptr: [*c]GtkRequisition) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_requisition_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkRequisition(arg__ptr: [*c][*c]GtkRequisition) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkRequisition(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkRequisition(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_requisition_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkRequisition(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_requisition_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkRequisition(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_requisition_free)))))));
    }
}
pub const struct__GtkApplication = extern struct {
    parent_instance: GApplication,
};
pub const GtkApplication = struct__GtkApplication;
pub const struct__GtkApplicationClass = extern struct {
    parent_class: GApplicationClass,
    window_added: ?*const fn ([*c]GtkApplication, [*c]GtkWindow) callconv(.C) void,
    window_removed: ?*const fn ([*c]GtkApplication, [*c]GtkWindow) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkApplicationClass = struct__GtkApplicationClass;
pub extern fn gtk_application_get_type() GType;
pub extern fn gtk_application_new(application_id: [*c]const u8, flags: GApplicationFlags) [*c]GtkApplication;
pub extern fn gtk_application_add_window(application: [*c]GtkApplication, window: [*c]GtkWindow) void;
pub extern fn gtk_application_remove_window(application: [*c]GtkApplication, window: [*c]GtkWindow) void;
pub extern fn gtk_application_get_windows(application: [*c]GtkApplication) [*c]GList;
pub extern fn gtk_application_get_menubar(application: [*c]GtkApplication) [*c]GMenuModel;
pub extern fn gtk_application_set_menubar(application: [*c]GtkApplication, menubar: [*c]GMenuModel) void;
pub const GTK_APPLICATION_INHIBIT_LOGOUT: c_int = 1;
pub const GTK_APPLICATION_INHIBIT_SWITCH: c_int = 2;
pub const GTK_APPLICATION_INHIBIT_SUSPEND: c_int = 4;
pub const GTK_APPLICATION_INHIBIT_IDLE: c_int = 8;
pub const GtkApplicationInhibitFlags = c_uint;
pub extern fn gtk_application_inhibit(application: [*c]GtkApplication, window: [*c]GtkWindow, flags: GtkApplicationInhibitFlags, reason: [*c]const u8) guint;
pub extern fn gtk_application_uninhibit(application: [*c]GtkApplication, cookie: guint) void;
pub extern fn gtk_application_get_window_by_id(application: [*c]GtkApplication, id: guint) [*c]GtkWindow;
pub extern fn gtk_application_get_active_window(application: [*c]GtkApplication) [*c]GtkWindow;
pub extern fn gtk_application_list_action_descriptions(application: [*c]GtkApplication) [*c][*c]u8;
pub extern fn gtk_application_get_accels_for_action(application: [*c]GtkApplication, detailed_action_name: [*c]const u8) [*c][*c]u8;
pub extern fn gtk_application_get_actions_for_accel(application: [*c]GtkApplication, accel: [*c]const u8) [*c][*c]u8;
pub extern fn gtk_application_set_accels_for_action(application: [*c]GtkApplication, detailed_action_name: [*c]const u8, accels: [*c]const [*c]const u8) void;
pub extern fn gtk_application_get_menu_by_id(application: [*c]GtkApplication, id: [*c]const u8) ?*GMenu;
pub const GtkApplication_autoptr = [*c]GtkApplication;
pub const GtkApplication_listautoptr = [*c]GList;
pub const GtkApplication_slistautoptr = [*c]GSList;
pub const GtkApplication_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkApplication(arg__ptr: [*c]GtkApplication) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkApplication(arg__ptr: [*c][*c]GtkApplication) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkApplication(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkApplication(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkApplication(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkApplication(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_accelerator_valid(keyval: guint, modifiers: GdkModifierType) gboolean;
pub extern fn gtk_accelerator_parse(accelerator: [*c]const u8, accelerator_key: [*c]guint, accelerator_mods: [*c]GdkModifierType) gboolean;
pub extern fn gtk_accelerator_parse_with_keycode(accelerator: [*c]const u8, display: ?*GdkDisplay, accelerator_key: [*c]guint, accelerator_codes: [*c][*c]guint, accelerator_mods: [*c]GdkModifierType) gboolean;
pub extern fn gtk_accelerator_name(accelerator_key: guint, accelerator_mods: GdkModifierType) [*c]u8;
pub extern fn gtk_accelerator_name_with_keycode(display: ?*GdkDisplay, accelerator_key: guint, keycode: guint, accelerator_mods: GdkModifierType) [*c]u8;
pub extern fn gtk_accelerator_get_label(accelerator_key: guint, accelerator_mods: GdkModifierType) [*c]u8;
pub extern fn gtk_accelerator_get_label_with_keycode(display: ?*GdkDisplay, accelerator_key: guint, keycode: guint, accelerator_mods: GdkModifierType) [*c]u8;
pub extern fn gtk_accelerator_get_default_mod_mask() GdkModifierType;
pub const struct__GtkWindowClass = extern struct {
    parent_class: GtkWidgetClass,
    activate_focus: ?*const fn ([*c]GtkWindow) callconv(.C) void,
    activate_default: ?*const fn ([*c]GtkWindow) callconv(.C) void,
    keys_changed: ?*const fn ([*c]GtkWindow) callconv(.C) void,
    enable_debugging: ?*const fn ([*c]GtkWindow, gboolean) callconv(.C) gboolean,
    close_request: ?*const fn ([*c]GtkWindow) callconv(.C) gboolean,
    padding: [8]gpointer,
};
pub const GtkWindowClass = struct__GtkWindowClass;
pub const struct__GtkWindowGroupPrivate = opaque {};
pub const GtkWindowGroupPrivate = struct__GtkWindowGroupPrivate;
pub const struct__GtkWindowGroup = extern struct {
    parent_instance: GObject,
    priv: ?*GtkWindowGroupPrivate,
};
pub const GtkWindowGroup = struct__GtkWindowGroup;
pub const struct__GtkWindowGroupClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkWindowGroupClass = struct__GtkWindowGroupClass;
pub extern fn gtk_window_get_type() GType;
pub extern fn gtk_window_new() [*c]GtkWidget;
pub extern fn gtk_window_set_title(window: [*c]GtkWindow, title: [*c]const u8) void;
pub extern fn gtk_window_get_title(window: [*c]GtkWindow) [*c]const u8;
pub extern fn gtk_window_set_startup_id(window: [*c]GtkWindow, startup_id: [*c]const u8) void;
pub extern fn gtk_window_set_focus(window: [*c]GtkWindow, focus: [*c]GtkWidget) void;
pub extern fn gtk_window_get_focus(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_set_default_widget(window: [*c]GtkWindow, default_widget: [*c]GtkWidget) void;
pub extern fn gtk_window_get_default_widget(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_set_transient_for(window: [*c]GtkWindow, parent: [*c]GtkWindow) void;
pub extern fn gtk_window_get_transient_for(window: [*c]GtkWindow) [*c]GtkWindow;
pub extern fn gtk_window_set_destroy_with_parent(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_destroy_with_parent(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_hide_on_close(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_hide_on_close(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_mnemonics_visible(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_mnemonics_visible(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_focus_visible(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_focus_visible(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_resizable(window: [*c]GtkWindow, resizable: gboolean) void;
pub extern fn gtk_window_get_resizable(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_display(window: [*c]GtkWindow, display: ?*GdkDisplay) void;
pub extern fn gtk_window_is_active(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_decorated(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_decorated(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_deletable(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_deletable(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_icon_name(window: [*c]GtkWindow, name: [*c]const u8) void;
pub extern fn gtk_window_get_icon_name(window: [*c]GtkWindow) [*c]const u8;
pub extern fn gtk_window_set_default_icon_name(name: [*c]const u8) void;
pub extern fn gtk_window_get_default_icon_name() [*c]const u8;
pub extern fn gtk_window_set_auto_startup_notification(setting: gboolean) void;
pub extern fn gtk_window_set_modal(window: [*c]GtkWindow, modal: gboolean) void;
pub extern fn gtk_window_get_modal(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_get_toplevels() ?*GListModel;
pub extern fn gtk_window_list_toplevels() [*c]GList;
pub extern fn gtk_window_present(window: [*c]GtkWindow) void;
pub extern fn gtk_window_present_with_time(window: [*c]GtkWindow, timestamp: guint32) void;
pub extern fn gtk_window_minimize(window: [*c]GtkWindow) void;
pub extern fn gtk_window_unminimize(window: [*c]GtkWindow) void;
pub extern fn gtk_window_maximize(window: [*c]GtkWindow) void;
pub extern fn gtk_window_unmaximize(window: [*c]GtkWindow) void;
pub extern fn gtk_window_fullscreen(window: [*c]GtkWindow) void;
pub extern fn gtk_window_unfullscreen(window: [*c]GtkWindow) void;
pub extern fn gtk_window_fullscreen_on_monitor(window: [*c]GtkWindow, monitor: ?*GdkMonitor) void;
pub extern fn gtk_window_close(window: [*c]GtkWindow) void;
pub extern fn gtk_window_set_default_size(window: [*c]GtkWindow, width: c_int, height: c_int) void;
pub extern fn gtk_window_get_default_size(window: [*c]GtkWindow, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_window_get_group(window: [*c]GtkWindow) [*c]GtkWindowGroup;
pub extern fn gtk_window_has_group(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_get_application(window: [*c]GtkWindow) [*c]GtkApplication;
pub extern fn gtk_window_set_application(window: [*c]GtkWindow, application: [*c]GtkApplication) void;
pub extern fn gtk_window_set_child(window: [*c]GtkWindow, child: [*c]GtkWidget) void;
pub extern fn gtk_window_get_child(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_set_titlebar(window: [*c]GtkWindow, titlebar: [*c]GtkWidget) void;
pub extern fn gtk_window_get_titlebar(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_is_maximized(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_is_fullscreen(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_is_suspended(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_destroy(window: [*c]GtkWindow) void;
pub extern fn gtk_window_set_interactive_debugging(enable: gboolean) void;
pub extern fn gtk_window_set_handle_menubar_accel(window: [*c]GtkWindow, handle_menubar_accel: gboolean) void;
pub extern fn gtk_window_get_handle_menubar_accel(window: [*c]GtkWindow) gboolean;
pub const GtkWindow_autoptr = [*c]GtkWindow;
pub const GtkWindow_listautoptr = [*c]GList;
pub const GtkWindow_slistautoptr = [*c]GSList;
pub const GtkWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindow(arg__ptr: [*c]GtkWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkWindow(arg__ptr: [*c][*c]GtkWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWindow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWindow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWindow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWindow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkWindowGroup_autoptr = [*c]GtkWindowGroup;
pub const GtkWindowGroup_listautoptr = [*c]GList;
pub const GtkWindowGroup_slistautoptr = [*c]GSList;
pub const GtkWindowGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindowGroup(arg__ptr: [*c]GtkWindowGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkWindowGroup(arg__ptr: [*c][*c]GtkWindowGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWindowGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWindowGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWindowGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWindowGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkAboutDialog = opaque {};
pub const GtkAboutDialog = struct__GtkAboutDialog;
pub const GTK_LICENSE_UNKNOWN: c_int = 0;
pub const GTK_LICENSE_CUSTOM: c_int = 1;
pub const GTK_LICENSE_GPL_2_0: c_int = 2;
pub const GTK_LICENSE_GPL_3_0: c_int = 3;
pub const GTK_LICENSE_LGPL_2_1: c_int = 4;
pub const GTK_LICENSE_LGPL_3_0: c_int = 5;
pub const GTK_LICENSE_BSD: c_int = 6;
pub const GTK_LICENSE_MIT_X11: c_int = 7;
pub const GTK_LICENSE_ARTISTIC: c_int = 8;
pub const GTK_LICENSE_GPL_2_0_ONLY: c_int = 9;
pub const GTK_LICENSE_GPL_3_0_ONLY: c_int = 10;
pub const GTK_LICENSE_LGPL_2_1_ONLY: c_int = 11;
pub const GTK_LICENSE_LGPL_3_0_ONLY: c_int = 12;
pub const GTK_LICENSE_AGPL_3_0: c_int = 13;
pub const GTK_LICENSE_AGPL_3_0_ONLY: c_int = 14;
pub const GTK_LICENSE_BSD_3: c_int = 15;
pub const GTK_LICENSE_APACHE_2_0: c_int = 16;
pub const GTK_LICENSE_MPL_2_0: c_int = 17;
pub const GtkLicense = c_uint;
pub extern fn gtk_about_dialog_get_type() GType;
pub extern fn gtk_about_dialog_new() [*c]GtkWidget;
pub extern fn gtk_show_about_dialog(parent: [*c]GtkWindow, first_property_name: [*c]const u8, ...) void;
pub extern fn gtk_about_dialog_get_program_name(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_program_name(about: ?*GtkAboutDialog, name: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_version(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_version(about: ?*GtkAboutDialog, version: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_copyright(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_copyright(about: ?*GtkAboutDialog, copyright: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_comments(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_comments(about: ?*GtkAboutDialog, comments: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_license(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_license(about: ?*GtkAboutDialog, license: [*c]const u8) void;
pub extern fn gtk_about_dialog_set_license_type(about: ?*GtkAboutDialog, license_type: GtkLicense) void;
pub extern fn gtk_about_dialog_get_license_type(about: ?*GtkAboutDialog) GtkLicense;
pub extern fn gtk_about_dialog_get_wrap_license(about: ?*GtkAboutDialog) gboolean;
pub extern fn gtk_about_dialog_set_wrap_license(about: ?*GtkAboutDialog, wrap_license: gboolean) void;
pub extern fn gtk_about_dialog_get_system_information(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_system_information(about: ?*GtkAboutDialog, system_information: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_website(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_website(about: ?*GtkAboutDialog, website: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_website_label(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_website_label(about: ?*GtkAboutDialog, website_label: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_authors(about: ?*GtkAboutDialog) [*c]const [*c]const u8;
pub extern fn gtk_about_dialog_set_authors(about: ?*GtkAboutDialog, authors: [*c][*c]const u8) void;
pub extern fn gtk_about_dialog_get_documenters(about: ?*GtkAboutDialog) [*c]const [*c]const u8;
pub extern fn gtk_about_dialog_set_documenters(about: ?*GtkAboutDialog, documenters: [*c][*c]const u8) void;
pub extern fn gtk_about_dialog_get_artists(about: ?*GtkAboutDialog) [*c]const [*c]const u8;
pub extern fn gtk_about_dialog_set_artists(about: ?*GtkAboutDialog, artists: [*c][*c]const u8) void;
pub extern fn gtk_about_dialog_get_translator_credits(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_translator_credits(about: ?*GtkAboutDialog, translator_credits: [*c]const u8) void;
pub extern fn gtk_about_dialog_get_logo(about: ?*GtkAboutDialog) ?*GdkPaintable;
pub extern fn gtk_about_dialog_set_logo(about: ?*GtkAboutDialog, logo: ?*GdkPaintable) void;
pub extern fn gtk_about_dialog_get_logo_icon_name(about: ?*GtkAboutDialog) [*c]const u8;
pub extern fn gtk_about_dialog_set_logo_icon_name(about: ?*GtkAboutDialog, icon_name: [*c]const u8) void;
pub extern fn gtk_about_dialog_add_credit_section(about: ?*GtkAboutDialog, section_name: [*c]const u8, people: [*c][*c]const u8) void;
pub const GtkAboutDialog_autoptr = ?*GtkAboutDialog;
pub const GtkAboutDialog_listautoptr = [*c]GList;
pub const GtkAboutDialog_slistautoptr = [*c]GSList;
pub const GtkAboutDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAboutDialog(arg__ptr: ?*GtkAboutDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAboutDialog(arg__ptr: [*c]?*GtkAboutDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAboutDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAboutDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAboutDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAboutDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_accessible_get_type() GType;
pub const struct__GtkAccessible = opaque {};
pub const GtkAccessible = struct__GtkAccessible;
pub const struct__GtkAccessibleInterface = extern struct {
    g_iface: GTypeInterface,
    get_at_context: ?*const fn (?*GtkAccessible) callconv(.C) ?*GtkATContext,
    get_platform_state: ?*const fn (?*GtkAccessible, GtkAccessiblePlatformState) callconv(.C) gboolean,
    get_accessible_parent: ?*const fn (?*GtkAccessible) callconv(.C) ?*GtkAccessible,
    get_first_accessible_child: ?*const fn (?*GtkAccessible) callconv(.C) ?*GtkAccessible,
    get_next_accessible_sibling: ?*const fn (?*GtkAccessible) callconv(.C) ?*GtkAccessible,
    get_bounds: ?*const fn (?*GtkAccessible, [*c]c_int, [*c]c_int, [*c]c_int, [*c]c_int) callconv(.C) gboolean,
};
pub const GtkAccessibleInterface = struct__GtkAccessibleInterface;
pub const GtkAccessible_autoptr = ?*GtkAccessible;
pub const GtkAccessible_listautoptr = [*c]GList;
pub const GtkAccessible_slistautoptr = [*c]GSList;
pub const GtkAccessible_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAccessible(arg__ptr: ?*GtkAccessible) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkAccessible(arg__ptr: [*c]?*GtkAccessible) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAccessible(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAccessible(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAccessible(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAccessible(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GTK_ACCESSIBLE(arg_ptr: gpointer) callconv(.C) ?*GtkAccessible {
    var ptr = arg_ptr;
    return @as(?*GtkAccessible, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_accessible_get_type())))));
}
pub fn GTK_IS_ACCESSIBLE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_accessible_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_ACCESSIBLE_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkAccessibleInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkAccessibleInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_accessible_get_type()))));
}
pub const GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSABLE: c_int = 0;
pub const GTK_ACCESSIBLE_PLATFORM_STATE_FOCUSED: c_int = 1;
pub const GTK_ACCESSIBLE_PLATFORM_STATE_ACTIVE: c_int = 2;
pub const GtkAccessiblePlatformState = c_uint;
pub extern fn gtk_accessible_get_at_context(self: ?*GtkAccessible) ?*GtkATContext;
pub extern fn gtk_accessible_get_platform_state(self: ?*GtkAccessible, state: GtkAccessiblePlatformState) gboolean;
pub extern fn gtk_accessible_get_accessible_parent(self: ?*GtkAccessible) ?*GtkAccessible;
pub extern fn gtk_accessible_set_accessible_parent(self: ?*GtkAccessible, parent: ?*GtkAccessible, next_sibling: ?*GtkAccessible) void;
pub extern fn gtk_accessible_get_first_accessible_child(self: ?*GtkAccessible) ?*GtkAccessible;
pub extern fn gtk_accessible_get_next_accessible_sibling(self: ?*GtkAccessible) ?*GtkAccessible;
pub extern fn gtk_accessible_update_next_accessible_sibling(self: ?*GtkAccessible, new_sibling: ?*GtkAccessible) void;
pub extern fn gtk_accessible_get_bounds(self: ?*GtkAccessible, x: [*c]c_int, y: [*c]c_int, width: [*c]c_int, height: [*c]c_int) gboolean;
pub extern fn gtk_accessible_get_accessible_role(self: ?*GtkAccessible) GtkAccessibleRole;
pub extern fn gtk_accessible_update_state(self: ?*GtkAccessible, first_state: GtkAccessibleState, ...) void;
pub extern fn gtk_accessible_update_property(self: ?*GtkAccessible, first_property: GtkAccessibleProperty, ...) void;
pub extern fn gtk_accessible_update_relation(self: ?*GtkAccessible, first_relation: GtkAccessibleRelation, ...) void;
pub extern fn gtk_accessible_update_state_value(self: ?*GtkAccessible, n_states: c_int, states: [*c]GtkAccessibleState, values: [*c]const GValue) void;
pub extern fn gtk_accessible_update_property_value(self: ?*GtkAccessible, n_properties: c_int, properties: [*c]GtkAccessibleProperty, values: [*c]const GValue) void;
pub extern fn gtk_accessible_update_relation_value(self: ?*GtkAccessible, n_relations: c_int, relations: [*c]GtkAccessibleRelation, values: [*c]const GValue) void;
pub extern fn gtk_accessible_reset_state(self: ?*GtkAccessible, state: GtkAccessibleState) void;
pub extern fn gtk_accessible_reset_property(self: ?*GtkAccessible, property: GtkAccessibleProperty) void;
pub extern fn gtk_accessible_reset_relation(self: ?*GtkAccessible, relation: GtkAccessibleRelation) void;
pub extern fn gtk_accessible_state_init_value(state: GtkAccessibleState, value: [*c]GValue) void;
pub extern fn gtk_accessible_property_init_value(property: GtkAccessibleProperty, value: [*c]GValue) void;
pub extern fn gtk_accessible_relation_init_value(relation: GtkAccessibleRelation, value: [*c]GValue) void;
pub extern fn gtk_accessible_range_get_type() GType;
pub const struct__GtkAccessibleRange = opaque {};
pub const GtkAccessibleRange = struct__GtkAccessibleRange;
pub const struct__GtkAccessibleRangeInterface = extern struct {
    g_iface: GTypeInterface,
    set_current_value: ?*const fn (?*GtkAccessibleRange, f64) callconv(.C) gboolean,
};
pub const GtkAccessibleRangeInterface = struct__GtkAccessibleRangeInterface;
pub const GtkAccessibleRange_autoptr = ?*GtkAccessibleRange;
pub const GtkAccessibleRange_listautoptr = [*c]GList;
pub const GtkAccessibleRange_slistautoptr = [*c]GSList;
pub const GtkAccessibleRange_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAccessibleRange(arg__ptr: ?*GtkAccessibleRange) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkAccessible(@as(?*GtkAccessible, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAccessibleRange(arg__ptr: [*c]?*GtkAccessibleRange) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAccessibleRange(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAccessibleRange(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkAccessible)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAccessibleRange(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkAccessible)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAccessibleRange(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkAccessible)))))));
    }
}
pub fn GTK_ACCESSIBLE_RANGE(arg_ptr: gpointer) callconv(.C) ?*GtkAccessibleRange {
    var ptr = arg_ptr;
    return @as(?*GtkAccessibleRange, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_accessible_range_get_type())))));
}
pub fn GTK_IS_ACCESSIBLE_RANGE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_accessible_range_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_ACCESSIBLE_RANGE_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkAccessibleRangeInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkAccessibleRangeInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_accessible_range_get_type()))));
}
pub const struct__GtkActionable = opaque {};
pub const GtkActionable = struct__GtkActionable;
pub const struct__GtkActionableInterface = extern struct {
    g_iface: GTypeInterface,
    get_action_name: ?*const fn (?*GtkActionable) callconv(.C) [*c]const u8,
    set_action_name: ?*const fn (?*GtkActionable, [*c]const u8) callconv(.C) void,
    get_action_target_value: ?*const fn (?*GtkActionable) callconv(.C) ?*GVariant,
    set_action_target_value: ?*const fn (?*GtkActionable, ?*GVariant) callconv(.C) void,
};
pub const GtkActionableInterface = struct__GtkActionableInterface;
pub extern fn gtk_actionable_get_type() GType;
pub extern fn gtk_actionable_get_action_name(actionable: ?*GtkActionable) [*c]const u8;
pub extern fn gtk_actionable_set_action_name(actionable: ?*GtkActionable, action_name: [*c]const u8) void;
pub extern fn gtk_actionable_get_action_target_value(actionable: ?*GtkActionable) ?*GVariant;
pub extern fn gtk_actionable_set_action_target_value(actionable: ?*GtkActionable, target_value: ?*GVariant) void;
pub extern fn gtk_actionable_set_action_target(actionable: ?*GtkActionable, format_string: [*c]const u8, ...) void;
pub extern fn gtk_actionable_set_detailed_action_name(actionable: ?*GtkActionable, detailed_action_name: [*c]const u8) void;
pub const GtkActionable_autoptr = ?*GtkActionable;
pub const GtkActionable_listautoptr = [*c]GList;
pub const GtkActionable_slistautoptr = [*c]GSList;
pub const GtkActionable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkActionable(arg__ptr: ?*GtkActionable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkActionable(arg__ptr: [*c]?*GtkActionable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkActionable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkActionable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkActionable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkActionable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkActionBar = opaque {};
pub const GtkActionBar = struct__GtkActionBar;
pub extern fn gtk_action_bar_get_type() GType;
pub extern fn gtk_action_bar_new() [*c]GtkWidget;
pub extern fn gtk_action_bar_get_center_widget(action_bar: ?*GtkActionBar) [*c]GtkWidget;
pub extern fn gtk_action_bar_set_center_widget(action_bar: ?*GtkActionBar, center_widget: [*c]GtkWidget) void;
pub extern fn gtk_action_bar_pack_start(action_bar: ?*GtkActionBar, child: [*c]GtkWidget) void;
pub extern fn gtk_action_bar_pack_end(action_bar: ?*GtkActionBar, child: [*c]GtkWidget) void;
pub extern fn gtk_action_bar_remove(action_bar: ?*GtkActionBar, child: [*c]GtkWidget) void;
pub extern fn gtk_action_bar_set_revealed(action_bar: ?*GtkActionBar, revealed: gboolean) void;
pub extern fn gtk_action_bar_get_revealed(action_bar: ?*GtkActionBar) gboolean;
pub const GtkActionBar_autoptr = ?*GtkActionBar;
pub const GtkActionBar_listautoptr = [*c]GList;
pub const GtkActionBar_slistautoptr = [*c]GSList;
pub const GtkActionBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkActionBar(arg__ptr: ?*GtkActionBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkActionBar(arg__ptr: [*c]?*GtkActionBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkActionBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkActionBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkActionBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkActionBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkAdjustmentClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    changed: ?*const fn ([*c]GtkAdjustment) callconv(.C) void,
    value_changed: ?*const fn ([*c]GtkAdjustment) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkAdjustmentClass = struct__GtkAdjustmentClass;
pub extern fn gtk_adjustment_get_type() GType;
pub extern fn gtk_adjustment_new(value: f64, lower: f64, upper: f64, step_increment: f64, page_increment: f64, page_size: f64) [*c]GtkAdjustment;
pub extern fn gtk_adjustment_clamp_page(adjustment: [*c]GtkAdjustment, lower: f64, upper: f64) void;
pub extern fn gtk_adjustment_get_value(adjustment: [*c]GtkAdjustment) f64;
pub extern fn gtk_adjustment_set_value(adjustment: [*c]GtkAdjustment, value: f64) void;
pub extern fn gtk_adjustment_get_lower(adjustment: [*c]GtkAdjustment) f64;
pub extern fn gtk_adjustment_set_lower(adjustment: [*c]GtkAdjustment, lower: f64) void;
pub extern fn gtk_adjustment_get_upper(adjustment: [*c]GtkAdjustment) f64;
pub extern fn gtk_adjustment_set_upper(adjustment: [*c]GtkAdjustment, upper: f64) void;
pub extern fn gtk_adjustment_get_step_increment(adjustment: [*c]GtkAdjustment) f64;
pub extern fn gtk_adjustment_set_step_increment(adjustment: [*c]GtkAdjustment, step_increment: f64) void;
pub extern fn gtk_adjustment_get_page_increment(adjustment: [*c]GtkAdjustment) f64;
pub extern fn gtk_adjustment_set_page_increment(adjustment: [*c]GtkAdjustment, page_increment: f64) void;
pub extern fn gtk_adjustment_get_page_size(adjustment: [*c]GtkAdjustment) f64;
pub extern fn gtk_adjustment_set_page_size(adjustment: [*c]GtkAdjustment, page_size: f64) void;
pub extern fn gtk_adjustment_configure(adjustment: [*c]GtkAdjustment, value: f64, lower: f64, upper: f64, step_increment: f64, page_increment: f64, page_size: f64) void;
pub extern fn gtk_adjustment_get_minimum_increment(adjustment: [*c]GtkAdjustment) f64;
pub const GtkAdjustment_autoptr = [*c]GtkAdjustment;
pub const GtkAdjustment_listautoptr = [*c]GList;
pub const GtkAdjustment_slistautoptr = [*c]GSList;
pub const GtkAdjustment_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAdjustment(arg__ptr: [*c]GtkAdjustment) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAdjustment(arg__ptr: [*c][*c]GtkAdjustment) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAdjustment(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAdjustment(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAdjustment(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAdjustment(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_alert_dialog_get_type() GType;
pub const struct__GtkAlertDialog = opaque {};
pub const GtkAlertDialog = struct__GtkAlertDialog;
pub const GtkAlertDialogClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkAlertDialog_autoptr = ?*GtkAlertDialog;
pub const GtkAlertDialog_listautoptr = [*c]GList;
pub const GtkAlertDialog_slistautoptr = [*c]GSList;
pub const GtkAlertDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAlertDialog(arg__ptr: ?*GtkAlertDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkAlertDialog(arg__ptr: [*c]?*GtkAlertDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAlertDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAlertDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAlertDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAlertDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkAlertDialogClass_autoptr = [*c]GtkAlertDialogClass;
pub const GtkAlertDialogClass_listautoptr = [*c]GList;
pub const GtkAlertDialogClass_slistautoptr = [*c]GSList;
pub const GtkAlertDialogClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAlertDialogClass(arg__ptr: [*c]GtkAlertDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAlertDialogClass(arg__ptr: [*c][*c]GtkAlertDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAlertDialogClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAlertDialogClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAlertDialogClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAlertDialogClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_ALERT_DIALOG(arg_ptr: gpointer) callconv(.C) ?*GtkAlertDialog {
    var ptr = arg_ptr;
    return @as(?*GtkAlertDialog, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_alert_dialog_get_type())))));
}
pub fn GTK_IS_ALERT_DIALOG(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_alert_dialog_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_alert_dialog_new(format: [*c]const u8, ...) ?*GtkAlertDialog;
pub extern fn gtk_alert_dialog_get_modal(self: ?*GtkAlertDialog) gboolean;
pub extern fn gtk_alert_dialog_set_modal(self: ?*GtkAlertDialog, modal: gboolean) void;
pub extern fn gtk_alert_dialog_get_message(self: ?*GtkAlertDialog) [*c]const u8;
pub extern fn gtk_alert_dialog_set_message(self: ?*GtkAlertDialog, message: [*c]const u8) void;
pub extern fn gtk_alert_dialog_get_detail(self: ?*GtkAlertDialog) [*c]const u8;
pub extern fn gtk_alert_dialog_set_detail(self: ?*GtkAlertDialog, detail: [*c]const u8) void;
pub extern fn gtk_alert_dialog_get_buttons(self: ?*GtkAlertDialog) [*c]const [*c]const u8;
pub extern fn gtk_alert_dialog_set_buttons(self: ?*GtkAlertDialog, labels: [*c]const [*c]const u8) void;
pub extern fn gtk_alert_dialog_get_cancel_button(self: ?*GtkAlertDialog) c_int;
pub extern fn gtk_alert_dialog_set_cancel_button(self: ?*GtkAlertDialog, button: c_int) void;
pub extern fn gtk_alert_dialog_get_default_button(self: ?*GtkAlertDialog) c_int;
pub extern fn gtk_alert_dialog_set_default_button(self: ?*GtkAlertDialog, button: c_int) void;
pub extern fn gtk_alert_dialog_choose(self: ?*GtkAlertDialog, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_alert_dialog_choose_finish(self: ?*GtkAlertDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) c_int;
pub extern fn gtk_alert_dialog_show(self: ?*GtkAlertDialog, parent: [*c]GtkWindow) void;
pub const struct__GtkAppChooser = opaque {};
pub const GtkAppChooser = struct__GtkAppChooser;
pub extern fn gtk_app_chooser_get_type() GType;
pub extern fn gtk_app_chooser_get_app_info(self: ?*GtkAppChooser) ?*GAppInfo;
pub extern fn gtk_app_chooser_get_content_type(self: ?*GtkAppChooser) [*c]u8;
pub extern fn gtk_app_chooser_refresh(self: ?*GtkAppChooser) void;
pub const GtkAppChooser_autoptr = ?*GtkAppChooser;
pub const GtkAppChooser_listautoptr = [*c]GList;
pub const GtkAppChooser_slistautoptr = [*c]GSList;
pub const GtkAppChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooser(arg__ptr: ?*GtkAppChooser) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAppChooser(arg__ptr: [*c]?*GtkAppChooser) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAppChooser(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooser(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooser(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooser(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_DIALOG_MODAL: c_int = 1;
pub const GTK_DIALOG_DESTROY_WITH_PARENT: c_int = 2;
pub const GTK_DIALOG_USE_HEADER_BAR: c_int = 4;
pub const GtkDialogFlags = c_uint;
pub const GTK_RESPONSE_NONE: c_int = -1;
pub const GTK_RESPONSE_REJECT: c_int = -2;
pub const GTK_RESPONSE_ACCEPT: c_int = -3;
pub const GTK_RESPONSE_DELETE_EVENT: c_int = -4;
pub const GTK_RESPONSE_OK: c_int = -5;
pub const GTK_RESPONSE_CANCEL: c_int = -6;
pub const GTK_RESPONSE_CLOSE: c_int = -7;
pub const GTK_RESPONSE_YES: c_int = -8;
pub const GTK_RESPONSE_NO: c_int = -9;
pub const GTK_RESPONSE_APPLY: c_int = -10;
pub const GTK_RESPONSE_HELP: c_int = -11;
pub const GtkResponseType = c_int;
pub const struct__GtkDialog = extern struct {
    parent_instance: GtkWindow,
};
pub const GtkDialog = struct__GtkDialog;
pub const struct__GtkDialogClass = extern struct {
    parent_class: GtkWindowClass,
    response: ?*const fn ([*c]GtkDialog, c_int) callconv(.C) void,
    close: ?*const fn ([*c]GtkDialog) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkDialogClass = struct__GtkDialogClass;
pub extern fn gtk_dialog_get_type() GType;
pub extern fn gtk_dialog_new() [*c]GtkWidget;
pub extern fn gtk_dialog_new_with_buttons(title: [*c]const u8, parent: [*c]GtkWindow, flags: GtkDialogFlags, first_button_text: [*c]const u8, ...) [*c]GtkWidget;
pub extern fn gtk_dialog_add_action_widget(dialog: [*c]GtkDialog, child: [*c]GtkWidget, response_id: c_int) void;
pub extern fn gtk_dialog_add_button(dialog: [*c]GtkDialog, button_text: [*c]const u8, response_id: c_int) [*c]GtkWidget;
pub extern fn gtk_dialog_add_buttons(dialog: [*c]GtkDialog, first_button_text: [*c]const u8, ...) void;
pub extern fn gtk_dialog_set_response_sensitive(dialog: [*c]GtkDialog, response_id: c_int, setting: gboolean) void;
pub extern fn gtk_dialog_set_default_response(dialog: [*c]GtkDialog, response_id: c_int) void;
pub extern fn gtk_dialog_get_widget_for_response(dialog: [*c]GtkDialog, response_id: c_int) [*c]GtkWidget;
pub extern fn gtk_dialog_get_response_for_widget(dialog: [*c]GtkDialog, widget: [*c]GtkWidget) c_int;
pub extern fn gtk_dialog_response(dialog: [*c]GtkDialog, response_id: c_int) void;
pub extern fn gtk_dialog_get_content_area(dialog: [*c]GtkDialog) [*c]GtkWidget;
pub extern fn gtk_dialog_get_header_bar(dialog: [*c]GtkDialog) [*c]GtkWidget;
pub const GtkDialog_autoptr = [*c]GtkDialog;
pub const GtkDialog_listautoptr = [*c]GList;
pub const GtkDialog_slistautoptr = [*c]GSList;
pub const GtkDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDialog(arg__ptr: [*c]GtkDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkDialog(arg__ptr: [*c][*c]GtkDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkAppChooserDialog = opaque {};
pub const GtkAppChooserDialog = struct__GtkAppChooserDialog;
pub extern fn gtk_app_chooser_dialog_get_type() GType;
pub extern fn gtk_app_chooser_dialog_new(parent: [*c]GtkWindow, flags: GtkDialogFlags, file: ?*GFile) [*c]GtkWidget;
pub extern fn gtk_app_chooser_dialog_new_for_content_type(parent: [*c]GtkWindow, flags: GtkDialogFlags, content_type: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_app_chooser_dialog_get_widget(self: ?*GtkAppChooserDialog) [*c]GtkWidget;
pub extern fn gtk_app_chooser_dialog_set_heading(self: ?*GtkAppChooserDialog, heading: [*c]const u8) void;
pub extern fn gtk_app_chooser_dialog_get_heading(self: ?*GtkAppChooserDialog) [*c]const u8;
pub const GtkAppChooserDialog_autoptr = ?*GtkAppChooserDialog;
pub const GtkAppChooserDialog_listautoptr = [*c]GList;
pub const GtkAppChooserDialog_slistautoptr = [*c]GSList;
pub const GtkAppChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooserDialog(arg__ptr: ?*GtkAppChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAppChooserDialog(arg__ptr: [*c]?*GtkAppChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAppChooserDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooserDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooserDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooserDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkAppChooserWidget = opaque {};
pub const GtkAppChooserWidget = struct__GtkAppChooserWidget;
pub extern fn gtk_app_chooser_widget_get_type() GType;
pub extern fn gtk_app_chooser_widget_new(content_type: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_app_chooser_widget_set_show_default(self: ?*GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_default(self: ?*GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_recommended(self: ?*GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_recommended(self: ?*GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_fallback(self: ?*GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_fallback(self: ?*GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_other(self: ?*GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_other(self: ?*GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_all(self: ?*GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_all(self: ?*GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_default_text(self: ?*GtkAppChooserWidget, text: [*c]const u8) void;
pub extern fn gtk_app_chooser_widget_get_default_text(self: ?*GtkAppChooserWidget) [*c]const u8;
pub const GtkAppChooserWidget_autoptr = ?*GtkAppChooserWidget;
pub const GtkAppChooserWidget_listautoptr = [*c]GList;
pub const GtkAppChooserWidget_slistautoptr = [*c]GSList;
pub const GtkAppChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooserWidget(arg__ptr: ?*GtkAppChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAppChooserWidget(arg__ptr: [*c]?*GtkAppChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAppChooserWidget(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooserWidget(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooserWidget(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooserWidget(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkAppChooserButton = opaque {};
pub const GtkAppChooserButton = struct__GtkAppChooserButton;
pub extern fn gtk_app_chooser_button_get_type() GType;
pub extern fn gtk_app_chooser_button_new(content_type: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_app_chooser_button_append_separator(self: ?*GtkAppChooserButton) void;
pub extern fn gtk_app_chooser_button_append_custom_item(self: ?*GtkAppChooserButton, name: [*c]const u8, label: [*c]const u8, icon: ?*GIcon) void;
pub extern fn gtk_app_chooser_button_set_active_custom_item(self: ?*GtkAppChooserButton, name: [*c]const u8) void;
pub extern fn gtk_app_chooser_button_set_show_dialog_item(self: ?*GtkAppChooserButton, setting: gboolean) void;
pub extern fn gtk_app_chooser_button_get_show_dialog_item(self: ?*GtkAppChooserButton) gboolean;
pub extern fn gtk_app_chooser_button_set_heading(self: ?*GtkAppChooserButton, heading: [*c]const u8) void;
pub extern fn gtk_app_chooser_button_get_heading(self: ?*GtkAppChooserButton) [*c]const u8;
pub extern fn gtk_app_chooser_button_set_show_default_item(self: ?*GtkAppChooserButton, setting: gboolean) void;
pub extern fn gtk_app_chooser_button_get_show_default_item(self: ?*GtkAppChooserButton) gboolean;
pub extern fn gtk_app_chooser_button_get_modal(self: ?*GtkAppChooserButton) gboolean;
pub extern fn gtk_app_chooser_button_set_modal(self: ?*GtkAppChooserButton, modal: gboolean) void;
pub const GtkAppChooserButton_autoptr = ?*GtkAppChooserButton;
pub const GtkAppChooserButton_listautoptr = [*c]GList;
pub const GtkAppChooserButton_slistautoptr = [*c]GSList;
pub const GtkAppChooserButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooserButton(arg__ptr: ?*GtkAppChooserButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAppChooserButton(arg__ptr: [*c]?*GtkAppChooserButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAppChooserButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooserButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooserButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooserButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkShortcutsWindow = opaque {};
pub const GtkShortcutsWindow = struct__GtkShortcutsWindow;
pub extern fn gtk_shortcuts_window_get_type() GType;
pub const GtkShortcutsWindow_autoptr = ?*GtkShortcutsWindow;
pub const GtkShortcutsWindow_listautoptr = [*c]GList;
pub const GtkShortcutsWindow_slistautoptr = [*c]GSList;
pub const GtkShortcutsWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutsWindow(arg__ptr: ?*GtkShortcutsWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutsWindow(arg__ptr: [*c]?*GtkShortcutsWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutsWindow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutsWindow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutsWindow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutsWindow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkApplicationWindowClass = extern struct {
    parent_class: GtkWindowClass,
    padding: [8]gpointer,
};
pub const GtkApplicationWindowClass = struct__GtkApplicationWindowClass;
pub const struct__GtkApplicationWindow = extern struct {
    parent_instance: GtkWindow,
};
pub const GtkApplicationWindow = struct__GtkApplicationWindow;
pub extern fn gtk_application_window_get_type() GType;
pub extern fn gtk_application_window_new(application: [*c]GtkApplication) [*c]GtkWidget;
pub extern fn gtk_application_window_set_show_menubar(window: [*c]GtkApplicationWindow, show_menubar: gboolean) void;
pub extern fn gtk_application_window_get_show_menubar(window: [*c]GtkApplicationWindow) gboolean;
pub extern fn gtk_application_window_get_id(window: [*c]GtkApplicationWindow) guint;
pub extern fn gtk_application_window_set_help_overlay(window: [*c]GtkApplicationWindow, help_overlay: ?*GtkShortcutsWindow) void;
pub extern fn gtk_application_window_get_help_overlay(window: [*c]GtkApplicationWindow) ?*GtkShortcutsWindow;
pub const GtkApplicationWindow_autoptr = [*c]GtkApplicationWindow;
pub const GtkApplicationWindow_listautoptr = [*c]GList;
pub const GtkApplicationWindow_slistautoptr = [*c]GSList;
pub const GtkApplicationWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkApplicationWindow(arg__ptr: [*c]GtkApplicationWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkApplicationWindow(arg__ptr: [*c][*c]GtkApplicationWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkApplicationWindow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkApplicationWindow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkApplicationWindow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkApplicationWindow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkAspectFrame = opaque {};
pub const GtkAspectFrame = struct__GtkAspectFrame;
pub extern fn gtk_aspect_frame_get_type() GType;
pub extern fn gtk_aspect_frame_new(xalign: f32, yalign: f32, ratio: f32, obey_child: gboolean) [*c]GtkWidget;
pub extern fn gtk_aspect_frame_set_xalign(self: ?*GtkAspectFrame, xalign: f32) void;
pub extern fn gtk_aspect_frame_get_xalign(self: ?*GtkAspectFrame) f32;
pub extern fn gtk_aspect_frame_set_yalign(self: ?*GtkAspectFrame, yalign: f32) void;
pub extern fn gtk_aspect_frame_get_yalign(self: ?*GtkAspectFrame) f32;
pub extern fn gtk_aspect_frame_set_ratio(self: ?*GtkAspectFrame, ratio: f32) void;
pub extern fn gtk_aspect_frame_get_ratio(self: ?*GtkAspectFrame) f32;
pub extern fn gtk_aspect_frame_set_obey_child(self: ?*GtkAspectFrame, obey_child: gboolean) void;
pub extern fn gtk_aspect_frame_get_obey_child(self: ?*GtkAspectFrame) gboolean;
pub extern fn gtk_aspect_frame_set_child(self: ?*GtkAspectFrame, child: [*c]GtkWidget) void;
pub extern fn gtk_aspect_frame_get_child(self: ?*GtkAspectFrame) [*c]GtkWidget;
pub const GtkAspectFrame_autoptr = ?*GtkAspectFrame;
pub const GtkAspectFrame_listautoptr = [*c]GList;
pub const GtkAspectFrame_slistautoptr = [*c]GSList;
pub const GtkAspectFrame_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAspectFrame(arg__ptr: ?*GtkAspectFrame) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAspectFrame(arg__ptr: [*c]?*GtkAspectFrame) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAspectFrame(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAspectFrame(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAspectFrame(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAspectFrame(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_ASSISTANT_PAGE_CONTENT: c_int = 0;
pub const GTK_ASSISTANT_PAGE_INTRO: c_int = 1;
pub const GTK_ASSISTANT_PAGE_CONFIRM: c_int = 2;
pub const GTK_ASSISTANT_PAGE_SUMMARY: c_int = 3;
pub const GTK_ASSISTANT_PAGE_PROGRESS: c_int = 4;
pub const GTK_ASSISTANT_PAGE_CUSTOM: c_int = 5;
pub const GtkAssistantPageType = c_uint;
pub const struct__GtkAssistant = opaque {};
pub const GtkAssistant = struct__GtkAssistant;
pub const struct__GtkAssistantPage = opaque {};
pub const GtkAssistantPage = struct__GtkAssistantPage;
pub const GtkAssistantPageFunc = ?*const fn (c_int, gpointer) callconv(.C) c_int;
pub extern fn gtk_assistant_page_get_type() GType;
pub extern fn gtk_assistant_get_type() GType;
pub extern fn gtk_assistant_new() [*c]GtkWidget;
pub extern fn gtk_assistant_next_page(assistant: ?*GtkAssistant) void;
pub extern fn gtk_assistant_previous_page(assistant: ?*GtkAssistant) void;
pub extern fn gtk_assistant_get_current_page(assistant: ?*GtkAssistant) c_int;
pub extern fn gtk_assistant_set_current_page(assistant: ?*GtkAssistant, page_num: c_int) void;
pub extern fn gtk_assistant_get_n_pages(assistant: ?*GtkAssistant) c_int;
pub extern fn gtk_assistant_get_nth_page(assistant: ?*GtkAssistant, page_num: c_int) [*c]GtkWidget;
pub extern fn gtk_assistant_prepend_page(assistant: ?*GtkAssistant, page: [*c]GtkWidget) c_int;
pub extern fn gtk_assistant_append_page(assistant: ?*GtkAssistant, page: [*c]GtkWidget) c_int;
pub extern fn gtk_assistant_insert_page(assistant: ?*GtkAssistant, page: [*c]GtkWidget, position: c_int) c_int;
pub extern fn gtk_assistant_remove_page(assistant: ?*GtkAssistant, page_num: c_int) void;
pub extern fn gtk_assistant_set_forward_page_func(assistant: ?*GtkAssistant, page_func: GtkAssistantPageFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_assistant_set_page_type(assistant: ?*GtkAssistant, page: [*c]GtkWidget, @"type": GtkAssistantPageType) void;
pub extern fn gtk_assistant_get_page_type(assistant: ?*GtkAssistant, page: [*c]GtkWidget) GtkAssistantPageType;
pub extern fn gtk_assistant_set_page_title(assistant: ?*GtkAssistant, page: [*c]GtkWidget, title: [*c]const u8) void;
pub extern fn gtk_assistant_get_page_title(assistant: ?*GtkAssistant, page: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_assistant_set_page_complete(assistant: ?*GtkAssistant, page: [*c]GtkWidget, complete: gboolean) void;
pub extern fn gtk_assistant_get_page_complete(assistant: ?*GtkAssistant, page: [*c]GtkWidget) gboolean;
pub extern fn gtk_assistant_add_action_widget(assistant: ?*GtkAssistant, child: [*c]GtkWidget) void;
pub extern fn gtk_assistant_remove_action_widget(assistant: ?*GtkAssistant, child: [*c]GtkWidget) void;
pub extern fn gtk_assistant_update_buttons_state(assistant: ?*GtkAssistant) void;
pub extern fn gtk_assistant_commit(assistant: ?*GtkAssistant) void;
pub extern fn gtk_assistant_get_page(assistant: ?*GtkAssistant, child: [*c]GtkWidget) ?*GtkAssistantPage;
pub extern fn gtk_assistant_page_get_child(page: ?*GtkAssistantPage) [*c]GtkWidget;
pub extern fn gtk_assistant_get_pages(assistant: ?*GtkAssistant) ?*GListModel;
pub const GtkAssistant_autoptr = ?*GtkAssistant;
pub const GtkAssistant_listautoptr = [*c]GList;
pub const GtkAssistant_slistautoptr = [*c]GSList;
pub const GtkAssistant_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAssistant(arg__ptr: ?*GtkAssistant) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAssistant(arg__ptr: [*c]?*GtkAssistant) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAssistant(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAssistant(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAssistant(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAssistant(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_at_context_get_type() GType;
pub const struct__GtkATContextClass = opaque {};
pub const GtkATContextClass = struct__GtkATContextClass;
pub const GtkATContext_autoptr = ?*GtkATContext;
pub const GtkATContext_listautoptr = [*c]GList;
pub const GtkATContext_slistautoptr = [*c]GSList;
pub const GtkATContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkATContext(arg__ptr: ?*GtkATContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkATContext(arg__ptr: [*c]?*GtkATContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkATContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkATContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkATContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkATContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkATContextClass_autoptr = ?*GtkATContextClass;
pub const GtkATContextClass_listautoptr = [*c]GList;
pub const GtkATContextClass_slistautoptr = [*c]GSList;
pub const GtkATContextClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkATContextClass(arg__ptr: ?*GtkATContextClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkATContextClass(arg__ptr: [*c]?*GtkATContextClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkATContextClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkATContextClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkATContextClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkATContextClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_AT_CONTEXT(arg_ptr: gpointer) callconv(.C) ?*GtkATContext {
    var ptr = arg_ptr;
    return @as(?*GtkATContext, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_at_context_get_type())))));
}
pub fn GTK_AT_CONTEXT_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkATContextClass {
    var ptr = arg_ptr;
    return @as(?*GtkATContextClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_at_context_get_type())))));
}
pub fn GTK_IS_AT_CONTEXT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_at_context_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_AT_CONTEXT_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_at_context_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_AT_CONTEXT_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkATContextClass {
    var ptr = arg_ptr;
    return @as(?*GtkATContextClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_at_context_get_accessible(self: ?*GtkATContext) ?*GtkAccessible;
pub extern fn gtk_at_context_get_accessible_role(self: ?*GtkATContext) GtkAccessibleRole;
pub extern fn gtk_at_context_create(accessible_role: GtkAccessibleRole, accessible: ?*GtkAccessible, display: ?*GdkDisplay) ?*GtkATContext;
pub extern fn gtk_layout_child_get_type() GType;
pub const struct__GtkLayoutChild = extern struct {
    parent_instance: GObject,
};
pub const GtkLayoutChild = struct__GtkLayoutChild;
pub const struct__GtkLayoutChildClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkLayoutChildClass = struct__GtkLayoutChildClass;
pub const GtkLayoutChild_autoptr = [*c]GtkLayoutChild;
pub const GtkLayoutChild_listautoptr = [*c]GList;
pub const GtkLayoutChild_slistautoptr = [*c]GSList;
pub const GtkLayoutChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLayoutChild(arg__ptr: [*c]GtkLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkLayoutChild(arg__ptr: [*c][*c]GtkLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLayoutChild(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLayoutChild(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLayoutChild(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLayoutChild(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkLayoutChildClass_autoptr = [*c]GtkLayoutChildClass;
pub const GtkLayoutChildClass_listautoptr = [*c]GList;
pub const GtkLayoutChildClass_slistautoptr = [*c]GSList;
pub const GtkLayoutChildClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLayoutChildClass(arg__ptr: [*c]GtkLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkLayoutChildClass(arg__ptr: [*c][*c]GtkLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLayoutChildClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLayoutChildClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLayoutChildClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLayoutChildClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) [*c]GtkLayoutChild {
    var ptr = arg_ptr;
    return @as([*c]GtkLayoutChild, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_layout_child_get_type()))))));
}
pub fn GTK_LAYOUT_CHILD_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkLayoutChildClass {
    var ptr = arg_ptr;
    return @as([*c]GtkLayoutChildClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_layout_child_get_type()))))));
}
pub fn GTK_IS_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_layout_child_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_LAYOUT_CHILD_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_layout_child_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_LAYOUT_CHILD_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkLayoutChildClass {
    var ptr = arg_ptr;
    return @as([*c]GtkLayoutChildClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_layout_child_get_layout_manager(layout_child: [*c]GtkLayoutChild) [*c]GtkLayoutManager;
pub extern fn gtk_layout_child_get_child_widget(layout_child: [*c]GtkLayoutChild) [*c]GtkWidget;
pub extern fn gtk_layout_manager_get_type() GType;
pub const struct__GtkLayoutManagerClass = extern struct {
    parent_class: GObjectClass,
    get_request_mode: ?*const fn ([*c]GtkLayoutManager, [*c]GtkWidget) callconv(.C) GtkSizeRequestMode,
    measure: ?*const fn ([*c]GtkLayoutManager, [*c]GtkWidget, GtkOrientation, c_int, [*c]c_int, [*c]c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    allocate: ?*const fn ([*c]GtkLayoutManager, [*c]GtkWidget, c_int, c_int, c_int) callconv(.C) void,
    layout_child_type: GType,
    create_layout_child: ?*const fn ([*c]GtkLayoutManager, [*c]GtkWidget, [*c]GtkWidget) callconv(.C) [*c]GtkLayoutChild,
    root: ?*const fn ([*c]GtkLayoutManager) callconv(.C) void,
    unroot: ?*const fn ([*c]GtkLayoutManager) callconv(.C) void,
    _padding: [16]gpointer,
};
pub const GtkLayoutManagerClass = struct__GtkLayoutManagerClass;
pub const GtkLayoutManager_autoptr = [*c]GtkLayoutManager;
pub const GtkLayoutManager_listautoptr = [*c]GList;
pub const GtkLayoutManager_slistautoptr = [*c]GSList;
pub const GtkLayoutManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLayoutManager(arg__ptr: [*c]GtkLayoutManager) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkLayoutManager(arg__ptr: [*c][*c]GtkLayoutManager) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLayoutManager(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLayoutManager(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLayoutManager(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLayoutManager(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkLayoutManagerClass_autoptr = [*c]GtkLayoutManagerClass;
pub const GtkLayoutManagerClass_listautoptr = [*c]GList;
pub const GtkLayoutManagerClass_slistautoptr = [*c]GSList;
pub const GtkLayoutManagerClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLayoutManagerClass(arg__ptr: [*c]GtkLayoutManagerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkLayoutManagerClass(arg__ptr: [*c][*c]GtkLayoutManagerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLayoutManagerClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLayoutManagerClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLayoutManagerClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLayoutManagerClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_LAYOUT_MANAGER(arg_ptr: gpointer) callconv(.C) [*c]GtkLayoutManager {
    var ptr = arg_ptr;
    return @as([*c]GtkLayoutManager, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_layout_manager_get_type()))))));
}
pub fn GTK_LAYOUT_MANAGER_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkLayoutManagerClass {
    var ptr = arg_ptr;
    return @as([*c]GtkLayoutManagerClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_layout_manager_get_type()))))));
}
pub fn GTK_IS_LAYOUT_MANAGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_layout_manager_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_LAYOUT_MANAGER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_layout_manager_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_LAYOUT_MANAGER_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkLayoutManagerClass {
    var ptr = arg_ptr;
    return @as([*c]GtkLayoutManagerClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_layout_manager_measure(manager: [*c]GtkLayoutManager, widget: [*c]GtkWidget, orientation: GtkOrientation, for_size: c_int, minimum: [*c]c_int, natural: [*c]c_int, minimum_baseline: [*c]c_int, natural_baseline: [*c]c_int) void;
pub extern fn gtk_layout_manager_allocate(manager: [*c]GtkLayoutManager, widget: [*c]GtkWidget, width: c_int, height: c_int, baseline: c_int) void;
pub extern fn gtk_layout_manager_get_request_mode(manager: [*c]GtkLayoutManager) GtkSizeRequestMode;
pub extern fn gtk_layout_manager_get_widget(manager: [*c]GtkLayoutManager) [*c]GtkWidget;
pub extern fn gtk_layout_manager_layout_changed(manager: [*c]GtkLayoutManager) void;
pub extern fn gtk_layout_manager_get_layout_child(manager: [*c]GtkLayoutManager, child: [*c]GtkWidget) [*c]GtkLayoutChild;
pub extern fn gtk_bin_layout_get_type() GType;
pub const struct__GtkBinLayout = opaque {};
pub const GtkBinLayout = struct__GtkBinLayout;
pub const GtkBinLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkBinLayout_autoptr = ?*GtkBinLayout;
pub const GtkBinLayout_listautoptr = [*c]GList;
pub const GtkBinLayout_slistautoptr = [*c]GSList;
pub const GtkBinLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBinLayout(arg__ptr: ?*GtkBinLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkBinLayout(arg__ptr: [*c]?*GtkBinLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBinLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBinLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBinLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBinLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkBinLayoutClass_autoptr = [*c]GtkBinLayoutClass;
pub const GtkBinLayoutClass_listautoptr = [*c]GList;
pub const GtkBinLayoutClass_slistautoptr = [*c]GSList;
pub const GtkBinLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBinLayoutClass(arg__ptr: [*c]GtkBinLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBinLayoutClass(arg__ptr: [*c][*c]GtkBinLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBinLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBinLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBinLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBinLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_BIN_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkBinLayout {
    var ptr = arg_ptr;
    return @as(?*GtkBinLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_bin_layout_get_type())))));
}
pub fn GTK_IS_BIN_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_bin_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_bin_layout_new() [*c]GtkLayoutManager;
pub extern fn gtk_bitset_get_type() GType;
pub extern fn gtk_bitset_ref(self: ?*GtkBitset) ?*GtkBitset;
pub extern fn gtk_bitset_unref(self: ?*GtkBitset) void;
pub const GtkBitset_autoptr = ?*GtkBitset;
pub const GtkBitset_listautoptr = [*c]GList;
pub const GtkBitset_slistautoptr = [*c]GSList;
pub const GtkBitset_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBitset(arg__ptr: ?*GtkBitset) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_bitset_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkBitset(arg__ptr: [*c]?*GtkBitset) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBitset(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBitset(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_bitset_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBitset(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_bitset_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBitset(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_bitset_unref)))))));
    }
}
pub extern fn gtk_bitset_contains(self: ?*const GtkBitset, value: guint) gboolean;
pub extern fn gtk_bitset_is_empty(self: ?*const GtkBitset) gboolean;
pub extern fn gtk_bitset_equals(self: ?*const GtkBitset, other: ?*const GtkBitset) gboolean;
pub extern fn gtk_bitset_get_size(self: ?*const GtkBitset) guint64;
pub extern fn gtk_bitset_get_size_in_range(self: ?*const GtkBitset, first: guint, last: guint) guint64;
pub extern fn gtk_bitset_get_nth(self: ?*const GtkBitset, nth: guint) guint;
pub extern fn gtk_bitset_get_minimum(self: ?*const GtkBitset) guint;
pub extern fn gtk_bitset_get_maximum(self: ?*const GtkBitset) guint;
pub extern fn gtk_bitset_new_empty() ?*GtkBitset;
pub extern fn gtk_bitset_copy(self: ?*const GtkBitset) ?*GtkBitset;
pub extern fn gtk_bitset_new_range(start: guint, n_items: guint) ?*GtkBitset;
pub extern fn gtk_bitset_remove_all(self: ?*GtkBitset) void;
pub extern fn gtk_bitset_add(self: ?*GtkBitset, value: guint) gboolean;
pub extern fn gtk_bitset_remove(self: ?*GtkBitset, value: guint) gboolean;
pub extern fn gtk_bitset_add_range(self: ?*GtkBitset, start: guint, n_items: guint) void;
pub extern fn gtk_bitset_remove_range(self: ?*GtkBitset, start: guint, n_items: guint) void;
pub extern fn gtk_bitset_add_range_closed(self: ?*GtkBitset, first: guint, last: guint) void;
pub extern fn gtk_bitset_remove_range_closed(self: ?*GtkBitset, first: guint, last: guint) void;
pub extern fn gtk_bitset_add_rectangle(self: ?*GtkBitset, start: guint, width: guint, height: guint, stride: guint) void;
pub extern fn gtk_bitset_remove_rectangle(self: ?*GtkBitset, start: guint, width: guint, height: guint, stride: guint) void;
pub extern fn gtk_bitset_union(self: ?*GtkBitset, other: ?*const GtkBitset) void;
pub extern fn gtk_bitset_intersect(self: ?*GtkBitset, other: ?*const GtkBitset) void;
pub extern fn gtk_bitset_subtract(self: ?*GtkBitset, other: ?*const GtkBitset) void;
pub extern fn gtk_bitset_difference(self: ?*GtkBitset, other: ?*const GtkBitset) void;
pub extern fn gtk_bitset_shift_left(self: ?*GtkBitset, amount: guint) void;
pub extern fn gtk_bitset_shift_right(self: ?*GtkBitset, amount: guint) void;
pub extern fn gtk_bitset_splice(self: ?*GtkBitset, position: guint, removed: guint, added: guint) void;
pub const struct__GtkBitsetIter = extern struct {
    private_data: [10]gpointer,
};
pub const GtkBitsetIter = struct__GtkBitsetIter;
pub extern fn gtk_bitset_iter_get_type() GType;
pub extern fn gtk_bitset_iter_init_first(iter: [*c]GtkBitsetIter, set: ?*const GtkBitset, value: [*c]guint) gboolean;
pub extern fn gtk_bitset_iter_init_last(iter: [*c]GtkBitsetIter, set: ?*const GtkBitset, value: [*c]guint) gboolean;
pub extern fn gtk_bitset_iter_init_at(iter: [*c]GtkBitsetIter, set: ?*const GtkBitset, target: guint, value: [*c]guint) gboolean;
pub extern fn gtk_bitset_iter_next(iter: [*c]GtkBitsetIter, value: [*c]guint) gboolean;
pub extern fn gtk_bitset_iter_previous(iter: [*c]GtkBitsetIter, value: [*c]guint) gboolean;
pub extern fn gtk_bitset_iter_get_value(iter: [*c]const GtkBitsetIter) guint;
pub extern fn gtk_bitset_iter_is_valid(iter: [*c]const GtkBitsetIter) gboolean;
pub extern fn gtk_bookmark_list_get_type() GType;
pub const struct__GtkBookmarkList = opaque {};
pub const GtkBookmarkList = struct__GtkBookmarkList;
pub const GtkBookmarkListClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkBookmarkList_autoptr = ?*GtkBookmarkList;
pub const GtkBookmarkList_listautoptr = [*c]GList;
pub const GtkBookmarkList_slistautoptr = [*c]GSList;
pub const GtkBookmarkList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBookmarkList(arg__ptr: ?*GtkBookmarkList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkBookmarkList(arg__ptr: [*c]?*GtkBookmarkList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBookmarkList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBookmarkList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBookmarkList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBookmarkList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkBookmarkListClass_autoptr = [*c]GtkBookmarkListClass;
pub const GtkBookmarkListClass_listautoptr = [*c]GList;
pub const GtkBookmarkListClass_slistautoptr = [*c]GSList;
pub const GtkBookmarkListClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBookmarkListClass(arg__ptr: [*c]GtkBookmarkListClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBookmarkListClass(arg__ptr: [*c][*c]GtkBookmarkListClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBookmarkListClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBookmarkListClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBookmarkListClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBookmarkListClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_BOOKMARK_LIST(arg_ptr: gpointer) callconv(.C) ?*GtkBookmarkList {
    var ptr = arg_ptr;
    return @as(?*GtkBookmarkList, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_bookmark_list_get_type())))));
}
pub fn GTK_IS_BOOKMARK_LIST(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_bookmark_list_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_bookmark_list_new(filename: [*c]const u8, attributes: [*c]const u8) ?*GtkBookmarkList;
pub extern fn gtk_bookmark_list_get_filename(self: ?*GtkBookmarkList) [*c]const u8;
pub extern fn gtk_bookmark_list_set_attributes(self: ?*GtkBookmarkList, attributes: [*c]const u8) void;
pub extern fn gtk_bookmark_list_get_attributes(self: ?*GtkBookmarkList) [*c]const u8;
pub extern fn gtk_bookmark_list_set_io_priority(self: ?*GtkBookmarkList, io_priority: c_int) void;
pub extern fn gtk_bookmark_list_get_io_priority(self: ?*GtkBookmarkList) c_int;
pub extern fn gtk_bookmark_list_is_loading(self: ?*GtkBookmarkList) gboolean;
pub const struct__GtkExpression = opaque {};
pub const GtkExpression = struct__GtkExpression;
pub const struct__GtkExpressionWatch = opaque {};
pub const GtkExpressionWatch = struct__GtkExpressionWatch;
pub const GtkExpressionNotify = ?*const fn (gpointer) callconv(.C) void;
pub extern fn gtk_expression_get_type() GType;
pub extern fn gtk_expression_ref(self: ?*GtkExpression) ?*GtkExpression;
pub extern fn gtk_expression_unref(self: ?*GtkExpression) void;
pub const GtkExpression_autoptr = ?*GtkExpression;
pub const GtkExpression_listautoptr = [*c]GList;
pub const GtkExpression_slistautoptr = [*c]GSList;
pub const GtkExpression_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkExpression(arg__ptr: ?*GtkExpression) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_expression_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkExpression(arg__ptr: [*c]?*GtkExpression) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkExpression(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkExpression(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_expression_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkExpression(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_expression_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkExpression(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_expression_unref)))))));
    }
}
pub extern fn gtk_expression_get_value_type(self: ?*GtkExpression) GType;
pub extern fn gtk_expression_is_static(self: ?*GtkExpression) gboolean;
pub extern fn gtk_expression_evaluate(self: ?*GtkExpression, this_: gpointer, value: [*c]GValue) gboolean;
pub extern fn gtk_expression_watch(self: ?*GtkExpression, this_: gpointer, notify: GtkExpressionNotify, user_data: gpointer, user_destroy: GDestroyNotify) ?*GtkExpressionWatch;
pub extern fn gtk_expression_bind(self: ?*GtkExpression, target: gpointer, property: [*c]const u8, this_: gpointer) ?*GtkExpressionWatch;
pub extern fn gtk_expression_watch_get_type() GType;
pub extern fn gtk_expression_watch_ref(watch: ?*GtkExpressionWatch) ?*GtkExpressionWatch;
pub extern fn gtk_expression_watch_unref(watch: ?*GtkExpressionWatch) void;
pub extern fn gtk_expression_watch_evaluate(watch: ?*GtkExpressionWatch, value: [*c]GValue) gboolean;
pub extern fn gtk_expression_watch_unwatch(watch: ?*GtkExpressionWatch) void;
pub const struct__GtkPropertyExpression = opaque {};
pub const GtkPropertyExpression = struct__GtkPropertyExpression;
pub extern fn gtk_property_expression_get_type() GType;
pub extern fn gtk_property_expression_new(this_type: GType, expression: ?*GtkExpression, property_name: [*c]const u8) ?*GtkExpression;
pub extern fn gtk_property_expression_new_for_pspec(expression: ?*GtkExpression, pspec: [*c]GParamSpec) ?*GtkExpression;
pub extern fn gtk_property_expression_get_expression(expression: ?*GtkExpression) ?*GtkExpression;
pub extern fn gtk_property_expression_get_pspec(expression: ?*GtkExpression) [*c]GParamSpec;
pub const struct__GtkConstantExpression = opaque {};
pub const GtkConstantExpression = struct__GtkConstantExpression;
pub extern fn gtk_constant_expression_get_type() GType;
pub extern fn gtk_constant_expression_new(value_type: GType, ...) ?*GtkExpression;
pub extern fn gtk_constant_expression_new_for_value(value: [*c]const GValue) ?*GtkExpression;
pub extern fn gtk_constant_expression_get_value(expression: ?*GtkExpression) [*c]const GValue;
pub const struct__GtkObjectExpression = opaque {};
pub const GtkObjectExpression = struct__GtkObjectExpression;
pub extern fn gtk_object_expression_get_type() GType;
pub extern fn gtk_object_expression_new(object: [*c]GObject) ?*GtkExpression;
pub extern fn gtk_object_expression_get_object(expression: ?*GtkExpression) [*c]GObject;
pub const struct__GtkClosureExpression = opaque {};
pub const GtkClosureExpression = struct__GtkClosureExpression;
pub extern fn gtk_closure_expression_get_type() GType;
pub extern fn gtk_closure_expression_new(value_type: GType, closure: ?*GClosure, n_params: guint, params: [*c]?*GtkExpression) ?*GtkExpression;
pub const struct__GtkCClosureExpression = opaque {};
pub const GtkCClosureExpression = struct__GtkCClosureExpression;
pub extern fn gtk_cclosure_expression_get_type() GType;
pub extern fn gtk_cclosure_expression_new(value_type: GType, marshal: GClosureMarshal, n_params: guint, params: [*c]?*GtkExpression, callback_func: GCallback, user_data: gpointer, user_destroy: GClosureNotify) ?*GtkExpression;
pub extern fn gtk_value_set_expression(value: [*c]GValue, expression: ?*GtkExpression) void;
pub extern fn gtk_value_take_expression(value: [*c]GValue, expression: ?*GtkExpression) void;
pub extern fn gtk_value_get_expression(value: [*c]const GValue) ?*GtkExpression;
pub extern fn gtk_value_dup_expression(value: [*c]const GValue) ?*GtkExpression;
pub const GtkParamSpecExpression = extern struct {
    parent_instance: GParamSpec,
};
pub extern fn gtk_param_expression_get_type() GType;
pub extern fn gtk_param_spec_expression(name: [*c]const u8, nick: [*c]const u8, blurb: [*c]const u8, flags: GParamFlags) [*c]GParamSpec;
pub const GTK_FILTER_MATCH_SOME: c_int = 0;
pub const GTK_FILTER_MATCH_NONE: c_int = 1;
pub const GTK_FILTER_MATCH_ALL: c_int = 2;
pub const GtkFilterMatch = c_uint;
pub const GTK_FILTER_CHANGE_DIFFERENT: c_int = 0;
pub const GTK_FILTER_CHANGE_LESS_STRICT: c_int = 1;
pub const GTK_FILTER_CHANGE_MORE_STRICT: c_int = 2;
pub const GtkFilterChange = c_uint;
pub extern fn gtk_filter_get_type() GType;
pub const struct__GtkFilter = extern struct {
    parent_instance: GObject,
};
pub const GtkFilter = struct__GtkFilter;
pub const struct__GtkFilterClass = extern struct {
    parent_class: GObjectClass,
    match: ?*const fn ([*c]GtkFilter, gpointer) callconv(.C) gboolean,
    get_strictness: ?*const fn ([*c]GtkFilter) callconv(.C) GtkFilterMatch,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
    _gtk_reserved5: ?*const fn () callconv(.C) void,
    _gtk_reserved6: ?*const fn () callconv(.C) void,
    _gtk_reserved7: ?*const fn () callconv(.C) void,
    _gtk_reserved8: ?*const fn () callconv(.C) void,
};
pub const GtkFilterClass = struct__GtkFilterClass;
pub const GtkFilter_autoptr = [*c]GtkFilter;
pub const GtkFilter_listautoptr = [*c]GList;
pub const GtkFilter_slistautoptr = [*c]GSList;
pub const GtkFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFilter(arg__ptr: [*c]GtkFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFilter(arg__ptr: [*c][*c]GtkFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkFilterClass_autoptr = [*c]GtkFilterClass;
pub const GtkFilterClass_listautoptr = [*c]GList;
pub const GtkFilterClass_slistautoptr = [*c]GSList;
pub const GtkFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFilterClass(arg__ptr: [*c]GtkFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFilterClass(arg__ptr: [*c][*c]GtkFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FILTER(arg_ptr: gpointer) callconv(.C) [*c]GtkFilter {
    var ptr = arg_ptr;
    return @as([*c]GtkFilter, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_filter_get_type()))))));
}
pub fn GTK_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkFilterClass {
    var ptr = arg_ptr;
    return @as([*c]GtkFilterClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_filter_get_type()))))));
}
pub fn GTK_IS_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_FILTER_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkFilterClass {
    var ptr = arg_ptr;
    return @as([*c]GtkFilterClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_filter_match(self: [*c]GtkFilter, item: gpointer) gboolean;
pub extern fn gtk_filter_get_strictness(self: [*c]GtkFilter) GtkFilterMatch;
pub extern fn gtk_filter_changed(self: [*c]GtkFilter, change: GtkFilterChange) void;
pub extern fn gtk_bool_filter_get_type() GType;
pub const struct__GtkBoolFilter = opaque {};
pub const GtkBoolFilter = struct__GtkBoolFilter;
pub const GtkBoolFilterClass = extern struct {
    parent_class: GtkFilterClass,
};
pub const GtkBoolFilter_autoptr = ?*GtkBoolFilter;
pub const GtkBoolFilter_listautoptr = [*c]GList;
pub const GtkBoolFilter_slistautoptr = [*c]GSList;
pub const GtkBoolFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBoolFilter(arg__ptr: ?*GtkBoolFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkFilter(@as([*c]GtkFilter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkBoolFilter(arg__ptr: [*c]?*GtkBoolFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBoolFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBoolFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBoolFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBoolFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
    }
}
pub const GtkBoolFilterClass_autoptr = [*c]GtkBoolFilterClass;
pub const GtkBoolFilterClass_listautoptr = [*c]GList;
pub const GtkBoolFilterClass_slistautoptr = [*c]GSList;
pub const GtkBoolFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBoolFilterClass(arg__ptr: [*c]GtkBoolFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBoolFilterClass(arg__ptr: [*c][*c]GtkBoolFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBoolFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBoolFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBoolFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBoolFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_BOOL_FILTER(arg_ptr: gpointer) callconv(.C) ?*GtkBoolFilter {
    var ptr = arg_ptr;
    return @as(?*GtkBoolFilter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_bool_filter_get_type())))));
}
pub fn GTK_IS_BOOL_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_bool_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_bool_filter_new(expression: ?*GtkExpression) ?*GtkBoolFilter;
pub extern fn gtk_bool_filter_get_expression(self: ?*GtkBoolFilter) ?*GtkExpression;
pub extern fn gtk_bool_filter_set_expression(self: ?*GtkBoolFilter, expression: ?*GtkExpression) void;
pub extern fn gtk_bool_filter_get_invert(self: ?*GtkBoolFilter) gboolean;
pub extern fn gtk_bool_filter_set_invert(self: ?*GtkBoolFilter, invert: gboolean) void;
pub const struct__GtkBorder = extern struct {
    left: gint16,
    right: gint16,
    top: gint16,
    bottom: gint16,
};
pub const GtkBorder = struct__GtkBorder;
pub extern fn gtk_border_get_type() GType;
pub extern fn gtk_border_new() [*c]GtkBorder;
pub extern fn gtk_border_copy(border_: [*c]const GtkBorder) [*c]GtkBorder;
pub extern fn gtk_border_free(border_: [*c]GtkBorder) void;
pub const GtkBorder_autoptr = [*c]GtkBorder;
pub const GtkBorder_listautoptr = [*c]GList;
pub const GtkBorder_slistautoptr = [*c]GSList;
pub const GtkBorder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBorder(arg__ptr: [*c]GtkBorder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_border_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkBorder(arg__ptr: [*c][*c]GtkBorder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBorder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBorder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_border_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBorder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_border_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBorder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_border_free)))))));
    }
}
pub extern fn gtk_box_layout_get_type() GType;
pub const struct__GtkBoxLayout = opaque {};
pub const GtkBoxLayout = struct__GtkBoxLayout;
pub const GtkBoxLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkBoxLayout_autoptr = ?*GtkBoxLayout;
pub const GtkBoxLayout_listautoptr = [*c]GList;
pub const GtkBoxLayout_slistautoptr = [*c]GSList;
pub const GtkBoxLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBoxLayout(arg__ptr: ?*GtkBoxLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkBoxLayout(arg__ptr: [*c]?*GtkBoxLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBoxLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBoxLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBoxLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBoxLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkBoxLayoutClass_autoptr = [*c]GtkBoxLayoutClass;
pub const GtkBoxLayoutClass_listautoptr = [*c]GList;
pub const GtkBoxLayoutClass_slistautoptr = [*c]GSList;
pub const GtkBoxLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBoxLayoutClass(arg__ptr: [*c]GtkBoxLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBoxLayoutClass(arg__ptr: [*c][*c]GtkBoxLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBoxLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBoxLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBoxLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBoxLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_BOX_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkBoxLayout {
    var ptr = arg_ptr;
    return @as(?*GtkBoxLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_box_layout_get_type())))));
}
pub fn GTK_IS_BOX_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_box_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_box_layout_new(orientation: GtkOrientation) [*c]GtkLayoutManager;
pub extern fn gtk_box_layout_set_homogeneous(box_layout: ?*GtkBoxLayout, homogeneous: gboolean) void;
pub extern fn gtk_box_layout_get_homogeneous(box_layout: ?*GtkBoxLayout) gboolean;
pub extern fn gtk_box_layout_set_spacing(box_layout: ?*GtkBoxLayout, spacing: guint) void;
pub extern fn gtk_box_layout_get_spacing(box_layout: ?*GtkBoxLayout) guint;
pub extern fn gtk_box_layout_set_baseline_position(box_layout: ?*GtkBoxLayout, position: GtkBaselinePosition) void;
pub extern fn gtk_box_layout_get_baseline_position(box_layout: ?*GtkBoxLayout) GtkBaselinePosition;
pub extern fn gtk_box_layout_set_baseline_child(box_layout: ?*GtkBoxLayout, child: c_int) void;
pub extern fn gtk_box_layout_get_baseline_child(box_layout: ?*GtkBoxLayout) c_int;
pub const struct__GtkBox = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkBox = struct__GtkBox;
pub const struct__GtkBoxClass = extern struct {
    parent_class: GtkWidgetClass,
    padding: [8]gpointer,
};
pub const GtkBoxClass = struct__GtkBoxClass;
pub extern fn gtk_box_get_type() GType;
pub extern fn gtk_box_new(orientation: GtkOrientation, spacing: c_int) [*c]GtkWidget;
pub extern fn gtk_box_set_homogeneous(box: [*c]GtkBox, homogeneous: gboolean) void;
pub extern fn gtk_box_get_homogeneous(box: [*c]GtkBox) gboolean;
pub extern fn gtk_box_set_spacing(box: [*c]GtkBox, spacing: c_int) void;
pub extern fn gtk_box_get_spacing(box: [*c]GtkBox) c_int;
pub extern fn gtk_box_set_baseline_position(box: [*c]GtkBox, position: GtkBaselinePosition) void;
pub extern fn gtk_box_get_baseline_position(box: [*c]GtkBox) GtkBaselinePosition;
pub extern fn gtk_box_set_baseline_child(box: [*c]GtkBox, child: c_int) void;
pub extern fn gtk_box_get_baseline_child(box: [*c]GtkBox) c_int;
pub extern fn gtk_box_append(box: [*c]GtkBox, child: [*c]GtkWidget) void;
pub extern fn gtk_box_prepend(box: [*c]GtkBox, child: [*c]GtkWidget) void;
pub extern fn gtk_box_remove(box: [*c]GtkBox, child: [*c]GtkWidget) void;
pub extern fn gtk_box_insert_child_after(box: [*c]GtkBox, child: [*c]GtkWidget, sibling: [*c]GtkWidget) void;
pub extern fn gtk_box_reorder_child_after(box: [*c]GtkBox, child: [*c]GtkWidget, sibling: [*c]GtkWidget) void;
pub const GtkBox_autoptr = [*c]GtkBox;
pub const GtkBox_listautoptr = [*c]GList;
pub const GtkBox_slistautoptr = [*c]GSList;
pub const GtkBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBox(arg__ptr: [*c]GtkBox) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBox(arg__ptr: [*c][*c]GtkBox) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBox(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBox(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBox(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBox(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_builder_scope_get_type() GType;
pub const struct__GtkBuilderScopeInterface = extern struct {
    g_iface: GTypeInterface,
    get_type_from_name: ?*const fn (?*GtkBuilderScope, ?*GtkBuilder, [*c]const u8) callconv(.C) GType,
    get_type_from_function: ?*const fn (?*GtkBuilderScope, ?*GtkBuilder, [*c]const u8) callconv(.C) GType,
    create_closure: ?*const fn (?*GtkBuilderScope, ?*GtkBuilder, [*c]const u8, GtkBuilderClosureFlags, [*c]GObject, [*c][*c]GError) callconv(.C) ?*GClosure,
};
pub const GtkBuilderScopeInterface = struct__GtkBuilderScopeInterface;
pub const GtkBuilderScope_autoptr = ?*GtkBuilderScope;
pub const GtkBuilderScope_listautoptr = [*c]GList;
pub const GtkBuilderScope_slistautoptr = [*c]GSList;
pub const GtkBuilderScope_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuilderScope(arg__ptr: ?*GtkBuilderScope) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkBuilderScope(arg__ptr: [*c]?*GtkBuilderScope) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBuilderScope(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBuilderScope(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBuilderScope(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBuilderScope(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GTK_BUILDER_SCOPE(arg_ptr: gpointer) callconv(.C) ?*GtkBuilderScope {
    var ptr = arg_ptr;
    return @as(?*GtkBuilderScope, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_builder_scope_get_type())))));
}
pub fn GTK_IS_BUILDER_SCOPE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_builder_scope_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_BUILDER_SCOPE_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkBuilderScopeInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkBuilderScopeInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_builder_scope_get_type()))));
}
pub const GTK_BUILDER_CLOSURE_SWAPPED: c_int = 1;
pub const GtkBuilderClosureFlags = c_uint;
pub const struct__GtkBuilderCScopeClass = extern struct {
    parent_class: GObjectClass,
};
pub extern fn gtk_builder_cscope_get_type() GType;
pub const struct__GtkBuilderCScope = extern struct {
    parent_instance: GObject,
};
pub const GtkBuilderCScope = struct__GtkBuilderCScope;
pub const GtkBuilderCScopeClass = struct__GtkBuilderCScopeClass;
pub const GtkBuilderCScope_autoptr = [*c]GtkBuilderCScope;
pub const GtkBuilderCScope_listautoptr = [*c]GList;
pub const GtkBuilderCScope_slistautoptr = [*c]GSList;
pub const GtkBuilderCScope_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuilderCScope(arg__ptr: [*c]GtkBuilderCScope) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkBuilderCScope(arg__ptr: [*c][*c]GtkBuilderCScope) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBuilderCScope(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBuilderCScope(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBuilderCScope(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBuilderCScope(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkBuilderCScopeClass_autoptr = [*c]GtkBuilderCScopeClass;
pub const GtkBuilderCScopeClass_listautoptr = [*c]GList;
pub const GtkBuilderCScopeClass_slistautoptr = [*c]GSList;
pub const GtkBuilderCScopeClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuilderCScopeClass(arg__ptr: [*c]GtkBuilderCScopeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBuilderCScopeClass(arg__ptr: [*c][*c]GtkBuilderCScopeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBuilderCScopeClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBuilderCScopeClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBuilderCScopeClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBuilderCScopeClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_BUILDER_CSCOPE(arg_ptr: gpointer) callconv(.C) [*c]GtkBuilderCScope {
    var ptr = arg_ptr;
    return @as([*c]GtkBuilderCScope, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_builder_cscope_get_type()))))));
}
pub fn GTK_BUILDER_CSCOPE_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkBuilderCScopeClass {
    var ptr = arg_ptr;
    return @as([*c]GtkBuilderCScopeClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_builder_cscope_get_type()))))));
}
pub fn GTK_IS_BUILDER_CSCOPE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_builder_cscope_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_BUILDER_CSCOPE_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_builder_cscope_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_BUILDER_CSCOPE_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkBuilderCScopeClass {
    var ptr = arg_ptr;
    return @as([*c]GtkBuilderCScopeClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_builder_cscope_new() ?*GtkBuilderScope;
pub extern fn gtk_builder_cscope_add_callback_symbol(self: [*c]GtkBuilderCScope, callback_name: [*c]const u8, callback_symbol: GCallback) void;
pub extern fn gtk_builder_cscope_add_callback_symbols(self: [*c]GtkBuilderCScope, first_callback_name: [*c]const u8, first_callback_symbol: GCallback, ...) void;
pub extern fn gtk_builder_cscope_lookup_callback_symbol(self: [*c]GtkBuilderCScope, callback_name: [*c]const u8) GCallback;
pub const struct__GtkBuilderClass = opaque {};
pub const GtkBuilderClass = struct__GtkBuilderClass;
pub const GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION: c_int = 0;
pub const GTK_BUILDER_ERROR_UNHANDLED_TAG: c_int = 1;
pub const GTK_BUILDER_ERROR_MISSING_ATTRIBUTE: c_int = 2;
pub const GTK_BUILDER_ERROR_INVALID_ATTRIBUTE: c_int = 3;
pub const GTK_BUILDER_ERROR_INVALID_TAG: c_int = 4;
pub const GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE: c_int = 5;
pub const GTK_BUILDER_ERROR_INVALID_VALUE: c_int = 6;
pub const GTK_BUILDER_ERROR_VERSION_MISMATCH: c_int = 7;
pub const GTK_BUILDER_ERROR_DUPLICATE_ID: c_int = 8;
pub const GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED: c_int = 9;
pub const GTK_BUILDER_ERROR_TEMPLATE_MISMATCH: c_int = 10;
pub const GTK_BUILDER_ERROR_INVALID_PROPERTY: c_int = 11;
pub const GTK_BUILDER_ERROR_INVALID_SIGNAL: c_int = 12;
pub const GTK_BUILDER_ERROR_INVALID_ID: c_int = 13;
pub const GTK_BUILDER_ERROR_INVALID_FUNCTION: c_int = 14;
pub const GtkBuilderError = c_uint;
pub extern fn gtk_builder_error_quark() GQuark;
pub extern fn gtk_builder_get_type() GType;
pub extern fn gtk_builder_new() ?*GtkBuilder;
pub extern fn gtk_builder_add_from_file(builder: ?*GtkBuilder, filename: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_add_from_resource(builder: ?*GtkBuilder, resource_path: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_add_from_string(builder: ?*GtkBuilder, buffer: [*c]const u8, length: gssize, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_add_objects_from_file(builder: ?*GtkBuilder, filename: [*c]const u8, object_ids: [*c][*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_add_objects_from_resource(builder: ?*GtkBuilder, resource_path: [*c]const u8, object_ids: [*c][*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_add_objects_from_string(builder: ?*GtkBuilder, buffer: [*c]const u8, length: gssize, object_ids: [*c][*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_get_object(builder: ?*GtkBuilder, name: [*c]const u8) [*c]GObject;
pub extern fn gtk_builder_get_objects(builder: ?*GtkBuilder) [*c]GSList;
pub extern fn gtk_builder_expose_object(builder: ?*GtkBuilder, name: [*c]const u8, object: [*c]GObject) void;
pub extern fn gtk_builder_get_current_object(builder: ?*GtkBuilder) [*c]GObject;
pub extern fn gtk_builder_set_current_object(builder: ?*GtkBuilder, current_object: [*c]GObject) void;
pub extern fn gtk_builder_set_translation_domain(builder: ?*GtkBuilder, domain: [*c]const u8) void;
pub extern fn gtk_builder_get_translation_domain(builder: ?*GtkBuilder) [*c]const u8;
pub extern fn gtk_builder_get_scope(builder: ?*GtkBuilder) ?*GtkBuilderScope;
pub extern fn gtk_builder_set_scope(builder: ?*GtkBuilder, scope: ?*GtkBuilderScope) void;
pub extern fn gtk_builder_get_type_from_name(builder: ?*GtkBuilder, type_name: [*c]const u8) GType;
pub extern fn gtk_builder_value_from_string(builder: ?*GtkBuilder, pspec: [*c]GParamSpec, string: [*c]const u8, value: [*c]GValue, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_value_from_string_type(builder: ?*GtkBuilder, @"type": GType, string: [*c]const u8, value: [*c]GValue, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_builder_new_from_file(filename: [*c]const u8) ?*GtkBuilder;
pub extern fn gtk_builder_new_from_resource(resource_path: [*c]const u8) ?*GtkBuilder;
pub extern fn gtk_builder_new_from_string(string: [*c]const u8, length: gssize) ?*GtkBuilder;
pub extern fn gtk_builder_create_closure(builder: ?*GtkBuilder, function_name: [*c]const u8, flags: GtkBuilderClosureFlags, object: [*c]GObject, @"error": [*c][*c]GError) ?*GClosure;
pub extern fn gtk_builder_extend_with_template(builder: ?*GtkBuilder, object: [*c]GObject, template_type: GType, buffer: [*c]const u8, length: gssize, @"error": [*c][*c]GError) gboolean;
pub const GtkBuilder_autoptr = ?*GtkBuilder;
pub const GtkBuilder_listautoptr = [*c]GList;
pub const GtkBuilder_slistautoptr = [*c]GSList;
pub const GtkBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuilder(arg__ptr: ?*GtkBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBuilder(arg__ptr: [*c]?*GtkBuilder) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBuilder(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBuilder(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBuilder(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBuilder(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkBuildable = opaque {};
pub const GtkBuildable = struct__GtkBuildable;
pub const struct__GtkBuildableParseContext = opaque {};
pub const GtkBuildableParseContext = struct__GtkBuildableParseContext;
pub const struct__GtkBuildableParser = extern struct {
    start_element: ?*const fn (?*GtkBuildableParseContext, [*c]const u8, [*c][*c]const u8, [*c][*c]const u8, gpointer, [*c][*c]GError) callconv(.C) void,
    end_element: ?*const fn (?*GtkBuildableParseContext, [*c]const u8, gpointer, [*c][*c]GError) callconv(.C) void,
    text: ?*const fn (?*GtkBuildableParseContext, [*c]const u8, gsize, gpointer, [*c][*c]GError) callconv(.C) void,
    @"error": ?*const fn (?*GtkBuildableParseContext, [*c]GError, gpointer) callconv(.C) void,
    padding: [4]gpointer,
};
pub const GtkBuildableParser = struct__GtkBuildableParser;
pub const struct__GtkBuildableIface = extern struct {
    g_iface: GTypeInterface,
    set_id: ?*const fn (?*GtkBuildable, [*c]const u8) callconv(.C) void,
    get_id: ?*const fn (?*GtkBuildable) callconv(.C) [*c]const u8,
    add_child: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]GObject, [*c]const u8) callconv(.C) void,
    set_buildable_property: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]const u8, [*c]const GValue) callconv(.C) void,
    construct_child: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]const u8) callconv(.C) [*c]GObject,
    custom_tag_start: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]GObject, [*c]const u8, [*c]GtkBuildableParser, [*c]gpointer) callconv(.C) gboolean,
    custom_tag_end: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]GObject, [*c]const u8, gpointer) callconv(.C) void,
    custom_finished: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]GObject, [*c]const u8, gpointer) callconv(.C) void,
    parser_finished: ?*const fn (?*GtkBuildable, ?*GtkBuilder) callconv(.C) void,
    get_internal_child: ?*const fn (?*GtkBuildable, ?*GtkBuilder, [*c]const u8) callconv(.C) [*c]GObject,
};
pub const GtkBuildableIface = struct__GtkBuildableIface;
pub extern fn gtk_buildable_get_type() GType;
pub extern fn gtk_buildable_get_buildable_id(buildable: ?*GtkBuildable) [*c]const u8;
pub extern fn gtk_buildable_parse_context_push(context: ?*GtkBuildableParseContext, parser: [*c]const GtkBuildableParser, user_data: gpointer) void;
pub extern fn gtk_buildable_parse_context_pop(context: ?*GtkBuildableParseContext) gpointer;
pub extern fn gtk_buildable_parse_context_get_element(context: ?*GtkBuildableParseContext) [*c]const u8;
pub extern fn gtk_buildable_parse_context_get_element_stack(context: ?*GtkBuildableParseContext) [*c]GPtrArray;
pub extern fn gtk_buildable_parse_context_get_position(context: ?*GtkBuildableParseContext, line_number: [*c]c_int, char_number: [*c]c_int) void;
pub const GtkBuildable_autoptr = ?*GtkBuildable;
pub const GtkBuildable_listautoptr = [*c]GList;
pub const GtkBuildable_slistautoptr = [*c]GSList;
pub const GtkBuildable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuildable(arg__ptr: ?*GtkBuildable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkBuildable(arg__ptr: [*c]?*GtkBuildable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkBuildable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkBuildable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkBuildable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkBuildable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkListItemFactoryClass = opaque {};
pub const GtkListItemFactoryClass = struct__GtkListItemFactoryClass;
pub extern fn gtk_list_item_factory_get_type() GType;
pub const GtkListItemFactory_autoptr = ?*GtkListItemFactory;
pub const GtkListItemFactory_listautoptr = [*c]GList;
pub const GtkListItemFactory_slistautoptr = [*c]GSList;
pub const GtkListItemFactory_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListItemFactory(arg__ptr: ?*GtkListItemFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListItemFactory(arg__ptr: [*c]?*GtkListItemFactory) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListItemFactory(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListItemFactory(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListItemFactory(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListItemFactory(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkBuilderListItemFactory = opaque {};
pub const GtkBuilderListItemFactory = struct__GtkBuilderListItemFactory;
pub const struct__GtkBuilderListItemFactoryClass = opaque {};
pub const GtkBuilderListItemFactoryClass = struct__GtkBuilderListItemFactoryClass;
pub extern fn gtk_builder_list_item_factory_get_type() GType;
pub extern fn gtk_builder_list_item_factory_new_from_bytes(scope: ?*GtkBuilderScope, bytes: ?*GBytes) ?*GtkListItemFactory;
pub extern fn gtk_builder_list_item_factory_new_from_resource(scope: ?*GtkBuilderScope, resource_path: [*c]const u8) ?*GtkListItemFactory;
pub extern fn gtk_builder_list_item_factory_get_bytes(self: ?*GtkBuilderListItemFactory) ?*GBytes;
pub extern fn gtk_builder_list_item_factory_get_resource(self: ?*GtkBuilderListItemFactory) [*c]const u8;
pub extern fn gtk_builder_list_item_factory_get_scope(self: ?*GtkBuilderListItemFactory) ?*GtkBuilderScope;
pub const struct__GtkButton = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkButton = struct__GtkButton;
pub const struct__GtkButtonPrivate = opaque {};
pub const GtkButtonPrivate = struct__GtkButtonPrivate;
pub const struct__GtkButtonClass = extern struct {
    parent_class: GtkWidgetClass,
    clicked: ?*const fn ([*c]GtkButton) callconv(.C) void,
    activate: ?*const fn ([*c]GtkButton) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkButtonClass = struct__GtkButtonClass;
pub extern fn gtk_button_get_type() GType;
pub extern fn gtk_button_new() [*c]GtkWidget;
pub extern fn gtk_button_new_with_label(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_button_new_from_icon_name(icon_name: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_button_new_with_mnemonic(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_button_set_has_frame(button: [*c]GtkButton, has_frame: gboolean) void;
pub extern fn gtk_button_get_has_frame(button: [*c]GtkButton) gboolean;
pub extern fn gtk_button_set_label(button: [*c]GtkButton, label: [*c]const u8) void;
pub extern fn gtk_button_get_label(button: [*c]GtkButton) [*c]const u8;
pub extern fn gtk_button_set_use_underline(button: [*c]GtkButton, use_underline: gboolean) void;
pub extern fn gtk_button_get_use_underline(button: [*c]GtkButton) gboolean;
pub extern fn gtk_button_set_icon_name(button: [*c]GtkButton, icon_name: [*c]const u8) void;
pub extern fn gtk_button_get_icon_name(button: [*c]GtkButton) [*c]const u8;
pub extern fn gtk_button_set_child(button: [*c]GtkButton, child: [*c]GtkWidget) void;
pub extern fn gtk_button_get_child(button: [*c]GtkButton) [*c]GtkWidget;
pub extern fn gtk_button_set_can_shrink(button: [*c]GtkButton, can_shrink: gboolean) void;
pub extern fn gtk_button_get_can_shrink(button: [*c]GtkButton) gboolean;
pub const GtkButton_autoptr = [*c]GtkButton;
pub const GtkButton_listautoptr = [*c]GList;
pub const GtkButton_slistautoptr = [*c]GSList;
pub const GtkButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkButton(arg__ptr: [*c]GtkButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkButton(arg__ptr: [*c][*c]GtkButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCalendar = opaque {};
pub const GtkCalendar = struct__GtkCalendar;
pub extern fn gtk_calendar_get_type() GType;
pub extern fn gtk_calendar_new() [*c]GtkWidget;
pub extern fn gtk_calendar_select_day(self: ?*GtkCalendar, date: ?*GDateTime) void;
pub extern fn gtk_calendar_mark_day(calendar: ?*GtkCalendar, day: guint) void;
pub extern fn gtk_calendar_unmark_day(calendar: ?*GtkCalendar, day: guint) void;
pub extern fn gtk_calendar_clear_marks(calendar: ?*GtkCalendar) void;
pub extern fn gtk_calendar_set_show_week_numbers(self: ?*GtkCalendar, value: gboolean) void;
pub extern fn gtk_calendar_get_show_week_numbers(self: ?*GtkCalendar) gboolean;
pub extern fn gtk_calendar_set_show_heading(self: ?*GtkCalendar, value: gboolean) void;
pub extern fn gtk_calendar_get_show_heading(self: ?*GtkCalendar) gboolean;
pub extern fn gtk_calendar_set_show_day_names(self: ?*GtkCalendar, value: gboolean) void;
pub extern fn gtk_calendar_get_show_day_names(self: ?*GtkCalendar) gboolean;
pub extern fn gtk_calendar_get_date(self: ?*GtkCalendar) ?*GDateTime;
pub extern fn gtk_calendar_get_day_is_marked(calendar: ?*GtkCalendar, day: guint) gboolean;
pub const GtkCalendar_autoptr = ?*GtkCalendar;
pub const GtkCalendar_listautoptr = [*c]GList;
pub const GtkCalendar_slistautoptr = [*c]GSList;
pub const GtkCalendar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCalendar(arg__ptr: ?*GtkCalendar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCalendar(arg__ptr: [*c]?*GtkCalendar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCalendar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCalendar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCalendar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCalendar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellEditable = opaque {};
pub const GtkCellEditable = struct__GtkCellEditable;
pub const struct__GtkCellEditableIface = extern struct {
    g_iface: GTypeInterface,
    editing_done: ?*const fn (?*GtkCellEditable) callconv(.C) void,
    remove_widget: ?*const fn (?*GtkCellEditable) callconv(.C) void,
    start_editing: ?*const fn (?*GtkCellEditable, ?*GdkEvent) callconv(.C) void,
};
pub const GtkCellEditableIface = struct__GtkCellEditableIface;
pub extern fn gtk_cell_editable_get_type() GType;
pub extern fn gtk_cell_editable_start_editing(cell_editable: ?*GtkCellEditable, event: ?*GdkEvent) void;
pub extern fn gtk_cell_editable_editing_done(cell_editable: ?*GtkCellEditable) void;
pub extern fn gtk_cell_editable_remove_widget(cell_editable: ?*GtkCellEditable) void;
pub const GtkCellEditable_autoptr = ?*GtkCellEditable;
pub const GtkCellEditable_listautoptr = [*c]GList;
pub const GtkCellEditable_slistautoptr = [*c]GSList;
pub const GtkCellEditable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellEditable(arg__ptr: ?*GtkCellEditable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellEditable(arg__ptr: [*c]?*GtkCellEditable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellEditable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellEditable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellEditable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellEditable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_CELL_RENDERER_SELECTED: c_int = 1;
pub const GTK_CELL_RENDERER_PRELIT: c_int = 2;
pub const GTK_CELL_RENDERER_INSENSITIVE: c_int = 4;
pub const GTK_CELL_RENDERER_SORTED: c_int = 8;
pub const GTK_CELL_RENDERER_FOCUSED: c_int = 16;
pub const GTK_CELL_RENDERER_EXPANDABLE: c_int = 32;
pub const GTK_CELL_RENDERER_EXPANDED: c_int = 64;
pub const GtkCellRendererState = c_uint;
pub const GTK_CELL_RENDERER_MODE_INERT: c_int = 0;
pub const GTK_CELL_RENDERER_MODE_ACTIVATABLE: c_int = 1;
pub const GTK_CELL_RENDERER_MODE_EDITABLE: c_int = 2;
pub const GtkCellRendererMode = c_uint;
pub const struct__GtkCellRendererPrivate = opaque {};
pub const GtkCellRendererPrivate = struct__GtkCellRendererPrivate;
pub const struct__GtkCellRenderer = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkCellRendererPrivate,
};
pub const GtkCellRenderer = struct__GtkCellRenderer;
pub const struct__GtkCellRendererClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    get_request_mode: ?*const fn ([*c]GtkCellRenderer) callconv(.C) GtkSizeRequestMode,
    get_preferred_width: ?*const fn ([*c]GtkCellRenderer, [*c]GtkWidget, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_height_for_width: ?*const fn ([*c]GtkCellRenderer, [*c]GtkWidget, c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_height: ?*const fn ([*c]GtkCellRenderer, [*c]GtkWidget, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_width_for_height: ?*const fn ([*c]GtkCellRenderer, [*c]GtkWidget, c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_aligned_area: ?*const fn ([*c]GtkCellRenderer, [*c]GtkWidget, GtkCellRendererState, [*c]const GdkRectangle, [*c]GdkRectangle) callconv(.C) void,
    snapshot: ?*const fn ([*c]GtkCellRenderer, ?*GtkSnapshot, [*c]GtkWidget, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState) callconv(.C) void,
    activate: ?*const fn ([*c]GtkCellRenderer, ?*GdkEvent, [*c]GtkWidget, [*c]const u8, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState) callconv(.C) gboolean,
    start_editing: ?*const fn ([*c]GtkCellRenderer, ?*GdkEvent, [*c]GtkWidget, [*c]const u8, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState) callconv(.C) ?*GtkCellEditable,
    editing_canceled: ?*const fn ([*c]GtkCellRenderer) callconv(.C) void,
    editing_started: ?*const fn ([*c]GtkCellRenderer, ?*GtkCellEditable, [*c]const u8) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkCellRendererClass = struct__GtkCellRendererClass;
pub const struct__GtkCellRendererClassPrivate = opaque {};
pub const GtkCellRendererClassPrivate = struct__GtkCellRendererClassPrivate;
pub extern fn gtk_cell_renderer_get_type() GType;
pub extern fn gtk_cell_renderer_get_request_mode(cell: [*c]GtkCellRenderer) GtkSizeRequestMode;
pub extern fn gtk_cell_renderer_get_preferred_width(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, minimum_size: [*c]c_int, natural_size: [*c]c_int) void;
pub extern fn gtk_cell_renderer_get_preferred_height_for_width(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, width: c_int, minimum_height: [*c]c_int, natural_height: [*c]c_int) void;
pub extern fn gtk_cell_renderer_get_preferred_height(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, minimum_size: [*c]c_int, natural_size: [*c]c_int) void;
pub extern fn gtk_cell_renderer_get_preferred_width_for_height(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, height: c_int, minimum_width: [*c]c_int, natural_width: [*c]c_int) void;
pub extern fn gtk_cell_renderer_get_preferred_size(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, minimum_size: [*c]GtkRequisition, natural_size: [*c]GtkRequisition) void;
pub extern fn gtk_cell_renderer_get_aligned_area(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, flags: GtkCellRendererState, cell_area: [*c]const GdkRectangle, aligned_area: [*c]GdkRectangle) void;
pub extern fn gtk_cell_renderer_snapshot(cell: [*c]GtkCellRenderer, snapshot: ?*GtkSnapshot, widget: [*c]GtkWidget, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) void;
pub extern fn gtk_cell_renderer_activate(cell: [*c]GtkCellRenderer, event: ?*GdkEvent, widget: [*c]GtkWidget, path: [*c]const u8, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) gboolean;
pub extern fn gtk_cell_renderer_start_editing(cell: [*c]GtkCellRenderer, event: ?*GdkEvent, widget: [*c]GtkWidget, path: [*c]const u8, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) ?*GtkCellEditable;
pub extern fn gtk_cell_renderer_set_fixed_size(cell: [*c]GtkCellRenderer, width: c_int, height: c_int) void;
pub extern fn gtk_cell_renderer_get_fixed_size(cell: [*c]GtkCellRenderer, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_cell_renderer_set_alignment(cell: [*c]GtkCellRenderer, xalign: f32, yalign: f32) void;
pub extern fn gtk_cell_renderer_get_alignment(cell: [*c]GtkCellRenderer, xalign: [*c]f32, yalign: [*c]f32) void;
pub extern fn gtk_cell_renderer_set_padding(cell: [*c]GtkCellRenderer, xpad: c_int, ypad: c_int) void;
pub extern fn gtk_cell_renderer_get_padding(cell: [*c]GtkCellRenderer, xpad: [*c]c_int, ypad: [*c]c_int) void;
pub extern fn gtk_cell_renderer_set_visible(cell: [*c]GtkCellRenderer, visible: gboolean) void;
pub extern fn gtk_cell_renderer_get_visible(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_set_sensitive(cell: [*c]GtkCellRenderer, sensitive: gboolean) void;
pub extern fn gtk_cell_renderer_get_sensitive(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_is_activatable(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_set_is_expander(cell: [*c]GtkCellRenderer, is_expander: gboolean) void;
pub extern fn gtk_cell_renderer_get_is_expander(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_set_is_expanded(cell: [*c]GtkCellRenderer, is_expanded: gboolean) void;
pub extern fn gtk_cell_renderer_get_is_expanded(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_stop_editing(cell: [*c]GtkCellRenderer, canceled: gboolean) void;
pub extern fn _gtk_cell_renderer_calc_offset(cell: [*c]GtkCellRenderer, cell_area: [*c]const GdkRectangle, direction: GtkTextDirection, width: c_int, height: c_int, x_offset: [*c]c_int, y_offset: [*c]c_int) void;
pub extern fn gtk_cell_renderer_get_state(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, cell_state: GtkCellRendererState) GtkStateFlags;
pub const GtkCellRenderer_autoptr = [*c]GtkCellRenderer;
pub const GtkCellRenderer_listautoptr = [*c]GList;
pub const GtkCellRenderer_slistautoptr = [*c]GSList;
pub const GtkCellRenderer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRenderer(arg__ptr: [*c]GtkCellRenderer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRenderer(arg__ptr: [*c][*c]GtkCellRenderer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRenderer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRenderer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRenderer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRenderer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkTreeIter = extern struct {
    stamp: c_int,
    user_data: gpointer,
    user_data2: gpointer,
    user_data3: gpointer,
};
pub const GtkTreeIter = struct__GtkTreeIter;
pub const struct__GtkTreePath = opaque {};
pub const GtkTreePath = struct__GtkTreePath;
pub const struct__GtkTreeRowReference = opaque {};
pub const GtkTreeRowReference = struct__GtkTreeRowReference;
pub const struct__GtkTreeModel = opaque {};
pub const GtkTreeModel = struct__GtkTreeModel;
pub const struct__GtkTreeModelIface = extern struct {
    g_iface: GTypeInterface,
    row_changed: ?*const fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter) callconv(.C) void,
    row_inserted: ?*const fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter) callconv(.C) void,
    row_has_child_toggled: ?*const fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter) callconv(.C) void,
    row_deleted: ?*const fn (?*GtkTreeModel, ?*GtkTreePath) callconv(.C) void,
    rows_reordered: ?*const fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter, [*c]c_int) callconv(.C) void,
    get_flags: ?*const fn (?*GtkTreeModel) callconv(.C) GtkTreeModelFlags,
    get_n_columns: ?*const fn (?*GtkTreeModel) callconv(.C) c_int,
    get_column_type: ?*const fn (?*GtkTreeModel, c_int) callconv(.C) GType,
    get_iter: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, ?*GtkTreePath) callconv(.C) gboolean,
    get_path: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) ?*GtkTreePath,
    get_value: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, c_int, [*c]GValue) callconv(.C) void,
    iter_next: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) gboolean,
    iter_previous: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) gboolean,
    iter_children: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter) callconv(.C) gboolean,
    iter_has_child: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) gboolean,
    iter_n_children: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) c_int,
    iter_nth_child: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter, c_int) callconv(.C) gboolean,
    iter_parent: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter) callconv(.C) gboolean,
    ref_node: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) void,
    unref_node: ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) void,
};
pub const GtkTreeModelIface = struct__GtkTreeModelIface;
pub const GtkTreeModelForeachFunc = ?*const fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter, gpointer) callconv(.C) gboolean;
pub const GTK_TREE_MODEL_ITERS_PERSIST: c_int = 1;
pub const GTK_TREE_MODEL_LIST_ONLY: c_int = 2;
pub const GtkTreeModelFlags = c_uint;
pub extern fn gtk_tree_path_new() ?*GtkTreePath;
pub extern fn gtk_tree_path_new_from_string(path: [*c]const u8) ?*GtkTreePath;
pub extern fn gtk_tree_path_new_from_indices(first_index: c_int, ...) ?*GtkTreePath;
pub extern fn gtk_tree_path_new_from_indicesv(indices: [*c]c_int, length: gsize) ?*GtkTreePath;
pub extern fn gtk_tree_path_to_string(path: ?*GtkTreePath) [*c]u8;
pub extern fn gtk_tree_path_new_first() ?*GtkTreePath;
pub extern fn gtk_tree_path_append_index(path: ?*GtkTreePath, index_: c_int) void;
pub extern fn gtk_tree_path_prepend_index(path: ?*GtkTreePath, index_: c_int) void;
pub extern fn gtk_tree_path_get_depth(path: ?*GtkTreePath) c_int;
pub extern fn gtk_tree_path_get_indices(path: ?*GtkTreePath) [*c]c_int;
pub extern fn gtk_tree_path_get_indices_with_depth(path: ?*GtkTreePath, depth: [*c]c_int) [*c]c_int;
pub extern fn gtk_tree_path_free(path: ?*GtkTreePath) void;
pub extern fn gtk_tree_path_copy(path: ?*const GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_path_get_type() GType;
pub extern fn gtk_tree_path_compare(a: ?*const GtkTreePath, b: ?*const GtkTreePath) c_int;
pub extern fn gtk_tree_path_next(path: ?*GtkTreePath) void;
pub extern fn gtk_tree_path_prev(path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_path_up(path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_path_down(path: ?*GtkTreePath) void;
pub extern fn gtk_tree_path_is_ancestor(path: ?*GtkTreePath, descendant: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_path_is_descendant(path: ?*GtkTreePath, ancestor: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_row_reference_get_type() GType;
pub extern fn gtk_tree_row_reference_new(model: ?*GtkTreeModel, path: ?*GtkTreePath) ?*GtkTreeRowReference;
pub extern fn gtk_tree_row_reference_new_proxy(proxy: [*c]GObject, model: ?*GtkTreeModel, path: ?*GtkTreePath) ?*GtkTreeRowReference;
pub extern fn gtk_tree_row_reference_get_path(reference: ?*GtkTreeRowReference) ?*GtkTreePath;
pub extern fn gtk_tree_row_reference_get_model(reference: ?*GtkTreeRowReference) ?*GtkTreeModel;
pub extern fn gtk_tree_row_reference_valid(reference: ?*GtkTreeRowReference) gboolean;
pub extern fn gtk_tree_row_reference_copy(reference: ?*GtkTreeRowReference) ?*GtkTreeRowReference;
pub extern fn gtk_tree_row_reference_free(reference: ?*GtkTreeRowReference) void;
pub extern fn gtk_tree_row_reference_inserted(proxy: [*c]GObject, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_row_reference_deleted(proxy: [*c]GObject, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_row_reference_reordered(proxy: [*c]GObject, path: ?*GtkTreePath, iter: [*c]GtkTreeIter, new_order: [*c]c_int) void;
pub extern fn gtk_tree_iter_copy(iter: [*c]GtkTreeIter) [*c]GtkTreeIter;
pub extern fn gtk_tree_iter_free(iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_iter_get_type() GType;
pub extern fn gtk_tree_model_get_type() GType;
pub extern fn gtk_tree_model_get_flags(tree_model: ?*GtkTreeModel) GtkTreeModelFlags;
pub extern fn gtk_tree_model_get_n_columns(tree_model: ?*GtkTreeModel) c_int;
pub extern fn gtk_tree_model_get_column_type(tree_model: ?*GtkTreeModel, index_: c_int) GType;
pub extern fn gtk_tree_model_get_iter(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_model_get_iter_from_string(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, path_string: [*c]const u8) gboolean;
pub extern fn gtk_tree_model_get_string_from_iter(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) [*c]u8;
pub extern fn gtk_tree_model_get_iter_first(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_get_path(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) ?*GtkTreePath;
pub extern fn gtk_tree_model_get_value(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, column: c_int, value: [*c]GValue) void;
pub extern fn gtk_tree_model_iter_previous(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_next(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_children(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_has_child(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_n_children(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) c_int;
pub extern fn gtk_tree_model_iter_nth_child(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, n: c_int) gboolean;
pub extern fn gtk_tree_model_iter_parent(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, child: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_ref_node(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_unref_node(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_get(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, ...) void;
pub extern fn gtk_tree_model_get_valist(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, var_args: [*c]struct___va_list_tag) void;
pub extern fn gtk_tree_model_foreach(model: ?*GtkTreeModel, func: GtkTreeModelForeachFunc, user_data: gpointer) void;
pub extern fn gtk_tree_model_row_changed(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_row_inserted(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_row_has_child_toggled(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_row_deleted(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_model_rows_reordered(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter, new_order: [*c]c_int) void;
pub extern fn gtk_tree_model_rows_reordered_with_length(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter, new_order: [*c]c_int, length: c_int) void;
pub const GtkTreeModel_autoptr = ?*GtkTreeModel;
pub const GtkTreeModel_listautoptr = [*c]GList;
pub const GtkTreeModel_slistautoptr = [*c]GSList;
pub const GtkTreeModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeModel(arg__ptr: ?*GtkTreeModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeModel(arg__ptr: [*c]?*GtkTreeModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkTreeIter_autoptr = [*c]GtkTreeIter;
pub const GtkTreeIter_listautoptr = [*c]GList;
pub const GtkTreeIter_slistautoptr = [*c]GSList;
pub const GtkTreeIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeIter(arg__ptr: [*c]GtkTreeIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_tree_iter_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkTreeIter(arg__ptr: [*c][*c]GtkTreeIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_iter_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_iter_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_iter_free)))))));
    }
}
pub const GtkTreePath_autoptr = ?*GtkTreePath;
pub const GtkTreePath_listautoptr = [*c]GList;
pub const GtkTreePath_slistautoptr = [*c]GSList;
pub const GtkTreePath_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreePath(arg__ptr: ?*GtkTreePath) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_tree_path_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkTreePath(arg__ptr: [*c]?*GtkTreePath) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreePath(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreePath(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_path_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreePath(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_path_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreePath(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_path_free)))))));
    }
}
pub const GtkTreeRowReference_autoptr = ?*GtkTreeRowReference;
pub const GtkTreeRowReference_listautoptr = [*c]GList;
pub const GtkTreeRowReference_slistautoptr = [*c]GSList;
pub const GtkTreeRowReference_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeRowReference(arg__ptr: ?*GtkTreeRowReference) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_tree_row_reference_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkTreeRowReference(arg__ptr: [*c]?*GtkTreeRowReference) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeRowReference(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeRowReference(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_row_reference_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeRowReference(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_row_reference_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeRowReference(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_tree_row_reference_free)))))));
    }
}
pub const struct__GtkCellArea = extern struct {
    parent_instance: GInitiallyUnowned,
};
pub const GtkCellArea = struct__GtkCellArea;
pub const GtkCellCallback = ?*const fn ([*c]GtkCellRenderer, gpointer) callconv(.C) gboolean;
pub const struct__GtkCellAreaContext = extern struct {
    parent_instance: GObject,
};
pub const GtkCellAreaContext = struct__GtkCellAreaContext;
pub const GtkCellAllocCallback = ?*const fn ([*c]GtkCellRenderer, [*c]const GdkRectangle, [*c]const GdkRectangle, gpointer) callconv(.C) gboolean;
pub const struct__GtkCellAreaClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    add: ?*const fn ([*c]GtkCellArea, [*c]GtkCellRenderer) callconv(.C) void,
    remove: ?*const fn ([*c]GtkCellArea, [*c]GtkCellRenderer) callconv(.C) void,
    foreach: ?*const fn ([*c]GtkCellArea, GtkCellCallback, gpointer) callconv(.C) void,
    foreach_alloc: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellAllocCallback, gpointer) callconv(.C) void,
    event: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, ?*GdkEvent, [*c]const GdkRectangle, GtkCellRendererState) callconv(.C) c_int,
    snapshot: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, ?*GtkSnapshot, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState, gboolean) callconv(.C) void,
    apply_attributes: ?*const fn ([*c]GtkCellArea, ?*GtkTreeModel, [*c]GtkTreeIter, gboolean, gboolean) callconv(.C) void,
    create_context: ?*const fn ([*c]GtkCellArea) callconv(.C) [*c]GtkCellAreaContext,
    copy_context: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext) callconv(.C) [*c]GtkCellAreaContext,
    get_request_mode: ?*const fn ([*c]GtkCellArea) callconv(.C) GtkSizeRequestMode,
    get_preferred_width: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_height_for_width: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_height: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_width_for_height: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    set_cell_property: ?*const fn ([*c]GtkCellArea, [*c]GtkCellRenderer, guint, [*c]const GValue, [*c]GParamSpec) callconv(.C) void,
    get_cell_property: ?*const fn ([*c]GtkCellArea, [*c]GtkCellRenderer, guint, [*c]GValue, [*c]GParamSpec) callconv(.C) void,
    focus: ?*const fn ([*c]GtkCellArea, GtkDirectionType) callconv(.C) gboolean,
    is_activatable: ?*const fn ([*c]GtkCellArea) callconv(.C) gboolean,
    activate: ?*const fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]const GdkRectangle, GtkCellRendererState, gboolean) callconv(.C) gboolean,
    padding: [8]gpointer,
};
pub const GtkCellAreaClass = struct__GtkCellAreaClass;
pub extern fn gtk_cell_area_get_type() GType;
pub extern fn gtk_cell_area_add(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_remove(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_has_renderer(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_area_foreach(area: [*c]GtkCellArea, callback: GtkCellCallback, callback_data: gpointer) void;
pub extern fn gtk_cell_area_foreach_alloc(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, background_area: [*c]const GdkRectangle, callback: GtkCellAllocCallback, callback_data: gpointer) void;
pub extern fn gtk_cell_area_event(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, event: ?*GdkEvent, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) c_int;
pub extern fn gtk_cell_area_snapshot(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, snapshot: ?*GtkSnapshot, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState, paint_focus: gboolean) void;
pub extern fn gtk_cell_area_get_cell_allocation(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, renderer: [*c]GtkCellRenderer, cell_area: [*c]const GdkRectangle, allocation: [*c]GdkRectangle) void;
pub extern fn gtk_cell_area_get_cell_at_position(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, x: c_int, y: c_int, alloc_area: [*c]GdkRectangle) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_create_context(area: [*c]GtkCellArea) [*c]GtkCellAreaContext;
pub extern fn gtk_cell_area_copy_context(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext) [*c]GtkCellAreaContext;
pub extern fn gtk_cell_area_get_request_mode(area: [*c]GtkCellArea) GtkSizeRequestMode;
pub extern fn gtk_cell_area_get_preferred_width(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, minimum_width: [*c]c_int, natural_width: [*c]c_int) void;
pub extern fn gtk_cell_area_get_preferred_height_for_width(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, width: c_int, minimum_height: [*c]c_int, natural_height: [*c]c_int) void;
pub extern fn gtk_cell_area_get_preferred_height(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, minimum_height: [*c]c_int, natural_height: [*c]c_int) void;
pub extern fn gtk_cell_area_get_preferred_width_for_height(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, height: c_int, minimum_width: [*c]c_int, natural_width: [*c]c_int) void;
pub extern fn gtk_cell_area_get_current_path_string(area: [*c]GtkCellArea) [*c]const u8;
pub extern fn gtk_cell_area_apply_attributes(area: [*c]GtkCellArea, tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, is_expander: gboolean, is_expanded: gboolean) void;
pub extern fn gtk_cell_area_attribute_connect(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, attribute: [*c]const u8, column: c_int) void;
pub extern fn gtk_cell_area_attribute_disconnect(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, attribute: [*c]const u8) void;
pub extern fn gtk_cell_area_attribute_get_column(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, attribute: [*c]const u8) c_int;
pub extern fn gtk_cell_area_class_install_cell_property(aclass: [*c]GtkCellAreaClass, property_id: guint, pspec: [*c]GParamSpec) void;
pub extern fn gtk_cell_area_class_find_cell_property(aclass: [*c]GtkCellAreaClass, property_name: [*c]const u8) [*c]GParamSpec;
pub extern fn gtk_cell_area_class_list_cell_properties(aclass: [*c]GtkCellAreaClass, n_properties: [*c]guint) [*c][*c]GParamSpec;
pub extern fn gtk_cell_area_add_with_properties(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_prop_name: [*c]const u8, ...) void;
pub extern fn gtk_cell_area_cell_set(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_prop_name: [*c]const u8, ...) void;
pub extern fn gtk_cell_area_cell_get(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_prop_name: [*c]const u8, ...) void;
pub extern fn gtk_cell_area_cell_set_valist(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_property_name: [*c]const u8, var_args: [*c]struct___va_list_tag) void;
pub extern fn gtk_cell_area_cell_get_valist(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_property_name: [*c]const u8, var_args: [*c]struct___va_list_tag) void;
pub extern fn gtk_cell_area_cell_set_property(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, property_name: [*c]const u8, value: [*c]const GValue) void;
pub extern fn gtk_cell_area_cell_get_property(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, property_name: [*c]const u8, value: [*c]GValue) void;
pub extern fn gtk_cell_area_is_activatable(area: [*c]GtkCellArea) gboolean;
pub extern fn gtk_cell_area_activate(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState, edit_only: gboolean) gboolean;
pub extern fn gtk_cell_area_focus(area: [*c]GtkCellArea, direction: GtkDirectionType) gboolean;
pub extern fn gtk_cell_area_set_focus_cell(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_get_focus_cell(area: [*c]GtkCellArea) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_add_focus_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, sibling: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_remove_focus_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, sibling: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_is_focus_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, sibling: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_area_get_focus_siblings(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) [*c]const GList;
pub extern fn gtk_cell_area_get_focus_from_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_get_edited_cell(area: [*c]GtkCellArea) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_get_edit_widget(area: [*c]GtkCellArea) ?*GtkCellEditable;
pub extern fn gtk_cell_area_activate_cell(area: [*c]GtkCellArea, widget: [*c]GtkWidget, renderer: [*c]GtkCellRenderer, event: ?*GdkEvent, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) gboolean;
pub extern fn gtk_cell_area_stop_editing(area: [*c]GtkCellArea, canceled: gboolean) void;
pub extern fn gtk_cell_area_inner_cell_area(area: [*c]GtkCellArea, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, inner_area: [*c]GdkRectangle) void;
pub extern fn gtk_cell_area_request_renderer(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, orientation: GtkOrientation, widget: [*c]GtkWidget, for_size: c_int, minimum_size: [*c]c_int, natural_size: [*c]c_int) void;
pub extern fn _gtk_cell_area_set_cell_data_func_with_proxy(area: [*c]GtkCellArea, cell: [*c]GtkCellRenderer, func: GFunc, func_data: gpointer, destroy: GDestroyNotify, proxy: gpointer) void;
pub const GtkCellArea_autoptr = [*c]GtkCellArea;
pub const GtkCellArea_listautoptr = [*c]GList;
pub const GtkCellArea_slistautoptr = [*c]GSList;
pub const GtkCellArea_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellArea(arg__ptr: [*c]GtkCellArea) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellArea(arg__ptr: [*c][*c]GtkCellArea) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellArea(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellArea(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellArea(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellArea(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellAreaBox = opaque {};
pub const GtkCellAreaBox = struct__GtkCellAreaBox;
pub extern fn gtk_cell_area_box_get_type() GType;
pub extern fn gtk_cell_area_box_new() [*c]GtkCellArea;
pub extern fn gtk_cell_area_box_pack_start(box: ?*GtkCellAreaBox, renderer: [*c]GtkCellRenderer, expand: gboolean, @"align": gboolean, fixed: gboolean) void;
pub extern fn gtk_cell_area_box_pack_end(box: ?*GtkCellAreaBox, renderer: [*c]GtkCellRenderer, expand: gboolean, @"align": gboolean, fixed: gboolean) void;
pub extern fn gtk_cell_area_box_get_spacing(box: ?*GtkCellAreaBox) c_int;
pub extern fn gtk_cell_area_box_set_spacing(box: ?*GtkCellAreaBox, spacing: c_int) void;
pub extern fn _gtk_cell_area_box_group_visible(box: ?*GtkCellAreaBox, group_idx: c_int) gboolean;
pub const GtkCellAreaBox_autoptr = ?*GtkCellAreaBox;
pub const GtkCellAreaBox_listautoptr = [*c]GList;
pub const GtkCellAreaBox_slistautoptr = [*c]GSList;
pub const GtkCellAreaBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellAreaBox(arg__ptr: ?*GtkCellAreaBox) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellAreaBox(arg__ptr: [*c]?*GtkCellAreaBox) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellAreaBox(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellAreaBox(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellAreaBox(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellAreaBox(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellAreaContextPrivate = opaque {};
pub const GtkCellAreaContextPrivate = struct__GtkCellAreaContextPrivate;
pub const struct__GtkCellAreaContextClass = extern struct {
    parent_class: GObjectClass,
    allocate: ?*const fn ([*c]GtkCellAreaContext, c_int, c_int) callconv(.C) void,
    reset: ?*const fn ([*c]GtkCellAreaContext) callconv(.C) void,
    get_preferred_height_for_width: ?*const fn ([*c]GtkCellAreaContext, c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    get_preferred_width_for_height: ?*const fn ([*c]GtkCellAreaContext, c_int, [*c]c_int, [*c]c_int) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkCellAreaContextClass = struct__GtkCellAreaContextClass;
pub extern fn gtk_cell_area_context_get_type() GType;
pub extern fn gtk_cell_area_context_get_area(context: [*c]GtkCellAreaContext) [*c]GtkCellArea;
pub extern fn gtk_cell_area_context_allocate(context: [*c]GtkCellAreaContext, width: c_int, height: c_int) void;
pub extern fn gtk_cell_area_context_reset(context: [*c]GtkCellAreaContext) void;
pub extern fn gtk_cell_area_context_get_preferred_width(context: [*c]GtkCellAreaContext, minimum_width: [*c]c_int, natural_width: [*c]c_int) void;
pub extern fn gtk_cell_area_context_get_preferred_height(context: [*c]GtkCellAreaContext, minimum_height: [*c]c_int, natural_height: [*c]c_int) void;
pub extern fn gtk_cell_area_context_get_preferred_height_for_width(context: [*c]GtkCellAreaContext, width: c_int, minimum_height: [*c]c_int, natural_height: [*c]c_int) void;
pub extern fn gtk_cell_area_context_get_preferred_width_for_height(context: [*c]GtkCellAreaContext, height: c_int, minimum_width: [*c]c_int, natural_width: [*c]c_int) void;
pub extern fn gtk_cell_area_context_get_allocation(context: [*c]GtkCellAreaContext, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_cell_area_context_push_preferred_width(context: [*c]GtkCellAreaContext, minimum_width: c_int, natural_width: c_int) void;
pub extern fn gtk_cell_area_context_push_preferred_height(context: [*c]GtkCellAreaContext, minimum_height: c_int, natural_height: c_int) void;
pub const GtkCellAreaContext_autoptr = [*c]GtkCellAreaContext;
pub const GtkCellAreaContext_listautoptr = [*c]GList;
pub const GtkCellAreaContext_slistautoptr = [*c]GSList;
pub const GtkCellAreaContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellAreaContext(arg__ptr: [*c]GtkCellAreaContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellAreaContext(arg__ptr: [*c][*c]GtkCellAreaContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellAreaContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellAreaContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellAreaContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellAreaContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellLayout = opaque {};
pub const GtkCellLayout = struct__GtkCellLayout;
pub const GtkCellLayoutDataFunc = ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer, ?*GtkTreeModel, [*c]GtkTreeIter, gpointer) callconv(.C) void;
pub const struct__GtkCellLayoutIface = extern struct {
    g_iface: GTypeInterface,
    pack_start: ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer, gboolean) callconv(.C) void,
    pack_end: ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer, gboolean) callconv(.C) void,
    clear: ?*const fn (?*GtkCellLayout) callconv(.C) void,
    add_attribute: ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer, [*c]const u8, c_int) callconv(.C) void,
    set_cell_data_func: ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer, GtkCellLayoutDataFunc, gpointer, GDestroyNotify) callconv(.C) void,
    clear_attributes: ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer) callconv(.C) void,
    reorder: ?*const fn (?*GtkCellLayout, [*c]GtkCellRenderer, c_int) callconv(.C) void,
    get_cells: ?*const fn (?*GtkCellLayout) callconv(.C) [*c]GList,
    get_area: ?*const fn (?*GtkCellLayout) callconv(.C) [*c]GtkCellArea,
};
pub const GtkCellLayoutIface = struct__GtkCellLayoutIface;
pub extern fn gtk_cell_layout_get_type() GType;
pub extern fn gtk_cell_layout_pack_start(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_cell_layout_pack_end(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_cell_layout_get_cells(cell_layout: ?*GtkCellLayout) [*c]GList;
pub extern fn gtk_cell_layout_clear(cell_layout: ?*GtkCellLayout) void;
pub extern fn gtk_cell_layout_set_attributes(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, ...) void;
pub extern fn gtk_cell_layout_add_attribute(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, attribute: [*c]const u8, column: c_int) void;
pub extern fn gtk_cell_layout_set_cell_data_func(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, func: GtkCellLayoutDataFunc, func_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_cell_layout_clear_attributes(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_layout_reorder(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, position: c_int) void;
pub extern fn gtk_cell_layout_get_area(cell_layout: ?*GtkCellLayout) [*c]GtkCellArea;
pub extern fn _gtk_cell_layout_buildable_custom_tag_start(buildable: ?*GtkBuildable, builder: ?*GtkBuilder, child: [*c]GObject, tagname: [*c]const u8, parser: [*c]GtkBuildableParser, data: [*c]gpointer) gboolean;
pub extern fn _gtk_cell_layout_buildable_custom_tag_end(buildable: ?*GtkBuildable, builder: ?*GtkBuilder, child: [*c]GObject, tagname: [*c]const u8, data: [*c]gpointer) gboolean;
pub extern fn _gtk_cell_layout_buildable_add_child(buildable: ?*GtkBuildable, builder: ?*GtkBuilder, child: [*c]GObject, @"type": [*c]const u8) void;
pub const GtkCellLayout_autoptr = ?*GtkCellLayout;
pub const GtkCellLayout_listautoptr = [*c]GList;
pub const GtkCellLayout_slistautoptr = [*c]GSList;
pub const GtkCellLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellLayout(arg__ptr: ?*GtkCellLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellLayout(arg__ptr: [*c]?*GtkCellLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererText = extern struct {
    parent: GtkCellRenderer,
};
pub const GtkCellRendererText = struct__GtkCellRendererText;
pub const struct__GtkCellRendererTextClass = extern struct {
    parent_class: GtkCellRendererClass,
    edited: ?*const fn ([*c]GtkCellRendererText, [*c]const u8, [*c]const u8) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkCellRendererTextClass = struct__GtkCellRendererTextClass;
pub extern fn gtk_cell_renderer_text_get_type() GType;
pub extern fn gtk_cell_renderer_text_new() [*c]GtkCellRenderer;
pub extern fn gtk_cell_renderer_text_set_fixed_height_from_font(renderer: [*c]GtkCellRendererText, number_of_rows: c_int) void;
pub const GtkCellRendererText_autoptr = [*c]GtkCellRendererText;
pub const GtkCellRendererText_listautoptr = [*c]GList;
pub const GtkCellRendererText_slistautoptr = [*c]GSList;
pub const GtkCellRendererText_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererText(arg__ptr: [*c]GtkCellRendererText) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererText(arg__ptr: [*c][*c]GtkCellRendererText) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererText(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererText(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererText(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererText(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererAccel = opaque {};
pub const GtkCellRendererAccel = struct__GtkCellRendererAccel;
pub const GTK_CELL_RENDERER_ACCEL_MODE_GTK: c_int = 0;
pub const GTK_CELL_RENDERER_ACCEL_MODE_OTHER: c_int = 1;
pub const GtkCellRendererAccelMode = c_uint;
pub extern fn gtk_cell_renderer_accel_get_type() GType;
pub extern fn gtk_cell_renderer_accel_new() [*c]GtkCellRenderer;
pub const GtkCellRendererAccel_autoptr = ?*GtkCellRendererAccel;
pub const GtkCellRendererAccel_listautoptr = [*c]GList;
pub const GtkCellRendererAccel_slistautoptr = [*c]GSList;
pub const GtkCellRendererAccel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererAccel(arg__ptr: ?*GtkCellRendererAccel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererAccel(arg__ptr: [*c]?*GtkCellRendererAccel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererAccel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererAccel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererAccel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererAccel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererCombo = opaque {};
pub const GtkCellRendererCombo = struct__GtkCellRendererCombo;
pub extern fn gtk_cell_renderer_combo_get_type() GType;
pub extern fn gtk_cell_renderer_combo_new() [*c]GtkCellRenderer;
pub const GtkCellRendererCombo_autoptr = ?*GtkCellRendererCombo;
pub const GtkCellRendererCombo_listautoptr = [*c]GList;
pub const GtkCellRendererCombo_slistautoptr = [*c]GSList;
pub const GtkCellRendererCombo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererCombo(arg__ptr: ?*GtkCellRendererCombo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererCombo(arg__ptr: [*c]?*GtkCellRendererCombo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererCombo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererCombo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererCombo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererCombo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererPixbuf = opaque {};
pub const GtkCellRendererPixbuf = struct__GtkCellRendererPixbuf;
pub extern fn gtk_cell_renderer_pixbuf_get_type() GType;
pub extern fn gtk_cell_renderer_pixbuf_new() [*c]GtkCellRenderer;
pub const GtkCellRendererPixbuf_autoptr = ?*GtkCellRendererPixbuf;
pub const GtkCellRendererPixbuf_listautoptr = [*c]GList;
pub const GtkCellRendererPixbuf_slistautoptr = [*c]GSList;
pub const GtkCellRendererPixbuf_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererPixbuf(arg__ptr: ?*GtkCellRendererPixbuf) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererPixbuf(arg__ptr: [*c]?*GtkCellRendererPixbuf) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererPixbuf(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererPixbuf(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererPixbuf(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererPixbuf(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererProgress = opaque {};
pub const GtkCellRendererProgress = struct__GtkCellRendererProgress;
pub extern fn gtk_cell_renderer_progress_get_type() GType;
pub extern fn gtk_cell_renderer_progress_new() [*c]GtkCellRenderer;
pub const GtkCellRendererProgress_autoptr = ?*GtkCellRendererProgress;
pub const GtkCellRendererProgress_listautoptr = [*c]GList;
pub const GtkCellRendererProgress_slistautoptr = [*c]GSList;
pub const GtkCellRendererProgress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererProgress(arg__ptr: ?*GtkCellRendererProgress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererProgress(arg__ptr: [*c]?*GtkCellRendererProgress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererProgress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererProgress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererProgress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererProgress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererSpin = opaque {};
pub const GtkCellRendererSpin = struct__GtkCellRendererSpin;
pub extern fn gtk_cell_renderer_spin_get_type() GType;
pub extern fn gtk_cell_renderer_spin_new() [*c]GtkCellRenderer;
pub const GtkCellRendererSpin_autoptr = ?*GtkCellRendererSpin;
pub const GtkCellRendererSpin_listautoptr = [*c]GList;
pub const GtkCellRendererSpin_slistautoptr = [*c]GSList;
pub const GtkCellRendererSpin_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererSpin(arg__ptr: ?*GtkCellRendererSpin) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererSpin(arg__ptr: [*c]?*GtkCellRendererSpin) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererSpin(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererSpin(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererSpin(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererSpin(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererSpinner = opaque {};
pub const GtkCellRendererSpinner = struct__GtkCellRendererSpinner;
pub extern fn gtk_cell_renderer_spinner_get_type() GType;
pub extern fn gtk_cell_renderer_spinner_new() [*c]GtkCellRenderer;
pub const GtkCellRendererSpinner_autoptr = ?*GtkCellRendererSpinner;
pub const GtkCellRendererSpinner_listautoptr = [*c]GList;
pub const GtkCellRendererSpinner_slistautoptr = [*c]GSList;
pub const GtkCellRendererSpinner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererSpinner(arg__ptr: ?*GtkCellRendererSpinner) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererSpinner(arg__ptr: [*c]?*GtkCellRendererSpinner) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererSpinner(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererSpinner(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererSpinner(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererSpinner(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellRendererToggle = opaque {};
pub const GtkCellRendererToggle = struct__GtkCellRendererToggle;
pub extern fn gtk_cell_renderer_toggle_get_type() GType;
pub extern fn gtk_cell_renderer_toggle_new() [*c]GtkCellRenderer;
pub extern fn gtk_cell_renderer_toggle_get_radio(toggle: ?*GtkCellRendererToggle) gboolean;
pub extern fn gtk_cell_renderer_toggle_set_radio(toggle: ?*GtkCellRendererToggle, radio: gboolean) void;
pub extern fn gtk_cell_renderer_toggle_get_active(toggle: ?*GtkCellRendererToggle) gboolean;
pub extern fn gtk_cell_renderer_toggle_set_active(toggle: ?*GtkCellRendererToggle, setting: gboolean) void;
pub extern fn gtk_cell_renderer_toggle_get_activatable(toggle: ?*GtkCellRendererToggle) gboolean;
pub extern fn gtk_cell_renderer_toggle_set_activatable(toggle: ?*GtkCellRendererToggle, setting: gboolean) void;
pub const GtkCellRendererToggle_autoptr = ?*GtkCellRendererToggle;
pub const GtkCellRendererToggle_listautoptr = [*c]GList;
pub const GtkCellRendererToggle_slistautoptr = [*c]GSList;
pub const GtkCellRendererToggle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererToggle(arg__ptr: ?*GtkCellRendererToggle) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellRendererToggle(arg__ptr: [*c]?*GtkCellRendererToggle) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellRendererToggle(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererToggle(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererToggle(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererToggle(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCellView = opaque {};
pub const GtkCellView = struct__GtkCellView;
pub extern fn gtk_cell_view_get_type() GType;
pub extern fn gtk_cell_view_new() [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_context(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext) [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_text(text: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_markup(markup: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_texture(texture: ?*GdkTexture) [*c]GtkWidget;
pub extern fn gtk_cell_view_set_model(cell_view: ?*GtkCellView, model: ?*GtkTreeModel) void;
pub extern fn gtk_cell_view_get_model(cell_view: ?*GtkCellView) ?*GtkTreeModel;
pub extern fn gtk_cell_view_set_displayed_row(cell_view: ?*GtkCellView, path: ?*GtkTreePath) void;
pub extern fn gtk_cell_view_get_displayed_row(cell_view: ?*GtkCellView) ?*GtkTreePath;
pub extern fn gtk_cell_view_get_draw_sensitive(cell_view: ?*GtkCellView) gboolean;
pub extern fn gtk_cell_view_set_draw_sensitive(cell_view: ?*GtkCellView, draw_sensitive: gboolean) void;
pub extern fn gtk_cell_view_get_fit_model(cell_view: ?*GtkCellView) gboolean;
pub extern fn gtk_cell_view_set_fit_model(cell_view: ?*GtkCellView, fit_model: gboolean) void;
pub const GtkCellView_autoptr = ?*GtkCellView;
pub const GtkCellView_listautoptr = [*c]GList;
pub const GtkCellView_slistautoptr = [*c]GSList;
pub const GtkCellView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellView(arg__ptr: ?*GtkCellView) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCellView(arg__ptr: [*c]?*GtkCellView) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCellView(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCellView(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCellView(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCellView(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCenterBox = opaque {};
pub const GtkCenterBox = struct__GtkCenterBox;
pub const struct__GtkCenterBoxClass = opaque {};
pub const GtkCenterBoxClass = struct__GtkCenterBoxClass;
pub extern fn gtk_center_box_get_type() GType;
pub extern fn gtk_center_box_new() [*c]GtkWidget;
pub extern fn gtk_center_box_set_start_widget(self: ?*GtkCenterBox, child: [*c]GtkWidget) void;
pub extern fn gtk_center_box_set_center_widget(self: ?*GtkCenterBox, child: [*c]GtkWidget) void;
pub extern fn gtk_center_box_set_end_widget(self: ?*GtkCenterBox, child: [*c]GtkWidget) void;
pub extern fn gtk_center_box_get_start_widget(self: ?*GtkCenterBox) [*c]GtkWidget;
pub extern fn gtk_center_box_get_center_widget(self: ?*GtkCenterBox) [*c]GtkWidget;
pub extern fn gtk_center_box_get_end_widget(self: ?*GtkCenterBox) [*c]GtkWidget;
pub extern fn gtk_center_box_set_baseline_position(self: ?*GtkCenterBox, position: GtkBaselinePosition) void;
pub extern fn gtk_center_box_get_baseline_position(self: ?*GtkCenterBox) GtkBaselinePosition;
pub extern fn gtk_center_box_set_shrink_center_last(self: ?*GtkCenterBox, shrink_center_last: gboolean) void;
pub extern fn gtk_center_box_get_shrink_center_last(self: ?*GtkCenterBox) gboolean;
pub extern fn gtk_center_layout_get_type() GType;
pub const struct__GtkCenterLayout = opaque {};
pub const GtkCenterLayout = struct__GtkCenterLayout;
pub const GtkCenterLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkCenterLayout_autoptr = ?*GtkCenterLayout;
pub const GtkCenterLayout_listautoptr = [*c]GList;
pub const GtkCenterLayout_slistautoptr = [*c]GSList;
pub const GtkCenterLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCenterLayout(arg__ptr: ?*GtkCenterLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkCenterLayout(arg__ptr: [*c]?*GtkCenterLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCenterLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCenterLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCenterLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCenterLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkCenterLayoutClass_autoptr = [*c]GtkCenterLayoutClass;
pub const GtkCenterLayoutClass_listautoptr = [*c]GList;
pub const GtkCenterLayoutClass_slistautoptr = [*c]GSList;
pub const GtkCenterLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCenterLayoutClass(arg__ptr: [*c]GtkCenterLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCenterLayoutClass(arg__ptr: [*c][*c]GtkCenterLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCenterLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCenterLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCenterLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCenterLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CENTER_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkCenterLayout {
    var ptr = arg_ptr;
    return @as(?*GtkCenterLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_center_layout_get_type())))));
}
pub fn GTK_IS_CENTER_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_center_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_center_layout_new() [*c]GtkLayoutManager;
pub extern fn gtk_center_layout_set_orientation(self: ?*GtkCenterLayout, orientation: GtkOrientation) void;
pub extern fn gtk_center_layout_get_orientation(self: ?*GtkCenterLayout) GtkOrientation;
pub extern fn gtk_center_layout_set_baseline_position(self: ?*GtkCenterLayout, baseline_position: GtkBaselinePosition) void;
pub extern fn gtk_center_layout_get_baseline_position(self: ?*GtkCenterLayout) GtkBaselinePosition;
pub extern fn gtk_center_layout_set_start_widget(self: ?*GtkCenterLayout, widget: [*c]GtkWidget) void;
pub extern fn gtk_center_layout_get_start_widget(self: ?*GtkCenterLayout) [*c]GtkWidget;
pub extern fn gtk_center_layout_set_center_widget(self: ?*GtkCenterLayout, widget: [*c]GtkWidget) void;
pub extern fn gtk_center_layout_get_center_widget(self: ?*GtkCenterLayout) [*c]GtkWidget;
pub extern fn gtk_center_layout_set_end_widget(self: ?*GtkCenterLayout, widget: [*c]GtkWidget) void;
pub extern fn gtk_center_layout_get_end_widget(self: ?*GtkCenterLayout) [*c]GtkWidget;
pub extern fn gtk_center_layout_set_shrink_center_last(self: ?*GtkCenterLayout, shrink_center_last: gboolean) void;
pub extern fn gtk_center_layout_get_shrink_center_last(self: ?*GtkCenterLayout) gboolean;
pub const struct__GtkToggleButton = extern struct {
    button: GtkButton,
};
pub const GtkToggleButton = struct__GtkToggleButton;
pub const struct__GtkToggleButtonClass = extern struct {
    parent_class: GtkButtonClass,
    toggled: ?*const fn ([*c]GtkToggleButton) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkToggleButtonClass = struct__GtkToggleButtonClass;
pub extern fn gtk_toggle_button_get_type() GType;
pub extern fn gtk_toggle_button_new() [*c]GtkWidget;
pub extern fn gtk_toggle_button_new_with_label(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_toggle_button_new_with_mnemonic(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_toggle_button_set_active(toggle_button: [*c]GtkToggleButton, is_active: gboolean) void;
pub extern fn gtk_toggle_button_get_active(toggle_button: [*c]GtkToggleButton) gboolean;
pub extern fn gtk_toggle_button_toggled(toggle_button: [*c]GtkToggleButton) void;
pub extern fn gtk_toggle_button_set_group(toggle_button: [*c]GtkToggleButton, group: [*c]GtkToggleButton) void;
pub const GtkToggleButton_autoptr = [*c]GtkToggleButton;
pub const GtkToggleButton_listautoptr = [*c]GList;
pub const GtkToggleButton_slistautoptr = [*c]GSList;
pub const GtkToggleButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToggleButton(arg__ptr: [*c]GtkToggleButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkToggleButton(arg__ptr: [*c][*c]GtkToggleButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkToggleButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkToggleButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkToggleButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkToggleButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkCheckButton = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkCheckButton = struct__GtkCheckButton;
pub const struct__GtkCheckButtonClass = extern struct {
    parent_class: GtkWidgetClass,
    toggled: ?*const fn ([*c]GtkCheckButton) callconv(.C) void,
    activate: ?*const fn ([*c]GtkCheckButton) callconv(.C) void,
    padding: [7]gpointer,
};
pub const GtkCheckButtonClass = struct__GtkCheckButtonClass;
pub extern fn gtk_check_button_get_type() GType;
pub extern fn gtk_check_button_new() [*c]GtkWidget;
pub extern fn gtk_check_button_new_with_label(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_check_button_new_with_mnemonic(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_check_button_set_inconsistent(check_button: [*c]GtkCheckButton, inconsistent: gboolean) void;
pub extern fn gtk_check_button_get_inconsistent(check_button: [*c]GtkCheckButton) gboolean;
pub extern fn gtk_check_button_get_active(self: [*c]GtkCheckButton) gboolean;
pub extern fn gtk_check_button_set_active(self: [*c]GtkCheckButton, setting: gboolean) void;
pub extern fn gtk_check_button_get_label(self: [*c]GtkCheckButton) [*c]const u8;
pub extern fn gtk_check_button_set_label(self: [*c]GtkCheckButton, label: [*c]const u8) void;
pub extern fn gtk_check_button_set_group(self: [*c]GtkCheckButton, group: [*c]GtkCheckButton) void;
pub extern fn gtk_check_button_get_use_underline(self: [*c]GtkCheckButton) gboolean;
pub extern fn gtk_check_button_set_use_underline(self: [*c]GtkCheckButton, setting: gboolean) void;
pub extern fn gtk_check_button_get_child(button: [*c]GtkCheckButton) [*c]GtkWidget;
pub extern fn gtk_check_button_set_child(button: [*c]GtkCheckButton, child: [*c]GtkWidget) void;
pub const GtkCheckButton_autoptr = [*c]GtkCheckButton;
pub const GtkCheckButton_listautoptr = [*c]GList;
pub const GtkCheckButton_slistautoptr = [*c]GSList;
pub const GtkCheckButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCheckButton(arg__ptr: [*c]GtkCheckButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCheckButton(arg__ptr: [*c][*c]GtkCheckButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCheckButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCheckButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCheckButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCheckButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkColorButton = opaque {};
pub const GtkColorButton = struct__GtkColorButton;
pub extern fn gtk_color_button_get_type() GType;
pub extern fn gtk_color_button_new() [*c]GtkWidget;
pub extern fn gtk_color_button_new_with_rgba(rgba: [*c]const GdkRGBA) [*c]GtkWidget;
pub extern fn gtk_color_button_set_title(button: ?*GtkColorButton, title: [*c]const u8) void;
pub extern fn gtk_color_button_get_title(button: ?*GtkColorButton) [*c]const u8;
pub extern fn gtk_color_button_get_modal(button: ?*GtkColorButton) gboolean;
pub extern fn gtk_color_button_set_modal(button: ?*GtkColorButton, modal: gboolean) void;
pub const GtkColorButton_autoptr = ?*GtkColorButton;
pub const GtkColorButton_listautoptr = [*c]GList;
pub const GtkColorButton_slistautoptr = [*c]GSList;
pub const GtkColorButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorButton(arg__ptr: ?*GtkColorButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColorButton(arg__ptr: [*c]?*GtkColorButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkColorChooser = opaque {};
pub const GtkColorChooser = struct__GtkColorChooser;
pub const struct__GtkColorChooserInterface = extern struct {
    base_interface: GTypeInterface,
    get_rgba: ?*const fn (?*GtkColorChooser, [*c]GdkRGBA) callconv(.C) void,
    set_rgba: ?*const fn (?*GtkColorChooser, [*c]const GdkRGBA) callconv(.C) void,
    add_palette: ?*const fn (?*GtkColorChooser, GtkOrientation, c_int, c_int, [*c]GdkRGBA) callconv(.C) void,
    color_activated: ?*const fn (?*GtkColorChooser, [*c]const GdkRGBA) callconv(.C) void,
    padding: [12]gpointer,
};
pub const GtkColorChooserInterface = struct__GtkColorChooserInterface;
pub extern fn gtk_color_chooser_get_type() GType;
pub extern fn gtk_color_chooser_get_rgba(chooser: ?*GtkColorChooser, color: [*c]GdkRGBA) void;
pub extern fn gtk_color_chooser_set_rgba(chooser: ?*GtkColorChooser, color: [*c]const GdkRGBA) void;
pub extern fn gtk_color_chooser_get_use_alpha(chooser: ?*GtkColorChooser) gboolean;
pub extern fn gtk_color_chooser_set_use_alpha(chooser: ?*GtkColorChooser, use_alpha: gboolean) void;
pub extern fn gtk_color_chooser_add_palette(chooser: ?*GtkColorChooser, orientation: GtkOrientation, colors_per_line: c_int, n_colors: c_int, colors: [*c]GdkRGBA) void;
pub const GtkColorChooser_autoptr = ?*GtkColorChooser;
pub const GtkColorChooser_listautoptr = [*c]GList;
pub const GtkColorChooser_slistautoptr = [*c]GSList;
pub const GtkColorChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorChooser(arg__ptr: ?*GtkColorChooser) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColorChooser(arg__ptr: [*c]?*GtkColorChooser) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorChooser(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorChooser(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorChooser(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorChooser(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkColorChooserDialog = opaque {};
pub const GtkColorChooserDialog = struct__GtkColorChooserDialog;
pub extern fn gtk_color_chooser_dialog_get_type() GType;
pub extern fn gtk_color_chooser_dialog_new(title: [*c]const u8, parent: [*c]GtkWindow) [*c]GtkWidget;
pub const GtkColorChooserDialog_autoptr = ?*GtkColorChooserDialog;
pub const GtkColorChooserDialog_listautoptr = [*c]GList;
pub const GtkColorChooserDialog_slistautoptr = [*c]GSList;
pub const GtkColorChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorChooserDialog(arg__ptr: ?*GtkColorChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColorChooserDialog(arg__ptr: [*c]?*GtkColorChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorChooserDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorChooserDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorChooserDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorChooserDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkColorChooserWidget = opaque {};
pub const GtkColorChooserWidget = struct__GtkColorChooserWidget;
pub extern fn gtk_color_chooser_widget_get_type() GType;
pub extern fn gtk_color_chooser_widget_new() [*c]GtkWidget;
pub const GtkColorChooserWidget_autoptr = ?*GtkColorChooserWidget;
pub const GtkColorChooserWidget_listautoptr = [*c]GList;
pub const GtkColorChooserWidget_slistautoptr = [*c]GSList;
pub const GtkColorChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorChooserWidget(arg__ptr: ?*GtkColorChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColorChooserWidget(arg__ptr: [*c]?*GtkColorChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorChooserWidget(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorChooserWidget(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorChooserWidget(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorChooserWidget(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_color_dialog_get_type() GType;
pub const struct__GtkColorDialog = opaque {};
pub const GtkColorDialog = struct__GtkColorDialog;
pub const GtkColorDialogClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkColorDialog_autoptr = ?*GtkColorDialog;
pub const GtkColorDialog_listautoptr = [*c]GList;
pub const GtkColorDialog_slistautoptr = [*c]GSList;
pub const GtkColorDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorDialog(arg__ptr: ?*GtkColorDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkColorDialog(arg__ptr: [*c]?*GtkColorDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkColorDialogClass_autoptr = [*c]GtkColorDialogClass;
pub const GtkColorDialogClass_listautoptr = [*c]GList;
pub const GtkColorDialogClass_slistautoptr = [*c]GSList;
pub const GtkColorDialogClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorDialogClass(arg__ptr: [*c]GtkColorDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColorDialogClass(arg__ptr: [*c][*c]GtkColorDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorDialogClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorDialogClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorDialogClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorDialogClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_COLOR_DIALOG(arg_ptr: gpointer) callconv(.C) ?*GtkColorDialog {
    var ptr = arg_ptr;
    return @as(?*GtkColorDialog, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_color_dialog_get_type())))));
}
pub fn GTK_IS_COLOR_DIALOG(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_color_dialog_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_color_dialog_new() ?*GtkColorDialog;
pub extern fn gtk_color_dialog_get_title(self: ?*GtkColorDialog) [*c]const u8;
pub extern fn gtk_color_dialog_set_title(self: ?*GtkColorDialog, title: [*c]const u8) void;
pub extern fn gtk_color_dialog_get_modal(self: ?*GtkColorDialog) gboolean;
pub extern fn gtk_color_dialog_set_modal(self: ?*GtkColorDialog, modal: gboolean) void;
pub extern fn gtk_color_dialog_get_with_alpha(self: ?*GtkColorDialog) gboolean;
pub extern fn gtk_color_dialog_set_with_alpha(self: ?*GtkColorDialog, with_alpha: gboolean) void;
pub extern fn gtk_color_dialog_choose_rgba(self: ?*GtkColorDialog, parent: [*c]GtkWindow, initial_color: [*c]const GdkRGBA, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_color_dialog_choose_rgba_finish(self: ?*GtkColorDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]GdkRGBA;
pub extern fn gtk_color_dialog_button_get_type() GType;
pub const struct__GtkColorDialogButton = opaque {};
pub const GtkColorDialogButton = struct__GtkColorDialogButton;
pub const GtkColorDialogButtonClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkColorDialogButton_autoptr = ?*GtkColorDialogButton;
pub const GtkColorDialogButton_listautoptr = [*c]GList;
pub const GtkColorDialogButton_slistautoptr = [*c]GSList;
pub const GtkColorDialogButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorDialogButton(arg__ptr: ?*GtkColorDialogButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkColorDialogButton(arg__ptr: [*c]?*GtkColorDialogButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorDialogButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorDialogButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorDialogButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorDialogButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkColorDialogButtonClass_autoptr = [*c]GtkColorDialogButtonClass;
pub const GtkColorDialogButtonClass_listautoptr = [*c]GList;
pub const GtkColorDialogButtonClass_slistautoptr = [*c]GSList;
pub const GtkColorDialogButtonClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorDialogButtonClass(arg__ptr: [*c]GtkColorDialogButtonClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColorDialogButtonClass(arg__ptr: [*c][*c]GtkColorDialogButtonClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColorDialogButtonClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColorDialogButtonClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColorDialogButtonClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColorDialogButtonClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_COLOR_DIALOG_BUTTON(arg_ptr: gpointer) callconv(.C) ?*GtkColorDialogButton {
    var ptr = arg_ptr;
    return @as(?*GtkColorDialogButton, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_color_dialog_button_get_type())))));
}
pub fn GTK_IS_COLOR_DIALOG_BUTTON(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_color_dialog_button_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_color_dialog_button_new(dialog: ?*GtkColorDialog) [*c]GtkWidget;
pub extern fn gtk_color_dialog_button_get_dialog(self: ?*GtkColorDialogButton) ?*GtkColorDialog;
pub extern fn gtk_color_dialog_button_set_dialog(self: ?*GtkColorDialogButton, dialog: ?*GtkColorDialog) void;
pub extern fn gtk_color_dialog_button_get_rgba(self: ?*GtkColorDialogButton) [*c]const GdkRGBA;
pub extern fn gtk_color_dialog_button_set_rgba(self: ?*GtkColorDialogButton, color: [*c]const GdkRGBA) void;
pub extern fn gtk_hsv_to_rgb(h: f32, s: f32, v: f32, r: [*c]f32, g: [*c]f32, b: [*c]f32) void;
pub extern fn gtk_rgb_to_hsv(r: f32, g: f32, b: f32, h: [*c]f32, s: [*c]f32, v: [*c]f32) void;
pub const GTK_SORTER_ORDER_PARTIAL: c_int = 0;
pub const GTK_SORTER_ORDER_NONE: c_int = 1;
pub const GTK_SORTER_ORDER_TOTAL: c_int = 2;
pub const GtkSorterOrder = c_uint;
pub const GTK_SORTER_CHANGE_DIFFERENT: c_int = 0;
pub const GTK_SORTER_CHANGE_INVERTED: c_int = 1;
pub const GTK_SORTER_CHANGE_LESS_STRICT: c_int = 2;
pub const GTK_SORTER_CHANGE_MORE_STRICT: c_int = 3;
pub const GtkSorterChange = c_uint;
pub extern fn gtk_sorter_get_type() GType;
pub const struct__GtkSorter = extern struct {
    parent_instance: GObject,
};
pub const GtkSorter = struct__GtkSorter;
pub const struct__GtkSorterClass = extern struct {
    parent_class: GObjectClass,
    compare: ?*const fn ([*c]GtkSorter, gpointer, gpointer) callconv(.C) GtkOrdering,
    get_order: ?*const fn ([*c]GtkSorter) callconv(.C) GtkSorterOrder,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
    _gtk_reserved5: ?*const fn () callconv(.C) void,
    _gtk_reserved6: ?*const fn () callconv(.C) void,
    _gtk_reserved7: ?*const fn () callconv(.C) void,
    _gtk_reserved8: ?*const fn () callconv(.C) void,
};
pub const GtkSorterClass = struct__GtkSorterClass;
pub const GtkSorter_autoptr = [*c]GtkSorter;
pub const GtkSorter_listautoptr = [*c]GList;
pub const GtkSorter_slistautoptr = [*c]GSList;
pub const GtkSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSorter(arg__ptr: [*c]GtkSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkSorter(arg__ptr: [*c][*c]GtkSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkSorterClass_autoptr = [*c]GtkSorterClass;
pub const GtkSorterClass_listautoptr = [*c]GList;
pub const GtkSorterClass_slistautoptr = [*c]GSList;
pub const GtkSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSorterClass(arg__ptr: [*c]GtkSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSorterClass(arg__ptr: [*c][*c]GtkSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SORTER(arg_ptr: gpointer) callconv(.C) [*c]GtkSorter {
    var ptr = arg_ptr;
    return @as([*c]GtkSorter, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_sorter_get_type()))))));
}
pub fn GTK_SORTER_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkSorterClass {
    var ptr = arg_ptr;
    return @as([*c]GtkSorterClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_sorter_get_type()))))));
}
pub fn GTK_IS_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_SORTER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SORTER_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkSorterClass {
    var ptr = arg_ptr;
    return @as([*c]GtkSorterClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_sorter_compare(self: [*c]GtkSorter, item1: gpointer, item2: gpointer) GtkOrdering;
pub extern fn gtk_sorter_get_order(self: [*c]GtkSorter) GtkSorterOrder;
pub extern fn gtk_sorter_changed(self: [*c]GtkSorter, change: GtkSorterChange) void;
pub extern fn gtk_sort_list_model_get_type() GType;
pub const struct__GtkSortListModel = opaque {};
pub const GtkSortListModel = struct__GtkSortListModel;
pub const GtkSortListModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkSortListModel_autoptr = ?*GtkSortListModel;
pub const GtkSortListModel_listautoptr = [*c]GList;
pub const GtkSortListModel_slistautoptr = [*c]GSList;
pub const GtkSortListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSortListModel(arg__ptr: ?*GtkSortListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkSortListModel(arg__ptr: [*c]?*GtkSortListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSortListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSortListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSortListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSortListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkSortListModelClass_autoptr = [*c]GtkSortListModelClass;
pub const GtkSortListModelClass_listautoptr = [*c]GList;
pub const GtkSortListModelClass_slistautoptr = [*c]GSList;
pub const GtkSortListModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSortListModelClass(arg__ptr: [*c]GtkSortListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSortListModelClass(arg__ptr: [*c][*c]GtkSortListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSortListModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSortListModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSortListModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSortListModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SORT_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkSortListModel {
    var ptr = arg_ptr;
    return @as(?*GtkSortListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_sort_list_model_get_type())))));
}
pub fn GTK_IS_SORT_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_sort_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_sort_list_model_new(model: ?*GListModel, sorter: [*c]GtkSorter) ?*GtkSortListModel;
pub extern fn gtk_sort_list_model_set_sorter(self: ?*GtkSortListModel, sorter: [*c]GtkSorter) void;
pub extern fn gtk_sort_list_model_get_sorter(self: ?*GtkSortListModel) [*c]GtkSorter;
pub extern fn gtk_sort_list_model_set_section_sorter(self: ?*GtkSortListModel, sorter: [*c]GtkSorter) void;
pub extern fn gtk_sort_list_model_get_section_sorter(self: ?*GtkSortListModel) [*c]GtkSorter;
pub extern fn gtk_sort_list_model_set_model(self: ?*GtkSortListModel, model: ?*GListModel) void;
pub extern fn gtk_sort_list_model_get_model(self: ?*GtkSortListModel) ?*GListModel;
pub extern fn gtk_sort_list_model_set_incremental(self: ?*GtkSortListModel, incremental: gboolean) void;
pub extern fn gtk_sort_list_model_get_incremental(self: ?*GtkSortListModel) gboolean;
pub extern fn gtk_sort_list_model_get_pending(self: ?*GtkSortListModel) guint;
pub extern fn gtk_selection_model_get_type() GType;
pub const struct__GtkSelectionModel = opaque {};
pub const GtkSelectionModel = struct__GtkSelectionModel;
pub const struct__GtkSelectionModelInterface = extern struct {
    g_iface: GTypeInterface,
    is_selected: ?*const fn (?*GtkSelectionModel, guint) callconv(.C) gboolean,
    get_selection_in_range: ?*const fn (?*GtkSelectionModel, guint, guint) callconv(.C) ?*GtkBitset,
    select_item: ?*const fn (?*GtkSelectionModel, guint, gboolean) callconv(.C) gboolean,
    unselect_item: ?*const fn (?*GtkSelectionModel, guint) callconv(.C) gboolean,
    select_range: ?*const fn (?*GtkSelectionModel, guint, guint, gboolean) callconv(.C) gboolean,
    unselect_range: ?*const fn (?*GtkSelectionModel, guint, guint) callconv(.C) gboolean,
    select_all: ?*const fn (?*GtkSelectionModel) callconv(.C) gboolean,
    unselect_all: ?*const fn (?*GtkSelectionModel) callconv(.C) gboolean,
    set_selection: ?*const fn (?*GtkSelectionModel, ?*GtkBitset, ?*GtkBitset) callconv(.C) gboolean,
};
pub const GtkSelectionModelInterface = struct__GtkSelectionModelInterface;
pub const GtkSelectionModel_autoptr = ?*GtkSelectionModel;
pub const GtkSelectionModel_listautoptr = [*c]GList;
pub const GtkSelectionModel_slistautoptr = [*c]GSList;
pub const GtkSelectionModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSelectionModel(arg__ptr: ?*GtkSelectionModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GListModel(@as(?*GListModel, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSelectionModel(arg__ptr: [*c]?*GtkSelectionModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSelectionModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSelectionModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GListModel)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSelectionModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GListModel)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSelectionModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GListModel)))))));
    }
}
pub fn GTK_SELECTION_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkSelectionModel {
    var ptr = arg_ptr;
    return @as(?*GtkSelectionModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_selection_model_get_type())))));
}
pub fn GTK_IS_SELECTION_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_selection_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SELECTION_MODEL_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkSelectionModelInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkSelectionModelInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_selection_model_get_type()))));
}
pub extern fn gtk_selection_model_is_selected(model: ?*GtkSelectionModel, position: guint) gboolean;
pub extern fn gtk_selection_model_get_selection(model: ?*GtkSelectionModel) ?*GtkBitset;
pub extern fn gtk_selection_model_get_selection_in_range(model: ?*GtkSelectionModel, position: guint, n_items: guint) ?*GtkBitset;
pub extern fn gtk_selection_model_select_item(model: ?*GtkSelectionModel, position: guint, unselect_rest: gboolean) gboolean;
pub extern fn gtk_selection_model_unselect_item(model: ?*GtkSelectionModel, position: guint) gboolean;
pub extern fn gtk_selection_model_select_range(model: ?*GtkSelectionModel, position: guint, n_items: guint, unselect_rest: gboolean) gboolean;
pub extern fn gtk_selection_model_unselect_range(model: ?*GtkSelectionModel, position: guint, n_items: guint) gboolean;
pub extern fn gtk_selection_model_select_all(model: ?*GtkSelectionModel) gboolean;
pub extern fn gtk_selection_model_unselect_all(model: ?*GtkSelectionModel) gboolean;
pub extern fn gtk_selection_model_set_selection(model: ?*GtkSelectionModel, selected: ?*GtkBitset, mask: ?*GtkBitset) gboolean;
pub extern fn gtk_selection_model_selection_changed(model: ?*GtkSelectionModel, position: guint, n_items: guint) void;
pub const struct__GtkColumnView = opaque {};
pub const GtkColumnView = struct__GtkColumnView;
pub const struct__GtkColumnViewClass = opaque {};
pub const GtkColumnViewClass = struct__GtkColumnViewClass;
pub const struct__GtkColumnViewColumn = opaque {};
pub const GtkColumnViewColumn = struct__GtkColumnViewColumn;
pub extern fn gtk_column_view_get_type() GType;
pub extern fn gtk_column_view_new(model: ?*GtkSelectionModel) [*c]GtkWidget;
pub extern fn gtk_column_view_get_columns(self: ?*GtkColumnView) ?*GListModel;
pub extern fn gtk_column_view_append_column(self: ?*GtkColumnView, column: ?*GtkColumnViewColumn) void;
pub extern fn gtk_column_view_remove_column(self: ?*GtkColumnView, column: ?*GtkColumnViewColumn) void;
pub extern fn gtk_column_view_insert_column(self: ?*GtkColumnView, position: guint, column: ?*GtkColumnViewColumn) void;
pub extern fn gtk_column_view_get_model(self: ?*GtkColumnView) ?*GtkSelectionModel;
pub extern fn gtk_column_view_set_model(self: ?*GtkColumnView, model: ?*GtkSelectionModel) void;
pub extern fn gtk_column_view_get_show_row_separators(self: ?*GtkColumnView) gboolean;
pub extern fn gtk_column_view_set_show_row_separators(self: ?*GtkColumnView, show_row_separators: gboolean) void;
pub extern fn gtk_column_view_get_show_column_separators(self: ?*GtkColumnView) gboolean;
pub extern fn gtk_column_view_set_show_column_separators(self: ?*GtkColumnView, show_column_separators: gboolean) void;
pub extern fn gtk_column_view_get_sorter(self: ?*GtkColumnView) [*c]GtkSorter;
pub extern fn gtk_column_view_sort_by_column(self: ?*GtkColumnView, column: ?*GtkColumnViewColumn, direction: GtkSortType) void;
pub extern fn gtk_column_view_set_single_click_activate(self: ?*GtkColumnView, single_click_activate: gboolean) void;
pub extern fn gtk_column_view_get_single_click_activate(self: ?*GtkColumnView) gboolean;
pub extern fn gtk_column_view_set_reorderable(self: ?*GtkColumnView, reorderable: gboolean) void;
pub extern fn gtk_column_view_get_reorderable(self: ?*GtkColumnView) gboolean;
pub extern fn gtk_column_view_set_enable_rubberband(self: ?*GtkColumnView, enable_rubberband: gboolean) void;
pub extern fn gtk_column_view_get_enable_rubberband(self: ?*GtkColumnView) gboolean;
pub extern fn gtk_column_view_set_tab_behavior(self: ?*GtkColumnView, tab_behavior: GtkListTabBehavior) void;
pub extern fn gtk_column_view_get_tab_behavior(self: ?*GtkColumnView) GtkListTabBehavior;
pub extern fn gtk_column_view_set_row_factory(self: ?*GtkColumnView, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_column_view_get_row_factory(self: ?*GtkColumnView) ?*GtkListItemFactory;
pub extern fn gtk_column_view_set_header_factory(self: ?*GtkColumnView, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_column_view_get_header_factory(self: ?*GtkColumnView) ?*GtkListItemFactory;
pub extern fn gtk_column_view_scroll_to(self: ?*GtkColumnView, pos: guint, column: ?*GtkColumnViewColumn, flags: GtkListScrollFlags, scroll: ?*GtkScrollInfo) void;
pub extern fn gtk_list_item_get_type() GType;
pub const struct__GtkListItemClass = opaque {};
pub const GtkListItemClass = struct__GtkListItemClass;
pub const GtkListItem_autoptr = ?*GtkListItem;
pub const GtkListItem_listautoptr = [*c]GList;
pub const GtkListItem_slistautoptr = [*c]GSList;
pub const GtkListItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListItem(arg__ptr: ?*GtkListItem) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkListItem(arg__ptr: [*c]?*GtkListItem) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListItem(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListItem(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListItem(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListItem(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkListItemClass_autoptr = ?*GtkListItemClass;
pub const GtkListItemClass_listautoptr = [*c]GList;
pub const GtkListItemClass_slistautoptr = [*c]GSList;
pub const GtkListItemClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListItemClass(arg__ptr: ?*GtkListItemClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListItemClass(arg__ptr: [*c]?*GtkListItemClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListItemClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListItemClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListItemClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListItemClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_LIST_ITEM(arg_ptr: gpointer) callconv(.C) ?*GtkListItem {
    var ptr = arg_ptr;
    return @as(?*GtkListItem, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_list_item_get_type())))));
}
pub fn GTK_LIST_ITEM_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkListItemClass {
    var ptr = arg_ptr;
    return @as(?*GtkListItemClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_list_item_get_type())))));
}
pub fn GTK_IS_LIST_ITEM(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_list_item_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_LIST_ITEM_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_list_item_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_LIST_ITEM_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkListItemClass {
    var ptr = arg_ptr;
    return @as(?*GtkListItemClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_list_item_get_item(self: ?*GtkListItem) gpointer;
pub extern fn gtk_list_item_get_position(self: ?*GtkListItem) guint;
pub extern fn gtk_list_item_get_selected(self: ?*GtkListItem) gboolean;
pub extern fn gtk_list_item_get_selectable(self: ?*GtkListItem) gboolean;
pub extern fn gtk_list_item_set_selectable(self: ?*GtkListItem, selectable: gboolean) void;
pub extern fn gtk_list_item_get_activatable(self: ?*GtkListItem) gboolean;
pub extern fn gtk_list_item_set_activatable(self: ?*GtkListItem, activatable: gboolean) void;
pub extern fn gtk_list_item_get_focusable(self: ?*GtkListItem) gboolean;
pub extern fn gtk_list_item_set_focusable(self: ?*GtkListItem, focusable: gboolean) void;
pub extern fn gtk_list_item_set_child(self: ?*GtkListItem, child: [*c]GtkWidget) void;
pub extern fn gtk_list_item_get_child(self: ?*GtkListItem) [*c]GtkWidget;
pub extern fn gtk_list_item_set_accessible_description(self: ?*GtkListItem, description: [*c]const u8) void;
pub extern fn gtk_list_item_get_accessible_description(self: ?*GtkListItem) [*c]const u8;
pub extern fn gtk_list_item_set_accessible_label(self: ?*GtkListItem, label: [*c]const u8) void;
pub extern fn gtk_list_item_get_accessible_label(self: ?*GtkListItem) [*c]const u8;
pub extern fn gtk_column_view_cell_get_type() GType;
pub const struct__GtkColumnViewCell = opaque {};
pub const GtkColumnViewCell = struct__GtkColumnViewCell;
pub const struct__GtkColumnViewCellClass = opaque {};
pub const GtkColumnViewCellClass = struct__GtkColumnViewCellClass;
pub const GtkColumnViewCell_autoptr = ?*GtkColumnViewCell;
pub const GtkColumnViewCell_listautoptr = [*c]GList;
pub const GtkColumnViewCell_slistautoptr = [*c]GSList;
pub const GtkColumnViewCell_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewCell(arg__ptr: ?*GtkColumnViewCell) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkListItem(@as(?*GtkListItem, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewCell(arg__ptr: [*c]?*GtkColumnViewCell) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewCell(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewCell(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkListItem)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewCell(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkListItem)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewCell(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkListItem)))))));
    }
}
pub const GtkColumnViewCellClass_autoptr = ?*GtkColumnViewCellClass;
pub const GtkColumnViewCellClass_listautoptr = [*c]GList;
pub const GtkColumnViewCellClass_slistautoptr = [*c]GSList;
pub const GtkColumnViewCellClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewCellClass(arg__ptr: ?*GtkColumnViewCellClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewCellClass(arg__ptr: [*c]?*GtkColumnViewCellClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewCellClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewCellClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewCellClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewCellClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_COLUMN_VIEW_CELL(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewCell {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewCell, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_column_view_cell_get_type())))));
}
pub fn GTK_COLUMN_VIEW_CELL_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewCellClass {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewCellClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_column_view_cell_get_type())))));
}
pub fn GTK_IS_COLUMN_VIEW_CELL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_column_view_cell_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_COLUMN_VIEW_CELL_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_column_view_cell_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_COLUMN_VIEW_CELL_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewCellClass {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewCellClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_column_view_cell_get_item(self: ?*GtkColumnViewCell) gpointer;
pub extern fn gtk_column_view_cell_get_position(self: ?*GtkColumnViewCell) guint;
pub extern fn gtk_column_view_cell_get_selected(self: ?*GtkColumnViewCell) gboolean;
pub extern fn gtk_column_view_cell_get_focusable(self: ?*GtkColumnViewCell) gboolean;
pub extern fn gtk_column_view_cell_set_focusable(self: ?*GtkColumnViewCell, focusable: gboolean) void;
pub extern fn gtk_column_view_cell_set_child(self: ?*GtkColumnViewCell, child: [*c]GtkWidget) void;
pub extern fn gtk_column_view_cell_get_child(self: ?*GtkColumnViewCell) [*c]GtkWidget;
pub const GtkColumnViewColumn_autoptr = ?*GtkColumnViewColumn;
pub const GtkColumnViewColumn_listautoptr = [*c]GList;
pub const GtkColumnViewColumn_slistautoptr = [*c]GSList;
pub const GtkColumnViewColumn_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewColumn(arg__ptr: ?*GtkColumnViewColumn) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewColumn(arg__ptr: [*c]?*GtkColumnViewColumn) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewColumn(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewColumn(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewColumn(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewColumn(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkColumnViewColumnClass = opaque {};
pub const GtkColumnViewColumnClass = struct__GtkColumnViewColumnClass;
pub extern fn gtk_column_view_column_get_type() GType;
pub extern fn gtk_column_view_column_new(title: [*c]const u8, factory: ?*GtkListItemFactory) ?*GtkColumnViewColumn;
pub extern fn gtk_column_view_column_get_column_view(self: ?*GtkColumnViewColumn) ?*GtkColumnView;
pub extern fn gtk_column_view_column_set_factory(self: ?*GtkColumnViewColumn, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_column_view_column_get_factory(self: ?*GtkColumnViewColumn) ?*GtkListItemFactory;
pub extern fn gtk_column_view_column_set_title(self: ?*GtkColumnViewColumn, title: [*c]const u8) void;
pub extern fn gtk_column_view_column_get_title(self: ?*GtkColumnViewColumn) [*c]const u8;
pub extern fn gtk_column_view_column_set_sorter(self: ?*GtkColumnViewColumn, sorter: [*c]GtkSorter) void;
pub extern fn gtk_column_view_column_get_sorter(self: ?*GtkColumnViewColumn) [*c]GtkSorter;
pub extern fn gtk_column_view_column_set_visible(self: ?*GtkColumnViewColumn, visible: gboolean) void;
pub extern fn gtk_column_view_column_get_visible(self: ?*GtkColumnViewColumn) gboolean;
pub extern fn gtk_column_view_column_set_header_menu(self: ?*GtkColumnViewColumn, menu: [*c]GMenuModel) void;
pub extern fn gtk_column_view_column_get_header_menu(self: ?*GtkColumnViewColumn) [*c]GMenuModel;
pub extern fn gtk_column_view_column_set_fixed_width(self: ?*GtkColumnViewColumn, fixed_width: c_int) void;
pub extern fn gtk_column_view_column_get_fixed_width(self: ?*GtkColumnViewColumn) c_int;
pub extern fn gtk_column_view_column_set_resizable(self: ?*GtkColumnViewColumn, resizable: gboolean) void;
pub extern fn gtk_column_view_column_get_resizable(self: ?*GtkColumnViewColumn) gboolean;
pub extern fn gtk_column_view_column_set_expand(self: ?*GtkColumnViewColumn, expand: gboolean) void;
pub extern fn gtk_column_view_column_get_expand(self: ?*GtkColumnViewColumn) gboolean;
pub extern fn gtk_column_view_column_set_id(self: ?*GtkColumnViewColumn, id: [*c]const u8) void;
pub extern fn gtk_column_view_column_get_id(self: ?*GtkColumnViewColumn) [*c]const u8;
pub extern fn gtk_column_view_row_get_type() GType;
pub const struct__GtkColumnViewRow = opaque {};
pub const GtkColumnViewRow = struct__GtkColumnViewRow;
pub const struct__GtkColumnViewRowClass = opaque {};
pub const GtkColumnViewRowClass = struct__GtkColumnViewRowClass;
pub const GtkColumnViewRow_autoptr = ?*GtkColumnViewRow;
pub const GtkColumnViewRow_listautoptr = [*c]GList;
pub const GtkColumnViewRow_slistautoptr = [*c]GSList;
pub const GtkColumnViewRow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewRow(arg__ptr: ?*GtkColumnViewRow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewRow(arg__ptr: [*c]?*GtkColumnViewRow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewRow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewRow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewRow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewRow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkColumnViewRowClass_autoptr = ?*GtkColumnViewRowClass;
pub const GtkColumnViewRowClass_listautoptr = [*c]GList;
pub const GtkColumnViewRowClass_slistautoptr = [*c]GSList;
pub const GtkColumnViewRowClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewRowClass(arg__ptr: ?*GtkColumnViewRowClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewRowClass(arg__ptr: [*c]?*GtkColumnViewRowClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewRowClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewRowClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewRowClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewRowClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_COLUMN_VIEW_ROW(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewRow {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewRow, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_column_view_row_get_type())))));
}
pub fn GTK_COLUMN_VIEW_ROW_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewRowClass {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewRowClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_column_view_row_get_type())))));
}
pub fn GTK_IS_COLUMN_VIEW_ROW(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_column_view_row_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_COLUMN_VIEW_ROW_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_column_view_row_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_COLUMN_VIEW_ROW_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewRowClass {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewRowClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_column_view_row_get_item(self: ?*GtkColumnViewRow) gpointer;
pub extern fn gtk_column_view_row_get_position(self: ?*GtkColumnViewRow) guint;
pub extern fn gtk_column_view_row_get_selected(self: ?*GtkColumnViewRow) gboolean;
pub extern fn gtk_column_view_row_get_selectable(self: ?*GtkColumnViewRow) gboolean;
pub extern fn gtk_column_view_row_set_selectable(self: ?*GtkColumnViewRow, selectable: gboolean) void;
pub extern fn gtk_column_view_row_get_activatable(self: ?*GtkColumnViewRow) gboolean;
pub extern fn gtk_column_view_row_set_activatable(self: ?*GtkColumnViewRow, activatable: gboolean) void;
pub extern fn gtk_column_view_row_get_focusable(self: ?*GtkColumnViewRow) gboolean;
pub extern fn gtk_column_view_row_set_focusable(self: ?*GtkColumnViewRow, focusable: gboolean) void;
pub extern fn gtk_column_view_row_get_accessible_description(self: ?*GtkColumnViewRow) [*c]const u8;
pub extern fn gtk_column_view_row_set_accessible_description(self: ?*GtkColumnViewRow, description: [*c]const u8) void;
pub extern fn gtk_column_view_row_get_accessible_label(self: ?*GtkColumnViewRow) [*c]const u8;
pub extern fn gtk_column_view_row_set_accessible_label(self: ?*GtkColumnViewRow, label: [*c]const u8) void;
pub extern fn gtk_column_view_sorter_get_type() GType;
pub const struct__GtkColumnViewSorter = opaque {};
pub const GtkColumnViewSorter = struct__GtkColumnViewSorter;
pub const GtkColumnViewSorterClass = extern struct {
    parent_class: GtkSorterClass,
};
pub const GtkColumnViewSorter_autoptr = ?*GtkColumnViewSorter;
pub const GtkColumnViewSorter_listautoptr = [*c]GList;
pub const GtkColumnViewSorter_slistautoptr = [*c]GSList;
pub const GtkColumnViewSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewSorter(arg__ptr: ?*GtkColumnViewSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkSorter(@as([*c]GtkSorter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewSorter(arg__ptr: [*c]?*GtkColumnViewSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
    }
}
pub const GtkColumnViewSorterClass_autoptr = [*c]GtkColumnViewSorterClass;
pub const GtkColumnViewSorterClass_listautoptr = [*c]GList;
pub const GtkColumnViewSorterClass_slistautoptr = [*c]GSList;
pub const GtkColumnViewSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColumnViewSorterClass(arg__ptr: [*c]GtkColumnViewSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkColumnViewSorterClass(arg__ptr: [*c][*c]GtkColumnViewSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkColumnViewSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkColumnViewSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkColumnViewSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkColumnViewSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_COLUMN_VIEW_SORTER(arg_ptr: gpointer) callconv(.C) ?*GtkColumnViewSorter {
    var ptr = arg_ptr;
    return @as(?*GtkColumnViewSorter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_column_view_sorter_get_type())))));
}
pub fn GTK_IS_COLUMN_VIEW_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_column_view_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_column_view_sorter_get_primary_sort_column(self: ?*GtkColumnViewSorter) ?*GtkColumnViewColumn;
pub extern fn gtk_column_view_sorter_get_primary_sort_order(self: ?*GtkColumnViewSorter) GtkSortType;
pub extern fn gtk_column_view_sorter_get_n_sort_columns(self: ?*GtkColumnViewSorter) guint;
pub extern fn gtk_column_view_sorter_get_nth_sort_column(self: ?*GtkColumnViewSorter, position: guint, sort_order: [*c]GtkSortType) ?*GtkColumnViewColumn;
pub const struct__GtkTreeSortable = opaque {};
pub const GtkTreeSortable = struct__GtkTreeSortable;
pub const GtkTreeIterCompareFunc = ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter, gpointer) callconv(.C) c_int;
pub const struct__GtkTreeSortableIface = extern struct {
    g_iface: GTypeInterface,
    sort_column_changed: ?*const fn (?*GtkTreeSortable) callconv(.C) void,
    get_sort_column_id: ?*const fn (?*GtkTreeSortable, [*c]c_int, [*c]GtkSortType) callconv(.C) gboolean,
    set_sort_column_id: ?*const fn (?*GtkTreeSortable, c_int, GtkSortType) callconv(.C) void,
    set_sort_func: ?*const fn (?*GtkTreeSortable, c_int, GtkTreeIterCompareFunc, gpointer, GDestroyNotify) callconv(.C) void,
    set_default_sort_func: ?*const fn (?*GtkTreeSortable, GtkTreeIterCompareFunc, gpointer, GDestroyNotify) callconv(.C) void,
    has_default_sort_func: ?*const fn (?*GtkTreeSortable) callconv(.C) gboolean,
};
pub const GtkTreeSortableIface = struct__GtkTreeSortableIface;
pub extern fn gtk_tree_sortable_get_type() GType;
pub extern fn gtk_tree_sortable_sort_column_changed(sortable: ?*GtkTreeSortable) void;
pub extern fn gtk_tree_sortable_get_sort_column_id(sortable: ?*GtkTreeSortable, sort_column_id: [*c]c_int, order: [*c]GtkSortType) gboolean;
pub extern fn gtk_tree_sortable_set_sort_column_id(sortable: ?*GtkTreeSortable, sort_column_id: c_int, order: GtkSortType) void;
pub extern fn gtk_tree_sortable_set_sort_func(sortable: ?*GtkTreeSortable, sort_column_id: c_int, sort_func: GtkTreeIterCompareFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_sortable_set_default_sort_func(sortable: ?*GtkTreeSortable, sort_func: GtkTreeIterCompareFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_sortable_has_default_sort_func(sortable: ?*GtkTreeSortable) gboolean;
pub const GtkTreeSortable_autoptr = ?*GtkTreeSortable;
pub const GtkTreeSortable_listautoptr = [*c]GList;
pub const GtkTreeSortable_slistautoptr = [*c]GSList;
pub const GtkTreeSortable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeSortable(arg__ptr: ?*GtkTreeSortable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeSortable(arg__ptr: [*c]?*GtkTreeSortable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeSortable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeSortable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeSortable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeSortable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkTreeViewColumn = opaque {};
pub const GtkTreeViewColumn = struct__GtkTreeViewColumn;
pub const GTK_TREE_VIEW_COLUMN_GROW_ONLY: c_int = 0;
pub const GTK_TREE_VIEW_COLUMN_AUTOSIZE: c_int = 1;
pub const GTK_TREE_VIEW_COLUMN_FIXED: c_int = 2;
pub const GtkTreeViewColumnSizing = c_uint;
pub const GtkTreeCellDataFunc = ?*const fn (?*GtkTreeViewColumn, [*c]GtkCellRenderer, ?*GtkTreeModel, [*c]GtkTreeIter, gpointer) callconv(.C) void;
pub extern fn gtk_tree_view_column_get_type() GType;
pub extern fn gtk_tree_view_column_new() ?*GtkTreeViewColumn;
pub extern fn gtk_tree_view_column_new_with_area(area: [*c]GtkCellArea) ?*GtkTreeViewColumn;
pub extern fn gtk_tree_view_column_new_with_attributes(title: [*c]const u8, cell: [*c]GtkCellRenderer, ...) ?*GtkTreeViewColumn;
pub extern fn gtk_tree_view_column_pack_start(tree_column: ?*GtkTreeViewColumn, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_tree_view_column_pack_end(tree_column: ?*GtkTreeViewColumn, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_tree_view_column_clear(tree_column: ?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_column_add_attribute(tree_column: ?*GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, attribute: [*c]const u8, column: c_int) void;
pub extern fn gtk_tree_view_column_set_attributes(tree_column: ?*GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, ...) void;
pub extern fn gtk_tree_view_column_set_cell_data_func(tree_column: ?*GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, func: GtkTreeCellDataFunc, func_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_column_clear_attributes(tree_column: ?*GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_tree_view_column_set_spacing(tree_column: ?*GtkTreeViewColumn, spacing: c_int) void;
pub extern fn gtk_tree_view_column_get_spacing(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_set_visible(tree_column: ?*GtkTreeViewColumn, visible: gboolean) void;
pub extern fn gtk_tree_view_column_get_visible(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_resizable(tree_column: ?*GtkTreeViewColumn, resizable: gboolean) void;
pub extern fn gtk_tree_view_column_get_resizable(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_sizing(tree_column: ?*GtkTreeViewColumn, @"type": GtkTreeViewColumnSizing) void;
pub extern fn gtk_tree_view_column_get_sizing(tree_column: ?*GtkTreeViewColumn) GtkTreeViewColumnSizing;
pub extern fn gtk_tree_view_column_get_x_offset(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_get_width(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_get_fixed_width(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_set_fixed_width(tree_column: ?*GtkTreeViewColumn, fixed_width: c_int) void;
pub extern fn gtk_tree_view_column_set_min_width(tree_column: ?*GtkTreeViewColumn, min_width: c_int) void;
pub extern fn gtk_tree_view_column_get_min_width(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_set_max_width(tree_column: ?*GtkTreeViewColumn, max_width: c_int) void;
pub extern fn gtk_tree_view_column_get_max_width(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_clicked(tree_column: ?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_column_set_title(tree_column: ?*GtkTreeViewColumn, title: [*c]const u8) void;
pub extern fn gtk_tree_view_column_get_title(tree_column: ?*GtkTreeViewColumn) [*c]const u8;
pub extern fn gtk_tree_view_column_set_expand(tree_column: ?*GtkTreeViewColumn, expand: gboolean) void;
pub extern fn gtk_tree_view_column_get_expand(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_clickable(tree_column: ?*GtkTreeViewColumn, clickable: gboolean) void;
pub extern fn gtk_tree_view_column_get_clickable(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_widget(tree_column: ?*GtkTreeViewColumn, widget: [*c]GtkWidget) void;
pub extern fn gtk_tree_view_column_get_widget(tree_column: ?*GtkTreeViewColumn) [*c]GtkWidget;
pub extern fn gtk_tree_view_column_set_alignment(tree_column: ?*GtkTreeViewColumn, xalign: f32) void;
pub extern fn gtk_tree_view_column_get_alignment(tree_column: ?*GtkTreeViewColumn) f32;
pub extern fn gtk_tree_view_column_set_reorderable(tree_column: ?*GtkTreeViewColumn, reorderable: gboolean) void;
pub extern fn gtk_tree_view_column_get_reorderable(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_sort_column_id(tree_column: ?*GtkTreeViewColumn, sort_column_id: c_int) void;
pub extern fn gtk_tree_view_column_get_sort_column_id(tree_column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_column_set_sort_indicator(tree_column: ?*GtkTreeViewColumn, setting: gboolean) void;
pub extern fn gtk_tree_view_column_get_sort_indicator(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_sort_order(tree_column: ?*GtkTreeViewColumn, order: GtkSortType) void;
pub extern fn gtk_tree_view_column_get_sort_order(tree_column: ?*GtkTreeViewColumn) GtkSortType;
pub extern fn gtk_tree_view_column_cell_set_cell_data(tree_column: ?*GtkTreeViewColumn, tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, is_expander: gboolean, is_expanded: gboolean) void;
pub extern fn gtk_tree_view_column_cell_get_size(tree_column: ?*GtkTreeViewColumn, x_offset: [*c]c_int, y_offset: [*c]c_int, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_tree_view_column_cell_is_visible(tree_column: ?*GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_focus_cell(tree_column: ?*GtkTreeViewColumn, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_tree_view_column_cell_get_position(tree_column: ?*GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, x_offset: [*c]c_int, width: [*c]c_int) gboolean;
pub extern fn gtk_tree_view_column_queue_resize(tree_column: ?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_column_get_tree_view(tree_column: ?*GtkTreeViewColumn) [*c]GtkWidget;
pub extern fn gtk_tree_view_column_get_button(tree_column: ?*GtkTreeViewColumn) [*c]GtkWidget;
pub const GtkTreeViewColumn_autoptr = ?*GtkTreeViewColumn;
pub const GtkTreeViewColumn_listautoptr = [*c]GList;
pub const GtkTreeViewColumn_slistautoptr = [*c]GSList;
pub const GtkTreeViewColumn_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeViewColumn(arg__ptr: ?*GtkTreeViewColumn) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeViewColumn(arg__ptr: [*c]?*GtkTreeViewColumn) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeViewColumn(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeViewColumn(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeViewColumn(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeViewColumn(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkEditable = opaque {};
pub const GtkEditable = struct__GtkEditable;
pub const struct__GtkEditableInterface = extern struct {
    base_iface: GTypeInterface,
    insert_text: ?*const fn (?*GtkEditable, [*c]const u8, c_int, [*c]c_int) callconv(.C) void,
    delete_text: ?*const fn (?*GtkEditable, c_int, c_int) callconv(.C) void,
    changed: ?*const fn (?*GtkEditable) callconv(.C) void,
    get_text: ?*const fn (?*GtkEditable) callconv(.C) [*c]const u8,
    do_insert_text: ?*const fn (?*GtkEditable, [*c]const u8, c_int, [*c]c_int) callconv(.C) void,
    do_delete_text: ?*const fn (?*GtkEditable, c_int, c_int) callconv(.C) void,
    get_selection_bounds: ?*const fn (?*GtkEditable, [*c]c_int, [*c]c_int) callconv(.C) gboolean,
    set_selection_bounds: ?*const fn (?*GtkEditable, c_int, c_int) callconv(.C) void,
    get_delegate: ?*const fn (?*GtkEditable) callconv(.C) ?*GtkEditable,
};
pub const GtkEditableInterface = struct__GtkEditableInterface;
pub extern fn gtk_editable_get_type() GType;
pub extern fn gtk_editable_get_text(editable: ?*GtkEditable) [*c]const u8;
pub extern fn gtk_editable_set_text(editable: ?*GtkEditable, text: [*c]const u8) void;
pub extern fn gtk_editable_get_chars(editable: ?*GtkEditable, start_pos: c_int, end_pos: c_int) [*c]u8;
pub extern fn gtk_editable_insert_text(editable: ?*GtkEditable, text: [*c]const u8, length: c_int, position: [*c]c_int) void;
pub extern fn gtk_editable_delete_text(editable: ?*GtkEditable, start_pos: c_int, end_pos: c_int) void;
pub extern fn gtk_editable_get_selection_bounds(editable: ?*GtkEditable, start_pos: [*c]c_int, end_pos: [*c]c_int) gboolean;
pub extern fn gtk_editable_delete_selection(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_select_region(editable: ?*GtkEditable, start_pos: c_int, end_pos: c_int) void;
pub extern fn gtk_editable_set_position(editable: ?*GtkEditable, position: c_int) void;
pub extern fn gtk_editable_get_position(editable: ?*GtkEditable) c_int;
pub extern fn gtk_editable_get_editable(editable: ?*GtkEditable) gboolean;
pub extern fn gtk_editable_set_editable(editable: ?*GtkEditable, is_editable: gboolean) void;
pub extern fn gtk_editable_get_alignment(editable: ?*GtkEditable) f32;
pub extern fn gtk_editable_set_alignment(editable: ?*GtkEditable, xalign: f32) void;
pub extern fn gtk_editable_get_width_chars(editable: ?*GtkEditable) c_int;
pub extern fn gtk_editable_set_width_chars(editable: ?*GtkEditable, n_chars: c_int) void;
pub extern fn gtk_editable_get_max_width_chars(editable: ?*GtkEditable) c_int;
pub extern fn gtk_editable_set_max_width_chars(editable: ?*GtkEditable, n_chars: c_int) void;
pub extern fn gtk_editable_get_enable_undo(editable: ?*GtkEditable) gboolean;
pub extern fn gtk_editable_set_enable_undo(editable: ?*GtkEditable, enable_undo: gboolean) void;
pub const GTK_EDITABLE_PROP_TEXT: c_int = 0;
pub const GTK_EDITABLE_PROP_CURSOR_POSITION: c_int = 1;
pub const GTK_EDITABLE_PROP_SELECTION_BOUND: c_int = 2;
pub const GTK_EDITABLE_PROP_EDITABLE: c_int = 3;
pub const GTK_EDITABLE_PROP_WIDTH_CHARS: c_int = 4;
pub const GTK_EDITABLE_PROP_MAX_WIDTH_CHARS: c_int = 5;
pub const GTK_EDITABLE_PROP_XALIGN: c_int = 6;
pub const GTK_EDITABLE_PROP_ENABLE_UNDO: c_int = 7;
pub const GTK_EDITABLE_NUM_PROPERTIES: c_int = 8;
pub const GtkEditableProperties = c_uint;
pub extern fn gtk_editable_install_properties(object_class: [*c]GObjectClass, first_prop: guint) guint;
pub extern fn gtk_editable_get_delegate(editable: ?*GtkEditable) ?*GtkEditable;
pub extern fn gtk_editable_init_delegate(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_finish_delegate(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_delegate_set_property(object: [*c]GObject, prop_id: guint, value: [*c]const GValue, pspec: [*c]GParamSpec) gboolean;
pub extern fn gtk_editable_delegate_get_property(object: [*c]GObject, prop_id: guint, value: [*c]GValue, pspec: [*c]GParamSpec) gboolean;
pub extern fn gtk_editable_delegate_get_accessible_platform_state(editable: ?*GtkEditable, state: GtkAccessiblePlatformState) gboolean;
pub const GtkEditable_autoptr = ?*GtkEditable;
pub const GtkEditable_listautoptr = [*c]GList;
pub const GtkEditable_slistautoptr = [*c]GSList;
pub const GtkEditable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEditable(arg__ptr: ?*GtkEditable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEditable(arg__ptr: [*c]?*GtkEditable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEditable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEditable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEditable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEditable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkIMContext = extern struct {
    parent_instance: GObject,
};
pub const GtkIMContext = struct__GtkIMContext;
pub const struct__GtkIMContextClass = extern struct {
    parent_class: GObjectClass,
    preedit_start: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    preedit_end: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    preedit_changed: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    commit: ?*const fn ([*c]GtkIMContext, [*c]const u8) callconv(.C) void,
    retrieve_surrounding: ?*const fn ([*c]GtkIMContext) callconv(.C) gboolean,
    delete_surrounding: ?*const fn ([*c]GtkIMContext, c_int, c_int) callconv(.C) gboolean,
    set_client_widget: ?*const fn ([*c]GtkIMContext, [*c]GtkWidget) callconv(.C) void,
    get_preedit_string: ?*const fn ([*c]GtkIMContext, [*c][*c]u8, [*c]?*PangoAttrList, [*c]c_int) callconv(.C) void,
    filter_keypress: ?*const fn ([*c]GtkIMContext, ?*GdkEvent) callconv(.C) gboolean,
    focus_in: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    focus_out: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    reset: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    set_cursor_location: ?*const fn ([*c]GtkIMContext, [*c]GdkRectangle) callconv(.C) void,
    set_use_preedit: ?*const fn ([*c]GtkIMContext, gboolean) callconv(.C) void,
    set_surrounding: ?*const fn ([*c]GtkIMContext, [*c]const u8, c_int, c_int) callconv(.C) void,
    get_surrounding: ?*const fn ([*c]GtkIMContext, [*c][*c]u8, [*c]c_int) callconv(.C) gboolean,
    set_surrounding_with_selection: ?*const fn ([*c]GtkIMContext, [*c]const u8, c_int, c_int, c_int) callconv(.C) void,
    get_surrounding_with_selection: ?*const fn ([*c]GtkIMContext, [*c][*c]u8, [*c]c_int, [*c]c_int) callconv(.C) gboolean,
    activate_osk: ?*const fn ([*c]GtkIMContext) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkIMContextClass = struct__GtkIMContextClass;
pub extern fn gtk_im_context_get_type() GType;
pub extern fn gtk_im_context_set_client_widget(context: [*c]GtkIMContext, widget: [*c]GtkWidget) void;
pub extern fn gtk_im_context_get_preedit_string(context: [*c]GtkIMContext, str: [*c][*c]u8, attrs: [*c]?*PangoAttrList, cursor_pos: [*c]c_int) void;
pub extern fn gtk_im_context_filter_keypress(context: [*c]GtkIMContext, event: ?*GdkEvent) gboolean;
pub extern fn gtk_im_context_filter_key(context: [*c]GtkIMContext, press: gboolean, surface: ?*GdkSurface, device: ?*GdkDevice, time: guint32, keycode: guint, state: GdkModifierType, group: c_int) gboolean;
pub extern fn gtk_im_context_focus_in(context: [*c]GtkIMContext) void;
pub extern fn gtk_im_context_focus_out(context: [*c]GtkIMContext) void;
pub extern fn gtk_im_context_reset(context: [*c]GtkIMContext) void;
pub extern fn gtk_im_context_set_cursor_location(context: [*c]GtkIMContext, area: [*c]const GdkRectangle) void;
pub extern fn gtk_im_context_set_use_preedit(context: [*c]GtkIMContext, use_preedit: gboolean) void;
pub extern fn gtk_im_context_set_surrounding(context: [*c]GtkIMContext, text: [*c]const u8, len: c_int, cursor_index: c_int) void;
pub extern fn gtk_im_context_get_surrounding(context: [*c]GtkIMContext, text: [*c][*c]u8, cursor_index: [*c]c_int) gboolean;
pub extern fn gtk_im_context_set_surrounding_with_selection(context: [*c]GtkIMContext, text: [*c]const u8, len: c_int, cursor_index: c_int, anchor_index: c_int) void;
pub extern fn gtk_im_context_get_surrounding_with_selection(context: [*c]GtkIMContext, text: [*c][*c]u8, cursor_index: [*c]c_int, anchor_index: [*c]c_int) gboolean;
pub extern fn gtk_im_context_delete_surrounding(context: [*c]GtkIMContext, offset: c_int, n_chars: c_int) gboolean;
pub const GtkIMContext_autoptr = [*c]GtkIMContext;
pub const GtkIMContext_listautoptr = [*c]GList;
pub const GtkIMContext_slistautoptr = [*c]GSList;
pub const GtkIMContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIMContext(arg__ptr: [*c]GtkIMContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkIMContext(arg__ptr: [*c][*c]GtkIMContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkIMContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkIMContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkIMContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkIMContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkEntryBuffer = extern struct {
    parent_instance: GObject,
};
pub const GtkEntryBuffer = struct__GtkEntryBuffer;
pub const struct__GtkEntryBufferClass = extern struct {
    parent_class: GObjectClass,
    inserted_text: ?*const fn ([*c]GtkEntryBuffer, guint, [*c]const u8, guint) callconv(.C) void,
    deleted_text: ?*const fn ([*c]GtkEntryBuffer, guint, guint) callconv(.C) void,
    get_text: ?*const fn ([*c]GtkEntryBuffer, [*c]gsize) callconv(.C) [*c]const u8,
    get_length: ?*const fn ([*c]GtkEntryBuffer) callconv(.C) guint,
    insert_text: ?*const fn ([*c]GtkEntryBuffer, guint, [*c]const u8, guint) callconv(.C) guint,
    delete_text: ?*const fn ([*c]GtkEntryBuffer, guint, guint) callconv(.C) guint,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
    _gtk_reserved5: ?*const fn () callconv(.C) void,
    _gtk_reserved6: ?*const fn () callconv(.C) void,
    _gtk_reserved7: ?*const fn () callconv(.C) void,
    _gtk_reserved8: ?*const fn () callconv(.C) void,
};
pub const GtkEntryBufferClass = struct__GtkEntryBufferClass;
pub extern fn gtk_entry_buffer_get_type() GType;
pub extern fn gtk_entry_buffer_new(initial_chars: [*c]const u8, n_initial_chars: c_int) [*c]GtkEntryBuffer;
pub extern fn gtk_entry_buffer_get_bytes(buffer: [*c]GtkEntryBuffer) gsize;
pub extern fn gtk_entry_buffer_get_length(buffer: [*c]GtkEntryBuffer) guint;
pub extern fn gtk_entry_buffer_get_text(buffer: [*c]GtkEntryBuffer) [*c]const u8;
pub extern fn gtk_entry_buffer_set_text(buffer: [*c]GtkEntryBuffer, chars: [*c]const u8, n_chars: c_int) void;
pub extern fn gtk_entry_buffer_set_max_length(buffer: [*c]GtkEntryBuffer, max_length: c_int) void;
pub extern fn gtk_entry_buffer_get_max_length(buffer: [*c]GtkEntryBuffer) c_int;
pub extern fn gtk_entry_buffer_insert_text(buffer: [*c]GtkEntryBuffer, position: guint, chars: [*c]const u8, n_chars: c_int) guint;
pub extern fn gtk_entry_buffer_delete_text(buffer: [*c]GtkEntryBuffer, position: guint, n_chars: c_int) guint;
pub extern fn gtk_entry_buffer_emit_inserted_text(buffer: [*c]GtkEntryBuffer, position: guint, chars: [*c]const u8, n_chars: guint) void;
pub extern fn gtk_entry_buffer_emit_deleted_text(buffer: [*c]GtkEntryBuffer, position: guint, n_chars: guint) void;
pub const GtkEntryBuffer_autoptr = [*c]GtkEntryBuffer;
pub const GtkEntryBuffer_listautoptr = [*c]GList;
pub const GtkEntryBuffer_slistautoptr = [*c]GSList;
pub const GtkEntryBuffer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEntryBuffer(arg__ptr: [*c]GtkEntryBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEntryBuffer(arg__ptr: [*c][*c]GtkEntryBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEntryBuffer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEntryBuffer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEntryBuffer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEntryBuffer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkListStorePrivate = opaque {};
pub const GtkListStorePrivate = struct__GtkListStorePrivate;
pub const struct__GtkListStore = extern struct {
    parent: GObject,
    priv: ?*GtkListStorePrivate,
};
pub const GtkListStore = struct__GtkListStore;
pub const struct__GtkListStoreClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GtkListStoreClass = struct__GtkListStoreClass;
pub extern fn gtk_list_store_get_type() GType;
pub extern fn gtk_list_store_new(n_columns: c_int, ...) [*c]GtkListStore;
pub extern fn gtk_list_store_newv(n_columns: c_int, types: [*c]GType) [*c]GtkListStore;
pub extern fn gtk_list_store_set_column_types(list_store: [*c]GtkListStore, n_columns: c_int, types: [*c]GType) void;
pub extern fn gtk_list_store_set_value(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, column: c_int, value: [*c]GValue) void;
pub extern fn gtk_list_store_set(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, ...) void;
pub extern fn gtk_list_store_set_valuesv(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, columns: [*c]c_int, values: [*c]GValue, n_values: c_int) void;
pub extern fn gtk_list_store_set_valist(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, var_args: [*c]struct___va_list_tag) void;
pub extern fn gtk_list_store_remove(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_list_store_insert(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: c_int) void;
pub extern fn gtk_list_store_insert_before(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_insert_after(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_insert_with_values(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: c_int, ...) void;
pub extern fn gtk_list_store_insert_with_valuesv(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: c_int, columns: [*c]c_int, values: [*c]GValue, n_values: c_int) void;
pub extern fn gtk_list_store_prepend(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_append(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_clear(list_store: [*c]GtkListStore) void;
pub extern fn gtk_list_store_iter_is_valid(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_list_store_reorder(store: [*c]GtkListStore, new_order: [*c]c_int) void;
pub extern fn gtk_list_store_swap(store: [*c]GtkListStore, a: [*c]GtkTreeIter, b: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_move_after(store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_move_before(store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub const GtkListStore_autoptr = [*c]GtkListStore;
pub const GtkListStore_listautoptr = [*c]GList;
pub const GtkListStore_slistautoptr = [*c]GSList;
pub const GtkListStore_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListStore(arg__ptr: [*c]GtkListStore) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListStore(arg__ptr: [*c][*c]GtkListStore) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListStore(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListStore(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListStore(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListStore(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkTreeModelFilterVisibleFunc = ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, gpointer) callconv(.C) gboolean;
pub const GtkTreeModelFilterModifyFunc = ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GValue, c_int, gpointer) callconv(.C) void;
pub const struct__GtkTreeModelFilterPrivate = opaque {};
pub const GtkTreeModelFilterPrivate = struct__GtkTreeModelFilterPrivate;
pub const struct__GtkTreeModelFilter = extern struct {
    parent: GObject,
    priv: ?*GtkTreeModelFilterPrivate,
};
pub const GtkTreeModelFilter = struct__GtkTreeModelFilter;
pub const struct__GtkTreeModelFilterClass = extern struct {
    parent_class: GObjectClass,
    visible: ?*const fn ([*c]GtkTreeModelFilter, ?*GtkTreeModel, [*c]GtkTreeIter) callconv(.C) gboolean,
    modify: ?*const fn ([*c]GtkTreeModelFilter, ?*GtkTreeModel, [*c]GtkTreeIter, [*c]GValue, c_int) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkTreeModelFilterClass = struct__GtkTreeModelFilterClass;
pub extern fn gtk_tree_model_filter_get_type() GType;
pub extern fn gtk_tree_model_filter_new(child_model: ?*GtkTreeModel, root: ?*GtkTreePath) ?*GtkTreeModel;
pub extern fn gtk_tree_model_filter_set_visible_func(filter: [*c]GtkTreeModelFilter, func: GtkTreeModelFilterVisibleFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_model_filter_set_modify_func(filter: [*c]GtkTreeModelFilter, n_columns: c_int, types: [*c]GType, func: GtkTreeModelFilterModifyFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_model_filter_set_visible_column(filter: [*c]GtkTreeModelFilter, column: c_int) void;
pub extern fn gtk_tree_model_filter_get_model(filter: [*c]GtkTreeModelFilter) ?*GtkTreeModel;
pub extern fn gtk_tree_model_filter_convert_child_iter_to_iter(filter: [*c]GtkTreeModelFilter, filter_iter: [*c]GtkTreeIter, child_iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_filter_convert_iter_to_child_iter(filter: [*c]GtkTreeModelFilter, child_iter: [*c]GtkTreeIter, filter_iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_filter_convert_child_path_to_path(filter: [*c]GtkTreeModelFilter, child_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_filter_convert_path_to_child_path(filter: [*c]GtkTreeModelFilter, filter_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_filter_refilter(filter: [*c]GtkTreeModelFilter) void;
pub extern fn gtk_tree_model_filter_clear_cache(filter: [*c]GtkTreeModelFilter) void;
pub const GtkTreeModelFilter_autoptr = [*c]GtkTreeModelFilter;
pub const GtkTreeModelFilter_listautoptr = [*c]GList;
pub const GtkTreeModelFilter_slistautoptr = [*c]GSList;
pub const GtkTreeModelFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeModelFilter(arg__ptr: [*c]GtkTreeModelFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeModelFilter(arg__ptr: [*c][*c]GtkTreeModelFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeModelFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeModelFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeModelFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeModelFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkEntryCompletion = opaque {};
pub const GtkEntryCompletion = struct__GtkEntryCompletion;
pub const GtkEntryCompletionMatchFunc = ?*const fn (?*GtkEntryCompletion, [*c]const u8, [*c]GtkTreeIter, gpointer) callconv(.C) gboolean;
pub extern fn gtk_entry_completion_get_type() GType;
pub extern fn gtk_entry_completion_new() ?*GtkEntryCompletion;
pub extern fn gtk_entry_completion_new_with_area(area: [*c]GtkCellArea) ?*GtkEntryCompletion;
pub extern fn gtk_entry_completion_get_entry(completion: ?*GtkEntryCompletion) [*c]GtkWidget;
pub extern fn gtk_entry_completion_set_model(completion: ?*GtkEntryCompletion, model: ?*GtkTreeModel) void;
pub extern fn gtk_entry_completion_get_model(completion: ?*GtkEntryCompletion) ?*GtkTreeModel;
pub extern fn gtk_entry_completion_set_match_func(completion: ?*GtkEntryCompletion, func: GtkEntryCompletionMatchFunc, func_data: gpointer, func_notify: GDestroyNotify) void;
pub extern fn gtk_entry_completion_set_minimum_key_length(completion: ?*GtkEntryCompletion, length: c_int) void;
pub extern fn gtk_entry_completion_get_minimum_key_length(completion: ?*GtkEntryCompletion) c_int;
pub extern fn gtk_entry_completion_compute_prefix(completion: ?*GtkEntryCompletion, key: [*c]const u8) [*c]u8;
pub extern fn gtk_entry_completion_complete(completion: ?*GtkEntryCompletion) void;
pub extern fn gtk_entry_completion_insert_prefix(completion: ?*GtkEntryCompletion) void;
pub extern fn gtk_entry_completion_set_inline_completion(completion: ?*GtkEntryCompletion, inline_completion: gboolean) void;
pub extern fn gtk_entry_completion_get_inline_completion(completion: ?*GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_inline_selection(completion: ?*GtkEntryCompletion, inline_selection: gboolean) void;
pub extern fn gtk_entry_completion_get_inline_selection(completion: ?*GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_popup_completion(completion: ?*GtkEntryCompletion, popup_completion: gboolean) void;
pub extern fn gtk_entry_completion_get_popup_completion(completion: ?*GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_popup_set_width(completion: ?*GtkEntryCompletion, popup_set_width: gboolean) void;
pub extern fn gtk_entry_completion_get_popup_set_width(completion: ?*GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_popup_single_match(completion: ?*GtkEntryCompletion, popup_single_match: gboolean) void;
pub extern fn gtk_entry_completion_get_popup_single_match(completion: ?*GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_get_completion_prefix(completion: ?*GtkEntryCompletion) [*c]const u8;
pub extern fn gtk_entry_completion_set_text_column(completion: ?*GtkEntryCompletion, column: c_int) void;
pub extern fn gtk_entry_completion_get_text_column(completion: ?*GtkEntryCompletion) c_int;
pub const GtkEntryCompletion_autoptr = ?*GtkEntryCompletion;
pub const GtkEntryCompletion_listautoptr = [*c]GList;
pub const GtkEntryCompletion_slistautoptr = [*c]GSList;
pub const GtkEntryCompletion_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEntryCompletion(arg__ptr: ?*GtkEntryCompletion) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEntryCompletion(arg__ptr: [*c]?*GtkEntryCompletion) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEntryCompletion(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEntryCompletion(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEntryCompletion(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEntryCompletion(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkImage = opaque {};
pub const GtkImage = struct__GtkImage;
pub const GTK_IMAGE_EMPTY: c_int = 0;
pub const GTK_IMAGE_ICON_NAME: c_int = 1;
pub const GTK_IMAGE_GICON: c_int = 2;
pub const GTK_IMAGE_PAINTABLE: c_int = 3;
pub const GtkImageType = c_uint;
pub extern fn gtk_image_get_type() GType;
pub extern fn gtk_image_new() [*c]GtkWidget;
pub extern fn gtk_image_new_from_file(filename: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_image_new_from_resource(resource_path: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_image_new_from_pixbuf(pixbuf: ?*GdkPixbuf) [*c]GtkWidget;
pub extern fn gtk_image_new_from_paintable(paintable: ?*GdkPaintable) [*c]GtkWidget;
pub extern fn gtk_image_new_from_icon_name(icon_name: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_image_new_from_gicon(icon: ?*GIcon) [*c]GtkWidget;
pub extern fn gtk_image_clear(image: ?*GtkImage) void;
pub extern fn gtk_image_set_from_file(image: ?*GtkImage, filename: [*c]const u8) void;
pub extern fn gtk_image_set_from_resource(image: ?*GtkImage, resource_path: [*c]const u8) void;
pub extern fn gtk_image_set_from_pixbuf(image: ?*GtkImage, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_image_set_from_paintable(image: ?*GtkImage, paintable: ?*GdkPaintable) void;
pub extern fn gtk_image_set_from_icon_name(image: ?*GtkImage, icon_name: [*c]const u8) void;
pub extern fn gtk_image_set_from_gicon(image: ?*GtkImage, icon: ?*GIcon) void;
pub extern fn gtk_image_set_pixel_size(image: ?*GtkImage, pixel_size: c_int) void;
pub extern fn gtk_image_set_icon_size(image: ?*GtkImage, icon_size: GtkIconSize) void;
pub extern fn gtk_image_get_storage_type(image: ?*GtkImage) GtkImageType;
pub extern fn gtk_image_get_paintable(image: ?*GtkImage) ?*GdkPaintable;
pub extern fn gtk_image_get_icon_name(image: ?*GtkImage) [*c]const u8;
pub extern fn gtk_image_get_gicon(image: ?*GtkImage) ?*GIcon;
pub extern fn gtk_image_get_pixel_size(image: ?*GtkImage) c_int;
pub extern fn gtk_image_get_icon_size(image: ?*GtkImage) GtkIconSize;
pub const GtkImage_autoptr = ?*GtkImage;
pub const GtkImage_listautoptr = [*c]GList;
pub const GtkImage_slistautoptr = [*c]GSList;
pub const GtkImage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkImage(arg__ptr: ?*GtkImage) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkImage(arg__ptr: [*c]?*GtkImage) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkImage(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkImage(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkImage(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkImage(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_ENTRY_ICON_PRIMARY: c_int = 0;
pub const GTK_ENTRY_ICON_SECONDARY: c_int = 1;
pub const GtkEntryIconPosition = c_uint;
pub const struct__GtkEntry = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkEntry = struct__GtkEntry;
pub const struct__GtkEntryClass = extern struct {
    parent_class: GtkWidgetClass,
    activate: ?*const fn ([*c]GtkEntry) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkEntryClass = struct__GtkEntryClass;
pub extern fn gtk_entry_get_type() GType;
pub extern fn gtk_entry_new() [*c]GtkWidget;
pub extern fn gtk_entry_new_with_buffer(buffer: [*c]GtkEntryBuffer) [*c]GtkWidget;
pub extern fn gtk_entry_get_buffer(entry: [*c]GtkEntry) [*c]GtkEntryBuffer;
pub extern fn gtk_entry_set_buffer(entry: [*c]GtkEntry, buffer: [*c]GtkEntryBuffer) void;
pub extern fn gtk_entry_set_visibility(entry: [*c]GtkEntry, visible: gboolean) void;
pub extern fn gtk_entry_get_visibility(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_invisible_char(entry: [*c]GtkEntry, ch: gunichar) void;
pub extern fn gtk_entry_get_invisible_char(entry: [*c]GtkEntry) gunichar;
pub extern fn gtk_entry_unset_invisible_char(entry: [*c]GtkEntry) void;
pub extern fn gtk_entry_set_has_frame(entry: [*c]GtkEntry, setting: gboolean) void;
pub extern fn gtk_entry_get_has_frame(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_overwrite_mode(entry: [*c]GtkEntry, overwrite: gboolean) void;
pub extern fn gtk_entry_get_overwrite_mode(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_max_length(entry: [*c]GtkEntry, max: c_int) void;
pub extern fn gtk_entry_get_max_length(entry: [*c]GtkEntry) c_int;
pub extern fn gtk_entry_get_text_length(entry: [*c]GtkEntry) guint16;
pub extern fn gtk_entry_set_activates_default(entry: [*c]GtkEntry, setting: gboolean) void;
pub extern fn gtk_entry_get_activates_default(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_alignment(entry: [*c]GtkEntry, xalign: f32) void;
pub extern fn gtk_entry_get_alignment(entry: [*c]GtkEntry) f32;
pub extern fn gtk_entry_set_completion(entry: [*c]GtkEntry, completion: ?*GtkEntryCompletion) void;
pub extern fn gtk_entry_get_completion(entry: [*c]GtkEntry) ?*GtkEntryCompletion;
pub extern fn gtk_entry_set_progress_fraction(entry: [*c]GtkEntry, fraction: f64) void;
pub extern fn gtk_entry_get_progress_fraction(entry: [*c]GtkEntry) f64;
pub extern fn gtk_entry_set_progress_pulse_step(entry: [*c]GtkEntry, fraction: f64) void;
pub extern fn gtk_entry_get_progress_pulse_step(entry: [*c]GtkEntry) f64;
pub extern fn gtk_entry_progress_pulse(entry: [*c]GtkEntry) void;
pub extern fn gtk_entry_get_placeholder_text(entry: [*c]GtkEntry) [*c]const u8;
pub extern fn gtk_entry_set_placeholder_text(entry: [*c]GtkEntry, text: [*c]const u8) void;
pub extern fn gtk_entry_set_icon_from_paintable(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, paintable: ?*GdkPaintable) void;
pub extern fn gtk_entry_set_icon_from_icon_name(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, icon_name: [*c]const u8) void;
pub extern fn gtk_entry_set_icon_from_gicon(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, icon: ?*GIcon) void;
pub extern fn gtk_entry_get_icon_storage_type(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) GtkImageType;
pub extern fn gtk_entry_get_icon_paintable(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) ?*GdkPaintable;
pub extern fn gtk_entry_get_icon_name(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]const u8;
pub extern fn gtk_entry_get_icon_gicon(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) ?*GIcon;
pub extern fn gtk_entry_set_icon_activatable(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, activatable: gboolean) void;
pub extern fn gtk_entry_get_icon_activatable(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) gboolean;
pub extern fn gtk_entry_set_icon_sensitive(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, sensitive: gboolean) void;
pub extern fn gtk_entry_get_icon_sensitive(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) gboolean;
pub extern fn gtk_entry_get_icon_at_pos(entry: [*c]GtkEntry, x: c_int, y: c_int) c_int;
pub extern fn gtk_entry_set_icon_tooltip_text(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, tooltip: [*c]const u8) void;
pub extern fn gtk_entry_get_icon_tooltip_text(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]u8;
pub extern fn gtk_entry_set_icon_tooltip_markup(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, tooltip: [*c]const u8) void;
pub extern fn gtk_entry_get_icon_tooltip_markup(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]u8;
pub extern fn gtk_entry_set_icon_drag_source(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, provider: [*c]GdkContentProvider, actions: GdkDragAction) void;
pub extern fn gtk_entry_get_current_icon_drag_source(entry: [*c]GtkEntry) c_int;
pub extern fn gtk_entry_get_icon_area(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, icon_area: [*c]GdkRectangle) void;
pub extern fn gtk_entry_reset_im_context(entry: [*c]GtkEntry) void;
pub extern fn gtk_entry_set_input_purpose(entry: [*c]GtkEntry, purpose: GtkInputPurpose) void;
pub extern fn gtk_entry_get_input_purpose(entry: [*c]GtkEntry) GtkInputPurpose;
pub extern fn gtk_entry_set_input_hints(entry: [*c]GtkEntry, hints: GtkInputHints) void;
pub extern fn gtk_entry_get_input_hints(entry: [*c]GtkEntry) GtkInputHints;
pub extern fn gtk_entry_set_attributes(entry: [*c]GtkEntry, attrs: ?*PangoAttrList) void;
pub extern fn gtk_entry_get_attributes(entry: [*c]GtkEntry) ?*PangoAttrList;
pub extern fn gtk_entry_set_tabs(entry: [*c]GtkEntry, tabs: ?*PangoTabArray) void;
pub extern fn gtk_entry_get_tabs(entry: [*c]GtkEntry) ?*PangoTabArray;
pub extern fn gtk_entry_grab_focus_without_selecting(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_extra_menu(entry: [*c]GtkEntry, model: [*c]GMenuModel) void;
pub extern fn gtk_entry_get_extra_menu(entry: [*c]GtkEntry) [*c]GMenuModel;
pub const GtkEntry_autoptr = [*c]GtkEntry;
pub const GtkEntry_listautoptr = [*c]GList;
pub const GtkEntry_slistautoptr = [*c]GSList;
pub const GtkEntry_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEntry(arg__ptr: [*c]GtkEntry) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEntry(arg__ptr: [*c][*c]GtkEntry) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEntry(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEntry(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEntry(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEntry(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_TREE_VIEW_DROP_BEFORE: c_int = 0;
pub const GTK_TREE_VIEW_DROP_AFTER: c_int = 1;
pub const GTK_TREE_VIEW_DROP_INTO_OR_BEFORE: c_int = 2;
pub const GTK_TREE_VIEW_DROP_INTO_OR_AFTER: c_int = 3;
pub const GtkTreeViewDropPosition = c_uint;
pub const struct__GtkTreeView = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkTreeView = struct__GtkTreeView;
pub const struct__GtkTreeViewClass = extern struct {
    parent_class: GtkWidgetClass,
    row_activated: ?*const fn ([*c]GtkTreeView, ?*GtkTreePath, ?*GtkTreeViewColumn) callconv(.C) void,
    test_expand_row: ?*const fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) callconv(.C) gboolean,
    test_collapse_row: ?*const fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) callconv(.C) gboolean,
    row_expanded: ?*const fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) callconv(.C) void,
    row_collapsed: ?*const fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) callconv(.C) void,
    columns_changed: ?*const fn ([*c]GtkTreeView) callconv(.C) void,
    cursor_changed: ?*const fn ([*c]GtkTreeView) callconv(.C) void,
    move_cursor: ?*const fn ([*c]GtkTreeView, GtkMovementStep, c_int, gboolean, gboolean) callconv(.C) gboolean,
    select_all: ?*const fn ([*c]GtkTreeView) callconv(.C) gboolean,
    unselect_all: ?*const fn ([*c]GtkTreeView) callconv(.C) gboolean,
    select_cursor_row: ?*const fn ([*c]GtkTreeView, gboolean) callconv(.C) gboolean,
    toggle_cursor_row: ?*const fn ([*c]GtkTreeView) callconv(.C) gboolean,
    expand_collapse_cursor_row: ?*const fn ([*c]GtkTreeView, gboolean, gboolean, gboolean) callconv(.C) gboolean,
    select_cursor_parent: ?*const fn ([*c]GtkTreeView) callconv(.C) gboolean,
    start_interactive_search: ?*const fn ([*c]GtkTreeView) callconv(.C) gboolean,
    _reserved: [16]gpointer,
};
pub const GtkTreeViewClass = struct__GtkTreeViewClass;
pub const struct__GtkTreeSelection = opaque {};
pub const GtkTreeSelection = struct__GtkTreeSelection;
pub const GtkTreeViewColumnDropFunc = ?*const fn ([*c]GtkTreeView, ?*GtkTreeViewColumn, ?*GtkTreeViewColumn, ?*GtkTreeViewColumn, gpointer) callconv(.C) gboolean;
pub const GtkTreeViewMappingFunc = ?*const fn ([*c]GtkTreeView, ?*GtkTreePath, gpointer) callconv(.C) void;
pub const GtkTreeViewSearchEqualFunc = ?*const fn (?*GtkTreeModel, c_int, [*c]const u8, [*c]GtkTreeIter, gpointer) callconv(.C) gboolean;
pub const GtkTreeViewRowSeparatorFunc = ?*const fn (?*GtkTreeModel, [*c]GtkTreeIter, gpointer) callconv(.C) gboolean;
pub extern fn gtk_tree_view_get_type() GType;
pub extern fn gtk_tree_view_new() [*c]GtkWidget;
pub extern fn gtk_tree_view_new_with_model(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_tree_view_get_model(tree_view: [*c]GtkTreeView) ?*GtkTreeModel;
pub extern fn gtk_tree_view_set_model(tree_view: [*c]GtkTreeView, model: ?*GtkTreeModel) void;
pub extern fn gtk_tree_view_get_selection(tree_view: [*c]GtkTreeView) ?*GtkTreeSelection;
pub extern fn gtk_tree_view_get_headers_visible(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_headers_visible(tree_view: [*c]GtkTreeView, headers_visible: gboolean) void;
pub extern fn gtk_tree_view_columns_autosize(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_get_headers_clickable(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_headers_clickable(tree_view: [*c]GtkTreeView, setting: gboolean) void;
pub extern fn gtk_tree_view_get_activate_on_single_click(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_activate_on_single_click(tree_view: [*c]GtkTreeView, single: gboolean) void;
pub extern fn gtk_tree_view_append_column(tree_view: [*c]GtkTreeView, column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_remove_column(tree_view: [*c]GtkTreeView, column: ?*GtkTreeViewColumn) c_int;
pub extern fn gtk_tree_view_insert_column(tree_view: [*c]GtkTreeView, column: ?*GtkTreeViewColumn, position: c_int) c_int;
pub extern fn gtk_tree_view_insert_column_with_attributes(tree_view: [*c]GtkTreeView, position: c_int, title: [*c]const u8, cell: [*c]GtkCellRenderer, ...) c_int;
pub extern fn gtk_tree_view_insert_column_with_data_func(tree_view: [*c]GtkTreeView, position: c_int, title: [*c]const u8, cell: [*c]GtkCellRenderer, func: GtkTreeCellDataFunc, data: gpointer, dnotify: GDestroyNotify) c_int;
pub extern fn gtk_tree_view_get_n_columns(tree_view: [*c]GtkTreeView) guint;
pub extern fn gtk_tree_view_get_column(tree_view: [*c]GtkTreeView, n: c_int) ?*GtkTreeViewColumn;
pub extern fn gtk_tree_view_get_columns(tree_view: [*c]GtkTreeView) [*c]GList;
pub extern fn gtk_tree_view_move_column_after(tree_view: [*c]GtkTreeView, column: ?*GtkTreeViewColumn, base_column: ?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_set_expander_column(tree_view: [*c]GtkTreeView, column: ?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_get_expander_column(tree_view: [*c]GtkTreeView) ?*GtkTreeViewColumn;
pub extern fn gtk_tree_view_set_column_drag_function(tree_view: [*c]GtkTreeView, func: GtkTreeViewColumnDropFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_scroll_to_point(tree_view: [*c]GtkTreeView, tree_x: c_int, tree_y: c_int) void;
pub extern fn gtk_tree_view_scroll_to_cell(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: ?*GtkTreeViewColumn, use_align: gboolean, row_align: f32, col_align: f32) void;
pub extern fn gtk_tree_view_row_activated(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: ?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_expand_all(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_collapse_all(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_expand_to_path(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_view_expand_row(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, open_all: gboolean) gboolean;
pub extern fn gtk_tree_view_collapse_row(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_view_map_expanded_rows(tree_view: [*c]GtkTreeView, func: GtkTreeViewMappingFunc, data: gpointer) void;
pub extern fn gtk_tree_view_row_expanded(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_view_set_reorderable(tree_view: [*c]GtkTreeView, reorderable: gboolean) void;
pub extern fn gtk_tree_view_get_reorderable(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_cursor(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, focus_column: ?*GtkTreeViewColumn, start_editing: gboolean) void;
pub extern fn gtk_tree_view_set_cursor_on_cell(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, focus_column: ?*GtkTreeViewColumn, focus_cell: [*c]GtkCellRenderer, start_editing: gboolean) void;
pub extern fn gtk_tree_view_get_cursor(tree_view: [*c]GtkTreeView, path: [*c]?*GtkTreePath, focus_column: [*c]?*GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_get_path_at_pos(tree_view: [*c]GtkTreeView, x: c_int, y: c_int, path: [*c]?*GtkTreePath, column: [*c]?*GtkTreeViewColumn, cell_x: [*c]c_int, cell_y: [*c]c_int) gboolean;
pub extern fn gtk_tree_view_get_cell_area(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: ?*GtkTreeViewColumn, rect: [*c]GdkRectangle) void;
pub extern fn gtk_tree_view_get_background_area(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: ?*GtkTreeViewColumn, rect: [*c]GdkRectangle) void;
pub extern fn gtk_tree_view_get_visible_rect(tree_view: [*c]GtkTreeView, visible_rect: [*c]GdkRectangle) void;
pub extern fn gtk_tree_view_get_visible_range(tree_view: [*c]GtkTreeView, start_path: [*c]?*GtkTreePath, end_path: [*c]?*GtkTreePath) gboolean;
pub extern fn gtk_tree_view_is_blank_at_pos(tree_view: [*c]GtkTreeView, x: c_int, y: c_int, path: [*c]?*GtkTreePath, column: [*c]?*GtkTreeViewColumn, cell_x: [*c]c_int, cell_y: [*c]c_int) gboolean;
pub extern fn gtk_tree_view_enable_model_drag_source(tree_view: [*c]GtkTreeView, start_button_mask: GdkModifierType, formats: ?*GdkContentFormats, actions: GdkDragAction) void;
pub extern fn gtk_tree_view_enable_model_drag_dest(tree_view: [*c]GtkTreeView, formats: ?*GdkContentFormats, actions: GdkDragAction) void;
pub extern fn gtk_tree_view_unset_rows_drag_source(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_unset_rows_drag_dest(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_set_drag_dest_row(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, pos: GtkTreeViewDropPosition) void;
pub extern fn gtk_tree_view_get_drag_dest_row(tree_view: [*c]GtkTreeView, path: [*c]?*GtkTreePath, pos: [*c]GtkTreeViewDropPosition) void;
pub extern fn gtk_tree_view_get_dest_row_at_pos(tree_view: [*c]GtkTreeView, drag_x: c_int, drag_y: c_int, path: [*c]?*GtkTreePath, pos: [*c]GtkTreeViewDropPosition) gboolean;
pub extern fn gtk_tree_view_create_row_drag_icon(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) ?*GdkPaintable;
pub extern fn gtk_tree_view_set_enable_search(tree_view: [*c]GtkTreeView, enable_search: gboolean) void;
pub extern fn gtk_tree_view_get_enable_search(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_get_search_column(tree_view: [*c]GtkTreeView) c_int;
pub extern fn gtk_tree_view_set_search_column(tree_view: [*c]GtkTreeView, column: c_int) void;
pub extern fn gtk_tree_view_get_search_equal_func(tree_view: [*c]GtkTreeView) GtkTreeViewSearchEqualFunc;
pub extern fn gtk_tree_view_set_search_equal_func(tree_view: [*c]GtkTreeView, search_equal_func: GtkTreeViewSearchEqualFunc, search_user_data: gpointer, search_destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_get_search_entry(tree_view: [*c]GtkTreeView) ?*GtkEditable;
pub extern fn gtk_tree_view_set_search_entry(tree_view: [*c]GtkTreeView, entry: ?*GtkEditable) void;
pub extern fn gtk_tree_view_convert_widget_to_tree_coords(tree_view: [*c]GtkTreeView, wx: c_int, wy: c_int, tx: [*c]c_int, ty: [*c]c_int) void;
pub extern fn gtk_tree_view_convert_tree_to_widget_coords(tree_view: [*c]GtkTreeView, tx: c_int, ty: c_int, wx: [*c]c_int, wy: [*c]c_int) void;
pub extern fn gtk_tree_view_convert_widget_to_bin_window_coords(tree_view: [*c]GtkTreeView, wx: c_int, wy: c_int, bx: [*c]c_int, by: [*c]c_int) void;
pub extern fn gtk_tree_view_convert_bin_window_to_widget_coords(tree_view: [*c]GtkTreeView, bx: c_int, by: c_int, wx: [*c]c_int, wy: [*c]c_int) void;
pub extern fn gtk_tree_view_convert_tree_to_bin_window_coords(tree_view: [*c]GtkTreeView, tx: c_int, ty: c_int, bx: [*c]c_int, by: [*c]c_int) void;
pub extern fn gtk_tree_view_convert_bin_window_to_tree_coords(tree_view: [*c]GtkTreeView, bx: c_int, by: c_int, tx: [*c]c_int, ty: [*c]c_int) void;
pub extern fn gtk_tree_view_set_fixed_height_mode(tree_view: [*c]GtkTreeView, enable: gboolean) void;
pub extern fn gtk_tree_view_get_fixed_height_mode(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_hover_selection(tree_view: [*c]GtkTreeView, hover: gboolean) void;
pub extern fn gtk_tree_view_get_hover_selection(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_hover_expand(tree_view: [*c]GtkTreeView, expand: gboolean) void;
pub extern fn gtk_tree_view_get_hover_expand(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_rubber_banding(tree_view: [*c]GtkTreeView, enable: gboolean) void;
pub extern fn gtk_tree_view_get_rubber_banding(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_is_rubber_banding_active(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_get_row_separator_func(tree_view: [*c]GtkTreeView) GtkTreeViewRowSeparatorFunc;
pub extern fn gtk_tree_view_set_row_separator_func(tree_view: [*c]GtkTreeView, func: GtkTreeViewRowSeparatorFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_get_grid_lines(tree_view: [*c]GtkTreeView) GtkTreeViewGridLines;
pub extern fn gtk_tree_view_set_grid_lines(tree_view: [*c]GtkTreeView, grid_lines: GtkTreeViewGridLines) void;
pub extern fn gtk_tree_view_get_enable_tree_lines(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_enable_tree_lines(tree_view: [*c]GtkTreeView, enabled: gboolean) void;
pub extern fn gtk_tree_view_set_show_expanders(tree_view: [*c]GtkTreeView, enabled: gboolean) void;
pub extern fn gtk_tree_view_get_show_expanders(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_level_indentation(tree_view: [*c]GtkTreeView, indentation: c_int) void;
pub extern fn gtk_tree_view_get_level_indentation(tree_view: [*c]GtkTreeView) c_int;
pub extern fn gtk_tree_view_set_tooltip_row(tree_view: [*c]GtkTreeView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_view_set_tooltip_cell(tree_view: [*c]GtkTreeView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath, column: ?*GtkTreeViewColumn, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_tree_view_get_tooltip_context(tree_view: [*c]GtkTreeView, x: c_int, y: c_int, keyboard_tip: gboolean, model: [*c]?*GtkTreeModel, path: [*c]?*GtkTreePath, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_view_set_tooltip_column(tree_view: [*c]GtkTreeView, column: c_int) void;
pub extern fn gtk_tree_view_get_tooltip_column(tree_view: [*c]GtkTreeView) c_int;
pub const GtkTreeView_autoptr = [*c]GtkTreeView;
pub const GtkTreeView_listautoptr = [*c]GList;
pub const GtkTreeView_slistautoptr = [*c]GSList;
pub const GtkTreeView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeView(arg__ptr: [*c]GtkTreeView) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeView(arg__ptr: [*c][*c]GtkTreeView) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeView(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeView(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeView(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeView(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkComboBox = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkComboBox = struct__GtkComboBox;
pub const struct__GtkComboBoxClass = extern struct {
    parent_class: GtkWidgetClass,
    changed: ?*const fn ([*c]GtkComboBox) callconv(.C) void,
    format_entry_text: ?*const fn ([*c]GtkComboBox, [*c]const u8) callconv(.C) [*c]u8,
    activate: ?*const fn ([*c]GtkComboBox) callconv(.C) void,
    padding: [7]gpointer,
};
pub const GtkComboBoxClass = struct__GtkComboBoxClass;
pub extern fn gtk_combo_box_get_type() GType;
pub extern fn gtk_combo_box_new() [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_entry() [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_model(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_model_and_entry(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_combo_box_get_active(combo_box: [*c]GtkComboBox) c_int;
pub extern fn gtk_combo_box_set_active(combo_box: [*c]GtkComboBox, index_: c_int) void;
pub extern fn gtk_combo_box_get_active_iter(combo_box: [*c]GtkComboBox, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_combo_box_set_active_iter(combo_box: [*c]GtkComboBox, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_combo_box_set_model(combo_box: [*c]GtkComboBox, model: ?*GtkTreeModel) void;
pub extern fn gtk_combo_box_get_model(combo_box: [*c]GtkComboBox) ?*GtkTreeModel;
pub extern fn gtk_combo_box_get_row_separator_func(combo_box: [*c]GtkComboBox) GtkTreeViewRowSeparatorFunc;
pub extern fn gtk_combo_box_set_row_separator_func(combo_box: [*c]GtkComboBox, func: GtkTreeViewRowSeparatorFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_combo_box_set_button_sensitivity(combo_box: [*c]GtkComboBox, sensitivity: GtkSensitivityType) void;
pub extern fn gtk_combo_box_get_button_sensitivity(combo_box: [*c]GtkComboBox) GtkSensitivityType;
pub extern fn gtk_combo_box_get_has_entry(combo_box: [*c]GtkComboBox) gboolean;
pub extern fn gtk_combo_box_set_entry_text_column(combo_box: [*c]GtkComboBox, text_column: c_int) void;
pub extern fn gtk_combo_box_get_entry_text_column(combo_box: [*c]GtkComboBox) c_int;
pub extern fn gtk_combo_box_set_popup_fixed_width(combo_box: [*c]GtkComboBox, fixed: gboolean) void;
pub extern fn gtk_combo_box_get_popup_fixed_width(combo_box: [*c]GtkComboBox) gboolean;
pub extern fn gtk_combo_box_popup(combo_box: [*c]GtkComboBox) void;
pub extern fn gtk_combo_box_popup_for_device(combo_box: [*c]GtkComboBox, device: ?*GdkDevice) void;
pub extern fn gtk_combo_box_popdown(combo_box: [*c]GtkComboBox) void;
pub extern fn gtk_combo_box_get_id_column(combo_box: [*c]GtkComboBox) c_int;
pub extern fn gtk_combo_box_set_id_column(combo_box: [*c]GtkComboBox, id_column: c_int) void;
pub extern fn gtk_combo_box_get_active_id(combo_box: [*c]GtkComboBox) [*c]const u8;
pub extern fn gtk_combo_box_set_active_id(combo_box: [*c]GtkComboBox, active_id: [*c]const u8) gboolean;
pub extern fn gtk_combo_box_set_child(combo_box: [*c]GtkComboBox, child: [*c]GtkWidget) void;
pub extern fn gtk_combo_box_get_child(combo_box: [*c]GtkComboBox) [*c]GtkWidget;
pub const GtkComboBox_autoptr = [*c]GtkComboBox;
pub const GtkComboBox_listautoptr = [*c]GList;
pub const GtkComboBox_slistautoptr = [*c]GSList;
pub const GtkComboBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkComboBox(arg__ptr: [*c]GtkComboBox) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkComboBox(arg__ptr: [*c][*c]GtkComboBox) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkComboBox(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkComboBox(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkComboBox(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkComboBox(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkComboBoxText = opaque {};
pub const GtkComboBoxText = struct__GtkComboBoxText;
pub extern fn gtk_combo_box_text_get_type() GType;
pub extern fn gtk_combo_box_text_new() [*c]GtkWidget;
pub extern fn gtk_combo_box_text_new_with_entry() [*c]GtkWidget;
pub extern fn gtk_combo_box_text_append_text(combo_box: ?*GtkComboBoxText, text: [*c]const u8) void;
pub extern fn gtk_combo_box_text_insert_text(combo_box: ?*GtkComboBoxText, position: c_int, text: [*c]const u8) void;
pub extern fn gtk_combo_box_text_prepend_text(combo_box: ?*GtkComboBoxText, text: [*c]const u8) void;
pub extern fn gtk_combo_box_text_remove(combo_box: ?*GtkComboBoxText, position: c_int) void;
pub extern fn gtk_combo_box_text_remove_all(combo_box: ?*GtkComboBoxText) void;
pub extern fn gtk_combo_box_text_get_active_text(combo_box: ?*GtkComboBoxText) [*c]u8;
pub extern fn gtk_combo_box_text_insert(combo_box: ?*GtkComboBoxText, position: c_int, id: [*c]const u8, text: [*c]const u8) void;
pub extern fn gtk_combo_box_text_append(combo_box: ?*GtkComboBoxText, id: [*c]const u8, text: [*c]const u8) void;
pub extern fn gtk_combo_box_text_prepend(combo_box: ?*GtkComboBoxText, id: [*c]const u8, text: [*c]const u8) void;
pub const GtkComboBoxText_autoptr = ?*GtkComboBoxText;
pub const GtkComboBoxText_listautoptr = [*c]GList;
pub const GtkComboBoxText_slistautoptr = [*c]GSList;
pub const GtkComboBoxText_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkComboBoxText(arg__ptr: ?*GtkComboBoxText) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkComboBoxText(arg__ptr: [*c]?*GtkComboBoxText) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkComboBoxText(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkComboBoxText(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkComboBoxText(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkComboBoxText(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkConstraintTarget = opaque {};
pub const GtkConstraintTarget = struct__GtkConstraintTarget;
pub extern fn gtk_constraint_target_get_type() GType;
pub const struct__GtkConstraintTargetInterface = opaque {};
pub const GtkConstraintTargetInterface = struct__GtkConstraintTargetInterface;
pub const GtkConstraintTarget_autoptr = ?*GtkConstraintTarget;
pub const GtkConstraintTarget_listautoptr = [*c]GList;
pub const GtkConstraintTarget_slistautoptr = [*c]GSList;
pub const GtkConstraintTarget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintTarget(arg__ptr: ?*GtkConstraintTarget) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintTarget(arg__ptr: [*c]?*GtkConstraintTarget) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintTarget(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintTarget(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintTarget(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintTarget(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub fn GTK_CONSTRAINT_TARGET(arg_ptr: gpointer) callconv(.C) ?*GtkConstraintTarget {
    var ptr = arg_ptr;
    return @as(?*GtkConstraintTarget, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_constraint_target_get_type())))));
}
pub fn GTK_IS_CONSTRAINT_TARGET(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_constraint_target_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_CONSTRAINT_TARGET_GET_IFACE(arg_ptr: gpointer) callconv(.C) ?*GtkConstraintTargetInterface {
    var ptr = arg_ptr;
    return @as(?*GtkConstraintTargetInterface, @ptrCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_constraint_target_get_type())));
}
pub extern fn gtk_constraint_get_type() GType;
pub const struct__GtkConstraint = opaque {};
pub const GtkConstraint = struct__GtkConstraint;
pub const GtkConstraintClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkConstraint_autoptr = ?*GtkConstraint;
pub const GtkConstraint_listautoptr = [*c]GList;
pub const GtkConstraint_slistautoptr = [*c]GSList;
pub const GtkConstraint_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraint(arg__ptr: ?*GtkConstraint) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraint(arg__ptr: [*c]?*GtkConstraint) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraint(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraint(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraint(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraint(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkConstraintClass_autoptr = [*c]GtkConstraintClass;
pub const GtkConstraintClass_listautoptr = [*c]GList;
pub const GtkConstraintClass_slistautoptr = [*c]GSList;
pub const GtkConstraintClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintClass(arg__ptr: [*c]GtkConstraintClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintClass(arg__ptr: [*c][*c]GtkConstraintClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CONSTRAINT(arg_ptr: gpointer) callconv(.C) ?*GtkConstraint {
    var ptr = arg_ptr;
    return @as(?*GtkConstraint, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_constraint_get_type())))));
}
pub fn GTK_IS_CONSTRAINT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_constraint_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_constraint_new(target: gpointer, target_attribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: gpointer, source_attribute: GtkConstraintAttribute, multiplier: f64, constant: f64, strength: c_int) ?*GtkConstraint;
pub extern fn gtk_constraint_new_constant(target: gpointer, target_attribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: f64, strength: c_int) ?*GtkConstraint;
pub extern fn gtk_constraint_get_target(constraint: ?*GtkConstraint) ?*GtkConstraintTarget;
pub extern fn gtk_constraint_get_target_attribute(constraint: ?*GtkConstraint) GtkConstraintAttribute;
pub extern fn gtk_constraint_get_source(constraint: ?*GtkConstraint) ?*GtkConstraintTarget;
pub extern fn gtk_constraint_get_source_attribute(constraint: ?*GtkConstraint) GtkConstraintAttribute;
pub extern fn gtk_constraint_get_relation(constraint: ?*GtkConstraint) GtkConstraintRelation;
pub extern fn gtk_constraint_get_multiplier(constraint: ?*GtkConstraint) f64;
pub extern fn gtk_constraint_get_constant(constraint: ?*GtkConstraint) f64;
pub extern fn gtk_constraint_get_strength(constraint: ?*GtkConstraint) c_int;
pub extern fn gtk_constraint_is_required(constraint: ?*GtkConstraint) gboolean;
pub extern fn gtk_constraint_is_attached(constraint: ?*GtkConstraint) gboolean;
pub extern fn gtk_constraint_is_constant(constraint: ?*GtkConstraint) gboolean;
pub extern fn gtk_assistant_page_type_get_type() GType;
pub extern fn gtk_cell_renderer_state_get_type() GType;
pub extern fn gtk_cell_renderer_mode_get_type() GType;
pub extern fn gtk_cell_renderer_accel_mode_get_type() GType;
pub extern fn gtk_dialog_flags_get_type() GType;
pub extern fn gtk_response_type_get_type() GType;
pub extern fn gtk_file_chooser_action_get_type() GType;
pub extern fn gtk_file_chooser_error_get_type() GType;
pub extern fn gtk_font_chooser_level_get_type() GType;
pub extern fn gtk_icon_view_drop_position_get_type() GType;
pub extern fn gtk_buttons_type_get_type() GType;
pub extern fn gtk_style_context_print_flags_get_type() GType;
pub extern fn gtk_tree_model_flags_get_type() GType;
pub extern fn gtk_tree_view_drop_position_get_type() GType;
pub extern fn gtk_tree_view_column_sizing_get_type() GType;
pub extern fn gtk_license_get_type() GType;
pub extern fn gtk_accessible_platform_state_get_type() GType;
pub extern fn gtk_application_inhibit_flags_get_type() GType;
pub extern fn gtk_builder_error_get_type() GType;
pub extern fn gtk_builder_closure_flags_get_type() GType;
pub extern fn gtk_debug_flags_get_type() GType;
pub extern fn gtk_dialog_error_get_type() GType;
pub extern fn gtk_editable_properties_get_type() GType;
pub extern fn gtk_entry_icon_position_get_type() GType;
pub extern fn gtk_align_get_type() GType;
pub extern fn gtk_arrow_type_get_type() GType;
pub extern fn gtk_baseline_position_get_type() GType;
pub extern fn gtk_content_fit_get_type() GType;
pub extern fn gtk_delete_type_get_type() GType;
pub extern fn gtk_direction_type_get_type() GType;
pub extern fn gtk_icon_size_get_type() GType;
pub extern fn gtk_sensitivity_type_get_type() GType;
pub extern fn gtk_text_direction_get_type() GType;
pub extern fn gtk_justification_get_type() GType;
pub extern fn gtk_list_tab_behavior_get_type() GType;
pub extern fn gtk_list_scroll_flags_get_type() GType;
pub extern fn gtk_message_type_get_type() GType;
pub extern fn gtk_movement_step_get_type() GType;
pub extern fn gtk_natural_wrap_mode_get_type() GType;
pub extern fn gtk_scroll_step_get_type() GType;
pub extern fn gtk_orientation_get_type() GType;
pub extern fn gtk_overflow_get_type() GType;
pub extern fn gtk_pack_type_get_type() GType;
pub extern fn gtk_position_type_get_type() GType;
pub extern fn gtk_scroll_type_get_type() GType;
pub extern fn gtk_selection_mode_get_type() GType;
pub extern fn gtk_wrap_mode_get_type() GType;
pub extern fn gtk_sort_type_get_type() GType;
pub extern fn gtk_print_pages_get_type() GType;
pub extern fn gtk_page_set_get_type() GType;
pub extern fn gtk_number_up_layout_get_type() GType;
pub extern fn gtk_ordering_get_type() GType;
pub extern fn gtk_page_orientation_get_type() GType;
pub extern fn gtk_print_quality_get_type() GType;
pub extern fn gtk_print_duplex_get_type() GType;
pub extern fn gtk_unit_get_type() GType;
pub extern fn gtk_tree_view_grid_lines_get_type() GType;
pub extern fn gtk_size_group_mode_get_type() GType;
pub extern fn gtk_size_request_mode_get_type() GType;
pub extern fn gtk_scrollable_policy_get_type() GType;
pub extern fn gtk_state_flags_get_type() GType;
pub extern fn gtk_border_style_get_type() GType;
pub extern fn gtk_level_bar_mode_get_type() GType;
pub extern fn gtk_input_purpose_get_type() GType;
pub extern fn gtk_input_hints_get_type() GType;
pub extern fn gtk_propagation_phase_get_type() GType;
pub extern fn gtk_propagation_limit_get_type() GType;
pub extern fn gtk_event_sequence_state_get_type() GType;
pub extern fn gtk_pan_direction_get_type() GType;
pub extern fn gtk_shortcut_scope_get_type() GType;
pub extern fn gtk_pick_flags_get_type() GType;
pub extern fn gtk_constraint_relation_get_type() GType;
pub extern fn gtk_constraint_strength_get_type() GType;
pub extern fn gtk_constraint_attribute_get_type() GType;
pub extern fn gtk_constraint_vfl_parser_error_get_type() GType;
pub extern fn gtk_system_setting_get_type() GType;
pub extern fn gtk_symbolic_color_get_type() GType;
pub extern fn gtk_accessible_role_get_type() GType;
pub extern fn gtk_accessible_state_get_type() GType;
pub extern fn gtk_accessible_property_get_type() GType;
pub extern fn gtk_accessible_relation_get_type() GType;
pub extern fn gtk_accessible_tristate_get_type() GType;
pub extern fn gtk_accessible_invalid_state_get_type() GType;
pub extern fn gtk_accessible_autocomplete_get_type() GType;
pub extern fn gtk_accessible_sort_get_type() GType;
pub extern fn gtk_event_controller_scroll_flags_get_type() GType;
pub extern fn gtk_filter_match_get_type() GType;
pub extern fn gtk_filter_change_get_type() GType;
pub extern fn gtk_font_level_get_type() GType;
pub extern fn gtk_icon_lookup_flags_get_type() GType;
pub extern fn gtk_icon_theme_error_get_type() GType;
pub extern fn gtk_image_type_get_type() GType;
pub extern fn gtk_inscription_overflow_get_type() GType;
pub extern fn gtk_notebook_tab_get_type() GType;
pub extern fn gtk_pad_action_type_get_type() GType;
pub extern fn gtk_popover_menu_flags_get_type() GType;
pub extern fn gtk_recent_manager_error_get_type() GType;
pub extern fn gtk_revealer_transition_type_get_type() GType;
pub extern fn gtk_corner_type_get_type() GType;
pub extern fn gtk_policy_type_get_type() GType;
pub extern fn gtk_shortcut_action_flags_get_type() GType;
pub extern fn gtk_shortcut_type_get_type() GType;
pub extern fn gtk_sorter_order_get_type() GType;
pub extern fn gtk_sorter_change_get_type() GType;
pub extern fn gtk_spin_button_update_policy_get_type() GType;
pub extern fn gtk_spin_type_get_type() GType;
pub extern fn gtk_stack_transition_type_get_type() GType;
pub extern fn gtk_string_filter_match_mode_get_type() GType;
pub extern fn gtk_collation_get_type() GType;
pub extern fn gtk_text_search_flags_get_type() GType;
pub extern fn gtk_text_window_type_get_type() GType;
pub extern fn gtk_text_view_layer_get_type() GType;
pub extern fn gtk_text_extend_selection_get_type() GType;
pub extern fn gtk_print_status_get_type() GType;
pub extern fn gtk_print_operation_result_get_type() GType;
pub extern fn gtk_print_operation_action_get_type() GType;
pub extern fn gtk_print_error_get_type() GType;
pub extern fn gtk_constraint_guide_get_type() GType;
pub const struct__GtkConstraintGuide = opaque {};
pub const GtkConstraintGuide = struct__GtkConstraintGuide;
pub const GtkConstraintGuideClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkConstraintGuide_autoptr = ?*GtkConstraintGuide;
pub const GtkConstraintGuide_listautoptr = [*c]GList;
pub const GtkConstraintGuide_slistautoptr = [*c]GSList;
pub const GtkConstraintGuide_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintGuide(arg__ptr: ?*GtkConstraintGuide) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintGuide(arg__ptr: [*c]?*GtkConstraintGuide) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintGuide(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintGuide(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintGuide(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintGuide(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkConstraintGuideClass_autoptr = [*c]GtkConstraintGuideClass;
pub const GtkConstraintGuideClass_listautoptr = [*c]GList;
pub const GtkConstraintGuideClass_slistautoptr = [*c]GSList;
pub const GtkConstraintGuideClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintGuideClass(arg__ptr: [*c]GtkConstraintGuideClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintGuideClass(arg__ptr: [*c][*c]GtkConstraintGuideClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintGuideClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintGuideClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintGuideClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintGuideClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CONSTRAINT_GUIDE(arg_ptr: gpointer) callconv(.C) ?*GtkConstraintGuide {
    var ptr = arg_ptr;
    return @as(?*GtkConstraintGuide, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_constraint_guide_get_type())))));
}
pub fn GTK_IS_CONSTRAINT_GUIDE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_constraint_guide_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_constraint_guide_new() ?*GtkConstraintGuide;
pub extern fn gtk_constraint_guide_set_min_size(guide: ?*GtkConstraintGuide, width: c_int, height: c_int) void;
pub extern fn gtk_constraint_guide_get_min_size(guide: ?*GtkConstraintGuide, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_constraint_guide_set_nat_size(guide: ?*GtkConstraintGuide, width: c_int, height: c_int) void;
pub extern fn gtk_constraint_guide_get_nat_size(guide: ?*GtkConstraintGuide, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_constraint_guide_set_max_size(guide: ?*GtkConstraintGuide, width: c_int, height: c_int) void;
pub extern fn gtk_constraint_guide_get_max_size(guide: ?*GtkConstraintGuide, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_constraint_guide_get_strength(guide: ?*GtkConstraintGuide) GtkConstraintStrength;
pub extern fn gtk_constraint_guide_set_strength(guide: ?*GtkConstraintGuide, strength: GtkConstraintStrength) void;
pub extern fn gtk_constraint_guide_set_name(guide: ?*GtkConstraintGuide, name: [*c]const u8) void;
pub extern fn gtk_constraint_guide_get_name(guide: ?*GtkConstraintGuide) [*c]const u8;
pub extern fn gtk_constraint_layout_child_get_type() GType;
pub const struct__GtkConstraintLayoutChild = opaque {};
pub const GtkConstraintLayoutChild = struct__GtkConstraintLayoutChild;
pub const GtkConstraintLayoutChildClass = extern struct {
    parent_class: GtkLayoutChildClass,
};
pub const GtkConstraintLayoutChild_autoptr = ?*GtkConstraintLayoutChild;
pub const GtkConstraintLayoutChild_listautoptr = [*c]GList;
pub const GtkConstraintLayoutChild_slistautoptr = [*c]GSList;
pub const GtkConstraintLayoutChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintLayoutChild(arg__ptr: ?*GtkConstraintLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutChild(@as([*c]GtkLayoutChild, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintLayoutChild(arg__ptr: [*c]?*GtkConstraintLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintLayoutChild(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintLayoutChild(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintLayoutChild(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintLayoutChild(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
    }
}
pub const GtkConstraintLayoutChildClass_autoptr = [*c]GtkConstraintLayoutChildClass;
pub const GtkConstraintLayoutChildClass_listautoptr = [*c]GList;
pub const GtkConstraintLayoutChildClass_slistautoptr = [*c]GSList;
pub const GtkConstraintLayoutChildClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintLayoutChildClass(arg__ptr: [*c]GtkConstraintLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintLayoutChildClass(arg__ptr: [*c][*c]GtkConstraintLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintLayoutChildClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintLayoutChildClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintLayoutChildClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintLayoutChildClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CONSTRAINT_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) ?*GtkConstraintLayoutChild {
    var ptr = arg_ptr;
    return @as(?*GtkConstraintLayoutChild, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_constraint_layout_child_get_type())))));
}
pub fn GTK_IS_CONSTRAINT_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_constraint_layout_child_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_constraint_layout_get_type() GType;
pub const struct__GtkConstraintLayout = opaque {};
pub const GtkConstraintLayout = struct__GtkConstraintLayout;
pub const GtkConstraintLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkConstraintLayout_autoptr = ?*GtkConstraintLayout;
pub const GtkConstraintLayout_listautoptr = [*c]GList;
pub const GtkConstraintLayout_slistautoptr = [*c]GSList;
pub const GtkConstraintLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintLayout(arg__ptr: ?*GtkConstraintLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintLayout(arg__ptr: [*c]?*GtkConstraintLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkConstraintLayoutClass_autoptr = [*c]GtkConstraintLayoutClass;
pub const GtkConstraintLayoutClass_listautoptr = [*c]GList;
pub const GtkConstraintLayoutClass_slistautoptr = [*c]GSList;
pub const GtkConstraintLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkConstraintLayoutClass(arg__ptr: [*c]GtkConstraintLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkConstraintLayoutClass(arg__ptr: [*c][*c]GtkConstraintLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkConstraintLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkConstraintLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkConstraintLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkConstraintLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CONSTRAINT_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkConstraintLayout {
    var ptr = arg_ptr;
    return @as(?*GtkConstraintLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_constraint_layout_get_type())))));
}
pub fn GTK_IS_CONSTRAINT_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_constraint_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_constraint_vfl_parser_error_quark() GQuark;
pub extern fn gtk_constraint_layout_new() [*c]GtkLayoutManager;
pub extern fn gtk_constraint_layout_add_constraint(layout: ?*GtkConstraintLayout, constraint: ?*GtkConstraint) void;
pub extern fn gtk_constraint_layout_remove_constraint(layout: ?*GtkConstraintLayout, constraint: ?*GtkConstraint) void;
pub extern fn gtk_constraint_layout_add_guide(layout: ?*GtkConstraintLayout, guide: ?*GtkConstraintGuide) void;
pub extern fn gtk_constraint_layout_remove_guide(layout: ?*GtkConstraintLayout, guide: ?*GtkConstraintGuide) void;
pub extern fn gtk_constraint_layout_remove_all_constraints(layout: ?*GtkConstraintLayout) void;
pub extern fn gtk_constraint_layout_add_constraints_from_description(layout: ?*GtkConstraintLayout, lines: [*c]const [*c]const u8, n_lines: gsize, hspacing: c_int, vspacing: c_int, @"error": [*c][*c]GError, first_view: [*c]const u8, ...) [*c]GList;
pub extern fn gtk_constraint_layout_add_constraints_from_descriptionv(layout: ?*GtkConstraintLayout, lines: [*c]const [*c]const u8, n_lines: gsize, hspacing: c_int, vspacing: c_int, views: ?*GHashTable, @"error": [*c][*c]GError) [*c]GList;
pub extern fn gtk_constraint_layout_observe_constraints(layout: ?*GtkConstraintLayout) ?*GListModel;
pub extern fn gtk_constraint_layout_observe_guides(layout: ?*GtkConstraintLayout) ?*GListModel;
pub const struct__GtkCssProvider = extern struct {
    parent_instance: GObject,
};
pub const GtkCssProvider = struct__GtkCssProvider;
pub const struct__GtkCssProviderClass = opaque {};
pub const GtkCssProviderClass = struct__GtkCssProviderClass;
pub const struct__GtkCssProviderPrivate = opaque {};
pub const GtkCssProviderPrivate = struct__GtkCssProviderPrivate;
pub extern fn gtk_css_provider_get_type() GType;
pub extern fn gtk_css_provider_new() [*c]GtkCssProvider;
pub extern fn gtk_css_provider_to_string(provider: [*c]GtkCssProvider) [*c]u8;
pub extern fn gtk_css_provider_load_from_data(css_provider: [*c]GtkCssProvider, data: [*c]const u8, length: gssize) void;
pub extern fn gtk_css_provider_load_from_string(css_provider: [*c]GtkCssProvider, string: [*c]const u8) void;
pub extern fn gtk_css_provider_load_from_bytes(css_provider: [*c]GtkCssProvider, data: ?*GBytes) void;
pub extern fn gtk_css_provider_load_from_file(css_provider: [*c]GtkCssProvider, file: ?*GFile) void;
pub extern fn gtk_css_provider_load_from_path(css_provider: [*c]GtkCssProvider, path: [*c]const u8) void;
pub extern fn gtk_css_provider_load_from_resource(css_provider: [*c]GtkCssProvider, resource_path: [*c]const u8) void;
pub extern fn gtk_css_provider_load_named(provider: [*c]GtkCssProvider, name: [*c]const u8, variant: [*c]const u8) void;
pub const GtkCssProvider_autoptr = [*c]GtkCssProvider;
pub const GtkCssProvider_listautoptr = [*c]GList;
pub const GtkCssProvider_slistautoptr = [*c]GSList;
pub const GtkCssProvider_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCssProvider(arg__ptr: [*c]GtkCssProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCssProvider(arg__ptr: [*c][*c]GtkCssProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCssProvider(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCssProvider(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCssProvider(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCssProvider(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkCustomRequestModeFunc = ?*const fn ([*c]GtkWidget) callconv(.C) GtkSizeRequestMode;
pub const GtkCustomMeasureFunc = ?*const fn ([*c]GtkWidget, GtkOrientation, c_int, [*c]c_int, [*c]c_int, [*c]c_int, [*c]c_int) callconv(.C) void;
pub const GtkCustomAllocateFunc = ?*const fn ([*c]GtkWidget, c_int, c_int, c_int) callconv(.C) void;
pub extern fn gtk_custom_layout_get_type() GType;
pub const struct__GtkCustomLayout = opaque {};
pub const GtkCustomLayout = struct__GtkCustomLayout;
pub const GtkCustomLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkCustomLayout_autoptr = ?*GtkCustomLayout;
pub const GtkCustomLayout_listautoptr = [*c]GList;
pub const GtkCustomLayout_slistautoptr = [*c]GSList;
pub const GtkCustomLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCustomLayout(arg__ptr: ?*GtkCustomLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkCustomLayout(arg__ptr: [*c]?*GtkCustomLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCustomLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCustomLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCustomLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCustomLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkCustomLayoutClass_autoptr = [*c]GtkCustomLayoutClass;
pub const GtkCustomLayoutClass_listautoptr = [*c]GList;
pub const GtkCustomLayoutClass_slistautoptr = [*c]GSList;
pub const GtkCustomLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCustomLayoutClass(arg__ptr: [*c]GtkCustomLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCustomLayoutClass(arg__ptr: [*c][*c]GtkCustomLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCustomLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCustomLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCustomLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCustomLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CUSTOM_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkCustomLayout {
    var ptr = arg_ptr;
    return @as(?*GtkCustomLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_custom_layout_get_type())))));
}
pub fn GTK_IS_CUSTOM_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_custom_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_custom_layout_new(request_mode: GtkCustomRequestModeFunc, measure: GtkCustomMeasureFunc, allocate: GtkCustomAllocateFunc) [*c]GtkLayoutManager;
pub extern fn gtk_custom_sorter_get_type() GType;
pub const struct__GtkCustomSorter = opaque {};
pub const GtkCustomSorter = struct__GtkCustomSorter;
pub const GtkCustomSorterClass = extern struct {
    parent_class: GtkSorterClass,
};
pub const GtkCustomSorter_autoptr = ?*GtkCustomSorter;
pub const GtkCustomSorter_listautoptr = [*c]GList;
pub const GtkCustomSorter_slistautoptr = [*c]GSList;
pub const GtkCustomSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCustomSorter(arg__ptr: ?*GtkCustomSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkSorter(@as([*c]GtkSorter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkCustomSorter(arg__ptr: [*c]?*GtkCustomSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCustomSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCustomSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCustomSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCustomSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
    }
}
pub const GtkCustomSorterClass_autoptr = [*c]GtkCustomSorterClass;
pub const GtkCustomSorterClass_listautoptr = [*c]GList;
pub const GtkCustomSorterClass_slistautoptr = [*c]GSList;
pub const GtkCustomSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCustomSorterClass(arg__ptr: [*c]GtkCustomSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCustomSorterClass(arg__ptr: [*c][*c]GtkCustomSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCustomSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCustomSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCustomSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCustomSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CUSTOM_SORTER(arg_ptr: gpointer) callconv(.C) ?*GtkCustomSorter {
    var ptr = arg_ptr;
    return @as(?*GtkCustomSorter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_custom_sorter_get_type())))));
}
pub fn GTK_IS_CUSTOM_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_custom_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_custom_sorter_new(sort_func: GCompareDataFunc, user_data: gpointer, user_destroy: GDestroyNotify) ?*GtkCustomSorter;
pub extern fn gtk_custom_sorter_set_sort_func(self: ?*GtkCustomSorter, sort_func: GCompareDataFunc, user_data: gpointer, user_destroy: GDestroyNotify) void;
pub const GTK_DEBUG_TEXT: c_int = 1;
pub const GTK_DEBUG_TREE: c_int = 2;
pub const GTK_DEBUG_KEYBINDINGS: c_int = 4;
pub const GTK_DEBUG_MODULES: c_int = 8;
pub const GTK_DEBUG_GEOMETRY: c_int = 16;
pub const GTK_DEBUG_ICONTHEME: c_int = 32;
pub const GTK_DEBUG_PRINTING: c_int = 64;
pub const GTK_DEBUG_BUILDER: c_int = 128;
pub const GTK_DEBUG_SIZE_REQUEST: c_int = 256;
pub const GTK_DEBUG_NO_CSS_CACHE: c_int = 512;
pub const GTK_DEBUG_INTERACTIVE: c_int = 1024;
pub const GTK_DEBUG_ACTIONS: c_int = 4096;
pub const GTK_DEBUG_LAYOUT: c_int = 8192;
pub const GTK_DEBUG_SNAPSHOT: c_int = 16384;
pub const GTK_DEBUG_CONSTRAINTS: c_int = 32768;
pub const GTK_DEBUG_BUILDER_OBJECTS: c_int = 65536;
pub const GTK_DEBUG_A11Y: c_int = 131072;
pub const GTK_DEBUG_ICONFALLBACK: c_int = 262144;
pub const GTK_DEBUG_INVERT_TEXT_DIR: c_int = 524288;
pub const GtkDebugFlags = c_uint;
pub extern fn gtk_get_debug_flags() GtkDebugFlags;
pub extern fn gtk_set_debug_flags(flags: GtkDebugFlags) void;
pub const GTK_DIALOG_ERROR_FAILED: c_int = 0;
pub const GTK_DIALOG_ERROR_CANCELLED: c_int = 1;
pub const GTK_DIALOG_ERROR_DISMISSED: c_int = 2;
pub const GtkDialogError = c_uint;
pub extern fn gtk_dialog_error_quark() GQuark;
pub extern fn gtk_directory_list_get_type() GType;
pub const struct__GtkDirectoryList = opaque {};
pub const GtkDirectoryList = struct__GtkDirectoryList;
pub const GtkDirectoryListClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkDirectoryList_autoptr = ?*GtkDirectoryList;
pub const GtkDirectoryList_listautoptr = [*c]GList;
pub const GtkDirectoryList_slistautoptr = [*c]GSList;
pub const GtkDirectoryList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDirectoryList(arg__ptr: ?*GtkDirectoryList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkDirectoryList(arg__ptr: [*c]?*GtkDirectoryList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDirectoryList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDirectoryList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDirectoryList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDirectoryList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkDirectoryListClass_autoptr = [*c]GtkDirectoryListClass;
pub const GtkDirectoryListClass_listautoptr = [*c]GList;
pub const GtkDirectoryListClass_slistautoptr = [*c]GSList;
pub const GtkDirectoryListClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDirectoryListClass(arg__ptr: [*c]GtkDirectoryListClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkDirectoryListClass(arg__ptr: [*c][*c]GtkDirectoryListClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDirectoryListClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDirectoryListClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDirectoryListClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDirectoryListClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_DIRECTORY_LIST(arg_ptr: gpointer) callconv(.C) ?*GtkDirectoryList {
    var ptr = arg_ptr;
    return @as(?*GtkDirectoryList, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_directory_list_get_type())))));
}
pub fn GTK_IS_DIRECTORY_LIST(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_directory_list_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_directory_list_new(attributes: [*c]const u8, file: ?*GFile) ?*GtkDirectoryList;
pub extern fn gtk_directory_list_set_file(self: ?*GtkDirectoryList, file: ?*GFile) void;
pub extern fn gtk_directory_list_get_file(self: ?*GtkDirectoryList) ?*GFile;
pub extern fn gtk_directory_list_set_attributes(self: ?*GtkDirectoryList, attributes: [*c]const u8) void;
pub extern fn gtk_directory_list_get_attributes(self: ?*GtkDirectoryList) [*c]const u8;
pub extern fn gtk_directory_list_set_io_priority(self: ?*GtkDirectoryList, io_priority: c_int) void;
pub extern fn gtk_directory_list_get_io_priority(self: ?*GtkDirectoryList) c_int;
pub extern fn gtk_directory_list_is_loading(self: ?*GtkDirectoryList) gboolean;
pub extern fn gtk_directory_list_get_error(self: ?*GtkDirectoryList) [*c]const GError;
pub extern fn gtk_directory_list_set_monitored(self: ?*GtkDirectoryList, monitored: gboolean) void;
pub extern fn gtk_directory_list_get_monitored(self: ?*GtkDirectoryList) gboolean;
pub extern fn gtk_drag_icon_get_type() GType;
pub const struct__GtkDragIcon = opaque {};
pub const GtkDragIcon = struct__GtkDragIcon;
pub const GtkDragIconClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkDragIcon_autoptr = ?*GtkDragIcon;
pub const GtkDragIcon_listautoptr = [*c]GList;
pub const GtkDragIcon_slistautoptr = [*c]GSList;
pub const GtkDragIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDragIcon(arg__ptr: ?*GtkDragIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkDragIcon(arg__ptr: [*c]?*GtkDragIcon) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDragIcon(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDragIcon(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDragIcon(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDragIcon(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkDragIconClass_autoptr = [*c]GtkDragIconClass;
pub const GtkDragIconClass_listautoptr = [*c]GList;
pub const GtkDragIconClass_slistautoptr = [*c]GSList;
pub const GtkDragIconClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDragIconClass(arg__ptr: [*c]GtkDragIconClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkDragIconClass(arg__ptr: [*c][*c]GtkDragIconClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDragIconClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDragIconClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDragIconClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDragIconClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_DRAG_ICON(arg_ptr: gpointer) callconv(.C) ?*GtkDragIcon {
    var ptr = arg_ptr;
    return @as(?*GtkDragIcon, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_drag_icon_get_type())))));
}
pub fn GTK_IS_DRAG_ICON(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_drag_icon_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_drag_icon_get_for_drag(drag: ?*GdkDrag) [*c]GtkWidget;
pub extern fn gtk_drag_icon_set_child(self: ?*GtkDragIcon, child: [*c]GtkWidget) void;
pub extern fn gtk_drag_icon_get_child(self: ?*GtkDragIcon) [*c]GtkWidget;
pub extern fn gtk_drag_icon_set_from_paintable(drag: ?*GdkDrag, paintable: ?*GdkPaintable, hot_x: c_int, hot_y: c_int) void;
pub extern fn gtk_drag_icon_create_widget_for_value(value: [*c]const GValue) [*c]GtkWidget;
pub const struct__GtkDragSource = opaque {};
pub const GtkDragSource = struct__GtkDragSource;
pub const struct__GtkDragSourceClass = opaque {};
pub const GtkDragSourceClass = struct__GtkDragSourceClass;
pub extern fn gtk_drag_source_get_type() GType;
pub extern fn gtk_drag_source_new() ?*GtkDragSource;
pub extern fn gtk_drag_source_set_content(source: ?*GtkDragSource, content: [*c]GdkContentProvider) void;
pub extern fn gtk_drag_source_get_content(source: ?*GtkDragSource) [*c]GdkContentProvider;
pub extern fn gtk_drag_source_set_actions(source: ?*GtkDragSource, actions: GdkDragAction) void;
pub extern fn gtk_drag_source_get_actions(source: ?*GtkDragSource) GdkDragAction;
pub extern fn gtk_drag_source_set_icon(source: ?*GtkDragSource, paintable: ?*GdkPaintable, hot_x: c_int, hot_y: c_int) void;
pub extern fn gtk_drag_source_drag_cancel(source: ?*GtkDragSource) void;
pub extern fn gtk_drag_source_get_drag(source: ?*GtkDragSource) ?*GdkDrag;
pub extern fn gtk_drag_check_threshold(widget: [*c]GtkWidget, start_x: c_int, start_y: c_int, current_x: c_int, current_y: c_int) gboolean;
pub const struct__GtkDrawingArea = extern struct {
    widget: GtkWidget,
};
pub const GtkDrawingArea = struct__GtkDrawingArea;
pub const struct__GtkDrawingAreaClass = extern struct {
    parent_class: GtkWidgetClass,
    resize: ?*const fn ([*c]GtkDrawingArea, c_int, c_int) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkDrawingAreaClass = struct__GtkDrawingAreaClass;
pub const GtkDrawingAreaDrawFunc = ?*const fn ([*c]GtkDrawingArea, ?*cairo_t, c_int, c_int, gpointer) callconv(.C) void;
pub extern fn gtk_drawing_area_get_type() GType;
pub extern fn gtk_drawing_area_new() [*c]GtkWidget;
pub extern fn gtk_drawing_area_set_content_width(self: [*c]GtkDrawingArea, width: c_int) void;
pub extern fn gtk_drawing_area_get_content_width(self: [*c]GtkDrawingArea) c_int;
pub extern fn gtk_drawing_area_set_content_height(self: [*c]GtkDrawingArea, height: c_int) void;
pub extern fn gtk_drawing_area_get_content_height(self: [*c]GtkDrawingArea) c_int;
pub extern fn gtk_drawing_area_set_draw_func(self: [*c]GtkDrawingArea, draw_func: GtkDrawingAreaDrawFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub const GtkDrawingArea_autoptr = [*c]GtkDrawingArea;
pub const GtkDrawingArea_listautoptr = [*c]GList;
pub const GtkDrawingArea_slistautoptr = [*c]GSList;
pub const GtkDrawingArea_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDrawingArea(arg__ptr: [*c]GtkDrawingArea) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkDrawingArea(arg__ptr: [*c][*c]GtkDrawingArea) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDrawingArea(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDrawingArea(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDrawingArea(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDrawingArea(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkEventControllerClass = opaque {};
pub const GtkEventControllerClass = struct__GtkEventControllerClass;
pub extern fn gtk_event_controller_get_type() GType;
pub extern fn gtk_event_controller_get_widget(controller: ?*GtkEventController) [*c]GtkWidget;
pub extern fn gtk_event_controller_reset(controller: ?*GtkEventController) void;
pub extern fn gtk_event_controller_get_propagation_phase(controller: ?*GtkEventController) GtkPropagationPhase;
pub extern fn gtk_event_controller_set_propagation_phase(controller: ?*GtkEventController, phase: GtkPropagationPhase) void;
pub extern fn gtk_event_controller_get_propagation_limit(controller: ?*GtkEventController) GtkPropagationLimit;
pub extern fn gtk_event_controller_set_propagation_limit(controller: ?*GtkEventController, limit: GtkPropagationLimit) void;
pub extern fn gtk_event_controller_get_name(controller: ?*GtkEventController) [*c]const u8;
pub extern fn gtk_event_controller_set_name(controller: ?*GtkEventController, name: [*c]const u8) void;
pub extern fn gtk_event_controller_set_static_name(controller: ?*GtkEventController, name: [*c]const u8) void;
pub extern fn gtk_event_controller_get_current_event(controller: ?*GtkEventController) ?*GdkEvent;
pub extern fn gtk_event_controller_get_current_event_time(controller: ?*GtkEventController) guint32;
pub extern fn gtk_event_controller_get_current_event_device(controller: ?*GtkEventController) ?*GdkDevice;
pub extern fn gtk_event_controller_get_current_event_state(controller: ?*GtkEventController) GdkModifierType;
pub const GtkEventController_autoptr = ?*GtkEventController;
pub const GtkEventController_listautoptr = [*c]GList;
pub const GtkEventController_slistautoptr = [*c]GSList;
pub const GtkEventController_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEventController(arg__ptr: ?*GtkEventController) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEventController(arg__ptr: [*c]?*GtkEventController) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEventController(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEventController(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEventController(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEventController(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkDropControllerMotion = opaque {};
pub const GtkDropControllerMotion = struct__GtkDropControllerMotion;
pub const struct__GtkDropControllerMotionClass = opaque {};
pub const GtkDropControllerMotionClass = struct__GtkDropControllerMotionClass;
pub extern fn gtk_drop_controller_motion_get_type() GType;
pub extern fn gtk_drop_controller_motion_new() ?*GtkEventController;
pub extern fn gtk_drop_controller_motion_contains_pointer(self: ?*GtkDropControllerMotion) gboolean;
pub extern fn gtk_drop_controller_motion_get_drop(self: ?*GtkDropControllerMotion) ?*GdkDrop;
pub extern fn gtk_drop_controller_motion_is_pointer(self: ?*GtkDropControllerMotion) gboolean;
pub const struct__GtkDropTarget = opaque {};
pub const GtkDropTarget = struct__GtkDropTarget;
pub const struct__GtkDropTargetClass = opaque {};
pub const GtkDropTargetClass = struct__GtkDropTargetClass;
pub extern fn gtk_drop_target_get_type() GType;
pub extern fn gtk_drop_target_new(@"type": GType, actions: GdkDragAction) ?*GtkDropTarget;
pub extern fn gtk_drop_target_set_gtypes(self: ?*GtkDropTarget, types: [*c]GType, n_types: gsize) void;
pub extern fn gtk_drop_target_get_gtypes(self: ?*GtkDropTarget, n_types: [*c]gsize) [*c]const GType;
pub extern fn gtk_drop_target_get_formats(self: ?*GtkDropTarget) ?*GdkContentFormats;
pub extern fn gtk_drop_target_set_actions(self: ?*GtkDropTarget, actions: GdkDragAction) void;
pub extern fn gtk_drop_target_get_actions(self: ?*GtkDropTarget) GdkDragAction;
pub extern fn gtk_drop_target_set_preload(self: ?*GtkDropTarget, preload: gboolean) void;
pub extern fn gtk_drop_target_get_preload(self: ?*GtkDropTarget) gboolean;
pub extern fn gtk_drop_target_get_drop(self: ?*GtkDropTarget) ?*GdkDrop;
pub extern fn gtk_drop_target_get_current_drop(self: ?*GtkDropTarget) ?*GdkDrop;
pub extern fn gtk_drop_target_get_value(self: ?*GtkDropTarget) [*c]const GValue;
pub extern fn gtk_drop_target_reject(self: ?*GtkDropTarget) void;
pub const struct__GtkDropTargetAsync = opaque {};
pub const GtkDropTargetAsync = struct__GtkDropTargetAsync;
pub const struct__GtkDropTargetAsyncClass = opaque {};
pub const GtkDropTargetAsyncClass = struct__GtkDropTargetAsyncClass;
pub extern fn gtk_drop_target_async_get_type() GType;
pub extern fn gtk_drop_target_async_new(formats: ?*GdkContentFormats, actions: GdkDragAction) ?*GtkDropTargetAsync;
pub extern fn gtk_drop_target_async_set_formats(self: ?*GtkDropTargetAsync, formats: ?*GdkContentFormats) void;
pub extern fn gtk_drop_target_async_get_formats(self: ?*GtkDropTargetAsync) ?*GdkContentFormats;
pub extern fn gtk_drop_target_async_set_actions(self: ?*GtkDropTargetAsync, actions: GdkDragAction) void;
pub extern fn gtk_drop_target_async_get_actions(self: ?*GtkDropTargetAsync) GdkDragAction;
pub extern fn gtk_drop_target_async_reject_drop(self: ?*GtkDropTargetAsync, drop: ?*GdkDrop) void;
pub const GTK_STRING_FILTER_MATCH_MODE_EXACT: c_int = 0;
pub const GTK_STRING_FILTER_MATCH_MODE_SUBSTRING: c_int = 1;
pub const GTK_STRING_FILTER_MATCH_MODE_PREFIX: c_int = 2;
pub const GtkStringFilterMatchMode = c_uint;
pub extern fn gtk_string_filter_get_type() GType;
pub const struct__GtkStringFilter = opaque {};
pub const GtkStringFilter = struct__GtkStringFilter;
pub const GtkStringFilterClass = extern struct {
    parent_class: GtkFilterClass,
};
pub const GtkStringFilter_autoptr = ?*GtkStringFilter;
pub const GtkStringFilter_listautoptr = [*c]GList;
pub const GtkStringFilter_slistautoptr = [*c]GSList;
pub const GtkStringFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringFilter(arg__ptr: ?*GtkStringFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkFilter(@as([*c]GtkFilter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkStringFilter(arg__ptr: [*c]?*GtkStringFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
    }
}
pub const GtkStringFilterClass_autoptr = [*c]GtkStringFilterClass;
pub const GtkStringFilterClass_listautoptr = [*c]GList;
pub const GtkStringFilterClass_slistautoptr = [*c]GSList;
pub const GtkStringFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringFilterClass(arg__ptr: [*c]GtkStringFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStringFilterClass(arg__ptr: [*c][*c]GtkStringFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_STRING_FILTER(arg_ptr: gpointer) callconv(.C) ?*GtkStringFilter {
    var ptr = arg_ptr;
    return @as(?*GtkStringFilter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_string_filter_get_type())))));
}
pub fn GTK_IS_STRING_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_string_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_string_filter_new(expression: ?*GtkExpression) ?*GtkStringFilter;
pub extern fn gtk_string_filter_get_search(self: ?*GtkStringFilter) [*c]const u8;
pub extern fn gtk_string_filter_set_search(self: ?*GtkStringFilter, search: [*c]const u8) void;
pub extern fn gtk_string_filter_get_expression(self: ?*GtkStringFilter) ?*GtkExpression;
pub extern fn gtk_string_filter_set_expression(self: ?*GtkStringFilter, expression: ?*GtkExpression) void;
pub extern fn gtk_string_filter_get_ignore_case(self: ?*GtkStringFilter) gboolean;
pub extern fn gtk_string_filter_set_ignore_case(self: ?*GtkStringFilter, ignore_case: gboolean) void;
pub extern fn gtk_string_filter_get_match_mode(self: ?*GtkStringFilter) GtkStringFilterMatchMode;
pub extern fn gtk_string_filter_set_match_mode(self: ?*GtkStringFilter, mode: GtkStringFilterMatchMode) void;
pub extern fn gtk_drop_down_get_type() GType;
pub const struct__GtkDropDown = opaque {};
pub const GtkDropDown = struct__GtkDropDown;
pub const GtkDropDownClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkDropDown_autoptr = ?*GtkDropDown;
pub const GtkDropDown_listautoptr = [*c]GList;
pub const GtkDropDown_slistautoptr = [*c]GSList;
pub const GtkDropDown_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDropDown(arg__ptr: ?*GtkDropDown) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkDropDown(arg__ptr: [*c]?*GtkDropDown) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDropDown(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDropDown(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDropDown(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDropDown(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkDropDownClass_autoptr = [*c]GtkDropDownClass;
pub const GtkDropDownClass_listautoptr = [*c]GList;
pub const GtkDropDownClass_slistautoptr = [*c]GSList;
pub const GtkDropDownClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDropDownClass(arg__ptr: [*c]GtkDropDownClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkDropDownClass(arg__ptr: [*c][*c]GtkDropDownClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkDropDownClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkDropDownClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkDropDownClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkDropDownClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_DROP_DOWN(arg_ptr: gpointer) callconv(.C) ?*GtkDropDown {
    var ptr = arg_ptr;
    return @as(?*GtkDropDown, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_drop_down_get_type())))));
}
pub fn GTK_IS_DROP_DOWN(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_drop_down_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_drop_down_new(model: ?*GListModel, expression: ?*GtkExpression) [*c]GtkWidget;
pub extern fn gtk_drop_down_new_from_strings(strings: [*c]const [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_drop_down_set_model(self: ?*GtkDropDown, model: ?*GListModel) void;
pub extern fn gtk_drop_down_get_model(self: ?*GtkDropDown) ?*GListModel;
pub extern fn gtk_drop_down_set_selected(self: ?*GtkDropDown, position: guint) void;
pub extern fn gtk_drop_down_get_selected(self: ?*GtkDropDown) guint;
pub extern fn gtk_drop_down_get_selected_item(self: ?*GtkDropDown) gpointer;
pub extern fn gtk_drop_down_set_factory(self: ?*GtkDropDown, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_drop_down_get_factory(self: ?*GtkDropDown) ?*GtkListItemFactory;
pub extern fn gtk_drop_down_set_list_factory(self: ?*GtkDropDown, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_drop_down_get_list_factory(self: ?*GtkDropDown) ?*GtkListItemFactory;
pub extern fn gtk_drop_down_set_header_factory(self: ?*GtkDropDown, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_drop_down_get_header_factory(self: ?*GtkDropDown) ?*GtkListItemFactory;
pub extern fn gtk_drop_down_set_expression(self: ?*GtkDropDown, expression: ?*GtkExpression) void;
pub extern fn gtk_drop_down_get_expression(self: ?*GtkDropDown) ?*GtkExpression;
pub extern fn gtk_drop_down_set_enable_search(self: ?*GtkDropDown, enable_search: gboolean) void;
pub extern fn gtk_drop_down_get_enable_search(self: ?*GtkDropDown) gboolean;
pub extern fn gtk_drop_down_set_show_arrow(self: ?*GtkDropDown, show_arrow: gboolean) void;
pub extern fn gtk_drop_down_get_show_arrow(self: ?*GtkDropDown) gboolean;
pub extern fn gtk_drop_down_set_search_match_mode(self: ?*GtkDropDown, search_match_mode: GtkStringFilterMatchMode) void;
pub extern fn gtk_drop_down_get_search_match_mode(self: ?*GtkDropDown) GtkStringFilterMatchMode;
pub extern fn gtk_editable_label_get_type() GType;
pub const struct__GtkEditableLabel = opaque {};
pub const GtkEditableLabel = struct__GtkEditableLabel;
pub const GtkEditableLabelClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkEditableLabel_autoptr = ?*GtkEditableLabel;
pub const GtkEditableLabel_listautoptr = [*c]GList;
pub const GtkEditableLabel_slistautoptr = [*c]GSList;
pub const GtkEditableLabel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEditableLabel(arg__ptr: ?*GtkEditableLabel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkEditableLabel(arg__ptr: [*c]?*GtkEditableLabel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEditableLabel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEditableLabel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEditableLabel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEditableLabel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkEditableLabelClass_autoptr = [*c]GtkEditableLabelClass;
pub const GtkEditableLabelClass_listautoptr = [*c]GList;
pub const GtkEditableLabelClass_slistautoptr = [*c]GSList;
pub const GtkEditableLabelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEditableLabelClass(arg__ptr: [*c]GtkEditableLabelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEditableLabelClass(arg__ptr: [*c][*c]GtkEditableLabelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEditableLabelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEditableLabelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEditableLabelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEditableLabelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_EDITABLE_LABEL(arg_ptr: gpointer) callconv(.C) ?*GtkEditableLabel {
    var ptr = arg_ptr;
    return @as(?*GtkEditableLabel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_editable_label_get_type())))));
}
pub fn GTK_IS_EDITABLE_LABEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_editable_label_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_editable_label_new(str: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_editable_label_get_editing(self: ?*GtkEditableLabel) gboolean;
pub extern fn gtk_editable_label_start_editing(self: ?*GtkEditableLabel) void;
pub extern fn gtk_editable_label_stop_editing(self: ?*GtkEditableLabel, commit: gboolean) void;
pub const struct__GtkEmojiChooser = opaque {};
pub const GtkEmojiChooser = struct__GtkEmojiChooser;
pub const struct__GtkEmojiChooserClass = opaque {};
pub const GtkEmojiChooserClass = struct__GtkEmojiChooserClass;
pub extern fn gtk_emoji_chooser_get_type() GType;
pub extern fn gtk_emoji_chooser_new() [*c]GtkWidget;
pub const struct__GtkEventControllerFocus = opaque {};
pub const GtkEventControllerFocus = struct__GtkEventControllerFocus;
pub const struct__GtkEventControllerFocusClass = opaque {};
pub const GtkEventControllerFocusClass = struct__GtkEventControllerFocusClass;
pub extern fn gtk_event_controller_focus_get_type() GType;
pub extern fn gtk_event_controller_focus_new() ?*GtkEventController;
pub extern fn gtk_event_controller_focus_contains_focus(self: ?*GtkEventControllerFocus) gboolean;
pub extern fn gtk_event_controller_focus_is_focus(self: ?*GtkEventControllerFocus) gboolean;
pub const struct__GtkEventControllerKey = opaque {};
pub const GtkEventControllerKey = struct__GtkEventControllerKey;
pub const struct__GtkEventControllerKeyClass = opaque {};
pub const GtkEventControllerKeyClass = struct__GtkEventControllerKeyClass;
pub extern fn gtk_event_controller_key_get_type() GType;
pub extern fn gtk_event_controller_key_new() ?*GtkEventController;
pub extern fn gtk_event_controller_key_set_im_context(controller: ?*GtkEventControllerKey, im_context: [*c]GtkIMContext) void;
pub extern fn gtk_event_controller_key_get_im_context(controller: ?*GtkEventControllerKey) [*c]GtkIMContext;
pub extern fn gtk_event_controller_key_forward(controller: ?*GtkEventControllerKey, widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_event_controller_key_get_group(controller: ?*GtkEventControllerKey) guint;
pub const struct__GtkEventControllerLegacy = opaque {};
pub const GtkEventControllerLegacy = struct__GtkEventControllerLegacy;
pub const struct__GtkEventControllerLegacyClass = opaque {};
pub const GtkEventControllerLegacyClass = struct__GtkEventControllerLegacyClass;
pub extern fn gtk_event_controller_legacy_get_type() GType;
pub extern fn gtk_event_controller_legacy_new() ?*GtkEventController;
pub const struct__GtkEventControllerMotion = opaque {};
pub const GtkEventControllerMotion = struct__GtkEventControllerMotion;
pub const struct__GtkEventControllerMotionClass = opaque {};
pub const GtkEventControllerMotionClass = struct__GtkEventControllerMotionClass;
pub extern fn gtk_event_controller_motion_get_type() GType;
pub extern fn gtk_event_controller_motion_new() ?*GtkEventController;
pub extern fn gtk_event_controller_motion_contains_pointer(self: ?*GtkEventControllerMotion) gboolean;
pub extern fn gtk_event_controller_motion_is_pointer(self: ?*GtkEventControllerMotion) gboolean;
pub const struct__GtkEventControllerScroll = opaque {};
pub const GtkEventControllerScroll = struct__GtkEventControllerScroll;
pub const struct__GtkEventControllerScrollClass = opaque {};
pub const GtkEventControllerScrollClass = struct__GtkEventControllerScrollClass;
pub const GTK_EVENT_CONTROLLER_SCROLL_NONE: c_int = 0;
pub const GTK_EVENT_CONTROLLER_SCROLL_VERTICAL: c_int = 1;
pub const GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL: c_int = 2;
pub const GTK_EVENT_CONTROLLER_SCROLL_DISCRETE: c_int = 4;
pub const GTK_EVENT_CONTROLLER_SCROLL_KINETIC: c_int = 8;
pub const GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES: c_int = 3;
pub const GtkEventControllerScrollFlags = c_uint;
pub extern fn gtk_event_controller_scroll_get_type() GType;
pub extern fn gtk_event_controller_scroll_new(flags: GtkEventControllerScrollFlags) ?*GtkEventController;
pub extern fn gtk_event_controller_scroll_set_flags(scroll: ?*GtkEventControllerScroll, flags: GtkEventControllerScrollFlags) void;
pub extern fn gtk_event_controller_scroll_get_flags(scroll: ?*GtkEventControllerScroll) GtkEventControllerScrollFlags;
pub extern fn gtk_event_controller_scroll_get_unit(scroll: ?*GtkEventControllerScroll) GdkScrollUnit;
pub const struct__GtkExpander = opaque {};
pub const GtkExpander = struct__GtkExpander;
pub extern fn gtk_expander_get_type() GType;
pub extern fn gtk_expander_new(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_expander_new_with_mnemonic(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_expander_set_expanded(expander: ?*GtkExpander, expanded: gboolean) void;
pub extern fn gtk_expander_get_expanded(expander: ?*GtkExpander) gboolean;
pub extern fn gtk_expander_set_label(expander: ?*GtkExpander, label: [*c]const u8) void;
pub extern fn gtk_expander_get_label(expander: ?*GtkExpander) [*c]const u8;
pub extern fn gtk_expander_set_use_underline(expander: ?*GtkExpander, use_underline: gboolean) void;
pub extern fn gtk_expander_get_use_underline(expander: ?*GtkExpander) gboolean;
pub extern fn gtk_expander_set_use_markup(expander: ?*GtkExpander, use_markup: gboolean) void;
pub extern fn gtk_expander_get_use_markup(expander: ?*GtkExpander) gboolean;
pub extern fn gtk_expander_set_label_widget(expander: ?*GtkExpander, label_widget: [*c]GtkWidget) void;
pub extern fn gtk_expander_get_label_widget(expander: ?*GtkExpander) [*c]GtkWidget;
pub extern fn gtk_expander_set_resize_toplevel(expander: ?*GtkExpander, resize_toplevel: gboolean) void;
pub extern fn gtk_expander_get_resize_toplevel(expander: ?*GtkExpander) gboolean;
pub extern fn gtk_expander_set_child(expander: ?*GtkExpander, child: [*c]GtkWidget) void;
pub extern fn gtk_expander_get_child(expander: ?*GtkExpander) [*c]GtkWidget;
pub const GtkExpander_autoptr = ?*GtkExpander;
pub const GtkExpander_listautoptr = [*c]GList;
pub const GtkExpander_slistautoptr = [*c]GSList;
pub const GtkExpander_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkExpander(arg__ptr: ?*GtkExpander) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkExpander(arg__ptr: [*c]?*GtkExpander) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkExpander(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkExpander(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkExpander(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkExpander(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkFixed = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkFixed = struct__GtkFixed;
pub const struct__GtkFixedClass = extern struct {
    parent_class: GtkWidgetClass,
    padding: [8]gpointer,
};
pub const GtkFixedClass = struct__GtkFixedClass;
pub extern fn gtk_fixed_get_type() GType;
pub extern fn gtk_fixed_new() [*c]GtkWidget;
pub extern fn gtk_fixed_put(fixed: [*c]GtkFixed, widget: [*c]GtkWidget, x: f64, y: f64) void;
pub extern fn gtk_fixed_remove(fixed: [*c]GtkFixed, widget: [*c]GtkWidget) void;
pub extern fn gtk_fixed_move(fixed: [*c]GtkFixed, widget: [*c]GtkWidget, x: f64, y: f64) void;
pub extern fn gtk_fixed_get_child_position(fixed: [*c]GtkFixed, widget: [*c]GtkWidget, x: [*c]f64, y: [*c]f64) void;
pub extern fn gtk_fixed_set_child_transform(fixed: [*c]GtkFixed, widget: [*c]GtkWidget, transform: ?*GskTransform) void;
pub extern fn gtk_fixed_get_child_transform(fixed: [*c]GtkFixed, widget: [*c]GtkWidget) ?*GskTransform;
pub const GtkFixed_autoptr = [*c]GtkFixed;
pub const GtkFixed_listautoptr = [*c]GList;
pub const GtkFixed_slistautoptr = [*c]GSList;
pub const GtkFixed_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFixed(arg__ptr: [*c]GtkFixed) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFixed(arg__ptr: [*c][*c]GtkFixed) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFixed(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFixed(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFixed(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFixed(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_fixed_layout_get_type() GType;
pub const struct__GtkFixedLayout = opaque {};
pub const GtkFixedLayout = struct__GtkFixedLayout;
pub const GtkFixedLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkFixedLayout_autoptr = ?*GtkFixedLayout;
pub const GtkFixedLayout_listautoptr = [*c]GList;
pub const GtkFixedLayout_slistautoptr = [*c]GSList;
pub const GtkFixedLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFixedLayout(arg__ptr: ?*GtkFixedLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFixedLayout(arg__ptr: [*c]?*GtkFixedLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFixedLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFixedLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFixedLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFixedLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkFixedLayoutClass_autoptr = [*c]GtkFixedLayoutClass;
pub const GtkFixedLayoutClass_listautoptr = [*c]GList;
pub const GtkFixedLayoutClass_slistautoptr = [*c]GSList;
pub const GtkFixedLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFixedLayoutClass(arg__ptr: [*c]GtkFixedLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFixedLayoutClass(arg__ptr: [*c][*c]GtkFixedLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFixedLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFixedLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFixedLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFixedLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FIXED_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkFixedLayout {
    var ptr = arg_ptr;
    return @as(?*GtkFixedLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_fixed_layout_get_type())))));
}
pub fn GTK_IS_FIXED_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_fixed_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_fixed_layout_new() [*c]GtkLayoutManager;
pub extern fn gtk_fixed_layout_child_get_type() GType;
pub const struct__GtkFixedLayoutChild = opaque {};
pub const GtkFixedLayoutChild = struct__GtkFixedLayoutChild;
pub const GtkFixedLayoutChildClass = extern struct {
    parent_class: GtkLayoutChildClass,
};
pub const GtkFixedLayoutChild_autoptr = ?*GtkFixedLayoutChild;
pub const GtkFixedLayoutChild_listautoptr = [*c]GList;
pub const GtkFixedLayoutChild_slistautoptr = [*c]GSList;
pub const GtkFixedLayoutChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFixedLayoutChild(arg__ptr: ?*GtkFixedLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutChild(@as([*c]GtkLayoutChild, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFixedLayoutChild(arg__ptr: [*c]?*GtkFixedLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFixedLayoutChild(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFixedLayoutChild(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFixedLayoutChild(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFixedLayoutChild(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
    }
}
pub const GtkFixedLayoutChildClass_autoptr = [*c]GtkFixedLayoutChildClass;
pub const GtkFixedLayoutChildClass_listautoptr = [*c]GList;
pub const GtkFixedLayoutChildClass_slistautoptr = [*c]GSList;
pub const GtkFixedLayoutChildClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFixedLayoutChildClass(arg__ptr: [*c]GtkFixedLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFixedLayoutChildClass(arg__ptr: [*c][*c]GtkFixedLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFixedLayoutChildClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFixedLayoutChildClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFixedLayoutChildClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFixedLayoutChildClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FIXED_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) ?*GtkFixedLayoutChild {
    var ptr = arg_ptr;
    return @as(?*GtkFixedLayoutChild, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_fixed_layout_child_get_type())))));
}
pub fn GTK_IS_FIXED_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_fixed_layout_child_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_fixed_layout_child_set_transform(child: ?*GtkFixedLayoutChild, transform: ?*GskTransform) void;
pub extern fn gtk_fixed_layout_child_get_transform(child: ?*GtkFixedLayoutChild) ?*GskTransform;
pub const struct__GtkFileFilter = opaque {};
pub const GtkFileFilter = struct__GtkFileFilter;
pub extern fn gtk_file_filter_get_type() GType;
pub extern fn gtk_file_filter_new() ?*GtkFileFilter;
pub extern fn gtk_file_filter_set_name(filter: ?*GtkFileFilter, name: [*c]const u8) void;
pub extern fn gtk_file_filter_get_name(filter: ?*GtkFileFilter) [*c]const u8;
pub extern fn gtk_file_filter_add_mime_type(filter: ?*GtkFileFilter, mime_type: [*c]const u8) void;
pub extern fn gtk_file_filter_add_pattern(filter: ?*GtkFileFilter, pattern: [*c]const u8) void;
pub extern fn gtk_file_filter_add_suffix(filter: ?*GtkFileFilter, suffix: [*c]const u8) void;
pub extern fn gtk_file_filter_add_pixbuf_formats(filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_filter_get_attributes(filter: ?*GtkFileFilter) [*c][*c]const u8;
pub extern fn gtk_file_filter_to_gvariant(filter: ?*GtkFileFilter) ?*GVariant;
pub extern fn gtk_file_filter_new_from_gvariant(variant: ?*GVariant) ?*GtkFileFilter;
pub const GtkFileFilter_autoptr = ?*GtkFileFilter;
pub const GtkFileFilter_listautoptr = [*c]GList;
pub const GtkFileFilter_slistautoptr = [*c]GSList;
pub const GtkFileFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileFilter(arg__ptr: ?*GtkFileFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFileFilter(arg__ptr: [*c]?*GtkFileFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkFileChooser = opaque {};
pub const GtkFileChooser = struct__GtkFileChooser;
pub const GTK_FILE_CHOOSER_ACTION_OPEN: c_int = 0;
pub const GTK_FILE_CHOOSER_ACTION_SAVE: c_int = 1;
pub const GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER: c_int = 2;
pub const GtkFileChooserAction = c_uint;
pub extern fn gtk_file_chooser_get_type() GType;
pub const GTK_FILE_CHOOSER_ERROR_NONEXISTENT: c_int = 0;
pub const GTK_FILE_CHOOSER_ERROR_BAD_FILENAME: c_int = 1;
pub const GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS: c_int = 2;
pub const GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME: c_int = 3;
pub const GtkFileChooserError = c_uint;
pub extern fn gtk_file_chooser_error_quark() GQuark;
pub extern fn gtk_file_chooser_set_action(chooser: ?*GtkFileChooser, action: GtkFileChooserAction) void;
pub extern fn gtk_file_chooser_get_action(chooser: ?*GtkFileChooser) GtkFileChooserAction;
pub extern fn gtk_file_chooser_set_select_multiple(chooser: ?*GtkFileChooser, select_multiple: gboolean) void;
pub extern fn gtk_file_chooser_get_select_multiple(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_create_folders(chooser: ?*GtkFileChooser, create_folders: gboolean) void;
pub extern fn gtk_file_chooser_get_create_folders(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_current_name(chooser: ?*GtkFileChooser, name: [*c]const u8) void;
pub extern fn gtk_file_chooser_get_current_name(chooser: ?*GtkFileChooser) [*c]u8;
pub extern fn gtk_file_chooser_get_file(chooser: ?*GtkFileChooser) ?*GFile;
pub extern fn gtk_file_chooser_set_file(chooser: ?*GtkFileChooser, file: ?*GFile, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_file_chooser_get_files(chooser: ?*GtkFileChooser) ?*GListModel;
pub extern fn gtk_file_chooser_set_current_folder(chooser: ?*GtkFileChooser, file: ?*GFile, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_file_chooser_get_current_folder(chooser: ?*GtkFileChooser) ?*GFile;
pub extern fn gtk_file_chooser_add_filter(chooser: ?*GtkFileChooser, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_chooser_remove_filter(chooser: ?*GtkFileChooser, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_chooser_get_filters(chooser: ?*GtkFileChooser) ?*GListModel;
pub extern fn gtk_file_chooser_set_filter(chooser: ?*GtkFileChooser, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_chooser_get_filter(chooser: ?*GtkFileChooser) ?*GtkFileFilter;
pub extern fn gtk_file_chooser_add_shortcut_folder(chooser: ?*GtkFileChooser, folder: ?*GFile, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_file_chooser_remove_shortcut_folder(chooser: ?*GtkFileChooser, folder: ?*GFile, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_file_chooser_get_shortcut_folders(chooser: ?*GtkFileChooser) ?*GListModel;
pub extern fn gtk_file_chooser_add_choice(chooser: ?*GtkFileChooser, id: [*c]const u8, label: [*c]const u8, options: [*c][*c]const u8, option_labels: [*c][*c]const u8) void;
pub extern fn gtk_file_chooser_remove_choice(chooser: ?*GtkFileChooser, id: [*c]const u8) void;
pub extern fn gtk_file_chooser_set_choice(chooser: ?*GtkFileChooser, id: [*c]const u8, option: [*c]const u8) void;
pub extern fn gtk_file_chooser_get_choice(chooser: ?*GtkFileChooser, id: [*c]const u8) [*c]const u8;
pub const struct__GtkFileChooserDialog = opaque {};
pub const GtkFileChooserDialog = struct__GtkFileChooserDialog;
pub extern fn gtk_file_chooser_dialog_get_type() GType;
pub extern fn gtk_file_chooser_dialog_new(title: [*c]const u8, parent: [*c]GtkWindow, action: GtkFileChooserAction, first_button_text: [*c]const u8, ...) [*c]GtkWidget;
pub const GtkFileChooserDialog_autoptr = ?*GtkFileChooserDialog;
pub const GtkFileChooserDialog_listautoptr = [*c]GList;
pub const GtkFileChooserDialog_slistautoptr = [*c]GSList;
pub const GtkFileChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserDialog(arg__ptr: ?*GtkFileChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFileChooserDialog(arg__ptr: [*c]?*GtkFileChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileChooserDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_native_dialog_get_type() GType;
pub const struct__GtkNativeDialog = extern struct {
    parent_instance: GObject,
};
pub const GtkNativeDialog = struct__GtkNativeDialog;
pub const struct__GtkNativeDialogClass = extern struct {
    parent_class: GObjectClass,
    response: ?*const fn ([*c]GtkNativeDialog, c_int) callconv(.C) void,
    show: ?*const fn ([*c]GtkNativeDialog) callconv(.C) void,
    hide: ?*const fn ([*c]GtkNativeDialog) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkNativeDialogClass = struct__GtkNativeDialogClass;
pub const GtkNativeDialog_autoptr = [*c]GtkNativeDialog;
pub const GtkNativeDialog_listautoptr = [*c]GList;
pub const GtkNativeDialog_slistautoptr = [*c]GSList;
pub const GtkNativeDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNativeDialog(arg__ptr: [*c]GtkNativeDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkNativeDialog(arg__ptr: [*c][*c]GtkNativeDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNativeDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNativeDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNativeDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNativeDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkNativeDialogClass_autoptr = [*c]GtkNativeDialogClass;
pub const GtkNativeDialogClass_listautoptr = [*c]GList;
pub const GtkNativeDialogClass_slistautoptr = [*c]GSList;
pub const GtkNativeDialogClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNativeDialogClass(arg__ptr: [*c]GtkNativeDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNativeDialogClass(arg__ptr: [*c][*c]GtkNativeDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNativeDialogClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNativeDialogClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNativeDialogClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNativeDialogClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_NATIVE_DIALOG(arg_ptr: gpointer) callconv(.C) [*c]GtkNativeDialog {
    var ptr = arg_ptr;
    return @as([*c]GtkNativeDialog, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_native_dialog_get_type()))))));
}
pub fn GTK_NATIVE_DIALOG_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkNativeDialogClass {
    var ptr = arg_ptr;
    return @as([*c]GtkNativeDialogClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_native_dialog_get_type()))))));
}
pub fn GTK_IS_NATIVE_DIALOG(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_native_dialog_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_NATIVE_DIALOG_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_native_dialog_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_NATIVE_DIALOG_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkNativeDialogClass {
    var ptr = arg_ptr;
    return @as([*c]GtkNativeDialogClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_native_dialog_show(self: [*c]GtkNativeDialog) void;
pub extern fn gtk_native_dialog_hide(self: [*c]GtkNativeDialog) void;
pub extern fn gtk_native_dialog_destroy(self: [*c]GtkNativeDialog) void;
pub extern fn gtk_native_dialog_get_visible(self: [*c]GtkNativeDialog) gboolean;
pub extern fn gtk_native_dialog_set_modal(self: [*c]GtkNativeDialog, modal: gboolean) void;
pub extern fn gtk_native_dialog_get_modal(self: [*c]GtkNativeDialog) gboolean;
pub extern fn gtk_native_dialog_set_title(self: [*c]GtkNativeDialog, title: [*c]const u8) void;
pub extern fn gtk_native_dialog_get_title(self: [*c]GtkNativeDialog) [*c]const u8;
pub extern fn gtk_native_dialog_set_transient_for(self: [*c]GtkNativeDialog, parent: [*c]GtkWindow) void;
pub extern fn gtk_native_dialog_get_transient_for(self: [*c]GtkNativeDialog) [*c]GtkWindow;
pub extern fn gtk_file_chooser_native_get_type() GType;
pub const struct__GtkFileChooserNative = opaque {};
pub const GtkFileChooserNative = struct__GtkFileChooserNative;
pub const GtkFileChooserNativeClass = extern struct {
    parent_class: GtkNativeDialogClass,
};
pub const GtkFileChooserNative_autoptr = ?*GtkFileChooserNative;
pub const GtkFileChooserNative_listautoptr = [*c]GList;
pub const GtkFileChooserNative_slistautoptr = [*c]GSList;
pub const GtkFileChooserNative_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserNative(arg__ptr: ?*GtkFileChooserNative) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkNativeDialog(@as([*c]GtkNativeDialog, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFileChooserNative(arg__ptr: [*c]?*GtkFileChooserNative) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileChooserNative(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserNative(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkNativeDialog)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserNative(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkNativeDialog)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserNative(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkNativeDialog)))))));
    }
}
pub const GtkFileChooserNativeClass_autoptr = [*c]GtkFileChooserNativeClass;
pub const GtkFileChooserNativeClass_listautoptr = [*c]GList;
pub const GtkFileChooserNativeClass_slistautoptr = [*c]GSList;
pub const GtkFileChooserNativeClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserNativeClass(arg__ptr: [*c]GtkFileChooserNativeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFileChooserNativeClass(arg__ptr: [*c][*c]GtkFileChooserNativeClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileChooserNativeClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserNativeClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserNativeClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserNativeClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FILE_CHOOSER_NATIVE(arg_ptr: gpointer) callconv(.C) ?*GtkFileChooserNative {
    var ptr = arg_ptr;
    return @as(?*GtkFileChooserNative, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_file_chooser_native_get_type())))));
}
pub fn GTK_IS_FILE_CHOOSER_NATIVE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_file_chooser_native_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_file_chooser_native_new(title: [*c]const u8, parent: [*c]GtkWindow, action: GtkFileChooserAction, accept_label: [*c]const u8, cancel_label: [*c]const u8) ?*GtkFileChooserNative;
pub extern fn gtk_file_chooser_native_get_accept_label(self: ?*GtkFileChooserNative) [*c]const u8;
pub extern fn gtk_file_chooser_native_set_accept_label(self: ?*GtkFileChooserNative, accept_label: [*c]const u8) void;
pub extern fn gtk_file_chooser_native_get_cancel_label(self: ?*GtkFileChooserNative) [*c]const u8;
pub extern fn gtk_file_chooser_native_set_cancel_label(self: ?*GtkFileChooserNative, cancel_label: [*c]const u8) void;
pub const struct__GtkFileChooserWidget = opaque {};
pub const GtkFileChooserWidget = struct__GtkFileChooserWidget;
pub extern fn gtk_file_chooser_widget_get_type() GType;
pub extern fn gtk_file_chooser_widget_new(action: GtkFileChooserAction) [*c]GtkWidget;
pub const GtkFileChooserWidget_autoptr = ?*GtkFileChooserWidget;
pub const GtkFileChooserWidget_listautoptr = [*c]GList;
pub const GtkFileChooserWidget_slistautoptr = [*c]GSList;
pub const GtkFileChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserWidget(arg__ptr: ?*GtkFileChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFileChooserWidget(arg__ptr: [*c]?*GtkFileChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileChooserWidget(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserWidget(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserWidget(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserWidget(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_file_dialog_get_type() GType;
pub const struct__GtkFileDialog = opaque {};
pub const GtkFileDialog = struct__GtkFileDialog;
pub const GtkFileDialogClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkFileDialog_autoptr = ?*GtkFileDialog;
pub const GtkFileDialog_listautoptr = [*c]GList;
pub const GtkFileDialog_slistautoptr = [*c]GSList;
pub const GtkFileDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileDialog(arg__ptr: ?*GtkFileDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFileDialog(arg__ptr: [*c]?*GtkFileDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkFileDialogClass_autoptr = [*c]GtkFileDialogClass;
pub const GtkFileDialogClass_listautoptr = [*c]GList;
pub const GtkFileDialogClass_slistautoptr = [*c]GSList;
pub const GtkFileDialogClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileDialogClass(arg__ptr: [*c]GtkFileDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFileDialogClass(arg__ptr: [*c][*c]GtkFileDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileDialogClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileDialogClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileDialogClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileDialogClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FILE_DIALOG(arg_ptr: gpointer) callconv(.C) ?*GtkFileDialog {
    var ptr = arg_ptr;
    return @as(?*GtkFileDialog, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_file_dialog_get_type())))));
}
pub fn GTK_IS_FILE_DIALOG(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_file_dialog_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_file_dialog_new() ?*GtkFileDialog;
pub extern fn gtk_file_dialog_get_title(self: ?*GtkFileDialog) [*c]const u8;
pub extern fn gtk_file_dialog_set_title(self: ?*GtkFileDialog, title: [*c]const u8) void;
pub extern fn gtk_file_dialog_get_modal(self: ?*GtkFileDialog) gboolean;
pub extern fn gtk_file_dialog_set_modal(self: ?*GtkFileDialog, modal: gboolean) void;
pub extern fn gtk_file_dialog_get_filters(self: ?*GtkFileDialog) ?*GListModel;
pub extern fn gtk_file_dialog_set_filters(self: ?*GtkFileDialog, filters: ?*GListModel) void;
pub extern fn gtk_file_dialog_get_default_filter(self: ?*GtkFileDialog) ?*GtkFileFilter;
pub extern fn gtk_file_dialog_set_default_filter(self: ?*GtkFileDialog, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_dialog_get_initial_folder(self: ?*GtkFileDialog) ?*GFile;
pub extern fn gtk_file_dialog_set_initial_folder(self: ?*GtkFileDialog, folder: ?*GFile) void;
pub extern fn gtk_file_dialog_get_initial_name(self: ?*GtkFileDialog) [*c]const u8;
pub extern fn gtk_file_dialog_set_initial_name(self: ?*GtkFileDialog, name: [*c]const u8) void;
pub extern fn gtk_file_dialog_get_initial_file(self: ?*GtkFileDialog) ?*GFile;
pub extern fn gtk_file_dialog_set_initial_file(self: ?*GtkFileDialog, file: ?*GFile) void;
pub extern fn gtk_file_dialog_get_accept_label(self: ?*GtkFileDialog) [*c]const u8;
pub extern fn gtk_file_dialog_set_accept_label(self: ?*GtkFileDialog, accept_label: [*c]const u8) void;
pub extern fn gtk_file_dialog_open(self: ?*GtkFileDialog, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_dialog_open_finish(self: ?*GtkFileDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFile;
pub extern fn gtk_file_dialog_select_folder(self: ?*GtkFileDialog, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_dialog_select_folder_finish(self: ?*GtkFileDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFile;
pub extern fn gtk_file_dialog_save(self: ?*GtkFileDialog, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_dialog_save_finish(self: ?*GtkFileDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GFile;
pub extern fn gtk_file_dialog_open_multiple(self: ?*GtkFileDialog, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_dialog_open_multiple_finish(self: ?*GtkFileDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GListModel;
pub extern fn gtk_file_dialog_select_multiple_folders(self: ?*GtkFileDialog, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_dialog_select_multiple_folders_finish(self: ?*GtkFileDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*GListModel;
pub extern fn gtk_file_launcher_get_type() GType;
pub const struct__GtkFileLauncher = opaque {};
pub const GtkFileLauncher = struct__GtkFileLauncher;
pub const GtkFileLauncherClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkFileLauncher_autoptr = ?*GtkFileLauncher;
pub const GtkFileLauncher_listautoptr = [*c]GList;
pub const GtkFileLauncher_slistautoptr = [*c]GSList;
pub const GtkFileLauncher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileLauncher(arg__ptr: ?*GtkFileLauncher) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFileLauncher(arg__ptr: [*c]?*GtkFileLauncher) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileLauncher(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileLauncher(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileLauncher(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileLauncher(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkFileLauncherClass_autoptr = [*c]GtkFileLauncherClass;
pub const GtkFileLauncherClass_listautoptr = [*c]GList;
pub const GtkFileLauncherClass_slistautoptr = [*c]GSList;
pub const GtkFileLauncherClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileLauncherClass(arg__ptr: [*c]GtkFileLauncherClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFileLauncherClass(arg__ptr: [*c][*c]GtkFileLauncherClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFileLauncherClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFileLauncherClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFileLauncherClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFileLauncherClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FILE_LAUNCHER(arg_ptr: gpointer) callconv(.C) ?*GtkFileLauncher {
    var ptr = arg_ptr;
    return @as(?*GtkFileLauncher, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_file_launcher_get_type())))));
}
pub fn GTK_IS_FILE_LAUNCHER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_file_launcher_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_file_launcher_new(file: ?*GFile) ?*GtkFileLauncher;
pub extern fn gtk_file_launcher_get_file(self: ?*GtkFileLauncher) ?*GFile;
pub extern fn gtk_file_launcher_set_file(self: ?*GtkFileLauncher, file: ?*GFile) void;
pub extern fn gtk_file_launcher_get_always_ask(self: ?*GtkFileLauncher) gboolean;
pub extern fn gtk_file_launcher_set_always_ask(self: ?*GtkFileLauncher, always_ask: gboolean) void;
pub extern fn gtk_file_launcher_launch(self: ?*GtkFileLauncher, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_launcher_launch_finish(self: ?*GtkFileLauncher, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_file_launcher_open_containing_folder(self: ?*GtkFileLauncher, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_file_launcher_open_containing_folder_finish(self: ?*GtkFileLauncher, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_filter_list_model_get_type() GType;
pub const struct__GtkFilterListModel = opaque {};
pub const GtkFilterListModel = struct__GtkFilterListModel;
pub const GtkFilterListModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkFilterListModel_autoptr = ?*GtkFilterListModel;
pub const GtkFilterListModel_listautoptr = [*c]GList;
pub const GtkFilterListModel_slistautoptr = [*c]GSList;
pub const GtkFilterListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFilterListModel(arg__ptr: ?*GtkFilterListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFilterListModel(arg__ptr: [*c]?*GtkFilterListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFilterListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFilterListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFilterListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFilterListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkFilterListModelClass_autoptr = [*c]GtkFilterListModelClass;
pub const GtkFilterListModelClass_listautoptr = [*c]GList;
pub const GtkFilterListModelClass_slistautoptr = [*c]GSList;
pub const GtkFilterListModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFilterListModelClass(arg__ptr: [*c]GtkFilterListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFilterListModelClass(arg__ptr: [*c][*c]GtkFilterListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFilterListModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFilterListModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFilterListModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFilterListModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FILTER_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkFilterListModel {
    var ptr = arg_ptr;
    return @as(?*GtkFilterListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_filter_list_model_get_type())))));
}
pub fn GTK_IS_FILTER_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_filter_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_filter_list_model_new(model: ?*GListModel, filter: [*c]GtkFilter) ?*GtkFilterListModel;
pub extern fn gtk_filter_list_model_set_filter(self: ?*GtkFilterListModel, filter: [*c]GtkFilter) void;
pub extern fn gtk_filter_list_model_get_filter(self: ?*GtkFilterListModel) [*c]GtkFilter;
pub extern fn gtk_filter_list_model_set_model(self: ?*GtkFilterListModel, model: ?*GListModel) void;
pub extern fn gtk_filter_list_model_get_model(self: ?*GtkFilterListModel) ?*GListModel;
pub extern fn gtk_filter_list_model_set_incremental(self: ?*GtkFilterListModel, incremental: gboolean) void;
pub extern fn gtk_filter_list_model_get_incremental(self: ?*GtkFilterListModel) gboolean;
pub extern fn gtk_filter_list_model_get_pending(self: ?*GtkFilterListModel) guint;
pub const GtkCustomFilterFunc = ?*const fn (gpointer, gpointer) callconv(.C) gboolean;
pub extern fn gtk_custom_filter_get_type() GType;
pub const struct__GtkCustomFilter = opaque {};
pub const GtkCustomFilter = struct__GtkCustomFilter;
pub const GtkCustomFilterClass = extern struct {
    parent_class: GtkFilterClass,
};
pub const GtkCustomFilter_autoptr = ?*GtkCustomFilter;
pub const GtkCustomFilter_listautoptr = [*c]GList;
pub const GtkCustomFilter_slistautoptr = [*c]GSList;
pub const GtkCustomFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCustomFilter(arg__ptr: ?*GtkCustomFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkFilter(@as([*c]GtkFilter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkCustomFilter(arg__ptr: [*c]?*GtkCustomFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCustomFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCustomFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCustomFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCustomFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
    }
}
pub const GtkCustomFilterClass_autoptr = [*c]GtkCustomFilterClass;
pub const GtkCustomFilterClass_listautoptr = [*c]GList;
pub const GtkCustomFilterClass_slistautoptr = [*c]GSList;
pub const GtkCustomFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCustomFilterClass(arg__ptr: [*c]GtkCustomFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkCustomFilterClass(arg__ptr: [*c][*c]GtkCustomFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkCustomFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkCustomFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkCustomFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkCustomFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_CUSTOM_FILTER(arg_ptr: gpointer) callconv(.C) ?*GtkCustomFilter {
    var ptr = arg_ptr;
    return @as(?*GtkCustomFilter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_custom_filter_get_type())))));
}
pub fn GTK_IS_CUSTOM_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_custom_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_custom_filter_new(match_func: GtkCustomFilterFunc, user_data: gpointer, user_destroy: GDestroyNotify) ?*GtkCustomFilter;
pub extern fn gtk_custom_filter_set_filter_func(self: ?*GtkCustomFilter, match_func: GtkCustomFilterFunc, user_data: gpointer, user_destroy: GDestroyNotify) void;
pub extern fn gtk_flatten_list_model_get_type() GType;
pub const struct__GtkFlattenListModel = opaque {};
pub const GtkFlattenListModel = struct__GtkFlattenListModel;
pub const GtkFlattenListModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkFlattenListModel_autoptr = ?*GtkFlattenListModel;
pub const GtkFlattenListModel_listautoptr = [*c]GList;
pub const GtkFlattenListModel_slistautoptr = [*c]GSList;
pub const GtkFlattenListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFlattenListModel(arg__ptr: ?*GtkFlattenListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFlattenListModel(arg__ptr: [*c]?*GtkFlattenListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFlattenListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFlattenListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFlattenListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFlattenListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkFlattenListModelClass_autoptr = [*c]GtkFlattenListModelClass;
pub const GtkFlattenListModelClass_listautoptr = [*c]GList;
pub const GtkFlattenListModelClass_slistautoptr = [*c]GSList;
pub const GtkFlattenListModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFlattenListModelClass(arg__ptr: [*c]GtkFlattenListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFlattenListModelClass(arg__ptr: [*c][*c]GtkFlattenListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFlattenListModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFlattenListModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFlattenListModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFlattenListModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FLATTEN_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkFlattenListModel {
    var ptr = arg_ptr;
    return @as(?*GtkFlattenListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_flatten_list_model_get_type())))));
}
pub fn GTK_IS_FLATTEN_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_flatten_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_flatten_list_model_new(model: ?*GListModel) ?*GtkFlattenListModel;
pub extern fn gtk_flatten_list_model_set_model(self: ?*GtkFlattenListModel, model: ?*GListModel) void;
pub extern fn gtk_flatten_list_model_get_model(self: ?*GtkFlattenListModel) ?*GListModel;
pub extern fn gtk_flatten_list_model_get_model_for_item(self: ?*GtkFlattenListModel, position: guint) ?*GListModel;
pub const struct__GtkFlowBox = opaque {};
pub const GtkFlowBox = struct__GtkFlowBox;
pub const struct__GtkFlowBoxChild = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkFlowBoxChild = struct__GtkFlowBoxChild;
pub const struct__GtkFlowBoxChildClass = extern struct {
    parent_class: GtkWidgetClass,
    activate: ?*const fn ([*c]GtkFlowBoxChild) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkFlowBoxChildClass = struct__GtkFlowBoxChildClass;
pub const GtkFlowBoxCreateWidgetFunc = ?*const fn (gpointer, gpointer) callconv(.C) [*c]GtkWidget;
pub extern fn gtk_flow_box_child_get_type() GType;
pub extern fn gtk_flow_box_child_new() [*c]GtkWidget;
pub extern fn gtk_flow_box_child_set_child(self: [*c]GtkFlowBoxChild, child: [*c]GtkWidget) void;
pub extern fn gtk_flow_box_child_get_child(self: [*c]GtkFlowBoxChild) [*c]GtkWidget;
pub extern fn gtk_flow_box_child_get_index(child: [*c]GtkFlowBoxChild) c_int;
pub extern fn gtk_flow_box_child_is_selected(child: [*c]GtkFlowBoxChild) gboolean;
pub extern fn gtk_flow_box_child_changed(child: [*c]GtkFlowBoxChild) void;
pub extern fn gtk_flow_box_get_type() GType;
pub extern fn gtk_flow_box_new() [*c]GtkWidget;
pub extern fn gtk_flow_box_bind_model(box: ?*GtkFlowBox, model: ?*GListModel, create_widget_func: GtkFlowBoxCreateWidgetFunc, user_data: gpointer, user_data_free_func: GDestroyNotify) void;
pub extern fn gtk_flow_box_set_homogeneous(box: ?*GtkFlowBox, homogeneous: gboolean) void;
pub extern fn gtk_flow_box_get_homogeneous(box: ?*GtkFlowBox) gboolean;
pub extern fn gtk_flow_box_set_row_spacing(box: ?*GtkFlowBox, spacing: guint) void;
pub extern fn gtk_flow_box_get_row_spacing(box: ?*GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_column_spacing(box: ?*GtkFlowBox, spacing: guint) void;
pub extern fn gtk_flow_box_get_column_spacing(box: ?*GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_min_children_per_line(box: ?*GtkFlowBox, n_children: guint) void;
pub extern fn gtk_flow_box_get_min_children_per_line(box: ?*GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_max_children_per_line(box: ?*GtkFlowBox, n_children: guint) void;
pub extern fn gtk_flow_box_get_max_children_per_line(box: ?*GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_activate_on_single_click(box: ?*GtkFlowBox, single: gboolean) void;
pub extern fn gtk_flow_box_get_activate_on_single_click(box: ?*GtkFlowBox) gboolean;
pub extern fn gtk_flow_box_prepend(self: ?*GtkFlowBox, child: [*c]GtkWidget) void;
pub extern fn gtk_flow_box_append(self: ?*GtkFlowBox, child: [*c]GtkWidget) void;
pub extern fn gtk_flow_box_insert(box: ?*GtkFlowBox, widget: [*c]GtkWidget, position: c_int) void;
pub extern fn gtk_flow_box_remove(box: ?*GtkFlowBox, widget: [*c]GtkWidget) void;
pub extern fn gtk_flow_box_remove_all(box: ?*GtkFlowBox) void;
pub extern fn gtk_flow_box_get_child_at_index(box: ?*GtkFlowBox, idx: c_int) [*c]GtkFlowBoxChild;
pub extern fn gtk_flow_box_get_child_at_pos(box: ?*GtkFlowBox, x: c_int, y: c_int) [*c]GtkFlowBoxChild;
pub const GtkFlowBoxForeachFunc = ?*const fn (?*GtkFlowBox, [*c]GtkFlowBoxChild, gpointer) callconv(.C) void;
pub extern fn gtk_flow_box_selected_foreach(box: ?*GtkFlowBox, func: GtkFlowBoxForeachFunc, data: gpointer) void;
pub extern fn gtk_flow_box_get_selected_children(box: ?*GtkFlowBox) [*c]GList;
pub extern fn gtk_flow_box_select_child(box: ?*GtkFlowBox, child: [*c]GtkFlowBoxChild) void;
pub extern fn gtk_flow_box_unselect_child(box: ?*GtkFlowBox, child: [*c]GtkFlowBoxChild) void;
pub extern fn gtk_flow_box_select_all(box: ?*GtkFlowBox) void;
pub extern fn gtk_flow_box_unselect_all(box: ?*GtkFlowBox) void;
pub extern fn gtk_flow_box_set_selection_mode(box: ?*GtkFlowBox, mode: GtkSelectionMode) void;
pub extern fn gtk_flow_box_get_selection_mode(box: ?*GtkFlowBox) GtkSelectionMode;
pub extern fn gtk_flow_box_set_hadjustment(box: ?*GtkFlowBox, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_flow_box_set_vadjustment(box: ?*GtkFlowBox, adjustment: [*c]GtkAdjustment) void;
pub const GtkFlowBoxFilterFunc = ?*const fn ([*c]GtkFlowBoxChild, gpointer) callconv(.C) gboolean;
pub extern fn gtk_flow_box_set_filter_func(box: ?*GtkFlowBox, filter_func: GtkFlowBoxFilterFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_flow_box_invalidate_filter(box: ?*GtkFlowBox) void;
pub const GtkFlowBoxSortFunc = ?*const fn ([*c]GtkFlowBoxChild, [*c]GtkFlowBoxChild, gpointer) callconv(.C) c_int;
pub extern fn gtk_flow_box_set_sort_func(box: ?*GtkFlowBox, sort_func: GtkFlowBoxSortFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_flow_box_invalidate_sort(box: ?*GtkFlowBox) void;
pub const GtkFlowBox_autoptr = ?*GtkFlowBox;
pub const GtkFlowBox_listautoptr = [*c]GList;
pub const GtkFlowBox_slistautoptr = [*c]GSList;
pub const GtkFlowBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFlowBox(arg__ptr: ?*GtkFlowBox) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFlowBox(arg__ptr: [*c]?*GtkFlowBox) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFlowBox(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFlowBox(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFlowBox(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFlowBox(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkFlowBoxChild_autoptr = [*c]GtkFlowBoxChild;
pub const GtkFlowBoxChild_listautoptr = [*c]GList;
pub const GtkFlowBoxChild_slistautoptr = [*c]GSList;
pub const GtkFlowBoxChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFlowBoxChild(arg__ptr: [*c]GtkFlowBoxChild) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFlowBoxChild(arg__ptr: [*c][*c]GtkFlowBoxChild) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFlowBoxChild(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFlowBoxChild(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFlowBoxChild(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFlowBoxChild(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkFontButton = opaque {};
pub const GtkFontButton = struct__GtkFontButton;
pub extern fn gtk_font_button_get_type() GType;
pub extern fn gtk_font_button_new() [*c]GtkWidget;
pub extern fn gtk_font_button_new_with_font(fontname: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_font_button_get_title(font_button: ?*GtkFontButton) [*c]const u8;
pub extern fn gtk_font_button_set_title(font_button: ?*GtkFontButton, title: [*c]const u8) void;
pub extern fn gtk_font_button_get_modal(font_button: ?*GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_modal(font_button: ?*GtkFontButton, modal: gboolean) void;
pub extern fn gtk_font_button_get_use_font(font_button: ?*GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_use_font(font_button: ?*GtkFontButton, use_font: gboolean) void;
pub extern fn gtk_font_button_get_use_size(font_button: ?*GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_use_size(font_button: ?*GtkFontButton, use_size: gboolean) void;
pub const GtkFontButton_autoptr = ?*GtkFontButton;
pub const GtkFontButton_listautoptr = [*c]GList;
pub const GtkFontButton_slistautoptr = [*c]GSList;
pub const GtkFontButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontButton(arg__ptr: ?*GtkFontButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFontButton(arg__ptr: [*c]?*GtkFontButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkFontFilterFunc = ?*const fn ([*c]const PangoFontFamily, [*c]const PangoFontFace, gpointer) callconv(.C) gboolean;
pub const GTK_FONT_CHOOSER_LEVEL_FAMILY: c_int = 0;
pub const GTK_FONT_CHOOSER_LEVEL_STYLE: c_int = 1;
pub const GTK_FONT_CHOOSER_LEVEL_SIZE: c_int = 2;
pub const GTK_FONT_CHOOSER_LEVEL_VARIATIONS: c_int = 4;
pub const GTK_FONT_CHOOSER_LEVEL_FEATURES: c_int = 8;
pub const GtkFontChooserLevel = c_uint;
pub const struct__GtkFontChooser = opaque {};
pub const GtkFontChooser = struct__GtkFontChooser;
pub const struct__GtkFontChooserIface = extern struct {
    base_iface: GTypeInterface,
    get_font_family: ?*const fn (?*GtkFontChooser) callconv(.C) [*c]PangoFontFamily,
    get_font_face: ?*const fn (?*GtkFontChooser) callconv(.C) [*c]PangoFontFace,
    get_font_size: ?*const fn (?*GtkFontChooser) callconv(.C) c_int,
    set_filter_func: ?*const fn (?*GtkFontChooser, GtkFontFilterFunc, gpointer, GDestroyNotify) callconv(.C) void,
    font_activated: ?*const fn (?*GtkFontChooser, [*c]const u8) callconv(.C) void,
    set_font_map: ?*const fn (?*GtkFontChooser, [*c]PangoFontMap) callconv(.C) void,
    get_font_map: ?*const fn (?*GtkFontChooser) callconv(.C) [*c]PangoFontMap,
    padding: [10]gpointer,
};
pub const GtkFontChooserIface = struct__GtkFontChooserIface;
pub extern fn gtk_font_chooser_get_type() GType;
pub extern fn gtk_font_chooser_get_font_family(fontchooser: ?*GtkFontChooser) [*c]PangoFontFamily;
pub extern fn gtk_font_chooser_get_font_face(fontchooser: ?*GtkFontChooser) [*c]PangoFontFace;
pub extern fn gtk_font_chooser_get_font_size(fontchooser: ?*GtkFontChooser) c_int;
pub extern fn gtk_font_chooser_get_font_desc(fontchooser: ?*GtkFontChooser) ?*PangoFontDescription;
pub extern fn gtk_font_chooser_set_font_desc(fontchooser: ?*GtkFontChooser, font_desc: ?*const PangoFontDescription) void;
pub extern fn gtk_font_chooser_get_font(fontchooser: ?*GtkFontChooser) [*c]u8;
pub extern fn gtk_font_chooser_set_font(fontchooser: ?*GtkFontChooser, fontname: [*c]const u8) void;
pub extern fn gtk_font_chooser_get_preview_text(fontchooser: ?*GtkFontChooser) [*c]u8;
pub extern fn gtk_font_chooser_set_preview_text(fontchooser: ?*GtkFontChooser, text: [*c]const u8) void;
pub extern fn gtk_font_chooser_get_show_preview_entry(fontchooser: ?*GtkFontChooser) gboolean;
pub extern fn gtk_font_chooser_set_show_preview_entry(fontchooser: ?*GtkFontChooser, show_preview_entry: gboolean) void;
pub extern fn gtk_font_chooser_set_filter_func(fontchooser: ?*GtkFontChooser, filter: GtkFontFilterFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_font_chooser_set_font_map(fontchooser: ?*GtkFontChooser, fontmap: [*c]PangoFontMap) void;
pub extern fn gtk_font_chooser_get_font_map(fontchooser: ?*GtkFontChooser) [*c]PangoFontMap;
pub extern fn gtk_font_chooser_set_level(fontchooser: ?*GtkFontChooser, level: GtkFontChooserLevel) void;
pub extern fn gtk_font_chooser_get_level(fontchooser: ?*GtkFontChooser) GtkFontChooserLevel;
pub extern fn gtk_font_chooser_get_font_features(fontchooser: ?*GtkFontChooser) [*c]u8;
pub extern fn gtk_font_chooser_get_language(fontchooser: ?*GtkFontChooser) [*c]u8;
pub extern fn gtk_font_chooser_set_language(fontchooser: ?*GtkFontChooser, language: [*c]const u8) void;
pub const GtkFontChooser_autoptr = ?*GtkFontChooser;
pub const GtkFontChooser_listautoptr = [*c]GList;
pub const GtkFontChooser_slistautoptr = [*c]GSList;
pub const GtkFontChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontChooser(arg__ptr: ?*GtkFontChooser) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFontChooser(arg__ptr: [*c]?*GtkFontChooser) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontChooser(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontChooser(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontChooser(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontChooser(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkFontChooserDialog = opaque {};
pub const GtkFontChooserDialog = struct__GtkFontChooserDialog;
pub extern fn gtk_font_chooser_dialog_get_type() GType;
pub extern fn gtk_font_chooser_dialog_new(title: [*c]const u8, parent: [*c]GtkWindow) [*c]GtkWidget;
pub const GtkFontChooserDialog_autoptr = ?*GtkFontChooserDialog;
pub const GtkFontChooserDialog_listautoptr = [*c]GList;
pub const GtkFontChooserDialog_slistautoptr = [*c]GSList;
pub const GtkFontChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontChooserDialog(arg__ptr: ?*GtkFontChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFontChooserDialog(arg__ptr: [*c]?*GtkFontChooserDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontChooserDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontChooserDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontChooserDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontChooserDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkFontChooserWidget = opaque {};
pub const GtkFontChooserWidget = struct__GtkFontChooserWidget;
pub extern fn gtk_font_chooser_widget_get_type() GType;
pub extern fn gtk_font_chooser_widget_new() [*c]GtkWidget;
pub const GtkFontChooserWidget_autoptr = ?*GtkFontChooserWidget;
pub const GtkFontChooserWidget_listautoptr = [*c]GList;
pub const GtkFontChooserWidget_slistautoptr = [*c]GSList;
pub const GtkFontChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontChooserWidget(arg__ptr: ?*GtkFontChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFontChooserWidget(arg__ptr: [*c]?*GtkFontChooserWidget) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontChooserWidget(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontChooserWidget(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontChooserWidget(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontChooserWidget(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_font_dialog_get_type() GType;
pub const struct__GtkFontDialog = opaque {};
pub const GtkFontDialog = struct__GtkFontDialog;
pub const GtkFontDialogClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkFontDialog_autoptr = ?*GtkFontDialog;
pub const GtkFontDialog_listautoptr = [*c]GList;
pub const GtkFontDialog_slistautoptr = [*c]GSList;
pub const GtkFontDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontDialog(arg__ptr: ?*GtkFontDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFontDialog(arg__ptr: [*c]?*GtkFontDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkFontDialogClass_autoptr = [*c]GtkFontDialogClass;
pub const GtkFontDialogClass_listautoptr = [*c]GList;
pub const GtkFontDialogClass_slistautoptr = [*c]GSList;
pub const GtkFontDialogClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontDialogClass(arg__ptr: [*c]GtkFontDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFontDialogClass(arg__ptr: [*c][*c]GtkFontDialogClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontDialogClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontDialogClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontDialogClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontDialogClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FONT_DIALOG(arg_ptr: gpointer) callconv(.C) ?*GtkFontDialog {
    var ptr = arg_ptr;
    return @as(?*GtkFontDialog, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_font_dialog_get_type())))));
}
pub fn GTK_IS_FONT_DIALOG(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_font_dialog_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_font_dialog_new() ?*GtkFontDialog;
pub extern fn gtk_font_dialog_get_title(self: ?*GtkFontDialog) [*c]const u8;
pub extern fn gtk_font_dialog_set_title(self: ?*GtkFontDialog, title: [*c]const u8) void;
pub extern fn gtk_font_dialog_get_modal(self: ?*GtkFontDialog) gboolean;
pub extern fn gtk_font_dialog_set_modal(self: ?*GtkFontDialog, modal: gboolean) void;
pub extern fn gtk_font_dialog_get_language(self: ?*GtkFontDialog) ?*PangoLanguage;
pub extern fn gtk_font_dialog_set_language(self: ?*GtkFontDialog, language: ?*PangoLanguage) void;
pub extern fn gtk_font_dialog_get_font_map(self: ?*GtkFontDialog) [*c]PangoFontMap;
pub extern fn gtk_font_dialog_set_font_map(self: ?*GtkFontDialog, fontmap: [*c]PangoFontMap) void;
pub extern fn gtk_font_dialog_get_filter(self: ?*GtkFontDialog) [*c]GtkFilter;
pub extern fn gtk_font_dialog_set_filter(self: ?*GtkFontDialog, filter: [*c]GtkFilter) void;
pub extern fn gtk_font_dialog_choose_family(self: ?*GtkFontDialog, parent: [*c]GtkWindow, initial_value: [*c]PangoFontFamily, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_font_dialog_choose_family_finish(self: ?*GtkFontDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]PangoFontFamily;
pub extern fn gtk_font_dialog_choose_face(self: ?*GtkFontDialog, parent: [*c]GtkWindow, initial_value: [*c]PangoFontFace, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_font_dialog_choose_face_finish(self: ?*GtkFontDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) [*c]PangoFontFace;
pub extern fn gtk_font_dialog_choose_font(self: ?*GtkFontDialog, parent: [*c]GtkWindow, initial_value: ?*PangoFontDescription, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_font_dialog_choose_font_finish(self: ?*GtkFontDialog, result: ?*GAsyncResult, @"error": [*c][*c]GError) ?*PangoFontDescription;
pub extern fn gtk_font_dialog_choose_font_and_features(self: ?*GtkFontDialog, parent: [*c]GtkWindow, initial_value: ?*PangoFontDescription, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_font_dialog_choose_font_and_features_finish(self: ?*GtkFontDialog, result: ?*GAsyncResult, font_desc: [*c]?*PangoFontDescription, font_features: [*c][*c]u8, language: [*c]?*PangoLanguage, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_font_dialog_button_get_type() GType;
pub const struct__GtkFontDialogButton = opaque {};
pub const GtkFontDialogButton = struct__GtkFontDialogButton;
pub const GtkFontDialogButtonClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkFontDialogButton_autoptr = ?*GtkFontDialogButton;
pub const GtkFontDialogButton_listautoptr = [*c]GList;
pub const GtkFontDialogButton_slistautoptr = [*c]GSList;
pub const GtkFontDialogButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontDialogButton(arg__ptr: ?*GtkFontDialogButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkFontDialogButton(arg__ptr: [*c]?*GtkFontDialogButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontDialogButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontDialogButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontDialogButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontDialogButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkFontDialogButtonClass_autoptr = [*c]GtkFontDialogButtonClass;
pub const GtkFontDialogButtonClass_listautoptr = [*c]GList;
pub const GtkFontDialogButtonClass_slistautoptr = [*c]GSList;
pub const GtkFontDialogButtonClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontDialogButtonClass(arg__ptr: [*c]GtkFontDialogButtonClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFontDialogButtonClass(arg__ptr: [*c][*c]GtkFontDialogButtonClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFontDialogButtonClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFontDialogButtonClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFontDialogButtonClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFontDialogButtonClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_FONT_DIALOG_BUTTON(arg_ptr: gpointer) callconv(.C) ?*GtkFontDialogButton {
    var ptr = arg_ptr;
    return @as(?*GtkFontDialogButton, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_font_dialog_button_get_type())))));
}
pub fn GTK_IS_FONT_DIALOG_BUTTON(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_font_dialog_button_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_font_dialog_button_new(dialog: ?*GtkFontDialog) [*c]GtkWidget;
pub extern fn gtk_font_dialog_button_get_dialog(self: ?*GtkFontDialogButton) ?*GtkFontDialog;
pub extern fn gtk_font_dialog_button_set_dialog(self: ?*GtkFontDialogButton, dialog: ?*GtkFontDialog) void;
pub const GTK_FONT_LEVEL_FAMILY: c_int = 0;
pub const GTK_FONT_LEVEL_FACE: c_int = 1;
pub const GTK_FONT_LEVEL_FONT: c_int = 2;
pub const GTK_FONT_LEVEL_FEATURES: c_int = 3;
pub const GtkFontLevel = c_uint;
pub extern fn gtk_font_dialog_button_get_level(self: ?*GtkFontDialogButton) GtkFontLevel;
pub extern fn gtk_font_dialog_button_set_level(self: ?*GtkFontDialogButton, level: GtkFontLevel) void;
pub extern fn gtk_font_dialog_button_get_font_desc(self: ?*GtkFontDialogButton) ?*PangoFontDescription;
pub extern fn gtk_font_dialog_button_set_font_desc(self: ?*GtkFontDialogButton, font_desc: ?*const PangoFontDescription) void;
pub extern fn gtk_font_dialog_button_get_font_features(self: ?*GtkFontDialogButton) [*c]const u8;
pub extern fn gtk_font_dialog_button_set_font_features(self: ?*GtkFontDialogButton, font_features: [*c]const u8) void;
pub extern fn gtk_font_dialog_button_get_language(self: ?*GtkFontDialogButton) ?*PangoLanguage;
pub extern fn gtk_font_dialog_button_set_language(self: ?*GtkFontDialogButton, language: ?*PangoLanguage) void;
pub extern fn gtk_font_dialog_button_get_use_font(self: ?*GtkFontDialogButton) gboolean;
pub extern fn gtk_font_dialog_button_set_use_font(self: ?*GtkFontDialogButton, use_font: gboolean) void;
pub extern fn gtk_font_dialog_button_get_use_size(self: ?*GtkFontDialogButton) gboolean;
pub extern fn gtk_font_dialog_button_set_use_size(self: ?*GtkFontDialogButton, use_size: gboolean) void;
pub const struct__GtkFrame = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkFrame = struct__GtkFrame;
pub const struct__GtkFrameClass = extern struct {
    parent_class: GtkWidgetClass,
    compute_child_allocation: ?*const fn ([*c]GtkFrame, [*c]GtkAllocation) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkFrameClass = struct__GtkFrameClass;
pub extern fn gtk_frame_get_type() GType;
pub extern fn gtk_frame_new(label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_frame_set_label(frame: [*c]GtkFrame, label: [*c]const u8) void;
pub extern fn gtk_frame_get_label(frame: [*c]GtkFrame) [*c]const u8;
pub extern fn gtk_frame_set_label_widget(frame: [*c]GtkFrame, label_widget: [*c]GtkWidget) void;
pub extern fn gtk_frame_get_label_widget(frame: [*c]GtkFrame) [*c]GtkWidget;
pub extern fn gtk_frame_set_label_align(frame: [*c]GtkFrame, xalign: f32) void;
pub extern fn gtk_frame_get_label_align(frame: [*c]GtkFrame) f32;
pub extern fn gtk_frame_set_child(frame: [*c]GtkFrame, child: [*c]GtkWidget) void;
pub extern fn gtk_frame_get_child(frame: [*c]GtkFrame) [*c]GtkWidget;
pub const GtkFrame_autoptr = [*c]GtkFrame;
pub const GtkFrame_listautoptr = [*c]GList;
pub const GtkFrame_slistautoptr = [*c]GSList;
pub const GtkFrame_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFrame(arg__ptr: [*c]GtkFrame) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkFrame(arg__ptr: [*c][*c]GtkFrame) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkFrame(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkFrame(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkFrame(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkFrame(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureClass = opaque {};
pub const GtkGestureClass = struct__GtkGestureClass;
pub extern fn gtk_gesture_get_type() GType;
pub extern fn gtk_gesture_get_device(gesture: ?*GtkGesture) ?*GdkDevice;
pub extern fn gtk_gesture_set_state(gesture: ?*GtkGesture, state: GtkEventSequenceState) gboolean;
pub extern fn gtk_gesture_get_sequence_state(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence) GtkEventSequenceState;
pub extern fn gtk_gesture_set_sequence_state(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence, state: GtkEventSequenceState) gboolean;
pub extern fn gtk_gesture_get_sequences(gesture: ?*GtkGesture) [*c]GList;
pub extern fn gtk_gesture_get_last_updated_sequence(gesture: ?*GtkGesture) ?*GdkEventSequence;
pub extern fn gtk_gesture_handles_sequence(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence) gboolean;
pub extern fn gtk_gesture_get_last_event(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence) ?*GdkEvent;
pub extern fn gtk_gesture_get_point(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence, x: [*c]f64, y: [*c]f64) gboolean;
pub extern fn gtk_gesture_get_bounding_box(gesture: ?*GtkGesture, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_gesture_get_bounding_box_center(gesture: ?*GtkGesture, x: [*c]f64, y: [*c]f64) gboolean;
pub extern fn gtk_gesture_is_active(gesture: ?*GtkGesture) gboolean;
pub extern fn gtk_gesture_is_recognized(gesture: ?*GtkGesture) gboolean;
pub extern fn gtk_gesture_group(group_gesture: ?*GtkGesture, gesture: ?*GtkGesture) void;
pub extern fn gtk_gesture_ungroup(gesture: ?*GtkGesture) void;
pub extern fn gtk_gesture_get_group(gesture: ?*GtkGesture) [*c]GList;
pub extern fn gtk_gesture_is_grouped_with(gesture: ?*GtkGesture, other: ?*GtkGesture) gboolean;
pub const GtkGesture_autoptr = ?*GtkGesture;
pub const GtkGesture_listautoptr = [*c]GList;
pub const GtkGesture_slistautoptr = [*c]GSList;
pub const GtkGesture_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGesture(arg__ptr: ?*GtkGesture) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGesture(arg__ptr: [*c]?*GtkGesture) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGesture(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGesture(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGesture(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGesture(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureSingle = opaque {};
pub const GtkGestureSingle = struct__GtkGestureSingle;
pub const struct__GtkGestureSingleClass = opaque {};
pub const GtkGestureSingleClass = struct__GtkGestureSingleClass;
pub extern fn gtk_gesture_single_get_type() GType;
pub extern fn gtk_gesture_single_get_touch_only(gesture: ?*GtkGestureSingle) gboolean;
pub extern fn gtk_gesture_single_set_touch_only(gesture: ?*GtkGestureSingle, touch_only: gboolean) void;
pub extern fn gtk_gesture_single_get_exclusive(gesture: ?*GtkGestureSingle) gboolean;
pub extern fn gtk_gesture_single_set_exclusive(gesture: ?*GtkGestureSingle, exclusive: gboolean) void;
pub extern fn gtk_gesture_single_get_button(gesture: ?*GtkGestureSingle) guint;
pub extern fn gtk_gesture_single_set_button(gesture: ?*GtkGestureSingle, button: guint) void;
pub extern fn gtk_gesture_single_get_current_button(gesture: ?*GtkGestureSingle) guint;
pub extern fn gtk_gesture_single_get_current_sequence(gesture: ?*GtkGestureSingle) ?*GdkEventSequence;
pub const GtkGestureSingle_autoptr = ?*GtkGestureSingle;
pub const GtkGestureSingle_listautoptr = [*c]GList;
pub const GtkGestureSingle_slistautoptr = [*c]GSList;
pub const GtkGestureSingle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureSingle(arg__ptr: ?*GtkGestureSingle) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureSingle(arg__ptr: [*c]?*GtkGestureSingle) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureSingle(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureSingle(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureSingle(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureSingle(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureClick = opaque {};
pub const GtkGestureClick = struct__GtkGestureClick;
pub const struct__GtkGestureClickClass = opaque {};
pub const GtkGestureClickClass = struct__GtkGestureClickClass;
pub extern fn gtk_gesture_click_get_type() GType;
pub extern fn gtk_gesture_click_new() ?*GtkGesture;
pub const GtkGestureClick_autoptr = ?*GtkGestureClick;
pub const GtkGestureClick_listautoptr = [*c]GList;
pub const GtkGestureClick_slistautoptr = [*c]GSList;
pub const GtkGestureClick_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureClick(arg__ptr: ?*GtkGestureClick) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureClick(arg__ptr: [*c]?*GtkGestureClick) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureClick(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureClick(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureClick(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureClick(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureDrag = opaque {};
pub const GtkGestureDrag = struct__GtkGestureDrag;
pub const struct__GtkGestureDragClass = opaque {};
pub const GtkGestureDragClass = struct__GtkGestureDragClass;
pub extern fn gtk_gesture_drag_get_type() GType;
pub extern fn gtk_gesture_drag_new() ?*GtkGesture;
pub extern fn gtk_gesture_drag_get_start_point(gesture: ?*GtkGestureDrag, x: [*c]f64, y: [*c]f64) gboolean;
pub extern fn gtk_gesture_drag_get_offset(gesture: ?*GtkGestureDrag, x: [*c]f64, y: [*c]f64) gboolean;
pub const GtkGestureDrag_autoptr = ?*GtkGestureDrag;
pub const GtkGestureDrag_listautoptr = [*c]GList;
pub const GtkGestureDrag_slistautoptr = [*c]GSList;
pub const GtkGestureDrag_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureDrag(arg__ptr: ?*GtkGestureDrag) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureDrag(arg__ptr: [*c]?*GtkGestureDrag) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureDrag(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureDrag(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureDrag(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureDrag(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureLongPress = opaque {};
pub const GtkGestureLongPress = struct__GtkGestureLongPress;
pub const struct__GtkGestureLongPressClass = opaque {};
pub const GtkGestureLongPressClass = struct__GtkGestureLongPressClass;
pub extern fn gtk_gesture_long_press_get_type() GType;
pub extern fn gtk_gesture_long_press_new() ?*GtkGesture;
pub extern fn gtk_gesture_long_press_set_delay_factor(gesture: ?*GtkGestureLongPress, delay_factor: f64) void;
pub extern fn gtk_gesture_long_press_get_delay_factor(gesture: ?*GtkGestureLongPress) f64;
pub const GtkGestureLongPress_autoptr = ?*GtkGestureLongPress;
pub const GtkGestureLongPress_listautoptr = [*c]GList;
pub const GtkGestureLongPress_slistautoptr = [*c]GSList;
pub const GtkGestureLongPress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureLongPress(arg__ptr: ?*GtkGestureLongPress) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureLongPress(arg__ptr: [*c]?*GtkGestureLongPress) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureLongPress(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureLongPress(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureLongPress(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureLongPress(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGesturePan = opaque {};
pub const GtkGesturePan = struct__GtkGesturePan;
pub const struct__GtkGesturePanClass = opaque {};
pub const GtkGesturePanClass = struct__GtkGesturePanClass;
pub extern fn gtk_gesture_pan_get_type() GType;
pub extern fn gtk_gesture_pan_new(orientation: GtkOrientation) ?*GtkGesture;
pub extern fn gtk_gesture_pan_get_orientation(gesture: ?*GtkGesturePan) GtkOrientation;
pub extern fn gtk_gesture_pan_set_orientation(gesture: ?*GtkGesturePan, orientation: GtkOrientation) void;
pub const GtkGesturePan_autoptr = ?*GtkGesturePan;
pub const GtkGesturePan_listautoptr = [*c]GList;
pub const GtkGesturePan_slistautoptr = [*c]GSList;
pub const GtkGesturePan_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGesturePan(arg__ptr: ?*GtkGesturePan) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGesturePan(arg__ptr: [*c]?*GtkGesturePan) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGesturePan(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGesturePan(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGesturePan(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGesturePan(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureRotate = opaque {};
pub const GtkGestureRotate = struct__GtkGestureRotate;
pub const struct__GtkGestureRotateClass = opaque {};
pub const GtkGestureRotateClass = struct__GtkGestureRotateClass;
pub extern fn gtk_gesture_rotate_get_type() GType;
pub extern fn gtk_gesture_rotate_new() ?*GtkGesture;
pub extern fn gtk_gesture_rotate_get_angle_delta(gesture: ?*GtkGestureRotate) f64;
pub const GtkGestureRotate_autoptr = ?*GtkGestureRotate;
pub const GtkGestureRotate_listautoptr = [*c]GList;
pub const GtkGestureRotate_slistautoptr = [*c]GSList;
pub const GtkGestureRotate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureRotate(arg__ptr: ?*GtkGestureRotate) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureRotate(arg__ptr: [*c]?*GtkGestureRotate) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureRotate(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureRotate(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureRotate(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureRotate(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureStylus = opaque {};
pub const GtkGestureStylus = struct__GtkGestureStylus;
pub const struct__GtkGestureStylusClass = opaque {};
pub const GtkGestureStylusClass = struct__GtkGestureStylusClass;
pub extern fn gtk_gesture_stylus_get_type() GType;
pub extern fn gtk_gesture_stylus_new() ?*GtkGesture;
pub extern fn gtk_gesture_stylus_get_stylus_only(gesture: ?*GtkGestureStylus) gboolean;
pub extern fn gtk_gesture_stylus_set_stylus_only(gesture: ?*GtkGestureStylus, stylus_only: gboolean) void;
pub extern fn gtk_gesture_stylus_get_axis(gesture: ?*GtkGestureStylus, axis: GdkAxisUse, value: [*c]f64) gboolean;
pub extern fn gtk_gesture_stylus_get_axes(gesture: ?*GtkGestureStylus, axes: [*c]GdkAxisUse, values: [*c][*c]f64) gboolean;
pub extern fn gtk_gesture_stylus_get_backlog(gesture: ?*GtkGestureStylus, backlog: [*c][*c]GdkTimeCoord, n_elems: [*c]guint) gboolean;
pub extern fn gtk_gesture_stylus_get_device_tool(gesture: ?*GtkGestureStylus) ?*GdkDeviceTool;
pub const struct__GtkGestureSwipe = opaque {};
pub const GtkGestureSwipe = struct__GtkGestureSwipe;
pub const struct__GtkGestureSwipeClass = opaque {};
pub const GtkGestureSwipeClass = struct__GtkGestureSwipeClass;
pub extern fn gtk_gesture_swipe_get_type() GType;
pub extern fn gtk_gesture_swipe_new() ?*GtkGesture;
pub extern fn gtk_gesture_swipe_get_velocity(gesture: ?*GtkGestureSwipe, velocity_x: [*c]f64, velocity_y: [*c]f64) gboolean;
pub const GtkGestureSwipe_autoptr = ?*GtkGestureSwipe;
pub const GtkGestureSwipe_listautoptr = [*c]GList;
pub const GtkGestureSwipe_slistautoptr = [*c]GSList;
pub const GtkGestureSwipe_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureSwipe(arg__ptr: ?*GtkGestureSwipe) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureSwipe(arg__ptr: [*c]?*GtkGestureSwipe) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureSwipe(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureSwipe(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureSwipe(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureSwipe(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGestureZoom = opaque {};
pub const GtkGestureZoom = struct__GtkGestureZoom;
pub const struct__GtkGestureZoomClass = opaque {};
pub const GtkGestureZoomClass = struct__GtkGestureZoomClass;
pub extern fn gtk_gesture_zoom_get_type() GType;
pub extern fn gtk_gesture_zoom_new() ?*GtkGesture;
pub extern fn gtk_gesture_zoom_get_scale_delta(gesture: ?*GtkGestureZoom) f64;
pub const GtkGestureZoom_autoptr = ?*GtkGestureZoom;
pub const GtkGestureZoom_listautoptr = [*c]GList;
pub const GtkGestureZoom_slistautoptr = [*c]GSList;
pub const GtkGestureZoom_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureZoom(arg__ptr: ?*GtkGestureZoom) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGestureZoom(arg__ptr: [*c]?*GtkGestureZoom) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGestureZoom(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureZoom(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureZoom(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureZoom(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGLArea = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkGLArea = struct__GtkGLArea;
pub const struct__GtkGLAreaClass = extern struct {
    parent_class: GtkWidgetClass,
    render: ?*const fn ([*c]GtkGLArea, ?*GdkGLContext) callconv(.C) gboolean,
    resize: ?*const fn ([*c]GtkGLArea, c_int, c_int) callconv(.C) void,
    create_context: ?*const fn ([*c]GtkGLArea) callconv(.C) ?*GdkGLContext,
    _padding: [8]gpointer,
};
pub const GtkGLAreaClass = struct__GtkGLAreaClass;
pub extern fn gtk_gl_area_get_type() GType;
pub extern fn gtk_gl_area_new() [*c]GtkWidget;
pub extern fn gtk_gl_area_set_allowed_apis(area: [*c]GtkGLArea, apis: GdkGLAPI) void;
pub extern fn gtk_gl_area_get_allowed_apis(area: [*c]GtkGLArea) GdkGLAPI;
pub extern fn gtk_gl_area_get_api(area: [*c]GtkGLArea) GdkGLAPI;
pub extern fn gtk_gl_area_set_use_es(area: [*c]GtkGLArea, use_es: gboolean) void;
pub extern fn gtk_gl_area_get_use_es(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_required_version(area: [*c]GtkGLArea, major: c_int, minor: c_int) void;
pub extern fn gtk_gl_area_get_required_version(area: [*c]GtkGLArea, major: [*c]c_int, minor: [*c]c_int) void;
pub extern fn gtk_gl_area_get_has_depth_buffer(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_has_depth_buffer(area: [*c]GtkGLArea, has_depth_buffer: gboolean) void;
pub extern fn gtk_gl_area_get_has_stencil_buffer(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_has_stencil_buffer(area: [*c]GtkGLArea, has_stencil_buffer: gboolean) void;
pub extern fn gtk_gl_area_get_auto_render(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_auto_render(area: [*c]GtkGLArea, auto_render: gboolean) void;
pub extern fn gtk_gl_area_queue_render(area: [*c]GtkGLArea) void;
pub extern fn gtk_gl_area_get_context(area: [*c]GtkGLArea) ?*GdkGLContext;
pub extern fn gtk_gl_area_make_current(area: [*c]GtkGLArea) void;
pub extern fn gtk_gl_area_attach_buffers(area: [*c]GtkGLArea) void;
pub extern fn gtk_gl_area_set_error(area: [*c]GtkGLArea, @"error": [*c]const GError) void;
pub extern fn gtk_gl_area_get_error(area: [*c]GtkGLArea) [*c]GError;
pub const GtkGLArea_autoptr = [*c]GtkGLArea;
pub const GtkGLArea_listautoptr = [*c]GList;
pub const GtkGLArea_slistautoptr = [*c]GSList;
pub const GtkGLArea_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGLArea(arg__ptr: [*c]GtkGLArea) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGLArea(arg__ptr: [*c][*c]GtkGLArea) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGLArea(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGLArea(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGLArea(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGLArea(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkGrid = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkGrid = struct__GtkGrid;
pub const struct__GtkGridClass = extern struct {
    parent_class: GtkWidgetClass,
    padding: [8]gpointer,
};
pub const GtkGridClass = struct__GtkGridClass;
pub extern fn gtk_grid_get_type() GType;
pub extern fn gtk_grid_new() [*c]GtkWidget;
pub extern fn gtk_grid_attach(grid: [*c]GtkGrid, child: [*c]GtkWidget, column: c_int, row: c_int, width: c_int, height: c_int) void;
pub extern fn gtk_grid_attach_next_to(grid: [*c]GtkGrid, child: [*c]GtkWidget, sibling: [*c]GtkWidget, side: GtkPositionType, width: c_int, height: c_int) void;
pub extern fn gtk_grid_get_child_at(grid: [*c]GtkGrid, column: c_int, row: c_int) [*c]GtkWidget;
pub extern fn gtk_grid_remove(grid: [*c]GtkGrid, child: [*c]GtkWidget) void;
pub extern fn gtk_grid_insert_row(grid: [*c]GtkGrid, position: c_int) void;
pub extern fn gtk_grid_insert_column(grid: [*c]GtkGrid, position: c_int) void;
pub extern fn gtk_grid_remove_row(grid: [*c]GtkGrid, position: c_int) void;
pub extern fn gtk_grid_remove_column(grid: [*c]GtkGrid, position: c_int) void;
pub extern fn gtk_grid_insert_next_to(grid: [*c]GtkGrid, sibling: [*c]GtkWidget, side: GtkPositionType) void;
pub extern fn gtk_grid_set_row_homogeneous(grid: [*c]GtkGrid, homogeneous: gboolean) void;
pub extern fn gtk_grid_get_row_homogeneous(grid: [*c]GtkGrid) gboolean;
pub extern fn gtk_grid_set_row_spacing(grid: [*c]GtkGrid, spacing: guint) void;
pub extern fn gtk_grid_get_row_spacing(grid: [*c]GtkGrid) guint;
pub extern fn gtk_grid_set_column_homogeneous(grid: [*c]GtkGrid, homogeneous: gboolean) void;
pub extern fn gtk_grid_get_column_homogeneous(grid: [*c]GtkGrid) gboolean;
pub extern fn gtk_grid_set_column_spacing(grid: [*c]GtkGrid, spacing: guint) void;
pub extern fn gtk_grid_get_column_spacing(grid: [*c]GtkGrid) guint;
pub extern fn gtk_grid_set_row_baseline_position(grid: [*c]GtkGrid, row: c_int, pos: GtkBaselinePosition) void;
pub extern fn gtk_grid_get_row_baseline_position(grid: [*c]GtkGrid, row: c_int) GtkBaselinePosition;
pub extern fn gtk_grid_set_baseline_row(grid: [*c]GtkGrid, row: c_int) void;
pub extern fn gtk_grid_get_baseline_row(grid: [*c]GtkGrid) c_int;
pub extern fn gtk_grid_query_child(grid: [*c]GtkGrid, child: [*c]GtkWidget, column: [*c]c_int, row: [*c]c_int, width: [*c]c_int, height: [*c]c_int) void;
pub const GtkGrid_autoptr = [*c]GtkGrid;
pub const GtkGrid_listautoptr = [*c]GList;
pub const GtkGrid_slistautoptr = [*c]GSList;
pub const GtkGrid_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGrid(arg__ptr: [*c]GtkGrid) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGrid(arg__ptr: [*c][*c]GtkGrid) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGrid(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGrid(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGrid(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGrid(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_grid_layout_get_type() GType;
pub const struct__GtkGridLayout = opaque {};
pub const GtkGridLayout = struct__GtkGridLayout;
pub const GtkGridLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkGridLayout_autoptr = ?*GtkGridLayout;
pub const GtkGridLayout_listautoptr = [*c]GList;
pub const GtkGridLayout_slistautoptr = [*c]GSList;
pub const GtkGridLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGridLayout(arg__ptr: ?*GtkGridLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkGridLayout(arg__ptr: [*c]?*GtkGridLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGridLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGridLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGridLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGridLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkGridLayoutClass_autoptr = [*c]GtkGridLayoutClass;
pub const GtkGridLayoutClass_listautoptr = [*c]GList;
pub const GtkGridLayoutClass_slistautoptr = [*c]GSList;
pub const GtkGridLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGridLayoutClass(arg__ptr: [*c]GtkGridLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGridLayoutClass(arg__ptr: [*c][*c]GtkGridLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGridLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGridLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGridLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGridLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_GRID_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkGridLayout {
    var ptr = arg_ptr;
    return @as(?*GtkGridLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_grid_layout_get_type())))));
}
pub fn GTK_IS_GRID_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_grid_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_grid_layout_new() [*c]GtkLayoutManager;
pub extern fn gtk_grid_layout_set_row_homogeneous(grid: ?*GtkGridLayout, homogeneous: gboolean) void;
pub extern fn gtk_grid_layout_get_row_homogeneous(grid: ?*GtkGridLayout) gboolean;
pub extern fn gtk_grid_layout_set_row_spacing(grid: ?*GtkGridLayout, spacing: guint) void;
pub extern fn gtk_grid_layout_get_row_spacing(grid: ?*GtkGridLayout) guint;
pub extern fn gtk_grid_layout_set_column_homogeneous(grid: ?*GtkGridLayout, homogeneous: gboolean) void;
pub extern fn gtk_grid_layout_get_column_homogeneous(grid: ?*GtkGridLayout) gboolean;
pub extern fn gtk_grid_layout_set_column_spacing(grid: ?*GtkGridLayout, spacing: guint) void;
pub extern fn gtk_grid_layout_get_column_spacing(grid: ?*GtkGridLayout) guint;
pub extern fn gtk_grid_layout_set_row_baseline_position(grid: ?*GtkGridLayout, row: c_int, pos: GtkBaselinePosition) void;
pub extern fn gtk_grid_layout_get_row_baseline_position(grid: ?*GtkGridLayout, row: c_int) GtkBaselinePosition;
pub extern fn gtk_grid_layout_set_baseline_row(grid: ?*GtkGridLayout, row: c_int) void;
pub extern fn gtk_grid_layout_get_baseline_row(grid: ?*GtkGridLayout) c_int;
pub extern fn gtk_grid_layout_child_get_type() GType;
pub const struct__GtkGridLayoutChild = opaque {};
pub const GtkGridLayoutChild = struct__GtkGridLayoutChild;
pub const GtkGridLayoutChildClass = extern struct {
    parent_class: GtkLayoutChildClass,
};
pub const GtkGridLayoutChild_autoptr = ?*GtkGridLayoutChild;
pub const GtkGridLayoutChild_listautoptr = [*c]GList;
pub const GtkGridLayoutChild_slistautoptr = [*c]GSList;
pub const GtkGridLayoutChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGridLayoutChild(arg__ptr: ?*GtkGridLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutChild(@as([*c]GtkLayoutChild, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkGridLayoutChild(arg__ptr: [*c]?*GtkGridLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGridLayoutChild(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGridLayoutChild(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGridLayoutChild(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGridLayoutChild(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
    }
}
pub const GtkGridLayoutChildClass_autoptr = [*c]GtkGridLayoutChildClass;
pub const GtkGridLayoutChildClass_listautoptr = [*c]GList;
pub const GtkGridLayoutChildClass_slistautoptr = [*c]GSList;
pub const GtkGridLayoutChildClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGridLayoutChildClass(arg__ptr: [*c]GtkGridLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGridLayoutChildClass(arg__ptr: [*c][*c]GtkGridLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGridLayoutChildClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGridLayoutChildClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGridLayoutChildClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGridLayoutChildClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_GRID_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) ?*GtkGridLayoutChild {
    var ptr = arg_ptr;
    return @as(?*GtkGridLayoutChild, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_grid_layout_child_get_type())))));
}
pub fn GTK_IS_GRID_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_grid_layout_child_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_grid_layout_child_set_row(child: ?*GtkGridLayoutChild, row: c_int) void;
pub extern fn gtk_grid_layout_child_get_row(child: ?*GtkGridLayoutChild) c_int;
pub extern fn gtk_grid_layout_child_set_column(child: ?*GtkGridLayoutChild, column: c_int) void;
pub extern fn gtk_grid_layout_child_get_column(child: ?*GtkGridLayoutChild) c_int;
pub extern fn gtk_grid_layout_child_set_column_span(child: ?*GtkGridLayoutChild, span: c_int) void;
pub extern fn gtk_grid_layout_child_get_column_span(child: ?*GtkGridLayoutChild) c_int;
pub extern fn gtk_grid_layout_child_set_row_span(child: ?*GtkGridLayoutChild, span: c_int) void;
pub extern fn gtk_grid_layout_child_get_row_span(child: ?*GtkGridLayoutChild) c_int;
pub const struct__GtkListBase = opaque {};
pub const GtkListBase = struct__GtkListBase;
pub const struct__GtkListBaseClass = opaque {};
pub const GtkListBaseClass = struct__GtkListBaseClass;
pub extern fn gtk_list_base_get_type() GType;
pub const struct__GtkGridView = opaque {};
pub const GtkGridView = struct__GtkGridView;
pub const struct__GtkGridViewClass = opaque {};
pub const GtkGridViewClass = struct__GtkGridViewClass;
pub extern fn gtk_grid_view_get_type() GType;
pub extern fn gtk_grid_view_new(model: ?*GtkSelectionModel, factory: ?*GtkListItemFactory) [*c]GtkWidget;
pub extern fn gtk_grid_view_get_model(self: ?*GtkGridView) ?*GtkSelectionModel;
pub extern fn gtk_grid_view_set_model(self: ?*GtkGridView, model: ?*GtkSelectionModel) void;
pub extern fn gtk_grid_view_set_factory(self: ?*GtkGridView, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_grid_view_get_factory(self: ?*GtkGridView) ?*GtkListItemFactory;
pub extern fn gtk_grid_view_get_min_columns(self: ?*GtkGridView) guint;
pub extern fn gtk_grid_view_set_min_columns(self: ?*GtkGridView, min_columns: guint) void;
pub extern fn gtk_grid_view_get_max_columns(self: ?*GtkGridView) guint;
pub extern fn gtk_grid_view_set_max_columns(self: ?*GtkGridView, max_columns: guint) void;
pub extern fn gtk_grid_view_set_enable_rubberband(self: ?*GtkGridView, enable_rubberband: gboolean) void;
pub extern fn gtk_grid_view_get_enable_rubberband(self: ?*GtkGridView) gboolean;
pub extern fn gtk_grid_view_set_tab_behavior(self: ?*GtkGridView, tab_behavior: GtkListTabBehavior) void;
pub extern fn gtk_grid_view_get_tab_behavior(self: ?*GtkGridView) GtkListTabBehavior;
pub extern fn gtk_grid_view_set_single_click_activate(self: ?*GtkGridView, single_click_activate: gboolean) void;
pub extern fn gtk_grid_view_get_single_click_activate(self: ?*GtkGridView) gboolean;
pub extern fn gtk_grid_view_scroll_to(self: ?*GtkGridView, pos: guint, flags: GtkListScrollFlags, scroll: ?*GtkScrollInfo) void;
pub const GtkGridView_autoptr = ?*GtkGridView;
pub const GtkGridView_listautoptr = [*c]GList;
pub const GtkGridView_slistautoptr = [*c]GSList;
pub const GtkGridView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGridView(arg__ptr: ?*GtkGridView) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkGridView(arg__ptr: [*c]?*GtkGridView) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkGridView(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkGridView(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkGridView(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkGridView(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkHeaderBar = opaque {};
pub const GtkHeaderBar = struct__GtkHeaderBar;
pub extern fn gtk_header_bar_get_type() GType;
pub extern fn gtk_header_bar_new() [*c]GtkWidget;
pub extern fn gtk_header_bar_set_title_widget(bar: ?*GtkHeaderBar, title_widget: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_get_title_widget(bar: ?*GtkHeaderBar) [*c]GtkWidget;
pub extern fn gtk_header_bar_pack_start(bar: ?*GtkHeaderBar, child: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_pack_end(bar: ?*GtkHeaderBar, child: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_remove(bar: ?*GtkHeaderBar, child: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_get_show_title_buttons(bar: ?*GtkHeaderBar) gboolean;
pub extern fn gtk_header_bar_set_show_title_buttons(bar: ?*GtkHeaderBar, setting: gboolean) void;
pub extern fn gtk_header_bar_set_decoration_layout(bar: ?*GtkHeaderBar, layout: [*c]const u8) void;
pub extern fn gtk_header_bar_get_decoration_layout(bar: ?*GtkHeaderBar) [*c]const u8;
pub const GtkHeaderBar_autoptr = ?*GtkHeaderBar;
pub const GtkHeaderBar_listautoptr = [*c]GList;
pub const GtkHeaderBar_slistautoptr = [*c]GSList;
pub const GtkHeaderBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkHeaderBar(arg__ptr: ?*GtkHeaderBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkHeaderBar(arg__ptr: [*c]?*GtkHeaderBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkHeaderBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkHeaderBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkHeaderBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkHeaderBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkIconPaintable = opaque {};
pub const GtkIconPaintable = struct__GtkIconPaintable;
pub const struct__GtkIconTheme = opaque {};
pub const GtkIconTheme = struct__GtkIconTheme;
pub const GTK_ICON_LOOKUP_FORCE_REGULAR: c_int = 1;
pub const GTK_ICON_LOOKUP_FORCE_SYMBOLIC: c_int = 2;
pub const GTK_ICON_LOOKUP_PRELOAD: c_int = 4;
pub const GtkIconLookupFlags = c_uint;
pub const GTK_ICON_THEME_NOT_FOUND: c_int = 0;
pub const GTK_ICON_THEME_FAILED: c_int = 1;
pub const GtkIconThemeError = c_uint;
pub extern fn gtk_icon_theme_error_quark() GQuark;
pub extern fn gtk_icon_theme_get_type() GType;
pub extern fn gtk_icon_theme_new() ?*GtkIconTheme;
pub extern fn gtk_icon_theme_get_for_display(display: ?*GdkDisplay) ?*GtkIconTheme;
pub extern fn gtk_icon_theme_get_display(self: ?*GtkIconTheme) ?*GdkDisplay;
pub extern fn gtk_icon_theme_set_search_path(self: ?*GtkIconTheme, path: [*c]const [*c]const u8) void;
pub extern fn gtk_icon_theme_get_search_path(self: ?*GtkIconTheme) [*c][*c]u8;
pub extern fn gtk_icon_theme_add_search_path(self: ?*GtkIconTheme, path: [*c]const u8) void;
pub extern fn gtk_icon_theme_set_resource_path(self: ?*GtkIconTheme, path: [*c]const [*c]const u8) void;
pub extern fn gtk_icon_theme_get_resource_path(self: ?*GtkIconTheme) [*c][*c]u8;
pub extern fn gtk_icon_theme_add_resource_path(self: ?*GtkIconTheme, path: [*c]const u8) void;
pub extern fn gtk_icon_theme_set_theme_name(self: ?*GtkIconTheme, theme_name: [*c]const u8) void;
pub extern fn gtk_icon_theme_get_theme_name(self: ?*GtkIconTheme) [*c]u8;
pub extern fn gtk_icon_theme_has_icon(self: ?*GtkIconTheme, icon_name: [*c]const u8) gboolean;
pub extern fn gtk_icon_theme_has_gicon(self: ?*GtkIconTheme, gicon: ?*GIcon) gboolean;
pub extern fn gtk_icon_theme_get_icon_sizes(self: ?*GtkIconTheme, icon_name: [*c]const u8) [*c]c_int;
pub extern fn gtk_icon_theme_lookup_icon(self: ?*GtkIconTheme, icon_name: [*c]const u8, fallbacks: [*c][*c]const u8, size: c_int, scale: c_int, direction: GtkTextDirection, flags: GtkIconLookupFlags) ?*GtkIconPaintable;
pub extern fn gtk_icon_theme_lookup_by_gicon(self: ?*GtkIconTheme, icon: ?*GIcon, size: c_int, scale: c_int, direction: GtkTextDirection, flags: GtkIconLookupFlags) ?*GtkIconPaintable;
pub extern fn gtk_icon_paintable_new_for_file(file: ?*GFile, size: c_int, scale: c_int) ?*GtkIconPaintable;
pub extern fn gtk_icon_theme_get_icon_names(self: ?*GtkIconTheme) [*c][*c]u8;
pub extern fn gtk_icon_paintable_get_type() GType;
pub extern fn gtk_icon_paintable_get_file(self: ?*GtkIconPaintable) ?*GFile;
pub extern fn gtk_icon_paintable_get_icon_name(self: ?*GtkIconPaintable) [*c]const u8;
pub extern fn gtk_icon_paintable_is_symbolic(self: ?*GtkIconPaintable) gboolean;
pub const GtkIconPaintable_autoptr = ?*GtkIconPaintable;
pub const GtkIconPaintable_listautoptr = [*c]GList;
pub const GtkIconPaintable_slistautoptr = [*c]GSList;
pub const GtkIconPaintable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIconPaintable(arg__ptr: ?*GtkIconPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkIconPaintable(arg__ptr: [*c]?*GtkIconPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkIconPaintable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkIconPaintable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkIconPaintable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkIconPaintable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkIconTheme_autoptr = ?*GtkIconTheme;
pub const GtkIconTheme_listautoptr = [*c]GList;
pub const GtkIconTheme_slistautoptr = [*c]GSList;
pub const GtkIconTheme_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIconTheme(arg__ptr: ?*GtkIconTheme) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkIconTheme(arg__ptr: [*c]?*GtkIconTheme) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkIconTheme(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkIconTheme(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkIconTheme(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkIconTheme(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_tooltip_get_type() GType;
pub extern fn gtk_tooltip_set_markup(tooltip: ?*GtkTooltip, markup: [*c]const u8) void;
pub extern fn gtk_tooltip_set_text(tooltip: ?*GtkTooltip, text: [*c]const u8) void;
pub extern fn gtk_tooltip_set_icon(tooltip: ?*GtkTooltip, paintable: ?*GdkPaintable) void;
pub extern fn gtk_tooltip_set_icon_from_icon_name(tooltip: ?*GtkTooltip, icon_name: [*c]const u8) void;
pub extern fn gtk_tooltip_set_icon_from_gicon(tooltip: ?*GtkTooltip, gicon: ?*GIcon) void;
pub extern fn gtk_tooltip_set_custom(tooltip: ?*GtkTooltip, custom_widget: [*c]GtkWidget) void;
pub extern fn gtk_tooltip_set_tip_area(tooltip: ?*GtkTooltip, rect: [*c]const GdkRectangle) void;
pub const GtkTooltip_autoptr = ?*GtkTooltip;
pub const GtkTooltip_listautoptr = [*c]GList;
pub const GtkTooltip_slistautoptr = [*c]GSList;
pub const GtkTooltip_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTooltip(arg__ptr: ?*GtkTooltip) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTooltip(arg__ptr: [*c]?*GtkTooltip) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTooltip(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTooltip(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTooltip(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTooltip(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkIconView = opaque {};
pub const GtkIconView = struct__GtkIconView;
pub const GtkIconViewForeachFunc = ?*const fn (?*GtkIconView, ?*GtkTreePath, gpointer) callconv(.C) void;
pub const GTK_ICON_VIEW_NO_DROP: c_int = 0;
pub const GTK_ICON_VIEW_DROP_INTO: c_int = 1;
pub const GTK_ICON_VIEW_DROP_LEFT: c_int = 2;
pub const GTK_ICON_VIEW_DROP_RIGHT: c_int = 3;
pub const GTK_ICON_VIEW_DROP_ABOVE: c_int = 4;
pub const GTK_ICON_VIEW_DROP_BELOW: c_int = 5;
pub const GtkIconViewDropPosition = c_uint;
pub extern fn gtk_icon_view_get_type() GType;
pub extern fn gtk_icon_view_new() [*c]GtkWidget;
pub extern fn gtk_icon_view_new_with_area(area: [*c]GtkCellArea) [*c]GtkWidget;
pub extern fn gtk_icon_view_new_with_model(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_icon_view_set_model(icon_view: ?*GtkIconView, model: ?*GtkTreeModel) void;
pub extern fn gtk_icon_view_get_model(icon_view: ?*GtkIconView) ?*GtkTreeModel;
pub extern fn gtk_icon_view_set_text_column(icon_view: ?*GtkIconView, column: c_int) void;
pub extern fn gtk_icon_view_get_text_column(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_markup_column(icon_view: ?*GtkIconView, column: c_int) void;
pub extern fn gtk_icon_view_get_markup_column(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_pixbuf_column(icon_view: ?*GtkIconView, column: c_int) void;
pub extern fn gtk_icon_view_get_pixbuf_column(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_item_orientation(icon_view: ?*GtkIconView, orientation: GtkOrientation) void;
pub extern fn gtk_icon_view_get_item_orientation(icon_view: ?*GtkIconView) GtkOrientation;
pub extern fn gtk_icon_view_set_columns(icon_view: ?*GtkIconView, columns: c_int) void;
pub extern fn gtk_icon_view_get_columns(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_item_width(icon_view: ?*GtkIconView, item_width: c_int) void;
pub extern fn gtk_icon_view_get_item_width(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_spacing(icon_view: ?*GtkIconView, spacing: c_int) void;
pub extern fn gtk_icon_view_get_spacing(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_row_spacing(icon_view: ?*GtkIconView, row_spacing: c_int) void;
pub extern fn gtk_icon_view_get_row_spacing(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_column_spacing(icon_view: ?*GtkIconView, column_spacing: c_int) void;
pub extern fn gtk_icon_view_get_column_spacing(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_margin(icon_view: ?*GtkIconView, margin: c_int) void;
pub extern fn gtk_icon_view_get_margin(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_set_item_padding(icon_view: ?*GtkIconView, item_padding: c_int) void;
pub extern fn gtk_icon_view_get_item_padding(icon_view: ?*GtkIconView) c_int;
pub extern fn gtk_icon_view_get_path_at_pos(icon_view: ?*GtkIconView, x: c_int, y: c_int) ?*GtkTreePath;
pub extern fn gtk_icon_view_get_item_at_pos(icon_view: ?*GtkIconView, x: c_int, y: c_int, path: [*c]?*GtkTreePath, cell: [*c][*c]GtkCellRenderer) gboolean;
pub extern fn gtk_icon_view_get_visible_range(icon_view: ?*GtkIconView, start_path: [*c]?*GtkTreePath, end_path: [*c]?*GtkTreePath) gboolean;
pub extern fn gtk_icon_view_set_activate_on_single_click(icon_view: ?*GtkIconView, single: gboolean) void;
pub extern fn gtk_icon_view_get_activate_on_single_click(icon_view: ?*GtkIconView) gboolean;
pub extern fn gtk_icon_view_selected_foreach(icon_view: ?*GtkIconView, func: GtkIconViewForeachFunc, data: gpointer) void;
pub extern fn gtk_icon_view_set_selection_mode(icon_view: ?*GtkIconView, mode: GtkSelectionMode) void;
pub extern fn gtk_icon_view_get_selection_mode(icon_view: ?*GtkIconView) GtkSelectionMode;
pub extern fn gtk_icon_view_select_path(icon_view: ?*GtkIconView, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_unselect_path(icon_view: ?*GtkIconView, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_path_is_selected(icon_view: ?*GtkIconView, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_icon_view_get_item_row(icon_view: ?*GtkIconView, path: ?*GtkTreePath) c_int;
pub extern fn gtk_icon_view_get_item_column(icon_view: ?*GtkIconView, path: ?*GtkTreePath) c_int;
pub extern fn gtk_icon_view_get_selected_items(icon_view: ?*GtkIconView) [*c]GList;
pub extern fn gtk_icon_view_select_all(icon_view: ?*GtkIconView) void;
pub extern fn gtk_icon_view_unselect_all(icon_view: ?*GtkIconView) void;
pub extern fn gtk_icon_view_item_activated(icon_view: ?*GtkIconView, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_set_cursor(icon_view: ?*GtkIconView, path: ?*GtkTreePath, cell: [*c]GtkCellRenderer, start_editing: gboolean) void;
pub extern fn gtk_icon_view_get_cursor(icon_view: ?*GtkIconView, path: [*c]?*GtkTreePath, cell: [*c][*c]GtkCellRenderer) gboolean;
pub extern fn gtk_icon_view_scroll_to_path(icon_view: ?*GtkIconView, path: ?*GtkTreePath, use_align: gboolean, row_align: f32, col_align: f32) void;
pub extern fn gtk_icon_view_enable_model_drag_source(icon_view: ?*GtkIconView, start_button_mask: GdkModifierType, formats: ?*GdkContentFormats, actions: GdkDragAction) void;
pub extern fn gtk_icon_view_enable_model_drag_dest(icon_view: ?*GtkIconView, formats: ?*GdkContentFormats, actions: GdkDragAction) void;
pub extern fn gtk_icon_view_unset_model_drag_source(icon_view: ?*GtkIconView) void;
pub extern fn gtk_icon_view_unset_model_drag_dest(icon_view: ?*GtkIconView) void;
pub extern fn gtk_icon_view_set_reorderable(icon_view: ?*GtkIconView, reorderable: gboolean) void;
pub extern fn gtk_icon_view_get_reorderable(icon_view: ?*GtkIconView) gboolean;
pub extern fn gtk_icon_view_set_drag_dest_item(icon_view: ?*GtkIconView, path: ?*GtkTreePath, pos: GtkIconViewDropPosition) void;
pub extern fn gtk_icon_view_get_drag_dest_item(icon_view: ?*GtkIconView, path: [*c]?*GtkTreePath, pos: [*c]GtkIconViewDropPosition) void;
pub extern fn gtk_icon_view_get_dest_item_at_pos(icon_view: ?*GtkIconView, drag_x: c_int, drag_y: c_int, path: [*c]?*GtkTreePath, pos: [*c]GtkIconViewDropPosition) gboolean;
pub extern fn gtk_icon_view_create_drag_icon(icon_view: ?*GtkIconView, path: ?*GtkTreePath) ?*GdkPaintable;
pub extern fn gtk_icon_view_get_cell_rect(icon_view: ?*GtkIconView, path: ?*GtkTreePath, cell: [*c]GtkCellRenderer, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_icon_view_set_tooltip_item(icon_view: ?*GtkIconView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_set_tooltip_cell(icon_view: ?*GtkIconView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_icon_view_get_tooltip_context(icon_view: ?*GtkIconView, x: c_int, y: c_int, keyboard_tip: gboolean, model: [*c]?*GtkTreeModel, path: [*c]?*GtkTreePath, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_icon_view_set_tooltip_column(icon_view: ?*GtkIconView, column: c_int) void;
pub extern fn gtk_icon_view_get_tooltip_column(icon_view: ?*GtkIconView) c_int;
pub const GtkIconView_autoptr = ?*GtkIconView;
pub const GtkIconView_listautoptr = [*c]GList;
pub const GtkIconView_slistautoptr = [*c]GSList;
pub const GtkIconView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIconView(arg__ptr: ?*GtkIconView) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkIconView(arg__ptr: [*c]?*GtkIconView) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkIconView(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkIconView(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkIconView(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkIconView(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkIMContextSimplePrivate = opaque {};
pub const GtkIMContextSimplePrivate = struct__GtkIMContextSimplePrivate;
pub const struct__GtkIMContextSimple = extern struct {
    object: GtkIMContext,
    priv: ?*GtkIMContextSimplePrivate,
};
pub const GtkIMContextSimple = struct__GtkIMContextSimple;
pub const struct__GtkIMContextSimpleClass = extern struct {
    parent_class: GtkIMContextClass,
};
pub const GtkIMContextSimpleClass = struct__GtkIMContextSimpleClass;
pub extern fn gtk_im_context_simple_get_type() GType;
pub extern fn gtk_im_context_simple_new() [*c]GtkIMContext;
pub extern fn gtk_im_context_simple_add_table(context_simple: [*c]GtkIMContextSimple, data: [*c]guint16, max_seq_len: c_int, n_seqs: c_int) void;
pub extern fn gtk_im_context_simple_add_compose_file(context_simple: [*c]GtkIMContextSimple, compose_file: [*c]const u8) void;
pub const GtkIMContextSimple_autoptr = [*c]GtkIMContextSimple;
pub const GtkIMContextSimple_listautoptr = [*c]GList;
pub const GtkIMContextSimple_slistautoptr = [*c]GSList;
pub const GtkIMContextSimple_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIMContextSimple(arg__ptr: [*c]GtkIMContextSimple) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkIMContextSimple(arg__ptr: [*c][*c]GtkIMContextSimple) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkIMContextSimple(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkIMContextSimple(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkIMContextSimple(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkIMContextSimple(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkIMMulticontextPrivate = opaque {};
pub const GtkIMMulticontextPrivate = struct__GtkIMMulticontextPrivate;
pub const struct__GtkIMMulticontext = extern struct {
    object: GtkIMContext,
    priv: ?*GtkIMMulticontextPrivate,
};
pub const GtkIMMulticontext = struct__GtkIMMulticontext;
pub const struct__GtkIMMulticontextClass = extern struct {
    parent_class: GtkIMContextClass,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkIMMulticontextClass = struct__GtkIMMulticontextClass;
pub extern fn gtk_im_multicontext_get_type() GType;
pub extern fn gtk_im_multicontext_new() [*c]GtkIMContext;
pub extern fn gtk_im_multicontext_get_context_id(context: [*c]GtkIMMulticontext) [*c]const u8;
pub extern fn gtk_im_multicontext_set_context_id(context: [*c]GtkIMMulticontext, context_id: [*c]const u8) void;
pub const GtkIMMulticontext_autoptr = [*c]GtkIMMulticontext;
pub const GtkIMMulticontext_listautoptr = [*c]GList;
pub const GtkIMMulticontext_slistautoptr = [*c]GSList;
pub const GtkIMMulticontext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIMMulticontext(arg__ptr: [*c]GtkIMMulticontext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkIMMulticontext(arg__ptr: [*c][*c]GtkIMMulticontext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkIMMulticontext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkIMMulticontext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkIMMulticontext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkIMMulticontext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkInfoBar = opaque {};
pub const GtkInfoBar = struct__GtkInfoBar;
pub extern fn gtk_info_bar_get_type() GType;
pub extern fn gtk_info_bar_new() [*c]GtkWidget;
pub extern fn gtk_info_bar_new_with_buttons(first_button_text: [*c]const u8, ...) [*c]GtkWidget;
pub extern fn gtk_info_bar_add_action_widget(info_bar: ?*GtkInfoBar, child: [*c]GtkWidget, response_id: c_int) void;
pub extern fn gtk_info_bar_remove_action_widget(info_bar: ?*GtkInfoBar, widget: [*c]GtkWidget) void;
pub extern fn gtk_info_bar_add_button(info_bar: ?*GtkInfoBar, button_text: [*c]const u8, response_id: c_int) [*c]GtkWidget;
pub extern fn gtk_info_bar_add_buttons(info_bar: ?*GtkInfoBar, first_button_text: [*c]const u8, ...) void;
pub extern fn gtk_info_bar_add_child(info_bar: ?*GtkInfoBar, widget: [*c]GtkWidget) void;
pub extern fn gtk_info_bar_remove_child(info_bar: ?*GtkInfoBar, widget: [*c]GtkWidget) void;
pub extern fn gtk_info_bar_set_response_sensitive(info_bar: ?*GtkInfoBar, response_id: c_int, setting: gboolean) void;
pub extern fn gtk_info_bar_set_default_response(info_bar: ?*GtkInfoBar, response_id: c_int) void;
pub extern fn gtk_info_bar_response(info_bar: ?*GtkInfoBar, response_id: c_int) void;
pub extern fn gtk_info_bar_set_message_type(info_bar: ?*GtkInfoBar, message_type: GtkMessageType) void;
pub extern fn gtk_info_bar_get_message_type(info_bar: ?*GtkInfoBar) GtkMessageType;
pub extern fn gtk_info_bar_set_show_close_button(info_bar: ?*GtkInfoBar, setting: gboolean) void;
pub extern fn gtk_info_bar_get_show_close_button(info_bar: ?*GtkInfoBar) gboolean;
pub extern fn gtk_info_bar_set_revealed(info_bar: ?*GtkInfoBar, revealed: gboolean) void;
pub extern fn gtk_info_bar_get_revealed(info_bar: ?*GtkInfoBar) gboolean;
pub const GtkInfoBar_autoptr = ?*GtkInfoBar;
pub const GtkInfoBar_listautoptr = [*c]GList;
pub const GtkInfoBar_slistautoptr = [*c]GSList;
pub const GtkInfoBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkInfoBar(arg__ptr: ?*GtkInfoBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkInfoBar(arg__ptr: [*c]?*GtkInfoBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkInfoBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkInfoBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkInfoBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkInfoBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_INSCRIPTION_OVERFLOW_CLIP: c_int = 0;
pub const GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_START: c_int = 1;
pub const GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_MIDDLE: c_int = 2;
pub const GTK_INSCRIPTION_OVERFLOW_ELLIPSIZE_END: c_int = 3;
pub const GtkInscriptionOverflow = c_uint;
pub extern fn gtk_inscription_get_type() GType;
pub const struct__GtkInscription = opaque {};
pub const GtkInscription = struct__GtkInscription;
pub const GtkInscriptionClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkInscription_autoptr = ?*GtkInscription;
pub const GtkInscription_listautoptr = [*c]GList;
pub const GtkInscription_slistautoptr = [*c]GSList;
pub const GtkInscription_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkInscription(arg__ptr: ?*GtkInscription) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkInscription(arg__ptr: [*c]?*GtkInscription) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkInscription(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkInscription(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkInscription(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkInscription(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkInscriptionClass_autoptr = [*c]GtkInscriptionClass;
pub const GtkInscriptionClass_listautoptr = [*c]GList;
pub const GtkInscriptionClass_slistautoptr = [*c]GSList;
pub const GtkInscriptionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkInscriptionClass(arg__ptr: [*c]GtkInscriptionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkInscriptionClass(arg__ptr: [*c][*c]GtkInscriptionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkInscriptionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkInscriptionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkInscriptionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkInscriptionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_INSCRIPTION(arg_ptr: gpointer) callconv(.C) ?*GtkInscription {
    var ptr = arg_ptr;
    return @as(?*GtkInscription, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_inscription_get_type())))));
}
pub fn GTK_IS_INSCRIPTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_inscription_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_inscription_new(text: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_inscription_get_text(self: ?*GtkInscription) [*c]const u8;
pub extern fn gtk_inscription_set_text(self: ?*GtkInscription, text: [*c]const u8) void;
pub extern fn gtk_inscription_get_attributes(self: ?*GtkInscription) ?*PangoAttrList;
pub extern fn gtk_inscription_set_attributes(self: ?*GtkInscription, attrs: ?*PangoAttrList) void;
pub extern fn gtk_inscription_set_markup(self: ?*GtkInscription, markup: [*c]const u8) void;
pub extern fn gtk_inscription_get_text_overflow(self: ?*GtkInscription) GtkInscriptionOverflow;
pub extern fn gtk_inscription_set_text_overflow(self: ?*GtkInscription, overflow: GtkInscriptionOverflow) void;
pub extern fn gtk_inscription_get_wrap_mode(self: ?*GtkInscription) PangoWrapMode;
pub extern fn gtk_inscription_set_wrap_mode(self: ?*GtkInscription, wrap_mode: PangoWrapMode) void;
pub extern fn gtk_inscription_get_min_chars(self: ?*GtkInscription) guint;
pub extern fn gtk_inscription_set_min_chars(self: ?*GtkInscription, min_chars: guint) void;
pub extern fn gtk_inscription_get_nat_chars(self: ?*GtkInscription) guint;
pub extern fn gtk_inscription_set_nat_chars(self: ?*GtkInscription, nat_chars: guint) void;
pub extern fn gtk_inscription_get_min_lines(self: ?*GtkInscription) guint;
pub extern fn gtk_inscription_set_min_lines(self: ?*GtkInscription, min_lines: guint) void;
pub extern fn gtk_inscription_get_nat_lines(self: ?*GtkInscription) guint;
pub extern fn gtk_inscription_set_nat_lines(self: ?*GtkInscription, nat_lines: guint) void;
pub extern fn gtk_inscription_get_xalign(self: ?*GtkInscription) f32;
pub extern fn gtk_inscription_set_xalign(self: ?*GtkInscription, xalign: f32) void;
pub extern fn gtk_inscription_get_yalign(self: ?*GtkInscription) f32;
pub extern fn gtk_inscription_set_yalign(self: ?*GtkInscription, yalign: f32) void;
pub const struct__GtkLabel = opaque {};
pub const GtkLabel = struct__GtkLabel;
pub extern fn gtk_label_get_type() GType;
pub extern fn gtk_label_new(str: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_label_new_with_mnemonic(str: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_label_set_text(self: ?*GtkLabel, str: [*c]const u8) void;
pub extern fn gtk_label_get_text(self: ?*GtkLabel) [*c]const u8;
pub extern fn gtk_label_set_attributes(self: ?*GtkLabel, attrs: ?*PangoAttrList) void;
pub extern fn gtk_label_get_attributes(self: ?*GtkLabel) ?*PangoAttrList;
pub extern fn gtk_label_set_label(self: ?*GtkLabel, str: [*c]const u8) void;
pub extern fn gtk_label_get_label(self: ?*GtkLabel) [*c]const u8;
pub extern fn gtk_label_set_markup(self: ?*GtkLabel, str: [*c]const u8) void;
pub extern fn gtk_label_set_use_markup(self: ?*GtkLabel, setting: gboolean) void;
pub extern fn gtk_label_get_use_markup(self: ?*GtkLabel) gboolean;
pub extern fn gtk_label_set_use_underline(self: ?*GtkLabel, setting: gboolean) void;
pub extern fn gtk_label_get_use_underline(self: ?*GtkLabel) gboolean;
pub extern fn gtk_label_set_markup_with_mnemonic(self: ?*GtkLabel, str: [*c]const u8) void;
pub extern fn gtk_label_get_mnemonic_keyval(self: ?*GtkLabel) guint;
pub extern fn gtk_label_set_mnemonic_widget(self: ?*GtkLabel, widget: [*c]GtkWidget) void;
pub extern fn gtk_label_get_mnemonic_widget(self: ?*GtkLabel) [*c]GtkWidget;
pub extern fn gtk_label_set_text_with_mnemonic(self: ?*GtkLabel, str: [*c]const u8) void;
pub extern fn gtk_label_set_justify(self: ?*GtkLabel, jtype: GtkJustification) void;
pub extern fn gtk_label_get_justify(self: ?*GtkLabel) GtkJustification;
pub extern fn gtk_label_set_ellipsize(self: ?*GtkLabel, mode: PangoEllipsizeMode) void;
pub extern fn gtk_label_get_ellipsize(self: ?*GtkLabel) PangoEllipsizeMode;
pub extern fn gtk_label_set_width_chars(self: ?*GtkLabel, n_chars: c_int) void;
pub extern fn gtk_label_get_width_chars(self: ?*GtkLabel) c_int;
pub extern fn gtk_label_set_max_width_chars(self: ?*GtkLabel, n_chars: c_int) void;
pub extern fn gtk_label_get_max_width_chars(self: ?*GtkLabel) c_int;
pub extern fn gtk_label_set_lines(self: ?*GtkLabel, lines: c_int) void;
pub extern fn gtk_label_get_lines(self: ?*GtkLabel) c_int;
pub extern fn gtk_label_set_wrap(self: ?*GtkLabel, wrap: gboolean) void;
pub extern fn gtk_label_get_wrap(self: ?*GtkLabel) gboolean;
pub extern fn gtk_label_set_wrap_mode(self: ?*GtkLabel, wrap_mode: PangoWrapMode) void;
pub extern fn gtk_label_get_wrap_mode(self: ?*GtkLabel) PangoWrapMode;
pub extern fn gtk_label_set_natural_wrap_mode(self: ?*GtkLabel, wrap_mode: GtkNaturalWrapMode) void;
pub extern fn gtk_label_get_natural_wrap_mode(self: ?*GtkLabel) GtkNaturalWrapMode;
pub extern fn gtk_label_set_selectable(self: ?*GtkLabel, setting: gboolean) void;
pub extern fn gtk_label_get_selectable(self: ?*GtkLabel) gboolean;
pub extern fn gtk_label_select_region(self: ?*GtkLabel, start_offset: c_int, end_offset: c_int) void;
pub extern fn gtk_label_get_selection_bounds(self: ?*GtkLabel, start: [*c]c_int, end: [*c]c_int) gboolean;
pub extern fn gtk_label_get_layout(self: ?*GtkLabel) ?*PangoLayout;
pub extern fn gtk_label_get_layout_offsets(self: ?*GtkLabel, x: [*c]c_int, y: [*c]c_int) void;
pub extern fn gtk_label_set_single_line_mode(self: ?*GtkLabel, single_line_mode: gboolean) void;
pub extern fn gtk_label_get_single_line_mode(self: ?*GtkLabel) gboolean;
pub extern fn gtk_label_get_current_uri(self: ?*GtkLabel) [*c]const u8;
pub extern fn gtk_label_set_xalign(self: ?*GtkLabel, xalign: f32) void;
pub extern fn gtk_label_get_xalign(self: ?*GtkLabel) f32;
pub extern fn gtk_label_set_yalign(self: ?*GtkLabel, yalign: f32) void;
pub extern fn gtk_label_get_yalign(self: ?*GtkLabel) f32;
pub extern fn gtk_label_set_extra_menu(self: ?*GtkLabel, model: [*c]GMenuModel) void;
pub extern fn gtk_label_get_extra_menu(self: ?*GtkLabel) [*c]GMenuModel;
pub extern fn gtk_label_set_tabs(self: ?*GtkLabel, tabs: ?*PangoTabArray) void;
pub extern fn gtk_label_get_tabs(self: ?*GtkLabel) ?*PangoTabArray;
pub const GtkLabel_autoptr = ?*GtkLabel;
pub const GtkLabel_listautoptr = [*c]GList;
pub const GtkLabel_slistautoptr = [*c]GSList;
pub const GtkLabel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLabel(arg__ptr: ?*GtkLabel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkLabel(arg__ptr: [*c]?*GtkLabel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLabel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLabel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLabel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLabel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkLevelBar = opaque {};
pub const GtkLevelBar = struct__GtkLevelBar;
pub extern fn gtk_level_bar_get_type() GType;
pub extern fn gtk_level_bar_new() [*c]GtkWidget;
pub extern fn gtk_level_bar_new_for_interval(min_value: f64, max_value: f64) [*c]GtkWidget;
pub extern fn gtk_level_bar_set_mode(self: ?*GtkLevelBar, mode: GtkLevelBarMode) void;
pub extern fn gtk_level_bar_get_mode(self: ?*GtkLevelBar) GtkLevelBarMode;
pub extern fn gtk_level_bar_set_value(self: ?*GtkLevelBar, value: f64) void;
pub extern fn gtk_level_bar_get_value(self: ?*GtkLevelBar) f64;
pub extern fn gtk_level_bar_set_min_value(self: ?*GtkLevelBar, value: f64) void;
pub extern fn gtk_level_bar_get_min_value(self: ?*GtkLevelBar) f64;
pub extern fn gtk_level_bar_set_max_value(self: ?*GtkLevelBar, value: f64) void;
pub extern fn gtk_level_bar_get_max_value(self: ?*GtkLevelBar) f64;
pub extern fn gtk_level_bar_set_inverted(self: ?*GtkLevelBar, inverted: gboolean) void;
pub extern fn gtk_level_bar_get_inverted(self: ?*GtkLevelBar) gboolean;
pub extern fn gtk_level_bar_add_offset_value(self: ?*GtkLevelBar, name: [*c]const u8, value: f64) void;
pub extern fn gtk_level_bar_remove_offset_value(self: ?*GtkLevelBar, name: [*c]const u8) void;
pub extern fn gtk_level_bar_get_offset_value(self: ?*GtkLevelBar, name: [*c]const u8, value: [*c]f64) gboolean;
pub const GtkLevelBar_autoptr = ?*GtkLevelBar;
pub const GtkLevelBar_listautoptr = [*c]GList;
pub const GtkLevelBar_slistautoptr = [*c]GSList;
pub const GtkLevelBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLevelBar(arg__ptr: ?*GtkLevelBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkLevelBar(arg__ptr: [*c]?*GtkLevelBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLevelBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLevelBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLevelBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLevelBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkLinkButton = opaque {};
pub const GtkLinkButton = struct__GtkLinkButton;
pub extern fn gtk_link_button_get_type() GType;
pub extern fn gtk_link_button_new(uri: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_link_button_new_with_label(uri: [*c]const u8, label: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_link_button_get_uri(link_button: ?*GtkLinkButton) [*c]const u8;
pub extern fn gtk_link_button_set_uri(link_button: ?*GtkLinkButton, uri: [*c]const u8) void;
pub extern fn gtk_link_button_get_visited(link_button: ?*GtkLinkButton) gboolean;
pub extern fn gtk_link_button_set_visited(link_button: ?*GtkLinkButton, visited: gboolean) void;
pub const GtkLinkButton_autoptr = ?*GtkLinkButton;
pub const GtkLinkButton_listautoptr = [*c]GList;
pub const GtkLinkButton_slistautoptr = [*c]GSList;
pub const GtkLinkButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLinkButton(arg__ptr: ?*GtkLinkButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkLinkButton(arg__ptr: [*c]?*GtkLinkButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLinkButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLinkButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLinkButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLinkButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkListBox = opaque {};
pub const GtkListBox = struct__GtkListBox;
pub const struct__GtkListBoxRow = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkListBoxRow = struct__GtkListBoxRow;
pub const struct__GtkListBoxRowClass = extern struct {
    parent_class: GtkWidgetClass,
    activate: ?*const fn ([*c]GtkListBoxRow) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkListBoxRowClass = struct__GtkListBoxRowClass;
pub const GtkListBoxFilterFunc = ?*const fn ([*c]GtkListBoxRow, gpointer) callconv(.C) gboolean;
pub const GtkListBoxSortFunc = ?*const fn ([*c]GtkListBoxRow, [*c]GtkListBoxRow, gpointer) callconv(.C) c_int;
pub const GtkListBoxUpdateHeaderFunc = ?*const fn ([*c]GtkListBoxRow, [*c]GtkListBoxRow, gpointer) callconv(.C) void;
pub const GtkListBoxCreateWidgetFunc = ?*const fn (gpointer, gpointer) callconv(.C) [*c]GtkWidget;
pub extern fn gtk_list_box_row_get_type() GType;
pub extern fn gtk_list_box_row_new() [*c]GtkWidget;
pub extern fn gtk_list_box_row_set_child(row: [*c]GtkListBoxRow, child: [*c]GtkWidget) void;
pub extern fn gtk_list_box_row_get_child(row: [*c]GtkListBoxRow) [*c]GtkWidget;
pub extern fn gtk_list_box_row_get_header(row: [*c]GtkListBoxRow) [*c]GtkWidget;
pub extern fn gtk_list_box_row_set_header(row: [*c]GtkListBoxRow, header: [*c]GtkWidget) void;
pub extern fn gtk_list_box_row_get_index(row: [*c]GtkListBoxRow) c_int;
pub extern fn gtk_list_box_row_changed(row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_row_is_selected(row: [*c]GtkListBoxRow) gboolean;
pub extern fn gtk_list_box_row_set_selectable(row: [*c]GtkListBoxRow, selectable: gboolean) void;
pub extern fn gtk_list_box_row_get_selectable(row: [*c]GtkListBoxRow) gboolean;
pub extern fn gtk_list_box_row_set_activatable(row: [*c]GtkListBoxRow, activatable: gboolean) void;
pub extern fn gtk_list_box_row_get_activatable(row: [*c]GtkListBoxRow) gboolean;
pub extern fn gtk_list_box_get_type() GType;
pub extern fn gtk_list_box_prepend(box: ?*GtkListBox, child: [*c]GtkWidget) void;
pub extern fn gtk_list_box_append(box: ?*GtkListBox, child: [*c]GtkWidget) void;
pub extern fn gtk_list_box_insert(box: ?*GtkListBox, child: [*c]GtkWidget, position: c_int) void;
pub extern fn gtk_list_box_remove(box: ?*GtkListBox, child: [*c]GtkWidget) void;
pub extern fn gtk_list_box_remove_all(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_get_selected_row(box: ?*GtkListBox) [*c]GtkListBoxRow;
pub extern fn gtk_list_box_get_row_at_index(box: ?*GtkListBox, index_: c_int) [*c]GtkListBoxRow;
pub extern fn gtk_list_box_get_row_at_y(box: ?*GtkListBox, y: c_int) [*c]GtkListBoxRow;
pub extern fn gtk_list_box_select_row(box: ?*GtkListBox, row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_set_placeholder(box: ?*GtkListBox, placeholder: [*c]GtkWidget) void;
pub extern fn gtk_list_box_set_adjustment(box: ?*GtkListBox, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_list_box_get_adjustment(box: ?*GtkListBox) [*c]GtkAdjustment;
pub const GtkListBoxForeachFunc = ?*const fn (?*GtkListBox, [*c]GtkListBoxRow, gpointer) callconv(.C) void;
pub extern fn gtk_list_box_selected_foreach(box: ?*GtkListBox, func: GtkListBoxForeachFunc, data: gpointer) void;
pub extern fn gtk_list_box_get_selected_rows(box: ?*GtkListBox) [*c]GList;
pub extern fn gtk_list_box_unselect_row(box: ?*GtkListBox, row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_select_all(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_unselect_all(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_set_selection_mode(box: ?*GtkListBox, mode: GtkSelectionMode) void;
pub extern fn gtk_list_box_get_selection_mode(box: ?*GtkListBox) GtkSelectionMode;
pub extern fn gtk_list_box_set_filter_func(box: ?*GtkListBox, filter_func: GtkListBoxFilterFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_list_box_set_header_func(box: ?*GtkListBox, update_header: GtkListBoxUpdateHeaderFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_list_box_invalidate_filter(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_invalidate_sort(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_invalidate_headers(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_set_sort_func(box: ?*GtkListBox, sort_func: GtkListBoxSortFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_list_box_set_activate_on_single_click(box: ?*GtkListBox, single: gboolean) void;
pub extern fn gtk_list_box_get_activate_on_single_click(box: ?*GtkListBox) gboolean;
pub extern fn gtk_list_box_drag_unhighlight_row(box: ?*GtkListBox) void;
pub extern fn gtk_list_box_drag_highlight_row(box: ?*GtkListBox, row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_new() [*c]GtkWidget;
pub extern fn gtk_list_box_bind_model(box: ?*GtkListBox, model: ?*GListModel, create_widget_func: GtkListBoxCreateWidgetFunc, user_data: gpointer, user_data_free_func: GDestroyNotify) void;
pub extern fn gtk_list_box_set_show_separators(box: ?*GtkListBox, show_separators: gboolean) void;
pub extern fn gtk_list_box_get_show_separators(box: ?*GtkListBox) gboolean;
pub const GtkListBox_autoptr = ?*GtkListBox;
pub const GtkListBox_listautoptr = [*c]GList;
pub const GtkListBox_slistautoptr = [*c]GSList;
pub const GtkListBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListBox(arg__ptr: ?*GtkListBox) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListBox(arg__ptr: [*c]?*GtkListBox) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListBox(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListBox(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListBox(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListBox(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkListBoxRow_autoptr = [*c]GtkListBoxRow;
pub const GtkListBoxRow_listautoptr = [*c]GList;
pub const GtkListBoxRow_slistautoptr = [*c]GSList;
pub const GtkListBoxRow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListBoxRow(arg__ptr: [*c]GtkListBoxRow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListBoxRow(arg__ptr: [*c][*c]GtkListBoxRow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListBoxRow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListBoxRow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListBoxRow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListBoxRow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_list_header_get_type() GType;
pub const struct__GtkListHeader = opaque {};
pub const GtkListHeader = struct__GtkListHeader;
pub const struct__GtkListHeaderClass = opaque {};
pub const GtkListHeaderClass = struct__GtkListHeaderClass;
pub const GtkListHeader_autoptr = ?*GtkListHeader;
pub const GtkListHeader_listautoptr = [*c]GList;
pub const GtkListHeader_slistautoptr = [*c]GSList;
pub const GtkListHeader_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListHeader(arg__ptr: ?*GtkListHeader) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkListHeader(arg__ptr: [*c]?*GtkListHeader) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListHeader(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListHeader(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListHeader(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListHeader(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkListHeaderClass_autoptr = ?*GtkListHeaderClass;
pub const GtkListHeaderClass_listautoptr = [*c]GList;
pub const GtkListHeaderClass_slistautoptr = [*c]GSList;
pub const GtkListHeaderClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListHeaderClass(arg__ptr: ?*GtkListHeaderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListHeaderClass(arg__ptr: [*c]?*GtkListHeaderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListHeaderClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListHeaderClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListHeaderClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListHeaderClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_LIST_HEADER(arg_ptr: gpointer) callconv(.C) ?*GtkListHeader {
    var ptr = arg_ptr;
    return @as(?*GtkListHeader, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_list_header_get_type())))));
}
pub fn GTK_LIST_HEADER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkListHeaderClass {
    var ptr = arg_ptr;
    return @as(?*GtkListHeaderClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_list_header_get_type())))));
}
pub fn GTK_IS_LIST_HEADER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_list_header_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_LIST_HEADER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_list_header_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_LIST_HEADER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkListHeaderClass {
    var ptr = arg_ptr;
    return @as(?*GtkListHeaderClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_list_header_get_item(self: ?*GtkListHeader) gpointer;
pub extern fn gtk_list_header_get_start(self: ?*GtkListHeader) guint;
pub extern fn gtk_list_header_get_end(self: ?*GtkListHeader) guint;
pub extern fn gtk_list_header_get_n_items(self: ?*GtkListHeader) guint;
pub extern fn gtk_list_header_set_child(self: ?*GtkListHeader, child: [*c]GtkWidget) void;
pub extern fn gtk_list_header_get_child(self: ?*GtkListHeader) [*c]GtkWidget;
pub const struct__GtkListView = opaque {};
pub const GtkListView = struct__GtkListView;
pub const struct__GtkListViewClass = opaque {};
pub const GtkListViewClass = struct__GtkListViewClass;
pub extern fn gtk_list_view_get_type() GType;
pub extern fn gtk_list_view_new(model: ?*GtkSelectionModel, factory: ?*GtkListItemFactory) [*c]GtkWidget;
pub extern fn gtk_list_view_get_model(self: ?*GtkListView) ?*GtkSelectionModel;
pub extern fn gtk_list_view_set_model(self: ?*GtkListView, model: ?*GtkSelectionModel) void;
pub extern fn gtk_list_view_set_factory(self: ?*GtkListView, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_list_view_get_factory(self: ?*GtkListView) ?*GtkListItemFactory;
pub extern fn gtk_list_view_set_header_factory(self: ?*GtkListView, factory: ?*GtkListItemFactory) void;
pub extern fn gtk_list_view_get_header_factory(self: ?*GtkListView) ?*GtkListItemFactory;
pub extern fn gtk_list_view_set_show_separators(self: ?*GtkListView, show_separators: gboolean) void;
pub extern fn gtk_list_view_get_show_separators(self: ?*GtkListView) gboolean;
pub extern fn gtk_list_view_set_single_click_activate(self: ?*GtkListView, single_click_activate: gboolean) void;
pub extern fn gtk_list_view_get_single_click_activate(self: ?*GtkListView) gboolean;
pub extern fn gtk_list_view_set_enable_rubberband(self: ?*GtkListView, enable_rubberband: gboolean) void;
pub extern fn gtk_list_view_get_enable_rubberband(self: ?*GtkListView) gboolean;
pub extern fn gtk_list_view_set_tab_behavior(self: ?*GtkListView, tab_behavior: GtkListTabBehavior) void;
pub extern fn gtk_list_view_get_tab_behavior(self: ?*GtkListView) GtkListTabBehavior;
pub extern fn gtk_list_view_scroll_to(self: ?*GtkListView, pos: guint, flags: GtkListScrollFlags, scroll: ?*GtkScrollInfo) void;
pub const GtkListView_autoptr = ?*GtkListView;
pub const GtkListView_listautoptr = [*c]GList;
pub const GtkListView_slistautoptr = [*c]GSList;
pub const GtkListView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListView(arg__ptr: ?*GtkListView) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkListView(arg__ptr: [*c]?*GtkListView) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkListView(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkListView(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkListView(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkListView(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkLockButton = opaque {};
pub const GtkLockButton = struct__GtkLockButton;
pub extern fn gtk_lock_button_get_type() GType;
pub extern fn gtk_lock_button_new(permission: [*c]GPermission) [*c]GtkWidget;
pub extern fn gtk_lock_button_get_permission(button: ?*GtkLockButton) [*c]GPermission;
pub extern fn gtk_lock_button_set_permission(button: ?*GtkLockButton, permission: [*c]GPermission) void;
pub const GtkLockButton_autoptr = ?*GtkLockButton;
pub const GtkLockButton_listautoptr = [*c]GList;
pub const GtkLockButton_slistautoptr = [*c]GSList;
pub const GtkLockButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLockButton(arg__ptr: ?*GtkLockButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkLockButton(arg__ptr: [*c]?*GtkLockButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkLockButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkLockButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkLockButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkLockButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_init() void;
pub extern fn gtk_init_check() gboolean;
pub extern fn gtk_is_initialized() gboolean;
pub extern fn gtk_disable_setlocale() void;
pub extern fn gtk_get_default_language() ?*PangoLanguage;
pub extern fn gtk_get_locale_direction() GtkTextDirection;
pub extern fn gtk_map_list_model_get_type() GType;
pub const struct__GtkMapListModel = opaque {};
pub const GtkMapListModel = struct__GtkMapListModel;
pub const GtkMapListModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkMapListModel_autoptr = ?*GtkMapListModel;
pub const GtkMapListModel_listautoptr = [*c]GList;
pub const GtkMapListModel_slistautoptr = [*c]GSList;
pub const GtkMapListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMapListModel(arg__ptr: ?*GtkMapListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMapListModel(arg__ptr: [*c]?*GtkMapListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMapListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMapListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMapListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMapListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkMapListModelClass_autoptr = [*c]GtkMapListModelClass;
pub const GtkMapListModelClass_listautoptr = [*c]GList;
pub const GtkMapListModelClass_slistautoptr = [*c]GSList;
pub const GtkMapListModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMapListModelClass(arg__ptr: [*c]GtkMapListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMapListModelClass(arg__ptr: [*c][*c]GtkMapListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMapListModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMapListModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMapListModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMapListModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MAP_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkMapListModel {
    var ptr = arg_ptr;
    return @as(?*GtkMapListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_map_list_model_get_type())))));
}
pub fn GTK_IS_MAP_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_map_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub const GtkMapListModelMapFunc = ?*const fn (gpointer, gpointer) callconv(.C) gpointer;
pub extern fn gtk_map_list_model_new(model: ?*GListModel, map_func: GtkMapListModelMapFunc, user_data: gpointer, user_destroy: GDestroyNotify) ?*GtkMapListModel;
pub extern fn gtk_map_list_model_set_map_func(self: ?*GtkMapListModel, map_func: GtkMapListModelMapFunc, user_data: gpointer, user_destroy: GDestroyNotify) void;
pub extern fn gtk_map_list_model_set_model(self: ?*GtkMapListModel, model: ?*GListModel) void;
pub extern fn gtk_map_list_model_get_model(self: ?*GtkMapListModel) ?*GListModel;
pub extern fn gtk_map_list_model_has_map(self: ?*GtkMapListModel) gboolean;
pub extern fn gtk_media_stream_get_type() GType;
pub const struct__GtkMediaStream = extern struct {
    parent_instance: GObject,
};
pub const GtkMediaStream = struct__GtkMediaStream;
pub const struct__GtkMediaStreamClass = extern struct {
    parent_class: GObjectClass,
    play: ?*const fn ([*c]GtkMediaStream) callconv(.C) gboolean,
    pause: ?*const fn ([*c]GtkMediaStream) callconv(.C) void,
    seek: ?*const fn ([*c]GtkMediaStream, gint64) callconv(.C) void,
    update_audio: ?*const fn ([*c]GtkMediaStream, gboolean, f64) callconv(.C) void,
    realize: ?*const fn ([*c]GtkMediaStream, ?*GdkSurface) callconv(.C) void,
    unrealize: ?*const fn ([*c]GtkMediaStream, ?*GdkSurface) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
    _gtk_reserved5: ?*const fn () callconv(.C) void,
    _gtk_reserved6: ?*const fn () callconv(.C) void,
    _gtk_reserved7: ?*const fn () callconv(.C) void,
    _gtk_reserved8: ?*const fn () callconv(.C) void,
};
pub const GtkMediaStreamClass = struct__GtkMediaStreamClass;
pub const GtkMediaStream_autoptr = [*c]GtkMediaStream;
pub const GtkMediaStream_listautoptr = [*c]GList;
pub const GtkMediaStream_slistautoptr = [*c]GSList;
pub const GtkMediaStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMediaStream(arg__ptr: [*c]GtkMediaStream) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMediaStream(arg__ptr: [*c][*c]GtkMediaStream) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMediaStream(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMediaStream(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMediaStream(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMediaStream(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkMediaStreamClass_autoptr = [*c]GtkMediaStreamClass;
pub const GtkMediaStreamClass_listautoptr = [*c]GList;
pub const GtkMediaStreamClass_slistautoptr = [*c]GSList;
pub const GtkMediaStreamClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMediaStreamClass(arg__ptr: [*c]GtkMediaStreamClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMediaStreamClass(arg__ptr: [*c][*c]GtkMediaStreamClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMediaStreamClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMediaStreamClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMediaStreamClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMediaStreamClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MEDIA_STREAM(arg_ptr: gpointer) callconv(.C) [*c]GtkMediaStream {
    var ptr = arg_ptr;
    return @as([*c]GtkMediaStream, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_media_stream_get_type()))))));
}
pub fn GTK_MEDIA_STREAM_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkMediaStreamClass {
    var ptr = arg_ptr;
    return @as([*c]GtkMediaStreamClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_media_stream_get_type()))))));
}
pub fn GTK_IS_MEDIA_STREAM(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_media_stream_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_MEDIA_STREAM_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_media_stream_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_MEDIA_STREAM_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkMediaStreamClass {
    var ptr = arg_ptr;
    return @as([*c]GtkMediaStreamClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_media_stream_is_prepared(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_get_error(self: [*c]GtkMediaStream) [*c]const GError;
pub extern fn gtk_media_stream_has_audio(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_has_video(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_play(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_pause(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_get_playing(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_set_playing(self: [*c]GtkMediaStream, playing: gboolean) void;
pub extern fn gtk_media_stream_get_ended(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_get_timestamp(self: [*c]GtkMediaStream) gint64;
pub extern fn gtk_media_stream_get_duration(self: [*c]GtkMediaStream) gint64;
pub extern fn gtk_media_stream_is_seekable(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_is_seeking(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_seek(self: [*c]GtkMediaStream, timestamp: gint64) void;
pub extern fn gtk_media_stream_get_loop(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_set_loop(self: [*c]GtkMediaStream, loop: gboolean) void;
pub extern fn gtk_media_stream_get_muted(self: [*c]GtkMediaStream) gboolean;
pub extern fn gtk_media_stream_set_muted(self: [*c]GtkMediaStream, muted: gboolean) void;
pub extern fn gtk_media_stream_get_volume(self: [*c]GtkMediaStream) f64;
pub extern fn gtk_media_stream_set_volume(self: [*c]GtkMediaStream, volume: f64) void;
pub extern fn gtk_media_stream_realize(self: [*c]GtkMediaStream, surface: ?*GdkSurface) void;
pub extern fn gtk_media_stream_unrealize(self: [*c]GtkMediaStream, surface: ?*GdkSurface) void;
pub extern fn gtk_media_stream_prepared(self: [*c]GtkMediaStream, has_audio: gboolean, has_video: gboolean, seekable: gboolean, duration: gint64) void;
pub extern fn gtk_media_stream_unprepared(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_stream_prepared(self: [*c]GtkMediaStream, has_audio: gboolean, has_video: gboolean, seekable: gboolean, duration: gint64) void;
pub extern fn gtk_media_stream_stream_unprepared(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_update(self: [*c]GtkMediaStream, timestamp: gint64) void;
pub extern fn gtk_media_stream_ended(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_stream_ended(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_seek_success(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_seek_failed(self: [*c]GtkMediaStream) void;
pub extern fn gtk_media_stream_gerror(self: [*c]GtkMediaStream, @"error": [*c]GError) void;
pub extern fn gtk_media_stream_error(self: [*c]GtkMediaStream, domain: GQuark, code: c_int, format: [*c]const u8, ...) void;
pub extern fn gtk_media_stream_error_valist(self: [*c]GtkMediaStream, domain: GQuark, code: c_int, format: [*c]const u8, args: [*c]struct___va_list_tag) void;
pub extern fn gtk_media_controls_get_type() GType;
pub const struct__GtkMediaControls = opaque {};
pub const GtkMediaControls = struct__GtkMediaControls;
pub const GtkMediaControlsClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkMediaControls_autoptr = ?*GtkMediaControls;
pub const GtkMediaControls_listautoptr = [*c]GList;
pub const GtkMediaControls_slistautoptr = [*c]GSList;
pub const GtkMediaControls_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMediaControls(arg__ptr: ?*GtkMediaControls) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMediaControls(arg__ptr: [*c]?*GtkMediaControls) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMediaControls(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMediaControls(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMediaControls(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMediaControls(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkMediaControlsClass_autoptr = [*c]GtkMediaControlsClass;
pub const GtkMediaControlsClass_listautoptr = [*c]GList;
pub const GtkMediaControlsClass_slistautoptr = [*c]GSList;
pub const GtkMediaControlsClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMediaControlsClass(arg__ptr: [*c]GtkMediaControlsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMediaControlsClass(arg__ptr: [*c][*c]GtkMediaControlsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMediaControlsClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMediaControlsClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMediaControlsClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMediaControlsClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MEDIA_CONTROLS(arg_ptr: gpointer) callconv(.C) ?*GtkMediaControls {
    var ptr = arg_ptr;
    return @as(?*GtkMediaControls, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_media_controls_get_type())))));
}
pub fn GTK_IS_MEDIA_CONTROLS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_media_controls_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_media_controls_new(stream: [*c]GtkMediaStream) [*c]GtkWidget;
pub extern fn gtk_media_controls_get_media_stream(controls: ?*GtkMediaControls) [*c]GtkMediaStream;
pub extern fn gtk_media_controls_set_media_stream(controls: ?*GtkMediaControls, stream: [*c]GtkMediaStream) void;
pub extern fn gtk_media_file_get_type() GType;
pub const struct__GtkMediaFile = extern struct {
    parent_instance: GtkMediaStream,
};
pub const GtkMediaFile = struct__GtkMediaFile;
pub const struct__GtkMediaFileClass = extern struct {
    parent_class: GtkMediaStreamClass,
    open: ?*const fn ([*c]GtkMediaFile) callconv(.C) void,
    close: ?*const fn ([*c]GtkMediaFile) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkMediaFileClass = struct__GtkMediaFileClass;
pub const GtkMediaFile_autoptr = [*c]GtkMediaFile;
pub const GtkMediaFile_listautoptr = [*c]GList;
pub const GtkMediaFile_slistautoptr = [*c]GSList;
pub const GtkMediaFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMediaFile(arg__ptr: [*c]GtkMediaFile) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkMediaStream(@as([*c]GtkMediaStream, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMediaFile(arg__ptr: [*c][*c]GtkMediaFile) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMediaFile(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMediaFile(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMediaStream)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMediaFile(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMediaStream)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMediaFile(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMediaStream)))))));
    }
}
pub const GtkMediaFileClass_autoptr = [*c]GtkMediaFileClass;
pub const GtkMediaFileClass_listautoptr = [*c]GList;
pub const GtkMediaFileClass_slistautoptr = [*c]GSList;
pub const GtkMediaFileClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMediaFileClass(arg__ptr: [*c]GtkMediaFileClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMediaFileClass(arg__ptr: [*c][*c]GtkMediaFileClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMediaFileClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMediaFileClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMediaFileClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMediaFileClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MEDIA_FILE(arg_ptr: gpointer) callconv(.C) [*c]GtkMediaFile {
    var ptr = arg_ptr;
    return @as([*c]GtkMediaFile, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_media_file_get_type()))))));
}
pub fn GTK_MEDIA_FILE_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkMediaFileClass {
    var ptr = arg_ptr;
    return @as([*c]GtkMediaFileClass, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_media_file_get_type()))))));
}
pub fn GTK_IS_MEDIA_FILE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_media_file_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_MEDIA_FILE_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_media_file_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_MEDIA_FILE_GET_CLASS(arg_ptr: gpointer) callconv(.C) [*c]GtkMediaFileClass {
    var ptr = arg_ptr;
    return @as([*c]GtkMediaFileClass, @ptrCast(@alignCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)));
}
pub extern fn gtk_media_file_new() [*c]GtkMediaStream;
pub extern fn gtk_media_file_new_for_filename(filename: [*c]const u8) [*c]GtkMediaStream;
pub extern fn gtk_media_file_new_for_resource(resource_path: [*c]const u8) [*c]GtkMediaStream;
pub extern fn gtk_media_file_new_for_file(file: ?*GFile) [*c]GtkMediaStream;
pub extern fn gtk_media_file_new_for_input_stream(stream: [*c]GInputStream) [*c]GtkMediaStream;
pub extern fn gtk_media_file_clear(self: [*c]GtkMediaFile) void;
pub extern fn gtk_media_file_set_filename(self: [*c]GtkMediaFile, filename: [*c]const u8) void;
pub extern fn gtk_media_file_set_resource(self: [*c]GtkMediaFile, resource_path: [*c]const u8) void;
pub extern fn gtk_media_file_set_file(self: [*c]GtkMediaFile, file: ?*GFile) void;
pub extern fn gtk_media_file_get_file(self: [*c]GtkMediaFile) ?*GFile;
pub extern fn gtk_media_file_set_input_stream(self: [*c]GtkMediaFile, stream: [*c]GInputStream) void;
pub extern fn gtk_media_file_get_input_stream(self: [*c]GtkMediaFile) [*c]GInputStream;
pub const struct__GtkPopover = extern struct {
    parent: GtkWidget,
};
pub const GtkPopover = struct__GtkPopover;
pub const struct__GtkPopoverClass = extern struct {
    parent_class: GtkWidgetClass,
    closed: ?*const fn ([*c]GtkPopover) callconv(.C) void,
    activate_default: ?*const fn ([*c]GtkPopover) callconv(.C) void,
    reserved: [8]gpointer,
};
pub const GtkPopoverClass = struct__GtkPopoverClass;
pub extern fn gtk_popover_get_type() GType;
pub extern fn gtk_popover_new() [*c]GtkWidget;
pub extern fn gtk_popover_set_child(popover: [*c]GtkPopover, child: [*c]GtkWidget) void;
pub extern fn gtk_popover_get_child(popover: [*c]GtkPopover) [*c]GtkWidget;
pub extern fn gtk_popover_set_pointing_to(popover: [*c]GtkPopover, rect: [*c]const GdkRectangle) void;
pub extern fn gtk_popover_get_pointing_to(popover: [*c]GtkPopover, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_popover_set_position(popover: [*c]GtkPopover, position: GtkPositionType) void;
pub extern fn gtk_popover_get_position(popover: [*c]GtkPopover) GtkPositionType;
pub extern fn gtk_popover_set_autohide(popover: [*c]GtkPopover, autohide: gboolean) void;
pub extern fn gtk_popover_get_autohide(popover: [*c]GtkPopover) gboolean;
pub extern fn gtk_popover_set_has_arrow(popover: [*c]GtkPopover, has_arrow: gboolean) void;
pub extern fn gtk_popover_get_has_arrow(popover: [*c]GtkPopover) gboolean;
pub extern fn gtk_popover_set_mnemonics_visible(popover: [*c]GtkPopover, mnemonics_visible: gboolean) void;
pub extern fn gtk_popover_get_mnemonics_visible(popover: [*c]GtkPopover) gboolean;
pub extern fn gtk_popover_popup(popover: [*c]GtkPopover) void;
pub extern fn gtk_popover_popdown(popover: [*c]GtkPopover) void;
pub extern fn gtk_popover_set_offset(popover: [*c]GtkPopover, x_offset: c_int, y_offset: c_int) void;
pub extern fn gtk_popover_get_offset(popover: [*c]GtkPopover, x_offset: [*c]c_int, y_offset: [*c]c_int) void;
pub extern fn gtk_popover_set_cascade_popdown(popover: [*c]GtkPopover, cascade_popdown: gboolean) void;
pub extern fn gtk_popover_get_cascade_popdown(popover: [*c]GtkPopover) gboolean;
pub extern fn gtk_popover_set_default_widget(popover: [*c]GtkPopover, widget: [*c]GtkWidget) void;
pub extern fn gtk_popover_present(popover: [*c]GtkPopover) void;
pub const GtkPopover_autoptr = [*c]GtkPopover;
pub const GtkPopover_listautoptr = [*c]GList;
pub const GtkPopover_slistautoptr = [*c]GSList;
pub const GtkPopover_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPopover(arg__ptr: [*c]GtkPopover) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPopover(arg__ptr: [*c][*c]GtkPopover) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPopover(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPopover(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPopover(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPopover(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkMenuButton = opaque {};
pub const GtkMenuButton = struct__GtkMenuButton;
pub const GtkMenuButtonCreatePopupFunc = ?*const fn (?*GtkMenuButton, gpointer) callconv(.C) void;
pub extern fn gtk_menu_button_get_type() GType;
pub extern fn gtk_menu_button_new() [*c]GtkWidget;
pub extern fn gtk_menu_button_set_popover(menu_button: ?*GtkMenuButton, popover: [*c]GtkWidget) void;
pub extern fn gtk_menu_button_get_popover(menu_button: ?*GtkMenuButton) [*c]GtkPopover;
pub extern fn gtk_menu_button_set_direction(menu_button: ?*GtkMenuButton, direction: GtkArrowType) void;
pub extern fn gtk_menu_button_get_direction(menu_button: ?*GtkMenuButton) GtkArrowType;
pub extern fn gtk_menu_button_set_menu_model(menu_button: ?*GtkMenuButton, menu_model: [*c]GMenuModel) void;
pub extern fn gtk_menu_button_get_menu_model(menu_button: ?*GtkMenuButton) [*c]GMenuModel;
pub extern fn gtk_menu_button_set_icon_name(menu_button: ?*GtkMenuButton, icon_name: [*c]const u8) void;
pub extern fn gtk_menu_button_get_icon_name(menu_button: ?*GtkMenuButton) [*c]const u8;
pub extern fn gtk_menu_button_set_always_show_arrow(menu_button: ?*GtkMenuButton, always_show_arrow: gboolean) void;
pub extern fn gtk_menu_button_get_always_show_arrow(menu_button: ?*GtkMenuButton) gboolean;
pub extern fn gtk_menu_button_set_label(menu_button: ?*GtkMenuButton, label: [*c]const u8) void;
pub extern fn gtk_menu_button_get_label(menu_button: ?*GtkMenuButton) [*c]const u8;
pub extern fn gtk_menu_button_set_use_underline(menu_button: ?*GtkMenuButton, use_underline: gboolean) void;
pub extern fn gtk_menu_button_get_use_underline(menu_button: ?*GtkMenuButton) gboolean;
pub extern fn gtk_menu_button_set_has_frame(menu_button: ?*GtkMenuButton, has_frame: gboolean) void;
pub extern fn gtk_menu_button_get_has_frame(menu_button: ?*GtkMenuButton) gboolean;
pub extern fn gtk_menu_button_popup(menu_button: ?*GtkMenuButton) void;
pub extern fn gtk_menu_button_popdown(menu_button: ?*GtkMenuButton) void;
pub extern fn gtk_menu_button_set_create_popup_func(menu_button: ?*GtkMenuButton, func: GtkMenuButtonCreatePopupFunc, user_data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn gtk_menu_button_set_primary(menu_button: ?*GtkMenuButton, primary: gboolean) void;
pub extern fn gtk_menu_button_get_primary(menu_button: ?*GtkMenuButton) gboolean;
pub extern fn gtk_menu_button_set_child(menu_button: ?*GtkMenuButton, child: [*c]GtkWidget) void;
pub extern fn gtk_menu_button_get_child(menu_button: ?*GtkMenuButton) [*c]GtkWidget;
pub extern fn gtk_menu_button_set_active(menu_button: ?*GtkMenuButton, active: gboolean) void;
pub extern fn gtk_menu_button_get_active(menu_button: ?*GtkMenuButton) gboolean;
pub extern fn gtk_menu_button_set_can_shrink(menu_button: ?*GtkMenuButton, can_shrink: gboolean) void;
pub extern fn gtk_menu_button_get_can_shrink(menu_button: ?*GtkMenuButton) gboolean;
pub const GtkMenuButton_autoptr = ?*GtkMenuButton;
pub const GtkMenuButton_listautoptr = [*c]GList;
pub const GtkMenuButton_slistautoptr = [*c]GSList;
pub const GtkMenuButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenuButton(arg__ptr: ?*GtkMenuButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMenuButton(arg__ptr: [*c]?*GtkMenuButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMenuButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMenuButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMenuButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMenuButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkMessageDialog = extern struct {
    parent_instance: GtkDialog,
};
pub const GtkMessageDialog = struct__GtkMessageDialog;
pub const struct__GtkMessageDialogClass = opaque {};
pub const GtkMessageDialogClass = struct__GtkMessageDialogClass;
pub const GTK_BUTTONS_NONE: c_int = 0;
pub const GTK_BUTTONS_OK: c_int = 1;
pub const GTK_BUTTONS_CLOSE: c_int = 2;
pub const GTK_BUTTONS_CANCEL: c_int = 3;
pub const GTK_BUTTONS_YES_NO: c_int = 4;
pub const GTK_BUTTONS_OK_CANCEL: c_int = 5;
pub const GtkButtonsType = c_uint;
pub extern fn gtk_message_dialog_get_type() GType;
pub extern fn gtk_message_dialog_new(parent: [*c]GtkWindow, flags: GtkDialogFlags, @"type": GtkMessageType, buttons: GtkButtonsType, message_format: [*c]const u8, ...) [*c]GtkWidget;
pub extern fn gtk_message_dialog_new_with_markup(parent: [*c]GtkWindow, flags: GtkDialogFlags, @"type": GtkMessageType, buttons: GtkButtonsType, message_format: [*c]const u8, ...) [*c]GtkWidget;
pub extern fn gtk_message_dialog_set_markup(message_dialog: [*c]GtkMessageDialog, str: [*c]const u8) void;
pub extern fn gtk_message_dialog_format_secondary_text(message_dialog: [*c]GtkMessageDialog, message_format: [*c]const u8, ...) void;
pub extern fn gtk_message_dialog_format_secondary_markup(message_dialog: [*c]GtkMessageDialog, message_format: [*c]const u8, ...) void;
pub extern fn gtk_message_dialog_get_message_area(message_dialog: [*c]GtkMessageDialog) [*c]GtkWidget;
pub const GtkMessageDialog_autoptr = [*c]GtkMessageDialog;
pub const GtkMessageDialog_listautoptr = [*c]GList;
pub const GtkMessageDialog_slistautoptr = [*c]GSList;
pub const GtkMessageDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMessageDialog(arg__ptr: [*c]GtkMessageDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMessageDialog(arg__ptr: [*c][*c]GtkMessageDialog) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMessageDialog(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMessageDialog(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMessageDialog(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMessageDialog(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkMountOperationPrivate = opaque {};
pub const GtkMountOperationPrivate = struct__GtkMountOperationPrivate;
pub const struct__GtkMountOperation = extern struct {
    parent_instance: GMountOperation,
    priv: ?*GtkMountOperationPrivate,
};
pub const GtkMountOperation = struct__GtkMountOperation;
pub const struct__GtkMountOperationClass = extern struct {
    parent_class: GMountOperationClass,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkMountOperationClass = struct__GtkMountOperationClass;
pub extern fn gtk_mount_operation_get_type() GType;
pub extern fn gtk_mount_operation_new(parent: [*c]GtkWindow) [*c]GMountOperation;
pub extern fn gtk_mount_operation_is_showing(op: [*c]GtkMountOperation) gboolean;
pub extern fn gtk_mount_operation_set_parent(op: [*c]GtkMountOperation, parent: [*c]GtkWindow) void;
pub extern fn gtk_mount_operation_get_parent(op: [*c]GtkMountOperation) [*c]GtkWindow;
pub extern fn gtk_mount_operation_set_display(op: [*c]GtkMountOperation, display: ?*GdkDisplay) void;
pub extern fn gtk_mount_operation_get_display(op: [*c]GtkMountOperation) ?*GdkDisplay;
pub const GtkMountOperation_autoptr = [*c]GtkMountOperation;
pub const GtkMountOperation_listautoptr = [*c]GList;
pub const GtkMountOperation_slistautoptr = [*c]GSList;
pub const GtkMountOperation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMountOperation(arg__ptr: [*c]GtkMountOperation) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMountOperation(arg__ptr: [*c][*c]GtkMountOperation) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMountOperation(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMountOperation(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMountOperation(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMountOperation(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_multi_filter_get_type() GType;
pub const struct__GtkMultiFilter = opaque {};
pub const GtkMultiFilter = struct__GtkMultiFilter;
pub const struct__GtkMultiFilterClass = opaque {};
pub const GtkMultiFilterClass = struct__GtkMultiFilterClass;
pub const GtkMultiFilter_autoptr = ?*GtkMultiFilter;
pub const GtkMultiFilter_listautoptr = [*c]GList;
pub const GtkMultiFilter_slistautoptr = [*c]GSList;
pub const GtkMultiFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMultiFilter(arg__ptr: ?*GtkMultiFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkFilter(@as([*c]GtkFilter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMultiFilter(arg__ptr: [*c]?*GtkMultiFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMultiFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMultiFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMultiFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMultiFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkFilter)))))));
    }
}
pub const GtkMultiFilterClass_autoptr = ?*GtkMultiFilterClass;
pub const GtkMultiFilterClass_listautoptr = [*c]GList;
pub const GtkMultiFilterClass_slistautoptr = [*c]GSList;
pub const GtkMultiFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMultiFilterClass(arg__ptr: ?*GtkMultiFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMultiFilterClass(arg__ptr: [*c]?*GtkMultiFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMultiFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMultiFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMultiFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMultiFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MULTI_FILTER(arg_ptr: gpointer) callconv(.C) ?*GtkMultiFilter {
    var ptr = arg_ptr;
    return @as(?*GtkMultiFilter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_multi_filter_get_type())))));
}
pub fn GTK_MULTI_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkMultiFilterClass {
    var ptr = arg_ptr;
    return @as(?*GtkMultiFilterClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_multi_filter_get_type())))));
}
pub fn GTK_IS_MULTI_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_multi_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_MULTI_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_multi_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_MULTI_FILTER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkMultiFilterClass {
    var ptr = arg_ptr;
    return @as(?*GtkMultiFilterClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_multi_filter_append(self: ?*GtkMultiFilter, filter: [*c]GtkFilter) void;
pub extern fn gtk_multi_filter_remove(self: ?*GtkMultiFilter, position: guint) void;
pub extern fn gtk_any_filter_get_type() GType;
pub const struct__GtkAnyFilter = opaque {};
pub const GtkAnyFilter = struct__GtkAnyFilter;
pub const struct__GtkAnyFilterClass = opaque {};
pub const GtkAnyFilterClass = struct__GtkAnyFilterClass;
pub const GtkAnyFilter_autoptr = ?*GtkAnyFilter;
pub const GtkAnyFilter_listautoptr = [*c]GList;
pub const GtkAnyFilter_slistautoptr = [*c]GSList;
pub const GtkAnyFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAnyFilter(arg__ptr: ?*GtkAnyFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkMultiFilter(@as(?*GtkMultiFilter, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAnyFilter(arg__ptr: [*c]?*GtkAnyFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAnyFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAnyFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMultiFilter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAnyFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMultiFilter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAnyFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMultiFilter)))))));
    }
}
pub const GtkAnyFilterClass_autoptr = ?*GtkAnyFilterClass;
pub const GtkAnyFilterClass_listautoptr = [*c]GList;
pub const GtkAnyFilterClass_slistautoptr = [*c]GSList;
pub const GtkAnyFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAnyFilterClass(arg__ptr: ?*GtkAnyFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAnyFilterClass(arg__ptr: [*c]?*GtkAnyFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAnyFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAnyFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAnyFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAnyFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_ANY_FILTER(arg_ptr: gpointer) callconv(.C) ?*GtkAnyFilter {
    var ptr = arg_ptr;
    return @as(?*GtkAnyFilter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_any_filter_get_type())))));
}
pub fn GTK_ANY_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkAnyFilterClass {
    var ptr = arg_ptr;
    return @as(?*GtkAnyFilterClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_any_filter_get_type())))));
}
pub fn GTK_IS_ANY_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_any_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_ANY_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_any_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_ANY_FILTER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkAnyFilterClass {
    var ptr = arg_ptr;
    return @as(?*GtkAnyFilterClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_any_filter_new() ?*GtkAnyFilter;
pub extern fn gtk_every_filter_get_type() GType;
pub const struct__GtkEveryFilter = opaque {};
pub const GtkEveryFilter = struct__GtkEveryFilter;
pub const struct__GtkEveryFilterClass = opaque {};
pub const GtkEveryFilterClass = struct__GtkEveryFilterClass;
pub const GtkEveryFilter_autoptr = ?*GtkEveryFilter;
pub const GtkEveryFilter_listautoptr = [*c]GList;
pub const GtkEveryFilter_slistautoptr = [*c]GSList;
pub const GtkEveryFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEveryFilter(arg__ptr: ?*GtkEveryFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkMultiFilter(@as(?*GtkMultiFilter, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEveryFilter(arg__ptr: [*c]?*GtkEveryFilter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEveryFilter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEveryFilter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMultiFilter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEveryFilter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMultiFilter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEveryFilter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkMultiFilter)))))));
    }
}
pub const GtkEveryFilterClass_autoptr = ?*GtkEveryFilterClass;
pub const GtkEveryFilterClass_listautoptr = [*c]GList;
pub const GtkEveryFilterClass_slistautoptr = [*c]GSList;
pub const GtkEveryFilterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEveryFilterClass(arg__ptr: ?*GtkEveryFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkEveryFilterClass(arg__ptr: [*c]?*GtkEveryFilterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkEveryFilterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkEveryFilterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkEveryFilterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkEveryFilterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_EVERY_FILTER(arg_ptr: gpointer) callconv(.C) ?*GtkEveryFilter {
    var ptr = arg_ptr;
    return @as(?*GtkEveryFilter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_every_filter_get_type())))));
}
pub fn GTK_EVERY_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkEveryFilterClass {
    var ptr = arg_ptr;
    return @as(?*GtkEveryFilterClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_every_filter_get_type())))));
}
pub fn GTK_IS_EVERY_FILTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_every_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_EVERY_FILTER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_every_filter_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_EVERY_FILTER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkEveryFilterClass {
    var ptr = arg_ptr;
    return @as(?*GtkEveryFilterClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_every_filter_new() ?*GtkEveryFilter;
pub extern fn gtk_multi_selection_get_type() GType;
pub const struct__GtkMultiSelection = opaque {};
pub const GtkMultiSelection = struct__GtkMultiSelection;
pub const GtkMultiSelectionClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkMultiSelection_autoptr = ?*GtkMultiSelection;
pub const GtkMultiSelection_listautoptr = [*c]GList;
pub const GtkMultiSelection_slistautoptr = [*c]GSList;
pub const GtkMultiSelection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMultiSelection(arg__ptr: ?*GtkMultiSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMultiSelection(arg__ptr: [*c]?*GtkMultiSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMultiSelection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMultiSelection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMultiSelection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMultiSelection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkMultiSelectionClass_autoptr = [*c]GtkMultiSelectionClass;
pub const GtkMultiSelectionClass_listautoptr = [*c]GList;
pub const GtkMultiSelectionClass_slistautoptr = [*c]GSList;
pub const GtkMultiSelectionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMultiSelectionClass(arg__ptr: [*c]GtkMultiSelectionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMultiSelectionClass(arg__ptr: [*c][*c]GtkMultiSelectionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMultiSelectionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMultiSelectionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMultiSelectionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMultiSelectionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MULTI_SELECTION(arg_ptr: gpointer) callconv(.C) ?*GtkMultiSelection {
    var ptr = arg_ptr;
    return @as(?*GtkMultiSelection, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_multi_selection_get_type())))));
}
pub fn GTK_IS_MULTI_SELECTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_multi_selection_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_multi_selection_new(model: ?*GListModel) ?*GtkMultiSelection;
pub extern fn gtk_multi_selection_get_model(self: ?*GtkMultiSelection) ?*GListModel;
pub extern fn gtk_multi_selection_set_model(self: ?*GtkMultiSelection, model: ?*GListModel) void;
pub extern fn gtk_multi_sorter_get_type() GType;
pub const struct__GtkMultiSorter = opaque {};
pub const GtkMultiSorter = struct__GtkMultiSorter;
pub const GtkMultiSorterClass = extern struct {
    parent_class: GtkSorterClass,
};
pub const GtkMultiSorter_autoptr = ?*GtkMultiSorter;
pub const GtkMultiSorter_listautoptr = [*c]GList;
pub const GtkMultiSorter_slistautoptr = [*c]GSList;
pub const GtkMultiSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMultiSorter(arg__ptr: ?*GtkMultiSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkSorter(@as([*c]GtkSorter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkMultiSorter(arg__ptr: [*c]?*GtkMultiSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMultiSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMultiSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMultiSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMultiSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
    }
}
pub const GtkMultiSorterClass_autoptr = [*c]GtkMultiSorterClass;
pub const GtkMultiSorterClass_listautoptr = [*c]GList;
pub const GtkMultiSorterClass_slistautoptr = [*c]GSList;
pub const GtkMultiSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMultiSorterClass(arg__ptr: [*c]GtkMultiSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMultiSorterClass(arg__ptr: [*c][*c]GtkMultiSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMultiSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMultiSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMultiSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMultiSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MULTI_SORTER(arg_ptr: gpointer) callconv(.C) ?*GtkMultiSorter {
    var ptr = arg_ptr;
    return @as(?*GtkMultiSorter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_multi_sorter_get_type())))));
}
pub fn GTK_IS_MULTI_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_multi_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_multi_sorter_new() ?*GtkMultiSorter;
pub extern fn gtk_multi_sorter_append(self: ?*GtkMultiSorter, sorter: [*c]GtkSorter) void;
pub extern fn gtk_multi_sorter_remove(self: ?*GtkMultiSorter, position: guint) void;
pub extern fn gtk_native_get_type() GType;
pub const struct__GtkNativeInterface = opaque {};
pub const GtkNativeInterface = struct__GtkNativeInterface;
pub const GtkNative_autoptr = ?*GtkNative;
pub const GtkNative_listautoptr = [*c]GList;
pub const GtkNative_slistautoptr = [*c]GSList;
pub const GtkNative_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNative(arg__ptr: ?*GtkNative) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkNative(arg__ptr: [*c]?*GtkNative) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNative(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNative(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNative(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNative(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub fn GTK_NATIVE(arg_ptr: gpointer) callconv(.C) ?*GtkNative {
    var ptr = arg_ptr;
    return @as(?*GtkNative, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_native_get_type())))));
}
pub fn GTK_IS_NATIVE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_native_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_NATIVE_GET_IFACE(arg_ptr: gpointer) callconv(.C) ?*GtkNativeInterface {
    var ptr = arg_ptr;
    return @as(?*GtkNativeInterface, @ptrCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_native_get_type())));
}
pub extern fn gtk_native_realize(self: ?*GtkNative) void;
pub extern fn gtk_native_unrealize(self: ?*GtkNative) void;
pub extern fn gtk_native_get_for_surface(surface: ?*GdkSurface) ?*GtkNative;
pub extern fn gtk_native_get_surface(self: ?*GtkNative) ?*GdkSurface;
pub extern fn gtk_native_get_renderer(self: ?*GtkNative) ?*GskRenderer;
pub extern fn gtk_native_get_surface_transform(self: ?*GtkNative, x: [*c]f64, y: [*c]f64) void;
pub extern fn gtk_no_selection_get_type() GType;
pub const struct__GtkNoSelection = opaque {};
pub const GtkNoSelection = struct__GtkNoSelection;
pub const GtkNoSelectionClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkNoSelection_autoptr = ?*GtkNoSelection;
pub const GtkNoSelection_listautoptr = [*c]GList;
pub const GtkNoSelection_slistautoptr = [*c]GSList;
pub const GtkNoSelection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNoSelection(arg__ptr: ?*GtkNoSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkNoSelection(arg__ptr: [*c]?*GtkNoSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNoSelection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNoSelection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNoSelection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNoSelection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkNoSelectionClass_autoptr = [*c]GtkNoSelectionClass;
pub const GtkNoSelectionClass_listautoptr = [*c]GList;
pub const GtkNoSelectionClass_slistautoptr = [*c]GSList;
pub const GtkNoSelectionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNoSelectionClass(arg__ptr: [*c]GtkNoSelectionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNoSelectionClass(arg__ptr: [*c][*c]GtkNoSelectionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNoSelectionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNoSelectionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNoSelectionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNoSelectionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_NO_SELECTION(arg_ptr: gpointer) callconv(.C) ?*GtkNoSelection {
    var ptr = arg_ptr;
    return @as(?*GtkNoSelection, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_no_selection_get_type())))));
}
pub fn GTK_IS_NO_SELECTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_no_selection_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_no_selection_new(model: ?*GListModel) ?*GtkNoSelection;
pub extern fn gtk_no_selection_get_model(self: ?*GtkNoSelection) ?*GListModel;
pub extern fn gtk_no_selection_set_model(self: ?*GtkNoSelection, model: ?*GListModel) void;
pub const struct__GtkNotebookPage = opaque {};
pub const GtkNotebookPage = struct__GtkNotebookPage;
pub const GTK_NOTEBOOK_TAB_FIRST: c_int = 0;
pub const GTK_NOTEBOOK_TAB_LAST: c_int = 1;
pub const GtkNotebookTab = c_uint;
pub const struct__GtkNotebook = opaque {};
pub const GtkNotebook = struct__GtkNotebook;
pub extern fn gtk_notebook_get_type() GType;
pub extern fn gtk_notebook_new() [*c]GtkWidget;
pub extern fn gtk_notebook_append_page(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget) c_int;
pub extern fn gtk_notebook_append_page_menu(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, menu_label: [*c]GtkWidget) c_int;
pub extern fn gtk_notebook_prepend_page(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget) c_int;
pub extern fn gtk_notebook_prepend_page_menu(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, menu_label: [*c]GtkWidget) c_int;
pub extern fn gtk_notebook_insert_page(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, position: c_int) c_int;
pub extern fn gtk_notebook_insert_page_menu(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, menu_label: [*c]GtkWidget, position: c_int) c_int;
pub extern fn gtk_notebook_remove_page(notebook: ?*GtkNotebook, page_num: c_int) void;
pub extern fn gtk_notebook_set_group_name(notebook: ?*GtkNotebook, group_name: [*c]const u8) void;
pub extern fn gtk_notebook_get_group_name(notebook: ?*GtkNotebook) [*c]const u8;
pub extern fn gtk_notebook_get_current_page(notebook: ?*GtkNotebook) c_int;
pub extern fn gtk_notebook_get_nth_page(notebook: ?*GtkNotebook, page_num: c_int) [*c]GtkWidget;
pub extern fn gtk_notebook_get_n_pages(notebook: ?*GtkNotebook) c_int;
pub extern fn gtk_notebook_page_num(notebook: ?*GtkNotebook, child: [*c]GtkWidget) c_int;
pub extern fn gtk_notebook_set_current_page(notebook: ?*GtkNotebook, page_num: c_int) void;
pub extern fn gtk_notebook_next_page(notebook: ?*GtkNotebook) void;
pub extern fn gtk_notebook_prev_page(notebook: ?*GtkNotebook) void;
pub extern fn gtk_notebook_set_show_border(notebook: ?*GtkNotebook, show_border: gboolean) void;
pub extern fn gtk_notebook_get_show_border(notebook: ?*GtkNotebook) gboolean;
pub extern fn gtk_notebook_set_show_tabs(notebook: ?*GtkNotebook, show_tabs: gboolean) void;
pub extern fn gtk_notebook_get_show_tabs(notebook: ?*GtkNotebook) gboolean;
pub extern fn gtk_notebook_set_tab_pos(notebook: ?*GtkNotebook, pos: GtkPositionType) void;
pub extern fn gtk_notebook_get_tab_pos(notebook: ?*GtkNotebook) GtkPositionType;
pub extern fn gtk_notebook_set_scrollable(notebook: ?*GtkNotebook, scrollable: gboolean) void;
pub extern fn gtk_notebook_get_scrollable(notebook: ?*GtkNotebook) gboolean;
pub extern fn gtk_notebook_popup_enable(notebook: ?*GtkNotebook) void;
pub extern fn gtk_notebook_popup_disable(notebook: ?*GtkNotebook) void;
pub extern fn gtk_notebook_get_tab_label(notebook: ?*GtkNotebook, child: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_notebook_set_tab_label(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget) void;
pub extern fn gtk_notebook_set_tab_label_text(notebook: ?*GtkNotebook, child: [*c]GtkWidget, tab_text: [*c]const u8) void;
pub extern fn gtk_notebook_get_tab_label_text(notebook: ?*GtkNotebook, child: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_notebook_get_menu_label(notebook: ?*GtkNotebook, child: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_notebook_set_menu_label(notebook: ?*GtkNotebook, child: [*c]GtkWidget, menu_label: [*c]GtkWidget) void;
pub extern fn gtk_notebook_set_menu_label_text(notebook: ?*GtkNotebook, child: [*c]GtkWidget, menu_text: [*c]const u8) void;
pub extern fn gtk_notebook_get_menu_label_text(notebook: ?*GtkNotebook, child: [*c]GtkWidget) [*c]const u8;
pub extern fn gtk_notebook_reorder_child(notebook: ?*GtkNotebook, child: [*c]GtkWidget, position: c_int) void;
pub extern fn gtk_notebook_get_tab_reorderable(notebook: ?*GtkNotebook, child: [*c]GtkWidget) gboolean;
pub extern fn gtk_notebook_set_tab_reorderable(notebook: ?*GtkNotebook, child: [*c]GtkWidget, reorderable: gboolean) void;
pub extern fn gtk_notebook_get_tab_detachable(notebook: ?*GtkNotebook, child: [*c]GtkWidget) gboolean;
pub extern fn gtk_notebook_set_tab_detachable(notebook: ?*GtkNotebook, child: [*c]GtkWidget, detachable: gboolean) void;
pub extern fn gtk_notebook_detach_tab(notebook: ?*GtkNotebook, child: [*c]GtkWidget) void;
pub extern fn gtk_notebook_get_action_widget(notebook: ?*GtkNotebook, pack_type: GtkPackType) [*c]GtkWidget;
pub extern fn gtk_notebook_set_action_widget(notebook: ?*GtkNotebook, widget: [*c]GtkWidget, pack_type: GtkPackType) void;
pub extern fn gtk_notebook_page_get_type() GType;
pub extern fn gtk_notebook_get_page(notebook: ?*GtkNotebook, child: [*c]GtkWidget) ?*GtkNotebookPage;
pub extern fn gtk_notebook_page_get_child(page: ?*GtkNotebookPage) [*c]GtkWidget;
pub extern fn gtk_notebook_get_pages(notebook: ?*GtkNotebook) ?*GListModel;
pub const GtkNotebook_autoptr = ?*GtkNotebook;
pub const GtkNotebook_listautoptr = [*c]GList;
pub const GtkNotebook_slistautoptr = [*c]GSList;
pub const GtkNotebook_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNotebook(arg__ptr: ?*GtkNotebook) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNotebook(arg__ptr: [*c]?*GtkNotebook) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNotebook(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNotebook(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNotebook(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNotebook(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_numeric_sorter_get_type() GType;
pub const struct__GtkNumericSorter = opaque {};
pub const GtkNumericSorter = struct__GtkNumericSorter;
pub const GtkNumericSorterClass = extern struct {
    parent_class: GtkSorterClass,
};
pub const GtkNumericSorter_autoptr = ?*GtkNumericSorter;
pub const GtkNumericSorter_listautoptr = [*c]GList;
pub const GtkNumericSorter_slistautoptr = [*c]GSList;
pub const GtkNumericSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNumericSorter(arg__ptr: ?*GtkNumericSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkSorter(@as([*c]GtkSorter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkNumericSorter(arg__ptr: [*c]?*GtkNumericSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNumericSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNumericSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNumericSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNumericSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
    }
}
pub const GtkNumericSorterClass_autoptr = [*c]GtkNumericSorterClass;
pub const GtkNumericSorterClass_listautoptr = [*c]GList;
pub const GtkNumericSorterClass_slistautoptr = [*c]GSList;
pub const GtkNumericSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNumericSorterClass(arg__ptr: [*c]GtkNumericSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNumericSorterClass(arg__ptr: [*c][*c]GtkNumericSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNumericSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNumericSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNumericSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNumericSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_NUMERIC_SORTER(arg_ptr: gpointer) callconv(.C) ?*GtkNumericSorter {
    var ptr = arg_ptr;
    return @as(?*GtkNumericSorter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_numeric_sorter_get_type())))));
}
pub fn GTK_IS_NUMERIC_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_numeric_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_numeric_sorter_new(expression: ?*GtkExpression) ?*GtkNumericSorter;
pub extern fn gtk_numeric_sorter_get_expression(self: ?*GtkNumericSorter) ?*GtkExpression;
pub extern fn gtk_numeric_sorter_set_expression(self: ?*GtkNumericSorter, expression: ?*GtkExpression) void;
pub extern fn gtk_numeric_sorter_get_sort_order(self: ?*GtkNumericSorter) GtkSortType;
pub extern fn gtk_numeric_sorter_set_sort_order(self: ?*GtkNumericSorter, sort_order: GtkSortType) void;
pub const struct__GtkOrientable = opaque {};
pub const GtkOrientable = struct__GtkOrientable;
pub const struct__GtkOrientableIface = extern struct {
    base_iface: GTypeInterface,
};
pub const GtkOrientableIface = struct__GtkOrientableIface;
pub extern fn gtk_orientable_get_type() GType;
pub extern fn gtk_orientable_set_orientation(orientable: ?*GtkOrientable, orientation: GtkOrientation) void;
pub extern fn gtk_orientable_get_orientation(orientable: ?*GtkOrientable) GtkOrientation;
pub const GtkOrientable_autoptr = ?*GtkOrientable;
pub const GtkOrientable_listautoptr = [*c]GList;
pub const GtkOrientable_slistautoptr = [*c]GSList;
pub const GtkOrientable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOrientable(arg__ptr: ?*GtkOrientable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkOrientable(arg__ptr: [*c]?*GtkOrientable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkOrientable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkOrientable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkOrientable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkOrientable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkOverlay = opaque {};
pub const GtkOverlay = struct__GtkOverlay;
pub extern fn gtk_overlay_get_type() GType;
pub extern fn gtk_overlay_new() [*c]GtkWidget;
pub extern fn gtk_overlay_add_overlay(overlay: ?*GtkOverlay, widget: [*c]GtkWidget) void;
pub extern fn gtk_overlay_remove_overlay(overlay: ?*GtkOverlay, widget: [*c]GtkWidget) void;
pub extern fn gtk_overlay_set_child(overlay: ?*GtkOverlay, child: [*c]GtkWidget) void;
pub extern fn gtk_overlay_get_child(overlay: ?*GtkOverlay) [*c]GtkWidget;
pub extern fn gtk_overlay_get_measure_overlay(overlay: ?*GtkOverlay, widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_overlay_set_measure_overlay(overlay: ?*GtkOverlay, widget: [*c]GtkWidget, measure: gboolean) void;
pub extern fn gtk_overlay_get_clip_overlay(overlay: ?*GtkOverlay, widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_overlay_set_clip_overlay(overlay: ?*GtkOverlay, widget: [*c]GtkWidget, clip_overlay: gboolean) void;
pub const GtkOverlay_autoptr = ?*GtkOverlay;
pub const GtkOverlay_listautoptr = [*c]GList;
pub const GtkOverlay_slistautoptr = [*c]GSList;
pub const GtkOverlay_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOverlay(arg__ptr: ?*GtkOverlay) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkOverlay(arg__ptr: [*c]?*GtkOverlay) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkOverlay(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkOverlay(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkOverlay(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkOverlay(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_overlay_layout_get_type() GType;
pub const struct__GtkOverlayLayout = opaque {};
pub const GtkOverlayLayout = struct__GtkOverlayLayout;
pub const GtkOverlayLayoutClass = extern struct {
    parent_class: GtkLayoutManagerClass,
};
pub const GtkOverlayLayout_autoptr = ?*GtkOverlayLayout;
pub const GtkOverlayLayout_listautoptr = [*c]GList;
pub const GtkOverlayLayout_slistautoptr = [*c]GSList;
pub const GtkOverlayLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOverlayLayout(arg__ptr: ?*GtkOverlayLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutManager(@as([*c]GtkLayoutManager, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkOverlayLayout(arg__ptr: [*c]?*GtkOverlayLayout) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkOverlayLayout(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkOverlayLayout(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_slistautoptr_cleanup_GtkOverlayLayout(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
}
pub fn glib_queueautoptr_cleanup_GtkOverlayLayout(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutManager)))))));
    }
}
pub const GtkOverlayLayoutClass_autoptr = [*c]GtkOverlayLayoutClass;
pub const GtkOverlayLayoutClass_listautoptr = [*c]GList;
pub const GtkOverlayLayoutClass_slistautoptr = [*c]GSList;
pub const GtkOverlayLayoutClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOverlayLayoutClass(arg__ptr: [*c]GtkOverlayLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkOverlayLayoutClass(arg__ptr: [*c][*c]GtkOverlayLayoutClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkOverlayLayoutClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkOverlayLayoutClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkOverlayLayoutClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkOverlayLayoutClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_OVERLAY_LAYOUT(arg_ptr: gpointer) callconv(.C) ?*GtkOverlayLayout {
    var ptr = arg_ptr;
    return @as(?*GtkOverlayLayout, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_overlay_layout_get_type())))));
}
pub fn GTK_IS_OVERLAY_LAYOUT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_overlay_layout_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_overlay_layout_new() [*c]GtkLayoutManager;
pub extern fn gtk_overlay_layout_child_get_type() GType;
pub const struct__GtkOverlayLayoutChild = opaque {};
pub const GtkOverlayLayoutChild = struct__GtkOverlayLayoutChild;
pub const GtkOverlayLayoutChildClass = extern struct {
    parent_class: GtkLayoutChildClass,
};
pub const GtkOverlayLayoutChild_autoptr = ?*GtkOverlayLayoutChild;
pub const GtkOverlayLayoutChild_listautoptr = [*c]GList;
pub const GtkOverlayLayoutChild_slistautoptr = [*c]GSList;
pub const GtkOverlayLayoutChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOverlayLayoutChild(arg__ptr: ?*GtkOverlayLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkLayoutChild(@as([*c]GtkLayoutChild, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkOverlayLayoutChild(arg__ptr: [*c]?*GtkOverlayLayoutChild) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkOverlayLayoutChild(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkOverlayLayoutChild(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_slistautoptr_cleanup_GtkOverlayLayoutChild(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
}
pub fn glib_queueautoptr_cleanup_GtkOverlayLayoutChild(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkLayoutChild)))))));
    }
}
pub const GtkOverlayLayoutChildClass_autoptr = [*c]GtkOverlayLayoutChildClass;
pub const GtkOverlayLayoutChildClass_listautoptr = [*c]GList;
pub const GtkOverlayLayoutChildClass_slistautoptr = [*c]GSList;
pub const GtkOverlayLayoutChildClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOverlayLayoutChildClass(arg__ptr: [*c]GtkOverlayLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkOverlayLayoutChildClass(arg__ptr: [*c][*c]GtkOverlayLayoutChildClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkOverlayLayoutChildClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkOverlayLayoutChildClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkOverlayLayoutChildClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkOverlayLayoutChildClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_OVERLAY_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) ?*GtkOverlayLayoutChild {
    var ptr = arg_ptr;
    return @as(?*GtkOverlayLayoutChild, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_overlay_layout_child_get_type())))));
}
pub fn GTK_IS_OVERLAY_LAYOUT_CHILD(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_overlay_layout_child_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_overlay_layout_child_set_measure(child: ?*GtkOverlayLayoutChild, measure: gboolean) void;
pub extern fn gtk_overlay_layout_child_get_measure(child: ?*GtkOverlayLayoutChild) gboolean;
pub extern fn gtk_overlay_layout_child_set_clip_overlay(child: ?*GtkOverlayLayoutChild, clip_overlay: gboolean) void;
pub extern fn gtk_overlay_layout_child_get_clip_overlay(child: ?*GtkOverlayLayoutChild) gboolean;
pub const struct__GtkPadController = opaque {};
pub const GtkPadController = struct__GtkPadController;
pub const struct__GtkPadControllerClass = opaque {};
pub const GtkPadControllerClass = struct__GtkPadControllerClass;
pub const struct__GtkPadActionEntry = extern struct {
    type: GtkPadActionType,
    index: c_int,
    mode: c_int,
    label: [*c]const u8,
    action_name: [*c]const u8,
};
pub const GtkPadActionEntry = struct__GtkPadActionEntry;
pub const GTK_PAD_ACTION_BUTTON: c_int = 0;
pub const GTK_PAD_ACTION_RING: c_int = 1;
pub const GTK_PAD_ACTION_STRIP: c_int = 2;
pub const GtkPadActionType = c_uint;
pub extern fn gtk_pad_controller_get_type() GType;
pub extern fn gtk_pad_controller_new(group: ?*GActionGroup, pad: ?*GdkDevice) ?*GtkPadController;
pub extern fn gtk_pad_controller_set_action_entries(controller: ?*GtkPadController, entries: [*c]const GtkPadActionEntry, n_entries: c_int) void;
pub extern fn gtk_pad_controller_set_action(controller: ?*GtkPadController, @"type": GtkPadActionType, index: c_int, mode: c_int, label: [*c]const u8, action_name: [*c]const u8) void;
pub const struct__GtkPaperSize = opaque {};
pub const GtkPaperSize = struct__GtkPaperSize;
pub extern fn gtk_paper_size_get_type() GType;
pub extern fn gtk_paper_size_new(name: [*c]const u8) ?*GtkPaperSize;
pub extern fn gtk_paper_size_new_from_ppd(ppd_name: [*c]const u8, ppd_display_name: [*c]const u8, width: f64, height: f64) ?*GtkPaperSize;
pub extern fn gtk_paper_size_new_from_ipp(ipp_name: [*c]const u8, width: f64, height: f64) ?*GtkPaperSize;
pub extern fn gtk_paper_size_new_custom(name: [*c]const u8, display_name: [*c]const u8, width: f64, height: f64, unit: GtkUnit) ?*GtkPaperSize;
pub extern fn gtk_paper_size_copy(other: ?*GtkPaperSize) ?*GtkPaperSize;
pub extern fn gtk_paper_size_free(size: ?*GtkPaperSize) void;
pub extern fn gtk_paper_size_is_equal(size1: ?*GtkPaperSize, size2: ?*GtkPaperSize) gboolean;
pub extern fn gtk_paper_size_get_paper_sizes(include_custom: gboolean) [*c]GList;
pub extern fn gtk_paper_size_get_name(size: ?*GtkPaperSize) [*c]const u8;
pub extern fn gtk_paper_size_get_display_name(size: ?*GtkPaperSize) [*c]const u8;
pub extern fn gtk_paper_size_get_ppd_name(size: ?*GtkPaperSize) [*c]const u8;
pub extern fn gtk_paper_size_get_width(size: ?*GtkPaperSize, unit: GtkUnit) f64;
pub extern fn gtk_paper_size_get_height(size: ?*GtkPaperSize, unit: GtkUnit) f64;
pub extern fn gtk_paper_size_is_custom(size: ?*GtkPaperSize) gboolean;
pub extern fn gtk_paper_size_is_ipp(size: ?*GtkPaperSize) gboolean;
pub extern fn gtk_paper_size_set_size(size: ?*GtkPaperSize, width: f64, height: f64, unit: GtkUnit) void;
pub extern fn gtk_paper_size_get_default_top_margin(size: ?*GtkPaperSize, unit: GtkUnit) f64;
pub extern fn gtk_paper_size_get_default_bottom_margin(size: ?*GtkPaperSize, unit: GtkUnit) f64;
pub extern fn gtk_paper_size_get_default_left_margin(size: ?*GtkPaperSize, unit: GtkUnit) f64;
pub extern fn gtk_paper_size_get_default_right_margin(size: ?*GtkPaperSize, unit: GtkUnit) f64;
pub extern fn gtk_paper_size_get_default() [*c]const u8;
pub extern fn gtk_paper_size_new_from_key_file(key_file: ?*GKeyFile, group_name: [*c]const u8, @"error": [*c][*c]GError) ?*GtkPaperSize;
pub extern fn gtk_paper_size_to_key_file(size: ?*GtkPaperSize, key_file: ?*GKeyFile, group_name: [*c]const u8) void;
pub extern fn gtk_paper_size_new_from_gvariant(variant: ?*GVariant) ?*GtkPaperSize;
pub extern fn gtk_paper_size_to_gvariant(paper_size: ?*GtkPaperSize) ?*GVariant;
pub const GtkPaperSize_autoptr = ?*GtkPaperSize;
pub const GtkPaperSize_listautoptr = [*c]GList;
pub const GtkPaperSize_slistautoptr = [*c]GSList;
pub const GtkPaperSize_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPaperSize(arg__ptr: ?*GtkPaperSize) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_paper_size_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkPaperSize(arg__ptr: [*c]?*GtkPaperSize) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPaperSize(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPaperSize(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_paper_size_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPaperSize(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_paper_size_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPaperSize(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_paper_size_free)))))));
    }
}
pub const struct__GtkPageSetup = opaque {};
pub const GtkPageSetup = struct__GtkPageSetup;
pub extern fn gtk_page_setup_get_type() GType;
pub extern fn gtk_page_setup_new() ?*GtkPageSetup;
pub extern fn gtk_page_setup_copy(other: ?*GtkPageSetup) ?*GtkPageSetup;
pub extern fn gtk_page_setup_get_orientation(setup: ?*GtkPageSetup) GtkPageOrientation;
pub extern fn gtk_page_setup_set_orientation(setup: ?*GtkPageSetup, orientation: GtkPageOrientation) void;
pub extern fn gtk_page_setup_get_paper_size(setup: ?*GtkPageSetup) ?*GtkPaperSize;
pub extern fn gtk_page_setup_set_paper_size(setup: ?*GtkPageSetup, size: ?*GtkPaperSize) void;
pub extern fn gtk_page_setup_get_top_margin(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_set_top_margin(setup: ?*GtkPageSetup, margin: f64, unit: GtkUnit) void;
pub extern fn gtk_page_setup_get_bottom_margin(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_set_bottom_margin(setup: ?*GtkPageSetup, margin: f64, unit: GtkUnit) void;
pub extern fn gtk_page_setup_get_left_margin(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_set_left_margin(setup: ?*GtkPageSetup, margin: f64, unit: GtkUnit) void;
pub extern fn gtk_page_setup_get_right_margin(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_set_right_margin(setup: ?*GtkPageSetup, margin: f64, unit: GtkUnit) void;
pub extern fn gtk_page_setup_set_paper_size_and_default_margins(setup: ?*GtkPageSetup, size: ?*GtkPaperSize) void;
pub extern fn gtk_page_setup_get_paper_width(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_get_paper_height(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_get_page_width(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_get_page_height(setup: ?*GtkPageSetup, unit: GtkUnit) f64;
pub extern fn gtk_page_setup_new_from_file(file_name: [*c]const u8, @"error": [*c][*c]GError) ?*GtkPageSetup;
pub extern fn gtk_page_setup_load_file(setup: ?*GtkPageSetup, file_name: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_page_setup_to_file(setup: ?*GtkPageSetup, file_name: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_page_setup_new_from_key_file(key_file: ?*GKeyFile, group_name: [*c]const u8, @"error": [*c][*c]GError) ?*GtkPageSetup;
pub extern fn gtk_page_setup_load_key_file(setup: ?*GtkPageSetup, key_file: ?*GKeyFile, group_name: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_page_setup_to_key_file(setup: ?*GtkPageSetup, key_file: ?*GKeyFile, group_name: [*c]const u8) void;
pub extern fn gtk_page_setup_to_gvariant(setup: ?*GtkPageSetup) ?*GVariant;
pub extern fn gtk_page_setup_new_from_gvariant(variant: ?*GVariant) ?*GtkPageSetup;
pub const GtkPageSetup_autoptr = ?*GtkPageSetup;
pub const GtkPageSetup_listautoptr = [*c]GList;
pub const GtkPageSetup_slistautoptr = [*c]GSList;
pub const GtkPageSetup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPageSetup(arg__ptr: ?*GtkPageSetup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPageSetup(arg__ptr: [*c]?*GtkPageSetup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPageSetup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPageSetup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPageSetup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPageSetup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPaned = opaque {};
pub const GtkPaned = struct__GtkPaned;
pub extern fn gtk_paned_get_type() GType;
pub extern fn gtk_paned_new(orientation: GtkOrientation) [*c]GtkWidget;
pub extern fn gtk_paned_set_start_child(paned: ?*GtkPaned, child: [*c]GtkWidget) void;
pub extern fn gtk_paned_get_start_child(paned: ?*GtkPaned) [*c]GtkWidget;
pub extern fn gtk_paned_set_resize_start_child(paned: ?*GtkPaned, resize: gboolean) void;
pub extern fn gtk_paned_get_resize_start_child(paned: ?*GtkPaned) gboolean;
pub extern fn gtk_paned_set_end_child(paned: ?*GtkPaned, child: [*c]GtkWidget) void;
pub extern fn gtk_paned_get_end_child(paned: ?*GtkPaned) [*c]GtkWidget;
pub extern fn gtk_paned_set_shrink_start_child(paned: ?*GtkPaned, resize: gboolean) void;
pub extern fn gtk_paned_get_shrink_start_child(paned: ?*GtkPaned) gboolean;
pub extern fn gtk_paned_set_resize_end_child(paned: ?*GtkPaned, resize: gboolean) void;
pub extern fn gtk_paned_get_resize_end_child(paned: ?*GtkPaned) gboolean;
pub extern fn gtk_paned_set_shrink_end_child(paned: ?*GtkPaned, resize: gboolean) void;
pub extern fn gtk_paned_get_shrink_end_child(paned: ?*GtkPaned) gboolean;
pub extern fn gtk_paned_get_position(paned: ?*GtkPaned) c_int;
pub extern fn gtk_paned_set_position(paned: ?*GtkPaned, position: c_int) void;
pub extern fn gtk_paned_set_wide_handle(paned: ?*GtkPaned, wide: gboolean) void;
pub extern fn gtk_paned_get_wide_handle(paned: ?*GtkPaned) gboolean;
pub const GtkPaned_autoptr = ?*GtkPaned;
pub const GtkPaned_listautoptr = [*c]GList;
pub const GtkPaned_slistautoptr = [*c]GSList;
pub const GtkPaned_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPaned(arg__ptr: ?*GtkPaned) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPaned(arg__ptr: [*c]?*GtkPaned) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPaned(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPaned(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPaned(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPaned(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPasswordEntry = opaque {};
pub const GtkPasswordEntry = struct__GtkPasswordEntry;
pub const struct__GtkPasswordEntryClass = opaque {};
pub const GtkPasswordEntryClass = struct__GtkPasswordEntryClass;
pub extern fn gtk_password_entry_get_type() GType;
pub extern fn gtk_password_entry_new() [*c]GtkWidget;
pub extern fn gtk_password_entry_set_show_peek_icon(entry: ?*GtkPasswordEntry, show_peek_icon: gboolean) void;
pub extern fn gtk_password_entry_get_show_peek_icon(entry: ?*GtkPasswordEntry) gboolean;
pub extern fn gtk_password_entry_set_extra_menu(entry: ?*GtkPasswordEntry, model: [*c]GMenuModel) void;
pub extern fn gtk_password_entry_get_extra_menu(entry: ?*GtkPasswordEntry) [*c]GMenuModel;
pub extern fn gtk_password_entry_buffer_get_type() GType;
pub const struct__GtkPasswordEntryBuffer = opaque {};
pub const GtkPasswordEntryBuffer = struct__GtkPasswordEntryBuffer;
pub const GtkPasswordEntryBufferClass = extern struct {
    parent_class: GtkEntryBufferClass,
};
pub const GtkPasswordEntryBuffer_autoptr = ?*GtkPasswordEntryBuffer;
pub const GtkPasswordEntryBuffer_listautoptr = [*c]GList;
pub const GtkPasswordEntryBuffer_slistautoptr = [*c]GSList;
pub const GtkPasswordEntryBuffer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPasswordEntryBuffer(arg__ptr: ?*GtkPasswordEntryBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkEntryBuffer(@as([*c]GtkEntryBuffer, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkPasswordEntryBuffer(arg__ptr: [*c]?*GtkPasswordEntryBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPasswordEntryBuffer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPasswordEntryBuffer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkEntryBuffer)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPasswordEntryBuffer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkEntryBuffer)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPasswordEntryBuffer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkEntryBuffer)))))));
    }
}
pub const GtkPasswordEntryBufferClass_autoptr = [*c]GtkPasswordEntryBufferClass;
pub const GtkPasswordEntryBufferClass_listautoptr = [*c]GList;
pub const GtkPasswordEntryBufferClass_slistautoptr = [*c]GSList;
pub const GtkPasswordEntryBufferClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPasswordEntryBufferClass(arg__ptr: [*c]GtkPasswordEntryBufferClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPasswordEntryBufferClass(arg__ptr: [*c][*c]GtkPasswordEntryBufferClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPasswordEntryBufferClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPasswordEntryBufferClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPasswordEntryBufferClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPasswordEntryBufferClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_PASSWORD_ENTRY_BUFFER(arg_ptr: gpointer) callconv(.C) ?*GtkPasswordEntryBuffer {
    var ptr = arg_ptr;
    return @as(?*GtkPasswordEntryBuffer, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_password_entry_buffer_get_type())))));
}
pub fn GTK_IS_PASSWORD_ENTRY_BUFFER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_password_entry_buffer_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_password_entry_buffer_new() [*c]GtkEntryBuffer;
pub extern fn gtk_picture_get_type() GType;
pub const struct__GtkPicture = opaque {};
pub const GtkPicture = struct__GtkPicture;
pub const GtkPictureClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkPicture_autoptr = ?*GtkPicture;
pub const GtkPicture_listautoptr = [*c]GList;
pub const GtkPicture_slistautoptr = [*c]GSList;
pub const GtkPicture_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPicture(arg__ptr: ?*GtkPicture) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkPicture(arg__ptr: [*c]?*GtkPicture) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPicture(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPicture(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPicture(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPicture(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkPictureClass_autoptr = [*c]GtkPictureClass;
pub const GtkPictureClass_listautoptr = [*c]GList;
pub const GtkPictureClass_slistautoptr = [*c]GSList;
pub const GtkPictureClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPictureClass(arg__ptr: [*c]GtkPictureClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPictureClass(arg__ptr: [*c][*c]GtkPictureClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPictureClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPictureClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPictureClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPictureClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_PICTURE(arg_ptr: gpointer) callconv(.C) ?*GtkPicture {
    var ptr = arg_ptr;
    return @as(?*GtkPicture, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_picture_get_type())))));
}
pub fn GTK_IS_PICTURE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_picture_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_picture_new() [*c]GtkWidget;
pub extern fn gtk_picture_new_for_paintable(paintable: ?*GdkPaintable) [*c]GtkWidget;
pub extern fn gtk_picture_new_for_pixbuf(pixbuf: ?*GdkPixbuf) [*c]GtkWidget;
pub extern fn gtk_picture_new_for_file(file: ?*GFile) [*c]GtkWidget;
pub extern fn gtk_picture_new_for_filename(filename: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_picture_new_for_resource(resource_path: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_picture_set_paintable(self: ?*GtkPicture, paintable: ?*GdkPaintable) void;
pub extern fn gtk_picture_get_paintable(self: ?*GtkPicture) ?*GdkPaintable;
pub extern fn gtk_picture_set_file(self: ?*GtkPicture, file: ?*GFile) void;
pub extern fn gtk_picture_get_file(self: ?*GtkPicture) ?*GFile;
pub extern fn gtk_picture_set_filename(self: ?*GtkPicture, filename: [*c]const u8) void;
pub extern fn gtk_picture_set_resource(self: ?*GtkPicture, resource_path: [*c]const u8) void;
pub extern fn gtk_picture_set_pixbuf(self: ?*GtkPicture, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_picture_set_keep_aspect_ratio(self: ?*GtkPicture, keep_aspect_ratio: gboolean) void;
pub extern fn gtk_picture_get_keep_aspect_ratio(self: ?*GtkPicture) gboolean;
pub extern fn gtk_picture_set_can_shrink(self: ?*GtkPicture, can_shrink: gboolean) void;
pub extern fn gtk_picture_get_can_shrink(self: ?*GtkPicture) gboolean;
pub extern fn gtk_picture_set_content_fit(self: ?*GtkPicture, content_fit: GtkContentFit) void;
pub extern fn gtk_picture_get_content_fit(self: ?*GtkPicture) GtkContentFit;
pub extern fn gtk_picture_set_alternative_text(self: ?*GtkPicture, alternative_text: [*c]const u8) void;
pub extern fn gtk_picture_get_alternative_text(self: ?*GtkPicture) [*c]const u8;
pub const struct__GtkPopoverMenu = opaque {};
pub const GtkPopoverMenu = struct__GtkPopoverMenu;
pub extern fn gtk_popover_menu_get_type() GType;
pub extern fn gtk_popover_menu_new_from_model(model: [*c]GMenuModel) [*c]GtkWidget;
pub const GTK_POPOVER_MENU_NESTED: c_int = 1;
pub const GtkPopoverMenuFlags = c_uint;
pub extern fn gtk_popover_menu_new_from_model_full(model: [*c]GMenuModel, flags: GtkPopoverMenuFlags) [*c]GtkWidget;
pub extern fn gtk_popover_menu_set_menu_model(popover: ?*GtkPopoverMenu, model: [*c]GMenuModel) void;
pub extern fn gtk_popover_menu_get_menu_model(popover: ?*GtkPopoverMenu) [*c]GMenuModel;
pub extern fn gtk_popover_menu_add_child(popover: ?*GtkPopoverMenu, child: [*c]GtkWidget, id: [*c]const u8) gboolean;
pub extern fn gtk_popover_menu_remove_child(popover: ?*GtkPopoverMenu, child: [*c]GtkWidget) gboolean;
pub const GtkPopoverMenu_autoptr = ?*GtkPopoverMenu;
pub const GtkPopoverMenu_listautoptr = [*c]GList;
pub const GtkPopoverMenu_slistautoptr = [*c]GSList;
pub const GtkPopoverMenu_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPopoverMenu(arg__ptr: ?*GtkPopoverMenu) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPopoverMenu(arg__ptr: [*c]?*GtkPopoverMenu) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPopoverMenu(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPopoverMenu(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPopoverMenu(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPopoverMenu(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPopoverMenuBar = opaque {};
pub const GtkPopoverMenuBar = struct__GtkPopoverMenuBar;
pub extern fn gtk_popover_menu_bar_get_type() GType;
pub extern fn gtk_popover_menu_bar_new_from_model(model: [*c]GMenuModel) [*c]GtkWidget;
pub extern fn gtk_popover_menu_bar_set_menu_model(bar: ?*GtkPopoverMenuBar, model: [*c]GMenuModel) void;
pub extern fn gtk_popover_menu_bar_get_menu_model(bar: ?*GtkPopoverMenuBar) [*c]GMenuModel;
pub extern fn gtk_popover_menu_bar_add_child(bar: ?*GtkPopoverMenuBar, child: [*c]GtkWidget, id: [*c]const u8) gboolean;
pub extern fn gtk_popover_menu_bar_remove_child(bar: ?*GtkPopoverMenuBar, child: [*c]GtkWidget) gboolean;
pub const GtkPopoverMenuBar_autoptr = ?*GtkPopoverMenuBar;
pub const GtkPopoverMenuBar_listautoptr = [*c]GList;
pub const GtkPopoverMenuBar_slistautoptr = [*c]GSList;
pub const GtkPopoverMenuBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPopoverMenuBar(arg__ptr: ?*GtkPopoverMenuBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPopoverMenuBar(arg__ptr: [*c]?*GtkPopoverMenuBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPopoverMenuBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPopoverMenuBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPopoverMenuBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPopoverMenuBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPrintContext = opaque {};
pub const GtkPrintContext = struct__GtkPrintContext;
pub extern fn gtk_print_context_get_type() GType;
pub extern fn gtk_print_context_get_cairo_context(context: ?*GtkPrintContext) ?*cairo_t;
pub extern fn gtk_print_context_get_page_setup(context: ?*GtkPrintContext) ?*GtkPageSetup;
pub extern fn gtk_print_context_get_width(context: ?*GtkPrintContext) f64;
pub extern fn gtk_print_context_get_height(context: ?*GtkPrintContext) f64;
pub extern fn gtk_print_context_get_dpi_x(context: ?*GtkPrintContext) f64;
pub extern fn gtk_print_context_get_dpi_y(context: ?*GtkPrintContext) f64;
pub extern fn gtk_print_context_get_hard_margins(context: ?*GtkPrintContext, top: [*c]f64, bottom: [*c]f64, left: [*c]f64, right: [*c]f64) gboolean;
pub extern fn gtk_print_context_get_pango_fontmap(context: ?*GtkPrintContext) [*c]PangoFontMap;
pub extern fn gtk_print_context_create_pango_context(context: ?*GtkPrintContext) ?*PangoContext;
pub extern fn gtk_print_context_create_pango_layout(context: ?*GtkPrintContext) ?*PangoLayout;
pub extern fn gtk_print_context_set_cairo_context(context: ?*GtkPrintContext, cr: ?*cairo_t, dpi_x: f64, dpi_y: f64) void;
pub const GtkPrintContext_autoptr = ?*GtkPrintContext;
pub const GtkPrintContext_listautoptr = [*c]GList;
pub const GtkPrintContext_slistautoptr = [*c]GSList;
pub const GtkPrintContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintContext(arg__ptr: ?*GtkPrintContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPrintContext(arg__ptr: [*c]?*GtkPrintContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPrintContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPrintSettings = opaque {};
pub const GtkPrintSettings = struct__GtkPrintSettings;
pub const GtkPrintSettingsFunc = ?*const fn ([*c]const u8, [*c]const u8, gpointer) callconv(.C) void;
pub const struct__GtkPageRange = extern struct {
    start: c_int,
    end: c_int,
};
pub const GtkPageRange = struct__GtkPageRange;
pub extern fn gtk_print_settings_get_type() GType;
pub extern fn gtk_print_settings_new() ?*GtkPrintSettings;
pub extern fn gtk_print_settings_copy(other: ?*GtkPrintSettings) ?*GtkPrintSettings;
pub extern fn gtk_print_settings_new_from_file(file_name: [*c]const u8, @"error": [*c][*c]GError) ?*GtkPrintSettings;
pub extern fn gtk_print_settings_load_file(settings: ?*GtkPrintSettings, file_name: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_print_settings_to_file(settings: ?*GtkPrintSettings, file_name: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_print_settings_new_from_key_file(key_file: ?*GKeyFile, group_name: [*c]const u8, @"error": [*c][*c]GError) ?*GtkPrintSettings;
pub extern fn gtk_print_settings_load_key_file(settings: ?*GtkPrintSettings, key_file: ?*GKeyFile, group_name: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_print_settings_to_key_file(settings: ?*GtkPrintSettings, key_file: ?*GKeyFile, group_name: [*c]const u8) void;
pub extern fn gtk_print_settings_has_key(settings: ?*GtkPrintSettings, key: [*c]const u8) gboolean;
pub extern fn gtk_print_settings_get(settings: ?*GtkPrintSettings, key: [*c]const u8) [*c]const u8;
pub extern fn gtk_print_settings_set(settings: ?*GtkPrintSettings, key: [*c]const u8, value: [*c]const u8) void;
pub extern fn gtk_print_settings_unset(settings: ?*GtkPrintSettings, key: [*c]const u8) void;
pub extern fn gtk_print_settings_foreach(settings: ?*GtkPrintSettings, func: GtkPrintSettingsFunc, user_data: gpointer) void;
pub extern fn gtk_print_settings_get_bool(settings: ?*GtkPrintSettings, key: [*c]const u8) gboolean;
pub extern fn gtk_print_settings_set_bool(settings: ?*GtkPrintSettings, key: [*c]const u8, value: gboolean) void;
pub extern fn gtk_print_settings_get_double(settings: ?*GtkPrintSettings, key: [*c]const u8) f64;
pub extern fn gtk_print_settings_get_double_with_default(settings: ?*GtkPrintSettings, key: [*c]const u8, def: f64) f64;
pub extern fn gtk_print_settings_set_double(settings: ?*GtkPrintSettings, key: [*c]const u8, value: f64) void;
pub extern fn gtk_print_settings_get_length(settings: ?*GtkPrintSettings, key: [*c]const u8, unit: GtkUnit) f64;
pub extern fn gtk_print_settings_set_length(settings: ?*GtkPrintSettings, key: [*c]const u8, value: f64, unit: GtkUnit) void;
pub extern fn gtk_print_settings_get_int(settings: ?*GtkPrintSettings, key: [*c]const u8) c_int;
pub extern fn gtk_print_settings_get_int_with_default(settings: ?*GtkPrintSettings, key: [*c]const u8, def: c_int) c_int;
pub extern fn gtk_print_settings_set_int(settings: ?*GtkPrintSettings, key: [*c]const u8, value: c_int) void;
pub extern fn gtk_print_settings_get_printer(settings: ?*GtkPrintSettings) [*c]const u8;
pub extern fn gtk_print_settings_set_printer(settings: ?*GtkPrintSettings, printer: [*c]const u8) void;
pub extern fn gtk_print_settings_get_orientation(settings: ?*GtkPrintSettings) GtkPageOrientation;
pub extern fn gtk_print_settings_set_orientation(settings: ?*GtkPrintSettings, orientation: GtkPageOrientation) void;
pub extern fn gtk_print_settings_get_paper_size(settings: ?*GtkPrintSettings) ?*GtkPaperSize;
pub extern fn gtk_print_settings_set_paper_size(settings: ?*GtkPrintSettings, paper_size: ?*GtkPaperSize) void;
pub extern fn gtk_print_settings_get_paper_width(settings: ?*GtkPrintSettings, unit: GtkUnit) f64;
pub extern fn gtk_print_settings_set_paper_width(settings: ?*GtkPrintSettings, width: f64, unit: GtkUnit) void;
pub extern fn gtk_print_settings_get_paper_height(settings: ?*GtkPrintSettings, unit: GtkUnit) f64;
pub extern fn gtk_print_settings_set_paper_height(settings: ?*GtkPrintSettings, height: f64, unit: GtkUnit) void;
pub extern fn gtk_print_settings_get_use_color(settings: ?*GtkPrintSettings) gboolean;
pub extern fn gtk_print_settings_set_use_color(settings: ?*GtkPrintSettings, use_color: gboolean) void;
pub extern fn gtk_print_settings_get_collate(settings: ?*GtkPrintSettings) gboolean;
pub extern fn gtk_print_settings_set_collate(settings: ?*GtkPrintSettings, collate: gboolean) void;
pub extern fn gtk_print_settings_get_reverse(settings: ?*GtkPrintSettings) gboolean;
pub extern fn gtk_print_settings_set_reverse(settings: ?*GtkPrintSettings, reverse: gboolean) void;
pub extern fn gtk_print_settings_get_duplex(settings: ?*GtkPrintSettings) GtkPrintDuplex;
pub extern fn gtk_print_settings_set_duplex(settings: ?*GtkPrintSettings, duplex: GtkPrintDuplex) void;
pub extern fn gtk_print_settings_get_quality(settings: ?*GtkPrintSettings) GtkPrintQuality;
pub extern fn gtk_print_settings_set_quality(settings: ?*GtkPrintSettings, quality: GtkPrintQuality) void;
pub extern fn gtk_print_settings_get_n_copies(settings: ?*GtkPrintSettings) c_int;
pub extern fn gtk_print_settings_set_n_copies(settings: ?*GtkPrintSettings, num_copies: c_int) void;
pub extern fn gtk_print_settings_get_number_up(settings: ?*GtkPrintSettings) c_int;
pub extern fn gtk_print_settings_set_number_up(settings: ?*GtkPrintSettings, number_up: c_int) void;
pub extern fn gtk_print_settings_get_number_up_layout(settings: ?*GtkPrintSettings) GtkNumberUpLayout;
pub extern fn gtk_print_settings_set_number_up_layout(settings: ?*GtkPrintSettings, number_up_layout: GtkNumberUpLayout) void;
pub extern fn gtk_print_settings_get_resolution(settings: ?*GtkPrintSettings) c_int;
pub extern fn gtk_print_settings_set_resolution(settings: ?*GtkPrintSettings, resolution: c_int) void;
pub extern fn gtk_print_settings_get_resolution_x(settings: ?*GtkPrintSettings) c_int;
pub extern fn gtk_print_settings_get_resolution_y(settings: ?*GtkPrintSettings) c_int;
pub extern fn gtk_print_settings_set_resolution_xy(settings: ?*GtkPrintSettings, resolution_x: c_int, resolution_y: c_int) void;
pub extern fn gtk_print_settings_get_printer_lpi(settings: ?*GtkPrintSettings) f64;
pub extern fn gtk_print_settings_set_printer_lpi(settings: ?*GtkPrintSettings, lpi: f64) void;
pub extern fn gtk_print_settings_get_scale(settings: ?*GtkPrintSettings) f64;
pub extern fn gtk_print_settings_set_scale(settings: ?*GtkPrintSettings, scale: f64) void;
pub extern fn gtk_print_settings_get_print_pages(settings: ?*GtkPrintSettings) GtkPrintPages;
pub extern fn gtk_print_settings_set_print_pages(settings: ?*GtkPrintSettings, pages: GtkPrintPages) void;
pub extern fn gtk_print_settings_get_page_ranges(settings: ?*GtkPrintSettings, num_ranges: [*c]c_int) [*c]GtkPageRange;
pub extern fn gtk_print_settings_set_page_ranges(settings: ?*GtkPrintSettings, page_ranges: [*c]GtkPageRange, num_ranges: c_int) void;
pub extern fn gtk_print_settings_get_page_set(settings: ?*GtkPrintSettings) GtkPageSet;
pub extern fn gtk_print_settings_set_page_set(settings: ?*GtkPrintSettings, page_set: GtkPageSet) void;
pub extern fn gtk_print_settings_get_default_source(settings: ?*GtkPrintSettings) [*c]const u8;
pub extern fn gtk_print_settings_set_default_source(settings: ?*GtkPrintSettings, default_source: [*c]const u8) void;
pub extern fn gtk_print_settings_get_media_type(settings: ?*GtkPrintSettings) [*c]const u8;
pub extern fn gtk_print_settings_set_media_type(settings: ?*GtkPrintSettings, media_type: [*c]const u8) void;
pub extern fn gtk_print_settings_get_dither(settings: ?*GtkPrintSettings) [*c]const u8;
pub extern fn gtk_print_settings_set_dither(settings: ?*GtkPrintSettings, dither: [*c]const u8) void;
pub extern fn gtk_print_settings_get_finishings(settings: ?*GtkPrintSettings) [*c]const u8;
pub extern fn gtk_print_settings_set_finishings(settings: ?*GtkPrintSettings, finishings: [*c]const u8) void;
pub extern fn gtk_print_settings_get_output_bin(settings: ?*GtkPrintSettings) [*c]const u8;
pub extern fn gtk_print_settings_set_output_bin(settings: ?*GtkPrintSettings, output_bin: [*c]const u8) void;
pub extern fn gtk_print_settings_to_gvariant(settings: ?*GtkPrintSettings) ?*GVariant;
pub extern fn gtk_print_settings_new_from_gvariant(variant: ?*GVariant) ?*GtkPrintSettings;
pub const GtkPrintSettings_autoptr = ?*GtkPrintSettings;
pub const GtkPrintSettings_listautoptr = [*c]GList;
pub const GtkPrintSettings_slistautoptr = [*c]GSList;
pub const GtkPrintSettings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintSettings(arg__ptr: ?*GtkPrintSettings) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPrintSettings(arg__ptr: [*c]?*GtkPrintSettings) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPrintSettings(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintSettings(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintSettings(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintSettings(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPrintOperationPreview = opaque {};
pub const GtkPrintOperationPreview = struct__GtkPrintOperationPreview;
pub const struct__GtkPrintOperationPreviewIface = extern struct {
    g_iface: GTypeInterface,
    ready: ?*const fn (?*GtkPrintOperationPreview, ?*GtkPrintContext) callconv(.C) void,
    got_page_size: ?*const fn (?*GtkPrintOperationPreview, ?*GtkPrintContext, ?*GtkPageSetup) callconv(.C) void,
    render_page: ?*const fn (?*GtkPrintOperationPreview, c_int) callconv(.C) void,
    is_selected: ?*const fn (?*GtkPrintOperationPreview, c_int) callconv(.C) gboolean,
    end_preview: ?*const fn (?*GtkPrintOperationPreview) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
    _gtk_reserved5: ?*const fn () callconv(.C) void,
    _gtk_reserved6: ?*const fn () callconv(.C) void,
    _gtk_reserved7: ?*const fn () callconv(.C) void,
    _gtk_reserved8: ?*const fn () callconv(.C) void,
};
pub const GtkPrintOperationPreviewIface = struct__GtkPrintOperationPreviewIface;
pub extern fn gtk_print_operation_preview_get_type() GType;
pub extern fn gtk_print_operation_preview_render_page(preview: ?*GtkPrintOperationPreview, page_nr: c_int) void;
pub extern fn gtk_print_operation_preview_end_preview(preview: ?*GtkPrintOperationPreview) void;
pub extern fn gtk_print_operation_preview_is_selected(preview: ?*GtkPrintOperationPreview, page_nr: c_int) gboolean;
pub const GtkPrintOperationPreview_autoptr = ?*GtkPrintOperationPreview;
pub const GtkPrintOperationPreview_listautoptr = [*c]GList;
pub const GtkPrintOperationPreview_slistautoptr = [*c]GSList;
pub const GtkPrintOperationPreview_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintOperationPreview(arg__ptr: ?*GtkPrintOperationPreview) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPrintOperationPreview(arg__ptr: [*c]?*GtkPrintOperationPreview) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPrintOperationPreview(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintOperationPreview(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintOperationPreview(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintOperationPreview(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkPrintOperationPrivate = opaque {};
pub const GtkPrintOperationPrivate = struct__GtkPrintOperationPrivate;
pub const struct__GtkPrintOperation = extern struct {
    parent_instance: GObject,
    priv: ?*GtkPrintOperationPrivate,
};
pub const GtkPrintOperation = struct__GtkPrintOperation;
pub const struct__GtkPrintOperationClass = extern struct {
    parent_class: GObjectClass,
    done: ?*const fn ([*c]GtkPrintOperation, GtkPrintOperationResult) callconv(.C) void,
    begin_print: ?*const fn ([*c]GtkPrintOperation, ?*GtkPrintContext) callconv(.C) void,
    paginate: ?*const fn ([*c]GtkPrintOperation, ?*GtkPrintContext) callconv(.C) gboolean,
    request_page_setup: ?*const fn ([*c]GtkPrintOperation, ?*GtkPrintContext, c_int, ?*GtkPageSetup) callconv(.C) void,
    draw_page: ?*const fn ([*c]GtkPrintOperation, ?*GtkPrintContext, c_int) callconv(.C) void,
    end_print: ?*const fn ([*c]GtkPrintOperation, ?*GtkPrintContext) callconv(.C) void,
    status_changed: ?*const fn ([*c]GtkPrintOperation) callconv(.C) void,
    create_custom_widget: ?*const fn ([*c]GtkPrintOperation) callconv(.C) [*c]GtkWidget,
    custom_widget_apply: ?*const fn ([*c]GtkPrintOperation, [*c]GtkWidget) callconv(.C) void,
    preview: ?*const fn ([*c]GtkPrintOperation, ?*GtkPrintOperationPreview, ?*GtkPrintContext, [*c]GtkWindow) callconv(.C) gboolean,
    update_custom_widget: ?*const fn ([*c]GtkPrintOperation, [*c]GtkWidget, ?*GtkPageSetup, ?*GtkPrintSettings) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkPrintOperationClass = struct__GtkPrintOperationClass;
pub const GTK_PRINT_STATUS_INITIAL: c_int = 0;
pub const GTK_PRINT_STATUS_PREPARING: c_int = 1;
pub const GTK_PRINT_STATUS_GENERATING_DATA: c_int = 2;
pub const GTK_PRINT_STATUS_SENDING_DATA: c_int = 3;
pub const GTK_PRINT_STATUS_PENDING: c_int = 4;
pub const GTK_PRINT_STATUS_PENDING_ISSUE: c_int = 5;
pub const GTK_PRINT_STATUS_PRINTING: c_int = 6;
pub const GTK_PRINT_STATUS_FINISHED: c_int = 7;
pub const GTK_PRINT_STATUS_FINISHED_ABORTED: c_int = 8;
pub const GtkPrintStatus = c_uint;
pub const GTK_PRINT_OPERATION_RESULT_ERROR: c_int = 0;
pub const GTK_PRINT_OPERATION_RESULT_APPLY: c_int = 1;
pub const GTK_PRINT_OPERATION_RESULT_CANCEL: c_int = 2;
pub const GTK_PRINT_OPERATION_RESULT_IN_PROGRESS: c_int = 3;
pub const GtkPrintOperationResult = c_uint;
pub const GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG: c_int = 0;
pub const GTK_PRINT_OPERATION_ACTION_PRINT: c_int = 1;
pub const GTK_PRINT_OPERATION_ACTION_PREVIEW: c_int = 2;
pub const GTK_PRINT_OPERATION_ACTION_EXPORT: c_int = 3;
pub const GtkPrintOperationAction = c_uint;
pub const GTK_PRINT_ERROR_GENERAL: c_int = 0;
pub const GTK_PRINT_ERROR_INTERNAL_ERROR: c_int = 1;
pub const GTK_PRINT_ERROR_NOMEM: c_int = 2;
pub const GTK_PRINT_ERROR_INVALID_FILE: c_int = 3;
pub const GtkPrintError = c_uint;
pub extern fn gtk_print_error_quark() GQuark;
pub extern fn gtk_print_operation_get_type() GType;
pub extern fn gtk_print_operation_new() [*c]GtkPrintOperation;
pub extern fn gtk_print_operation_set_default_page_setup(op: [*c]GtkPrintOperation, default_page_setup: ?*GtkPageSetup) void;
pub extern fn gtk_print_operation_get_default_page_setup(op: [*c]GtkPrintOperation) ?*GtkPageSetup;
pub extern fn gtk_print_operation_set_print_settings(op: [*c]GtkPrintOperation, print_settings: ?*GtkPrintSettings) void;
pub extern fn gtk_print_operation_get_print_settings(op: [*c]GtkPrintOperation) ?*GtkPrintSettings;
pub extern fn gtk_print_operation_set_job_name(op: [*c]GtkPrintOperation, job_name: [*c]const u8) void;
pub extern fn gtk_print_operation_set_n_pages(op: [*c]GtkPrintOperation, n_pages: c_int) void;
pub extern fn gtk_print_operation_set_current_page(op: [*c]GtkPrintOperation, current_page: c_int) void;
pub extern fn gtk_print_operation_set_use_full_page(op: [*c]GtkPrintOperation, full_page: gboolean) void;
pub extern fn gtk_print_operation_set_unit(op: [*c]GtkPrintOperation, unit: GtkUnit) void;
pub extern fn gtk_print_operation_set_export_filename(op: [*c]GtkPrintOperation, filename: [*c]const u8) void;
pub extern fn gtk_print_operation_set_track_print_status(op: [*c]GtkPrintOperation, track_status: gboolean) void;
pub extern fn gtk_print_operation_set_show_progress(op: [*c]GtkPrintOperation, show_progress: gboolean) void;
pub extern fn gtk_print_operation_set_allow_async(op: [*c]GtkPrintOperation, allow_async: gboolean) void;
pub extern fn gtk_print_operation_set_custom_tab_label(op: [*c]GtkPrintOperation, label: [*c]const u8) void;
pub extern fn gtk_print_operation_run(op: [*c]GtkPrintOperation, action: GtkPrintOperationAction, parent: [*c]GtkWindow, @"error": [*c][*c]GError) GtkPrintOperationResult;
pub extern fn gtk_print_operation_get_error(op: [*c]GtkPrintOperation, @"error": [*c][*c]GError) void;
pub extern fn gtk_print_operation_get_status(op: [*c]GtkPrintOperation) GtkPrintStatus;
pub extern fn gtk_print_operation_get_status_string(op: [*c]GtkPrintOperation) [*c]const u8;
pub extern fn gtk_print_operation_is_finished(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_cancel(op: [*c]GtkPrintOperation) void;
pub extern fn gtk_print_operation_draw_page_finish(op: [*c]GtkPrintOperation) void;
pub extern fn gtk_print_operation_set_defer_drawing(op: [*c]GtkPrintOperation) void;
pub extern fn gtk_print_operation_set_support_selection(op: [*c]GtkPrintOperation, support_selection: gboolean) void;
pub extern fn gtk_print_operation_get_support_selection(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_set_has_selection(op: [*c]GtkPrintOperation, has_selection: gboolean) void;
pub extern fn gtk_print_operation_get_has_selection(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_set_embed_page_setup(op: [*c]GtkPrintOperation, embed: gboolean) void;
pub extern fn gtk_print_operation_get_embed_page_setup(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_get_n_pages_to_print(op: [*c]GtkPrintOperation) c_int;
pub extern fn gtk_print_run_page_setup_dialog(parent: [*c]GtkWindow, page_setup: ?*GtkPageSetup, settings: ?*GtkPrintSettings) ?*GtkPageSetup;
pub const GtkPageSetupDoneFunc = ?*const fn (?*GtkPageSetup, gpointer) callconv(.C) void;
pub extern fn gtk_print_run_page_setup_dialog_async(parent: [*c]GtkWindow, page_setup: ?*GtkPageSetup, settings: ?*GtkPrintSettings, done_cb: GtkPageSetupDoneFunc, data: gpointer) void;
pub const GtkPrintOperation_autoptr = [*c]GtkPrintOperation;
pub const GtkPrintOperation_listautoptr = [*c]GList;
pub const GtkPrintOperation_slistautoptr = [*c]GSList;
pub const GtkPrintOperation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintOperation(arg__ptr: [*c]GtkPrintOperation) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkPrintOperation(arg__ptr: [*c][*c]GtkPrintOperation) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkPrintOperation(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintOperation(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintOperation(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintOperation(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkProgressBar = opaque {};
pub const GtkProgressBar = struct__GtkProgressBar;
pub extern fn gtk_progress_bar_get_type() GType;
pub extern fn gtk_progress_bar_new() [*c]GtkWidget;
pub extern fn gtk_progress_bar_pulse(pbar: ?*GtkProgressBar) void;
pub extern fn gtk_progress_bar_set_text(pbar: ?*GtkProgressBar, text: [*c]const u8) void;
pub extern fn gtk_progress_bar_set_fraction(pbar: ?*GtkProgressBar, fraction: f64) void;
pub extern fn gtk_progress_bar_set_pulse_step(pbar: ?*GtkProgressBar, fraction: f64) void;
pub extern fn gtk_progress_bar_set_inverted(pbar: ?*GtkProgressBar, inverted: gboolean) void;
pub extern fn gtk_progress_bar_get_text(pbar: ?*GtkProgressBar) [*c]const u8;
pub extern fn gtk_progress_bar_get_fraction(pbar: ?*GtkProgressBar) f64;
pub extern fn gtk_progress_bar_get_pulse_step(pbar: ?*GtkProgressBar) f64;
pub extern fn gtk_progress_bar_get_inverted(pbar: ?*GtkProgressBar) gboolean;
pub extern fn gtk_progress_bar_set_ellipsize(pbar: ?*GtkProgressBar, mode: PangoEllipsizeMode) void;
pub extern fn gtk_progress_bar_get_ellipsize(pbar: ?*GtkProgressBar) PangoEllipsizeMode;
pub extern fn gtk_progress_bar_set_show_text(pbar: ?*GtkProgressBar, show_text: gboolean) void;
pub extern fn gtk_progress_bar_get_show_text(pbar: ?*GtkProgressBar) gboolean;
pub const GtkProgressBar_autoptr = ?*GtkProgressBar;
pub const GtkProgressBar_listautoptr = [*c]GList;
pub const GtkProgressBar_slistautoptr = [*c]GSList;
pub const GtkProgressBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkProgressBar(arg__ptr: ?*GtkProgressBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkProgressBar(arg__ptr: [*c]?*GtkProgressBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkProgressBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkProgressBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkProgressBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkProgressBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkRange = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkRange = struct__GtkRange;
pub const struct__GtkRangeClass = extern struct {
    parent_class: GtkWidgetClass,
    value_changed: ?*const fn ([*c]GtkRange) callconv(.C) void,
    adjust_bounds: ?*const fn ([*c]GtkRange, f64) callconv(.C) void,
    move_slider: ?*const fn ([*c]GtkRange, GtkScrollType) callconv(.C) void,
    get_range_border: ?*const fn ([*c]GtkRange, [*c]GtkBorder) callconv(.C) void,
    change_value: ?*const fn ([*c]GtkRange, GtkScrollType, f64) callconv(.C) gboolean,
    padding: [8]gpointer,
};
pub const GtkRangeClass = struct__GtkRangeClass;
pub extern fn gtk_range_get_type() GType;
pub extern fn gtk_range_set_adjustment(range: [*c]GtkRange, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_range_get_adjustment(range: [*c]GtkRange) [*c]GtkAdjustment;
pub extern fn gtk_range_set_inverted(range: [*c]GtkRange, setting: gboolean) void;
pub extern fn gtk_range_get_inverted(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_flippable(range: [*c]GtkRange, flippable: gboolean) void;
pub extern fn gtk_range_get_flippable(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_slider_size_fixed(range: [*c]GtkRange, size_fixed: gboolean) void;
pub extern fn gtk_range_get_slider_size_fixed(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_get_range_rect(range: [*c]GtkRange, range_rect: [*c]GdkRectangle) void;
pub extern fn gtk_range_get_slider_range(range: [*c]GtkRange, slider_start: [*c]c_int, slider_end: [*c]c_int) void;
pub extern fn gtk_range_set_increments(range: [*c]GtkRange, step: f64, page: f64) void;
pub extern fn gtk_range_set_range(range: [*c]GtkRange, min: f64, max: f64) void;
pub extern fn gtk_range_set_value(range: [*c]GtkRange, value: f64) void;
pub extern fn gtk_range_get_value(range: [*c]GtkRange) f64;
pub extern fn gtk_range_set_show_fill_level(range: [*c]GtkRange, show_fill_level: gboolean) void;
pub extern fn gtk_range_get_show_fill_level(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_restrict_to_fill_level(range: [*c]GtkRange, restrict_to_fill_level: gboolean) void;
pub extern fn gtk_range_get_restrict_to_fill_level(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_fill_level(range: [*c]GtkRange, fill_level: f64) void;
pub extern fn gtk_range_get_fill_level(range: [*c]GtkRange) f64;
pub extern fn gtk_range_set_round_digits(range: [*c]GtkRange, round_digits: c_int) void;
pub extern fn gtk_range_get_round_digits(range: [*c]GtkRange) c_int;
pub const GtkRange_autoptr = [*c]GtkRange;
pub const GtkRange_listautoptr = [*c]GList;
pub const GtkRange_slistautoptr = [*c]GSList;
pub const GtkRange_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRange(arg__ptr: [*c]GtkRange) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkRange(arg__ptr: [*c][*c]GtkRange) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkRange(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkRange(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkRange(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkRange(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkRecentInfo = opaque {};
pub const GtkRecentInfo = struct__GtkRecentInfo;
pub const struct__GtkRecentData = extern struct {
    display_name: [*c]u8,
    description: [*c]u8,
    mime_type: [*c]u8,
    app_name: [*c]u8,
    app_exec: [*c]u8,
    groups: [*c][*c]u8,
    is_private: gboolean,
};
pub const GtkRecentData = struct__GtkRecentData;
pub const struct__GtkRecentManagerPrivate = opaque {};
pub const GtkRecentManagerPrivate = struct__GtkRecentManagerPrivate;
pub const struct__GtkRecentManager = extern struct {
    parent_instance: GObject,
    priv: ?*GtkRecentManagerPrivate,
};
pub const GtkRecentManager = struct__GtkRecentManager;
pub const struct__GtkRecentManagerClass = extern struct {
    parent_class: GObjectClass,
    changed: ?*const fn ([*c]GtkRecentManager) callconv(.C) void,
    _gtk_recent1: ?*const fn () callconv(.C) void,
    _gtk_recent2: ?*const fn () callconv(.C) void,
    _gtk_recent3: ?*const fn () callconv(.C) void,
    _gtk_recent4: ?*const fn () callconv(.C) void,
};
pub const GtkRecentManagerClass = struct__GtkRecentManagerClass;
pub const GTK_RECENT_MANAGER_ERROR_NOT_FOUND: c_int = 0;
pub const GTK_RECENT_MANAGER_ERROR_INVALID_URI: c_int = 1;
pub const GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING: c_int = 2;
pub const GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED: c_int = 3;
pub const GTK_RECENT_MANAGER_ERROR_READ: c_int = 4;
pub const GTK_RECENT_MANAGER_ERROR_WRITE: c_int = 5;
pub const GTK_RECENT_MANAGER_ERROR_UNKNOWN: c_int = 6;
pub const GtkRecentManagerError = c_uint;
pub extern fn gtk_recent_manager_error_quark() GQuark;
pub extern fn gtk_recent_manager_get_type() GType;
pub extern fn gtk_recent_manager_new() [*c]GtkRecentManager;
pub extern fn gtk_recent_manager_get_default() [*c]GtkRecentManager;
pub extern fn gtk_recent_manager_add_item(manager: [*c]GtkRecentManager, uri: [*c]const u8) gboolean;
pub extern fn gtk_recent_manager_add_full(manager: [*c]GtkRecentManager, uri: [*c]const u8, recent_data: [*c]const GtkRecentData) gboolean;
pub extern fn gtk_recent_manager_remove_item(manager: [*c]GtkRecentManager, uri: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_recent_manager_lookup_item(manager: [*c]GtkRecentManager, uri: [*c]const u8, @"error": [*c][*c]GError) ?*GtkRecentInfo;
pub extern fn gtk_recent_manager_has_item(manager: [*c]GtkRecentManager, uri: [*c]const u8) gboolean;
pub extern fn gtk_recent_manager_move_item(manager: [*c]GtkRecentManager, uri: [*c]const u8, new_uri: [*c]const u8, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_recent_manager_get_items(manager: [*c]GtkRecentManager) [*c]GList;
pub extern fn gtk_recent_manager_purge_items(manager: [*c]GtkRecentManager, @"error": [*c][*c]GError) c_int;
pub extern fn gtk_recent_info_get_type() GType;
pub extern fn gtk_recent_info_ref(info: ?*GtkRecentInfo) ?*GtkRecentInfo;
pub extern fn gtk_recent_info_unref(info: ?*GtkRecentInfo) void;
pub extern fn gtk_recent_info_get_uri(info: ?*GtkRecentInfo) [*c]const u8;
pub extern fn gtk_recent_info_get_display_name(info: ?*GtkRecentInfo) [*c]const u8;
pub extern fn gtk_recent_info_get_description(info: ?*GtkRecentInfo) [*c]const u8;
pub extern fn gtk_recent_info_get_mime_type(info: ?*GtkRecentInfo) [*c]const u8;
pub extern fn gtk_recent_info_get_added(info: ?*GtkRecentInfo) ?*GDateTime;
pub extern fn gtk_recent_info_get_modified(info: ?*GtkRecentInfo) ?*GDateTime;
pub extern fn gtk_recent_info_get_visited(info: ?*GtkRecentInfo) ?*GDateTime;
pub extern fn gtk_recent_info_get_private_hint(info: ?*GtkRecentInfo) gboolean;
pub extern fn gtk_recent_info_get_application_info(info: ?*GtkRecentInfo, app_name: [*c]const u8, app_exec: [*c][*c]const u8, count: [*c]guint, stamp: [*c]?*GDateTime) gboolean;
pub extern fn gtk_recent_info_create_app_info(info: ?*GtkRecentInfo, app_name: [*c]const u8, @"error": [*c][*c]GError) ?*GAppInfo;
pub extern fn gtk_recent_info_get_applications(info: ?*GtkRecentInfo, length: [*c]gsize) [*c][*c]u8;
pub extern fn gtk_recent_info_last_application(info: ?*GtkRecentInfo) [*c]u8;
pub extern fn gtk_recent_info_has_application(info: ?*GtkRecentInfo, app_name: [*c]const u8) gboolean;
pub extern fn gtk_recent_info_get_groups(info: ?*GtkRecentInfo, length: [*c]gsize) [*c][*c]u8;
pub extern fn gtk_recent_info_has_group(info: ?*GtkRecentInfo, group_name: [*c]const u8) gboolean;
pub extern fn gtk_recent_info_get_gicon(info: ?*GtkRecentInfo) ?*GIcon;
pub extern fn gtk_recent_info_get_short_name(info: ?*GtkRecentInfo) [*c]u8;
pub extern fn gtk_recent_info_get_uri_display(info: ?*GtkRecentInfo) [*c]u8;
pub extern fn gtk_recent_info_get_age(info: ?*GtkRecentInfo) c_int;
pub extern fn gtk_recent_info_is_local(info: ?*GtkRecentInfo) gboolean;
pub extern fn gtk_recent_info_exists(info: ?*GtkRecentInfo) gboolean;
pub extern fn gtk_recent_info_match(info_a: ?*GtkRecentInfo, info_b: ?*GtkRecentInfo) gboolean;
pub extern fn _gtk_recent_manager_sync() void;
pub const GtkRecentManager_autoptr = [*c]GtkRecentManager;
pub const GtkRecentManager_listautoptr = [*c]GList;
pub const GtkRecentManager_slistautoptr = [*c]GSList;
pub const GtkRecentManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentManager(arg__ptr: [*c]GtkRecentManager) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkRecentManager(arg__ptr: [*c][*c]GtkRecentManager) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkRecentManager(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentManager(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentManager(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentManager(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkRecentInfo_autoptr = ?*GtkRecentInfo;
pub const GtkRecentInfo_listautoptr = [*c]GList;
pub const GtkRecentInfo_slistautoptr = [*c]GSList;
pub const GtkRecentInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentInfo(arg__ptr: ?*GtkRecentInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_recent_info_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkRecentInfo(arg__ptr: [*c]?*GtkRecentInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkRecentInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_recent_info_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_recent_info_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_recent_info_unref)))))));
    }
}
pub const struct__GtkSnapshotClass = opaque {};
pub const GtkSnapshotClass = struct__GtkSnapshotClass;
pub const GtkSnapshot_autoptr = ?*GtkSnapshot;
pub const GtkSnapshot_listautoptr = [*c]GList;
pub const GtkSnapshot_slistautoptr = [*c]GSList;
pub const GtkSnapshot_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSnapshot(arg__ptr: ?*GtkSnapshot) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSnapshot(arg__ptr: [*c]?*GtkSnapshot) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSnapshot(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSnapshot(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSnapshot(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSnapshot(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_snapshot_get_type() GType;
pub extern fn gtk_snapshot_new() ?*GtkSnapshot;
pub extern fn gtk_snapshot_free_to_node(snapshot: ?*GtkSnapshot) ?*GskRenderNode;
pub extern fn gtk_snapshot_free_to_paintable(snapshot: ?*GtkSnapshot, size: [*c]const graphene_size_t) ?*GdkPaintable;
pub extern fn gtk_snapshot_to_node(snapshot: ?*GtkSnapshot) ?*GskRenderNode;
pub extern fn gtk_snapshot_to_paintable(snapshot: ?*GtkSnapshot, size: [*c]const graphene_size_t) ?*GdkPaintable;
pub extern fn gtk_snapshot_push_debug(snapshot: ?*GtkSnapshot, message: [*c]const u8, ...) void;
pub extern fn gtk_snapshot_push_opacity(snapshot: ?*GtkSnapshot, opacity: f64) void;
pub extern fn gtk_snapshot_push_blur(snapshot: ?*GtkSnapshot, radius: f64) void;
pub extern fn gtk_snapshot_push_color_matrix(snapshot: ?*GtkSnapshot, color_matrix: [*c]const graphene_matrix_t, color_offset: [*c]const graphene_vec4_t) void;
pub extern fn gtk_snapshot_push_repeat(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t, child_bounds: [*c]const graphene_rect_t) void;
pub extern fn gtk_snapshot_push_clip(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t) void;
pub extern fn gtk_snapshot_push_rounded_clip(snapshot: ?*GtkSnapshot, bounds: [*c]const GskRoundedRect) void;
pub extern fn gtk_snapshot_push_shadow(snapshot: ?*GtkSnapshot, shadow: [*c]const GskShadow, n_shadows: gsize) void;
pub extern fn gtk_snapshot_push_blend(snapshot: ?*GtkSnapshot, blend_mode: GskBlendMode) void;
pub extern fn gtk_snapshot_push_mask(snapshot: ?*GtkSnapshot, mask_mode: GskMaskMode) void;
pub extern fn gtk_snapshot_push_cross_fade(snapshot: ?*GtkSnapshot, progress: f64) void;
pub extern fn gtk_snapshot_push_gl_shader(snapshot: ?*GtkSnapshot, shader: ?*GskGLShader, bounds: [*c]const graphene_rect_t, take_args: ?*GBytes) void;
pub extern fn gtk_snapshot_gl_shader_pop_texture(snapshot: ?*GtkSnapshot) void;
pub extern fn gtk_snapshot_pop(snapshot: ?*GtkSnapshot) void;
pub extern fn gtk_snapshot_save(snapshot: ?*GtkSnapshot) void;
pub extern fn gtk_snapshot_restore(snapshot: ?*GtkSnapshot) void;
pub extern fn gtk_snapshot_transform(snapshot: ?*GtkSnapshot, transform: ?*GskTransform) void;
pub extern fn gtk_snapshot_transform_matrix(snapshot: ?*GtkSnapshot, matrix: [*c]const graphene_matrix_t) void;
pub extern fn gtk_snapshot_translate(snapshot: ?*GtkSnapshot, point: [*c]const graphene_point_t) void;
pub extern fn gtk_snapshot_translate_3d(snapshot: ?*GtkSnapshot, point: [*c]const graphene_point3d_t) void;
pub extern fn gtk_snapshot_rotate(snapshot: ?*GtkSnapshot, angle: f32) void;
pub extern fn gtk_snapshot_rotate_3d(snapshot: ?*GtkSnapshot, angle: f32, axis: [*c]const graphene_vec3_t) void;
pub extern fn gtk_snapshot_scale(snapshot: ?*GtkSnapshot, factor_x: f32, factor_y: f32) void;
pub extern fn gtk_snapshot_scale_3d(snapshot: ?*GtkSnapshot, factor_x: f32, factor_y: f32, factor_z: f32) void;
pub extern fn gtk_snapshot_perspective(snapshot: ?*GtkSnapshot, depth: f32) void;
pub extern fn gtk_snapshot_append_node(snapshot: ?*GtkSnapshot, node: ?*GskRenderNode) void;
pub extern fn gtk_snapshot_append_cairo(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t) ?*cairo_t;
pub extern fn gtk_snapshot_append_texture(snapshot: ?*GtkSnapshot, texture: ?*GdkTexture, bounds: [*c]const graphene_rect_t) void;
pub extern fn gtk_snapshot_append_scaled_texture(snapshot: ?*GtkSnapshot, texture: ?*GdkTexture, filter: GskScalingFilter, bounds: [*c]const graphene_rect_t) void;
pub extern fn gtk_snapshot_append_color(snapshot: ?*GtkSnapshot, color: [*c]const GdkRGBA, bounds: [*c]const graphene_rect_t) void;
pub extern fn gtk_snapshot_append_linear_gradient(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t, start_point: [*c]const graphene_point_t, end_point: [*c]const graphene_point_t, stops: [*c]const GskColorStop, n_stops: gsize) void;
pub extern fn gtk_snapshot_append_repeating_linear_gradient(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t, start_point: [*c]const graphene_point_t, end_point: [*c]const graphene_point_t, stops: [*c]const GskColorStop, n_stops: gsize) void;
pub extern fn gtk_snapshot_append_radial_gradient(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t, center: [*c]const graphene_point_t, hradius: f32, vradius: f32, start: f32, end: f32, stops: [*c]const GskColorStop, n_stops: gsize) void;
pub extern fn gtk_snapshot_append_repeating_radial_gradient(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t, center: [*c]const graphene_point_t, hradius: f32, vradius: f32, start: f32, end: f32, stops: [*c]const GskColorStop, n_stops: gsize) void;
pub extern fn gtk_snapshot_append_conic_gradient(snapshot: ?*GtkSnapshot, bounds: [*c]const graphene_rect_t, center: [*c]const graphene_point_t, rotation: f32, stops: [*c]const GskColorStop, n_stops: gsize) void;
pub extern fn gtk_snapshot_append_border(snapshot: ?*GtkSnapshot, outline: [*c]const GskRoundedRect, border_width: [*c]const f32, border_color: [*c]const GdkRGBA) void;
pub extern fn gtk_snapshot_append_inset_shadow(snapshot: ?*GtkSnapshot, outline: [*c]const GskRoundedRect, color: [*c]const GdkRGBA, dx: f32, dy: f32, spread: f32, blur_radius: f32) void;
pub extern fn gtk_snapshot_append_outset_shadow(snapshot: ?*GtkSnapshot, outline: [*c]const GskRoundedRect, color: [*c]const GdkRGBA, dx: f32, dy: f32, spread: f32, blur_radius: f32) void;
pub extern fn gtk_snapshot_append_layout(snapshot: ?*GtkSnapshot, layout: ?*PangoLayout, color: [*c]const GdkRGBA) void;
pub extern fn gtk_render_check(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_option(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_arrow(context: [*c]GtkStyleContext, cr: ?*cairo_t, angle: f64, x: f64, y: f64, size: f64) void;
pub extern fn gtk_render_background(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_frame(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_expander(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_focus(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_layout(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, layout: ?*PangoLayout) void;
pub extern fn gtk_render_line(context: [*c]GtkStyleContext, cr: ?*cairo_t, x0: f64, y0: f64, x1: f64, y1: f64) void;
pub extern fn gtk_render_handle(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_activity(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_render_icon(context: [*c]GtkStyleContext, cr: ?*cairo_t, texture: ?*GdkTexture, x: f64, y: f64) void;
pub extern fn gtk_snapshot_render_background(snapshot: ?*GtkSnapshot, context: [*c]GtkStyleContext, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_snapshot_render_frame(snapshot: ?*GtkSnapshot, context: [*c]GtkStyleContext, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_snapshot_render_focus(snapshot: ?*GtkSnapshot, context: [*c]GtkStyleContext, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gtk_snapshot_render_layout(snapshot: ?*GtkSnapshot, context: [*c]GtkStyleContext, x: f64, y: f64, layout: ?*PangoLayout) void;
pub extern fn gtk_snapshot_render_insertion_cursor(snapshot: ?*GtkSnapshot, context: [*c]GtkStyleContext, x: f64, y: f64, layout: ?*PangoLayout, index: c_int, direction: PangoDirection) void;
pub const struct__GtkRevealer = opaque {};
pub const GtkRevealer = struct__GtkRevealer;
pub const GTK_REVEALER_TRANSITION_TYPE_NONE: c_int = 0;
pub const GTK_REVEALER_TRANSITION_TYPE_CROSSFADE: c_int = 1;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT: c_int = 2;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT: c_int = 3;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP: c_int = 4;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN: c_int = 5;
pub const GTK_REVEALER_TRANSITION_TYPE_SWING_RIGHT: c_int = 6;
pub const GTK_REVEALER_TRANSITION_TYPE_SWING_LEFT: c_int = 7;
pub const GTK_REVEALER_TRANSITION_TYPE_SWING_UP: c_int = 8;
pub const GTK_REVEALER_TRANSITION_TYPE_SWING_DOWN: c_int = 9;
pub const GtkRevealerTransitionType = c_uint;
pub extern fn gtk_revealer_get_type() GType;
pub extern fn gtk_revealer_new() [*c]GtkWidget;
pub extern fn gtk_revealer_get_reveal_child(revealer: ?*GtkRevealer) gboolean;
pub extern fn gtk_revealer_set_reveal_child(revealer: ?*GtkRevealer, reveal_child: gboolean) void;
pub extern fn gtk_revealer_get_child_revealed(revealer: ?*GtkRevealer) gboolean;
pub extern fn gtk_revealer_get_transition_duration(revealer: ?*GtkRevealer) guint;
pub extern fn gtk_revealer_set_transition_duration(revealer: ?*GtkRevealer, duration: guint) void;
pub extern fn gtk_revealer_set_transition_type(revealer: ?*GtkRevealer, transition: GtkRevealerTransitionType) void;
pub extern fn gtk_revealer_get_transition_type(revealer: ?*GtkRevealer) GtkRevealerTransitionType;
pub extern fn gtk_revealer_set_child(revealer: ?*GtkRevealer, child: [*c]GtkWidget) void;
pub extern fn gtk_revealer_get_child(revealer: ?*GtkRevealer) [*c]GtkWidget;
pub const GtkRevealer_autoptr = ?*GtkRevealer;
pub const GtkRevealer_listautoptr = [*c]GList;
pub const GtkRevealer_slistautoptr = [*c]GSList;
pub const GtkRevealer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRevealer(arg__ptr: ?*GtkRevealer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkRevealer(arg__ptr: [*c]?*GtkRevealer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkRevealer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkRevealer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkRevealer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkRevealer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_root_get_type() GType;
pub const struct__GtkRootInterface = opaque {};
pub const GtkRootInterface = struct__GtkRootInterface;
pub const GtkRoot_autoptr = ?*GtkRoot;
pub const GtkRoot_listautoptr = [*c]GList;
pub const GtkRoot_slistautoptr = [*c]GSList;
pub const GtkRoot_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRoot(arg__ptr: ?*GtkRoot) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkRoot(arg__ptr: [*c]?*GtkRoot) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkRoot(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkRoot(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkRoot(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkRoot(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub fn GTK_ROOT(arg_ptr: gpointer) callconv(.C) ?*GtkRoot {
    var ptr = arg_ptr;
    return @as(?*GtkRoot, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_root_get_type())))));
}
pub fn GTK_IS_ROOT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_root_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_ROOT_GET_IFACE(arg_ptr: gpointer) callconv(.C) ?*GtkRootInterface {
    var ptr = arg_ptr;
    return @as(?*GtkRootInterface, @ptrCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_root_get_type())));
}
pub extern fn gtk_root_get_display(self: ?*GtkRoot) ?*GdkDisplay;
pub extern fn gtk_root_set_focus(self: ?*GtkRoot, focus: [*c]GtkWidget) void;
pub extern fn gtk_root_get_focus(self: ?*GtkRoot) [*c]GtkWidget;
pub const struct__GtkScale = extern struct {
    parent_instance: GtkRange,
};
pub const GtkScale = struct__GtkScale;
pub const struct__GtkScaleClass = extern struct {
    parent_class: GtkRangeClass,
    get_layout_offsets: ?*const fn ([*c]GtkScale, [*c]c_int, [*c]c_int) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkScaleClass = struct__GtkScaleClass;
pub const GtkScaleFormatValueFunc = ?*const fn ([*c]GtkScale, f64, gpointer) callconv(.C) [*c]u8;
pub extern fn gtk_scale_get_type() GType;
pub extern fn gtk_scale_new(orientation: GtkOrientation, adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_scale_new_with_range(orientation: GtkOrientation, min: f64, max: f64, step: f64) [*c]GtkWidget;
pub extern fn gtk_scale_set_digits(scale: [*c]GtkScale, digits: c_int) void;
pub extern fn gtk_scale_get_digits(scale: [*c]GtkScale) c_int;
pub extern fn gtk_scale_set_draw_value(scale: [*c]GtkScale, draw_value: gboolean) void;
pub extern fn gtk_scale_get_draw_value(scale: [*c]GtkScale) gboolean;
pub extern fn gtk_scale_set_has_origin(scale: [*c]GtkScale, has_origin: gboolean) void;
pub extern fn gtk_scale_get_has_origin(scale: [*c]GtkScale) gboolean;
pub extern fn gtk_scale_set_value_pos(scale: [*c]GtkScale, pos: GtkPositionType) void;
pub extern fn gtk_scale_get_value_pos(scale: [*c]GtkScale) GtkPositionType;
pub extern fn gtk_scale_get_layout(scale: [*c]GtkScale) ?*PangoLayout;
pub extern fn gtk_scale_get_layout_offsets(scale: [*c]GtkScale, x: [*c]c_int, y: [*c]c_int) void;
pub extern fn gtk_scale_add_mark(scale: [*c]GtkScale, value: f64, position: GtkPositionType, markup: [*c]const u8) void;
pub extern fn gtk_scale_clear_marks(scale: [*c]GtkScale) void;
pub extern fn gtk_scale_set_format_value_func(scale: [*c]GtkScale, func: GtkScaleFormatValueFunc, user_data: gpointer, destroy_notify: GDestroyNotify) void;
pub const GtkScale_autoptr = [*c]GtkScale;
pub const GtkScale_listautoptr = [*c]GList;
pub const GtkScale_slistautoptr = [*c]GSList;
pub const GtkScale_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScale(arg__ptr: [*c]GtkScale) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkScale(arg__ptr: [*c][*c]GtkScale) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkScale(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkScale(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkScale(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkScale(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkScaleButton = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkScaleButton = struct__GtkScaleButton;
pub const struct__GtkScaleButtonClass = extern struct {
    parent_class: GtkWidgetClass,
    value_changed: ?*const fn ([*c]GtkScaleButton, f64) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkScaleButtonClass = struct__GtkScaleButtonClass;
pub extern fn gtk_scale_button_get_type() GType;
pub extern fn gtk_scale_button_new(min: f64, max: f64, step: f64, icons: [*c][*c]const u8) [*c]GtkWidget;
pub extern fn gtk_scale_button_set_icons(button: [*c]GtkScaleButton, icons: [*c][*c]const u8) void;
pub extern fn gtk_scale_button_get_value(button: [*c]GtkScaleButton) f64;
pub extern fn gtk_scale_button_set_value(button: [*c]GtkScaleButton, value: f64) void;
pub extern fn gtk_scale_button_get_adjustment(button: [*c]GtkScaleButton) [*c]GtkAdjustment;
pub extern fn gtk_scale_button_set_adjustment(button: [*c]GtkScaleButton, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scale_button_get_plus_button(button: [*c]GtkScaleButton) [*c]GtkWidget;
pub extern fn gtk_scale_button_get_minus_button(button: [*c]GtkScaleButton) [*c]GtkWidget;
pub extern fn gtk_scale_button_get_popup(button: [*c]GtkScaleButton) [*c]GtkWidget;
pub extern fn gtk_scale_button_get_active(button: [*c]GtkScaleButton) gboolean;
pub const GtkScaleButton_autoptr = [*c]GtkScaleButton;
pub const GtkScaleButton_listautoptr = [*c]GList;
pub const GtkScaleButton_slistautoptr = [*c]GSList;
pub const GtkScaleButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScaleButton(arg__ptr: [*c]GtkScaleButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkScaleButton(arg__ptr: [*c][*c]GtkScaleButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkScaleButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkScaleButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkScaleButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkScaleButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkScrollable = opaque {};
pub const GtkScrollable = struct__GtkScrollable;
pub const struct__GtkScrollableInterface = extern struct {
    base_iface: GTypeInterface,
    get_border: ?*const fn (?*GtkScrollable, [*c]GtkBorder) callconv(.C) gboolean,
};
pub const GtkScrollableInterface = struct__GtkScrollableInterface;
pub extern fn gtk_scrollable_get_type() GType;
pub extern fn gtk_scrollable_get_hadjustment(scrollable: ?*GtkScrollable) [*c]GtkAdjustment;
pub extern fn gtk_scrollable_set_hadjustment(scrollable: ?*GtkScrollable, hadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrollable_get_vadjustment(scrollable: ?*GtkScrollable) [*c]GtkAdjustment;
pub extern fn gtk_scrollable_set_vadjustment(scrollable: ?*GtkScrollable, vadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrollable_get_hscroll_policy(scrollable: ?*GtkScrollable) GtkScrollablePolicy;
pub extern fn gtk_scrollable_set_hscroll_policy(scrollable: ?*GtkScrollable, policy: GtkScrollablePolicy) void;
pub extern fn gtk_scrollable_get_vscroll_policy(scrollable: ?*GtkScrollable) GtkScrollablePolicy;
pub extern fn gtk_scrollable_set_vscroll_policy(scrollable: ?*GtkScrollable, policy: GtkScrollablePolicy) void;
pub extern fn gtk_scrollable_get_border(scrollable: ?*GtkScrollable, border: [*c]GtkBorder) gboolean;
pub const GtkScrollable_autoptr = ?*GtkScrollable;
pub const GtkScrollable_listautoptr = [*c]GList;
pub const GtkScrollable_slistautoptr = [*c]GSList;
pub const GtkScrollable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrollable(arg__ptr: ?*GtkScrollable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkScrollable(arg__ptr: [*c]?*GtkScrollable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkScrollable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkScrollable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkScrollable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkScrollable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkScrollbar = opaque {};
pub const GtkScrollbar = struct__GtkScrollbar;
pub extern fn gtk_scrollbar_get_type() GType;
pub extern fn gtk_scrollbar_new(orientation: GtkOrientation, adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_scrollbar_set_adjustment(self: ?*GtkScrollbar, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrollbar_get_adjustment(self: ?*GtkScrollbar) [*c]GtkAdjustment;
pub const GtkScrollbar_autoptr = ?*GtkScrollbar;
pub const GtkScrollbar_listautoptr = [*c]GList;
pub const GtkScrollbar_slistautoptr = [*c]GSList;
pub const GtkScrollbar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrollbar(arg__ptr: ?*GtkScrollbar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkScrollbar(arg__ptr: [*c]?*GtkScrollbar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkScrollbar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkScrollbar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkScrollbar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkScrollbar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_scroll_info_get_type() GType;
pub extern fn gtk_scroll_info_new() ?*GtkScrollInfo;
pub extern fn gtk_scroll_info_ref(self: ?*GtkScrollInfo) ?*GtkScrollInfo;
pub extern fn gtk_scroll_info_unref(self: ?*GtkScrollInfo) void;
pub extern fn gtk_scroll_info_set_enable_horizontal(self: ?*GtkScrollInfo, horizontal: gboolean) void;
pub extern fn gtk_scroll_info_get_enable_horizontal(self: ?*GtkScrollInfo) gboolean;
pub extern fn gtk_scroll_info_set_enable_vertical(self: ?*GtkScrollInfo, vertical: gboolean) void;
pub extern fn gtk_scroll_info_get_enable_vertical(self: ?*GtkScrollInfo) gboolean;
pub const GtkScrollInfo_autoptr = ?*GtkScrollInfo;
pub const GtkScrollInfo_listautoptr = [*c]GList;
pub const GtkScrollInfo_slistautoptr = [*c]GSList;
pub const GtkScrollInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrollInfo(arg__ptr: ?*GtkScrollInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_scroll_info_unref(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkScrollInfo(arg__ptr: [*c]?*GtkScrollInfo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkScrollInfo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkScrollInfo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_scroll_info_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkScrollInfo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_scroll_info_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkScrollInfo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_scroll_info_unref)))))));
    }
}
pub const struct__GtkScrolledWindow = opaque {};
pub const GtkScrolledWindow = struct__GtkScrolledWindow;
pub const GTK_CORNER_TOP_LEFT: c_int = 0;
pub const GTK_CORNER_BOTTOM_LEFT: c_int = 1;
pub const GTK_CORNER_TOP_RIGHT: c_int = 2;
pub const GTK_CORNER_BOTTOM_RIGHT: c_int = 3;
pub const GtkCornerType = c_uint;
pub const GTK_POLICY_ALWAYS: c_int = 0;
pub const GTK_POLICY_AUTOMATIC: c_int = 1;
pub const GTK_POLICY_NEVER: c_int = 2;
pub const GTK_POLICY_EXTERNAL: c_int = 3;
pub const GtkPolicyType = c_uint;
pub extern fn gtk_scrolled_window_get_type() GType;
pub extern fn gtk_scrolled_window_new() [*c]GtkWidget;
pub extern fn gtk_scrolled_window_set_hadjustment(scrolled_window: ?*GtkScrolledWindow, hadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrolled_window_set_vadjustment(scrolled_window: ?*GtkScrolledWindow, vadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrolled_window_get_hadjustment(scrolled_window: ?*GtkScrolledWindow) [*c]GtkAdjustment;
pub extern fn gtk_scrolled_window_get_vadjustment(scrolled_window: ?*GtkScrolledWindow) [*c]GtkAdjustment;
pub extern fn gtk_scrolled_window_get_hscrollbar(scrolled_window: ?*GtkScrolledWindow) [*c]GtkWidget;
pub extern fn gtk_scrolled_window_get_vscrollbar(scrolled_window: ?*GtkScrolledWindow) [*c]GtkWidget;
pub extern fn gtk_scrolled_window_set_policy(scrolled_window: ?*GtkScrolledWindow, hscrollbar_policy: GtkPolicyType, vscrollbar_policy: GtkPolicyType) void;
pub extern fn gtk_scrolled_window_get_policy(scrolled_window: ?*GtkScrolledWindow, hscrollbar_policy: [*c]GtkPolicyType, vscrollbar_policy: [*c]GtkPolicyType) void;
pub extern fn gtk_scrolled_window_set_placement(scrolled_window: ?*GtkScrolledWindow, window_placement: GtkCornerType) void;
pub extern fn gtk_scrolled_window_unset_placement(scrolled_window: ?*GtkScrolledWindow) void;
pub extern fn gtk_scrolled_window_get_placement(scrolled_window: ?*GtkScrolledWindow) GtkCornerType;
pub extern fn gtk_scrolled_window_set_has_frame(scrolled_window: ?*GtkScrolledWindow, has_frame: gboolean) void;
pub extern fn gtk_scrolled_window_get_has_frame(scrolled_window: ?*GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_get_min_content_width(scrolled_window: ?*GtkScrolledWindow) c_int;
pub extern fn gtk_scrolled_window_set_min_content_width(scrolled_window: ?*GtkScrolledWindow, width: c_int) void;
pub extern fn gtk_scrolled_window_get_min_content_height(scrolled_window: ?*GtkScrolledWindow) c_int;
pub extern fn gtk_scrolled_window_set_min_content_height(scrolled_window: ?*GtkScrolledWindow, height: c_int) void;
pub extern fn gtk_scrolled_window_set_kinetic_scrolling(scrolled_window: ?*GtkScrolledWindow, kinetic_scrolling: gboolean) void;
pub extern fn gtk_scrolled_window_get_kinetic_scrolling(scrolled_window: ?*GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_overlay_scrolling(scrolled_window: ?*GtkScrolledWindow, overlay_scrolling: gboolean) void;
pub extern fn gtk_scrolled_window_get_overlay_scrolling(scrolled_window: ?*GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_max_content_width(scrolled_window: ?*GtkScrolledWindow, width: c_int) void;
pub extern fn gtk_scrolled_window_get_max_content_width(scrolled_window: ?*GtkScrolledWindow) c_int;
pub extern fn gtk_scrolled_window_set_max_content_height(scrolled_window: ?*GtkScrolledWindow, height: c_int) void;
pub extern fn gtk_scrolled_window_get_max_content_height(scrolled_window: ?*GtkScrolledWindow) c_int;
pub extern fn gtk_scrolled_window_set_propagate_natural_width(scrolled_window: ?*GtkScrolledWindow, propagate: gboolean) void;
pub extern fn gtk_scrolled_window_get_propagate_natural_width(scrolled_window: ?*GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_propagate_natural_height(scrolled_window: ?*GtkScrolledWindow, propagate: gboolean) void;
pub extern fn gtk_scrolled_window_get_propagate_natural_height(scrolled_window: ?*GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_child(scrolled_window: ?*GtkScrolledWindow, child: [*c]GtkWidget) void;
pub extern fn gtk_scrolled_window_get_child(scrolled_window: ?*GtkScrolledWindow) [*c]GtkWidget;
pub const GtkScrolledWindow_autoptr = ?*GtkScrolledWindow;
pub const GtkScrolledWindow_listautoptr = [*c]GList;
pub const GtkScrolledWindow_slistautoptr = [*c]GSList;
pub const GtkScrolledWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrolledWindow(arg__ptr: ?*GtkScrolledWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkScrolledWindow(arg__ptr: [*c]?*GtkScrolledWindow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkScrolledWindow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkScrolledWindow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkScrolledWindow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkScrolledWindow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkSearchBar = opaque {};
pub const GtkSearchBar = struct__GtkSearchBar;
pub extern fn gtk_search_bar_get_type() GType;
pub extern fn gtk_search_bar_new() [*c]GtkWidget;
pub extern fn gtk_search_bar_connect_entry(bar: ?*GtkSearchBar, entry: ?*GtkEditable) void;
pub extern fn gtk_search_bar_get_search_mode(bar: ?*GtkSearchBar) gboolean;
pub extern fn gtk_search_bar_set_search_mode(bar: ?*GtkSearchBar, search_mode: gboolean) void;
pub extern fn gtk_search_bar_get_show_close_button(bar: ?*GtkSearchBar) gboolean;
pub extern fn gtk_search_bar_set_show_close_button(bar: ?*GtkSearchBar, visible: gboolean) void;
pub extern fn gtk_search_bar_set_key_capture_widget(bar: ?*GtkSearchBar, widget: [*c]GtkWidget) void;
pub extern fn gtk_search_bar_get_key_capture_widget(bar: ?*GtkSearchBar) [*c]GtkWidget;
pub extern fn gtk_search_bar_set_child(bar: ?*GtkSearchBar, child: [*c]GtkWidget) void;
pub extern fn gtk_search_bar_get_child(bar: ?*GtkSearchBar) [*c]GtkWidget;
pub const GtkSearchBar_autoptr = ?*GtkSearchBar;
pub const GtkSearchBar_listautoptr = [*c]GList;
pub const GtkSearchBar_slistautoptr = [*c]GSList;
pub const GtkSearchBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSearchBar(arg__ptr: ?*GtkSearchBar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSearchBar(arg__ptr: [*c]?*GtkSearchBar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSearchBar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSearchBar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSearchBar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSearchBar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkSearchEntry = opaque {};
pub const GtkSearchEntry = struct__GtkSearchEntry;
pub extern fn gtk_search_entry_get_type() GType;
pub extern fn gtk_search_entry_new() [*c]GtkWidget;
pub extern fn gtk_search_entry_set_key_capture_widget(entry: ?*GtkSearchEntry, widget: [*c]GtkWidget) void;
pub extern fn gtk_search_entry_get_key_capture_widget(entry: ?*GtkSearchEntry) [*c]GtkWidget;
pub extern fn gtk_search_entry_set_search_delay(entry: ?*GtkSearchEntry, delay: guint) void;
pub extern fn gtk_search_entry_get_search_delay(entry: ?*GtkSearchEntry) guint;
pub extern fn gtk_search_entry_set_placeholder_text(entry: ?*GtkSearchEntry, text: [*c]const u8) void;
pub extern fn gtk_search_entry_get_placeholder_text(entry: ?*GtkSearchEntry) [*c]const u8;
pub const GtkSearchEntry_autoptr = ?*GtkSearchEntry;
pub const GtkSearchEntry_listautoptr = [*c]GList;
pub const GtkSearchEntry_slistautoptr = [*c]GSList;
pub const GtkSearchEntry_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSearchEntry(arg__ptr: ?*GtkSearchEntry) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSearchEntry(arg__ptr: [*c]?*GtkSearchEntry) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSearchEntry(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSearchEntry(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSearchEntry(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSearchEntry(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_section_model_get_type() GType;
pub const struct__GtkSectionModel = opaque {};
pub const GtkSectionModel = struct__GtkSectionModel;
pub const struct__GtkSectionModelInterface = extern struct {
    g_iface: GTypeInterface,
    get_section: ?*const fn (?*GtkSectionModel, guint, [*c]guint, [*c]guint) callconv(.C) void,
};
pub const GtkSectionModelInterface = struct__GtkSectionModelInterface;
pub const GtkSectionModel_autoptr = ?*GtkSectionModel;
pub const GtkSectionModel_listautoptr = [*c]GList;
pub const GtkSectionModel_slistautoptr = [*c]GSList;
pub const GtkSectionModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSectionModel(arg__ptr: ?*GtkSectionModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GListModel(@as(?*GListModel, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSectionModel(arg__ptr: [*c]?*GtkSectionModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSectionModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSectionModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GListModel)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSectionModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GListModel)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSectionModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GListModel)))))));
    }
}
pub fn GTK_SECTION_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkSectionModel {
    var ptr = arg_ptr;
    return @as(?*GtkSectionModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_section_model_get_type())))));
}
pub fn GTK_IS_SECTION_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_section_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SECTION_MODEL_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkSectionModelInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkSectionModelInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_section_model_get_type()))));
}
pub extern fn gtk_section_model_get_section(self: ?*GtkSectionModel, position: guint, out_start: [*c]guint, out_end: [*c]guint) void;
pub extern fn gtk_section_model_sections_changed(self: ?*GtkSectionModel, position: guint, n_items: guint) void;
pub extern fn gtk_selection_filter_model_get_type() GType;
pub const struct__GtkSelectionFilterModel = opaque {};
pub const GtkSelectionFilterModel = struct__GtkSelectionFilterModel;
pub const GtkSelectionFilterModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkSelectionFilterModel_autoptr = ?*GtkSelectionFilterModel;
pub const GtkSelectionFilterModel_listautoptr = [*c]GList;
pub const GtkSelectionFilterModel_slistautoptr = [*c]GSList;
pub const GtkSelectionFilterModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSelectionFilterModel(arg__ptr: ?*GtkSelectionFilterModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkSelectionFilterModel(arg__ptr: [*c]?*GtkSelectionFilterModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSelectionFilterModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSelectionFilterModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSelectionFilterModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSelectionFilterModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkSelectionFilterModelClass_autoptr = [*c]GtkSelectionFilterModelClass;
pub const GtkSelectionFilterModelClass_listautoptr = [*c]GList;
pub const GtkSelectionFilterModelClass_slistautoptr = [*c]GSList;
pub const GtkSelectionFilterModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSelectionFilterModelClass(arg__ptr: [*c]GtkSelectionFilterModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSelectionFilterModelClass(arg__ptr: [*c][*c]GtkSelectionFilterModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSelectionFilterModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSelectionFilterModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSelectionFilterModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSelectionFilterModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SELECTION_FILTER_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkSelectionFilterModel {
    var ptr = arg_ptr;
    return @as(?*GtkSelectionFilterModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_selection_filter_model_get_type())))));
}
pub fn GTK_IS_SELECTION_FILTER_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_selection_filter_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_selection_filter_model_new(model: ?*GtkSelectionModel) ?*GtkSelectionFilterModel;
pub extern fn gtk_selection_filter_model_set_model(self: ?*GtkSelectionFilterModel, model: ?*GtkSelectionModel) void;
pub extern fn gtk_selection_filter_model_get_model(self: ?*GtkSelectionFilterModel) ?*GtkSelectionModel;
pub const struct__GtkSeparator = opaque {};
pub const GtkSeparator = struct__GtkSeparator;
pub extern fn gtk_separator_get_type() GType;
pub extern fn gtk_separator_new(orientation: GtkOrientation) [*c]GtkWidget;
pub const GtkSeparator_autoptr = ?*GtkSeparator;
pub const GtkSeparator_listautoptr = [*c]GList;
pub const GtkSeparator_slistautoptr = [*c]GSList;
pub const GtkSeparator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSeparator(arg__ptr: ?*GtkSeparator) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSeparator(arg__ptr: [*c]?*GtkSeparator) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSeparator(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSeparator(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSeparator(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSeparator(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_settings_get_type() GType;
pub extern fn gtk_settings_get_default() ?*GtkSettings;
pub extern fn gtk_settings_get_for_display(display: ?*GdkDisplay) ?*GtkSettings;
pub extern fn gtk_settings_reset_property(settings: ?*GtkSettings, name: [*c]const u8) void;
pub const GtkSettings_autoptr = ?*GtkSettings;
pub const GtkSettings_listautoptr = [*c]GList;
pub const GtkSettings_slistautoptr = [*c]GSList;
pub const GtkSettings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSettings(arg__ptr: ?*GtkSettings) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSettings(arg__ptr: [*c]?*GtkSettings) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSettings(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSettings(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSettings(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSettings(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkShortcutController = opaque {};
pub const GtkShortcutController = struct__GtkShortcutController;
pub const struct__GtkShortcutControllerClass = opaque {};
pub const GtkShortcutControllerClass = struct__GtkShortcutControllerClass;
pub extern fn gtk_shortcut_controller_get_type() GType;
pub extern fn gtk_shortcut_controller_new() ?*GtkEventController;
pub extern fn gtk_shortcut_controller_new_for_model(model: ?*GListModel) ?*GtkEventController;
pub extern fn gtk_shortcut_controller_set_mnemonics_modifiers(self: ?*GtkShortcutController, modifiers: GdkModifierType) void;
pub extern fn gtk_shortcut_controller_get_mnemonics_modifiers(self: ?*GtkShortcutController) GdkModifierType;
pub extern fn gtk_shortcut_controller_set_scope(self: ?*GtkShortcutController, scope: GtkShortcutScope) void;
pub extern fn gtk_shortcut_controller_get_scope(self: ?*GtkShortcutController) GtkShortcutScope;
pub extern fn gtk_shortcut_controller_add_shortcut(self: ?*GtkShortcutController, shortcut: ?*GtkShortcut) void;
pub extern fn gtk_shortcut_controller_remove_shortcut(self: ?*GtkShortcutController, shortcut: ?*GtkShortcut) void;
pub const struct__GtkShortcutLabel = opaque {};
pub const GtkShortcutLabel = struct__GtkShortcutLabel;
pub const struct__GtkShortcutLabelClass = opaque {};
pub const GtkShortcutLabelClass = struct__GtkShortcutLabelClass;
pub extern fn gtk_shortcut_label_get_type() GType;
pub extern fn gtk_shortcut_label_new(accelerator: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_shortcut_label_get_accelerator(self: ?*GtkShortcutLabel) [*c]const u8;
pub extern fn gtk_shortcut_label_set_accelerator(self: ?*GtkShortcutLabel, accelerator: [*c]const u8) void;
pub extern fn gtk_shortcut_label_get_disabled_text(self: ?*GtkShortcutLabel) [*c]const u8;
pub extern fn gtk_shortcut_label_set_disabled_text(self: ?*GtkShortcutLabel, disabled_text: [*c]const u8) void;
pub extern fn gtk_shortcut_manager_get_type() GType;
pub const struct__GtkShortcutManager = opaque {};
pub const GtkShortcutManager = struct__GtkShortcutManager;
pub const struct__GtkShortcutManagerInterface = extern struct {
    g_iface: GTypeInterface,
    add_controller: ?*const fn (?*GtkShortcutManager, ?*GtkShortcutController) callconv(.C) void,
    remove_controller: ?*const fn (?*GtkShortcutManager, ?*GtkShortcutController) callconv(.C) void,
};
pub const GtkShortcutManagerInterface = struct__GtkShortcutManagerInterface;
pub const GtkShortcutManager_autoptr = ?*GtkShortcutManager;
pub const GtkShortcutManager_listautoptr = [*c]GList;
pub const GtkShortcutManager_slistautoptr = [*c]GSList;
pub const GtkShortcutManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutManager(arg__ptr: ?*GtkShortcutManager) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutManager(arg__ptr: [*c]?*GtkShortcutManager) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutManager(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutManager(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutManager(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutManager(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub fn GTK_SHORTCUT_MANAGER(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutManager {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutManager, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_shortcut_manager_get_type())))));
}
pub fn GTK_IS_SHORTCUT_MANAGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_shortcut_manager_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SHORTCUT_MANAGER_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkShortcutManagerInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkShortcutManagerInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_shortcut_manager_get_type()))));
}
pub const struct__GtkShortcutsGroup = opaque {};
pub const GtkShortcutsGroup = struct__GtkShortcutsGroup;
pub const struct__GtkShortcutsGroupClass = opaque {};
pub const GtkShortcutsGroupClass = struct__GtkShortcutsGroupClass;
pub extern fn gtk_shortcuts_group_get_type() GType;
pub const struct__GtkShortcutsSection = opaque {};
pub const GtkShortcutsSection = struct__GtkShortcutsSection;
pub const struct__GtkShortcutsSectionClass = opaque {};
pub const GtkShortcutsSectionClass = struct__GtkShortcutsSectionClass;
pub extern fn gtk_shortcuts_section_get_type() GType;
pub const struct__GtkShortcutsShortcut = opaque {};
pub const GtkShortcutsShortcut = struct__GtkShortcutsShortcut;
pub const struct__GtkShortcutsShortcutClass = opaque {};
pub const GtkShortcutsShortcutClass = struct__GtkShortcutsShortcutClass;
pub const GTK_SHORTCUT_ACCELERATOR: c_int = 0;
pub const GTK_SHORTCUT_GESTURE_PINCH: c_int = 1;
pub const GTK_SHORTCUT_GESTURE_STRETCH: c_int = 2;
pub const GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE: c_int = 3;
pub const GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE: c_int = 4;
pub const GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT: c_int = 5;
pub const GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT: c_int = 6;
pub const GTK_SHORTCUT_GESTURE: c_int = 7;
pub const GTK_SHORTCUT_GESTURE_SWIPE_LEFT: c_int = 8;
pub const GTK_SHORTCUT_GESTURE_SWIPE_RIGHT: c_int = 9;
pub const GtkShortcutType = c_uint;
pub extern fn gtk_shortcuts_shortcut_get_type() GType;
pub extern fn gtk_shortcut_trigger_get_type() GType;
pub const struct__GtkShortcutTriggerClass = opaque {};
pub const GtkShortcutTriggerClass = struct__GtkShortcutTriggerClass;
pub const GtkShortcutTrigger_autoptr = ?*GtkShortcutTrigger;
pub const GtkShortcutTrigger_listautoptr = [*c]GList;
pub const GtkShortcutTrigger_slistautoptr = [*c]GSList;
pub const GtkShortcutTrigger_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutTrigger(arg__ptr: ?*GtkShortcutTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutTrigger(arg__ptr: [*c]?*GtkShortcutTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutTrigger(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutTrigger(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutTrigger(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutTrigger(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkShortcutTriggerClass_autoptr = ?*GtkShortcutTriggerClass;
pub const GtkShortcutTriggerClass_listautoptr = [*c]GList;
pub const GtkShortcutTriggerClass_slistautoptr = [*c]GSList;
pub const GtkShortcutTriggerClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutTriggerClass(arg__ptr: ?*GtkShortcutTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkShortcutTriggerClass(arg__ptr: [*c]?*GtkShortcutTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkShortcutTriggerClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutTriggerClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutTriggerClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutTriggerClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SHORTCUT_TRIGGER(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutTrigger {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutTrigger, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_shortcut_trigger_get_type())))));
}
pub fn GTK_SHORTCUT_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutTriggerClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_shortcut_trigger_get_type())))));
}
pub fn GTK_IS_SHORTCUT_TRIGGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_shortcut_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_SHORTCUT_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_shortcut_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SHORTCUT_TRIGGER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkShortcutTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkShortcutTriggerClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_shortcut_trigger_parse_string(string: [*c]const u8) ?*GtkShortcutTrigger;
pub extern fn gtk_shortcut_trigger_to_string(self: ?*GtkShortcutTrigger) [*c]u8;
pub extern fn gtk_shortcut_trigger_print(self: ?*GtkShortcutTrigger, string: [*c]GString) void;
pub extern fn gtk_shortcut_trigger_to_label(self: ?*GtkShortcutTrigger, display: ?*GdkDisplay) [*c]u8;
pub extern fn gtk_shortcut_trigger_print_label(self: ?*GtkShortcutTrigger, display: ?*GdkDisplay, string: [*c]GString) gboolean;
pub extern fn gtk_shortcut_trigger_hash(trigger: gconstpointer) guint;
pub extern fn gtk_shortcut_trigger_equal(trigger1: gconstpointer, trigger2: gconstpointer) gboolean;
pub extern fn gtk_shortcut_trigger_compare(trigger1: gconstpointer, trigger2: gconstpointer) c_int;
pub extern fn gtk_shortcut_trigger_trigger(self: ?*GtkShortcutTrigger, event: ?*GdkEvent, enable_mnemonics: gboolean) GdkKeyMatch;
pub extern fn gtk_never_trigger_get_type() GType;
pub const struct__GtkNeverTrigger = opaque {};
pub const GtkNeverTrigger = struct__GtkNeverTrigger;
pub const struct__GtkNeverTriggerClass = opaque {};
pub const GtkNeverTriggerClass = struct__GtkNeverTriggerClass;
pub const GtkNeverTrigger_autoptr = ?*GtkNeverTrigger;
pub const GtkNeverTrigger_listautoptr = [*c]GList;
pub const GtkNeverTrigger_slistautoptr = [*c]GSList;
pub const GtkNeverTrigger_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNeverTrigger(arg__ptr: ?*GtkNeverTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutTrigger(@as(?*GtkShortcutTrigger, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNeverTrigger(arg__ptr: [*c]?*GtkNeverTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNeverTrigger(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNeverTrigger(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNeverTrigger(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNeverTrigger(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
    }
}
pub const GtkNeverTriggerClass_autoptr = ?*GtkNeverTriggerClass;
pub const GtkNeverTriggerClass_listautoptr = [*c]GList;
pub const GtkNeverTriggerClass_slistautoptr = [*c]GSList;
pub const GtkNeverTriggerClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNeverTriggerClass(arg__ptr: ?*GtkNeverTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkNeverTriggerClass(arg__ptr: [*c]?*GtkNeverTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkNeverTriggerClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkNeverTriggerClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkNeverTriggerClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkNeverTriggerClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_NEVER_TRIGGER(arg_ptr: gpointer) callconv(.C) ?*GtkNeverTrigger {
    var ptr = arg_ptr;
    return @as(?*GtkNeverTrigger, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_never_trigger_get_type())))));
}
pub fn GTK_NEVER_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkNeverTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkNeverTriggerClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_never_trigger_get_type())))));
}
pub fn GTK_IS_NEVER_TRIGGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_never_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_NEVER_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_never_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_NEVER_TRIGGER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkNeverTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkNeverTriggerClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_never_trigger_get() ?*GtkShortcutTrigger;
pub extern fn gtk_keyval_trigger_get_type() GType;
pub const struct__GtkKeyvalTrigger = opaque {};
pub const GtkKeyvalTrigger = struct__GtkKeyvalTrigger;
pub const struct__GtkKeyvalTriggerClass = opaque {};
pub const GtkKeyvalTriggerClass = struct__GtkKeyvalTriggerClass;
pub const GtkKeyvalTrigger_autoptr = ?*GtkKeyvalTrigger;
pub const GtkKeyvalTrigger_listautoptr = [*c]GList;
pub const GtkKeyvalTrigger_slistautoptr = [*c]GSList;
pub const GtkKeyvalTrigger_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkKeyvalTrigger(arg__ptr: ?*GtkKeyvalTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutTrigger(@as(?*GtkShortcutTrigger, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkKeyvalTrigger(arg__ptr: [*c]?*GtkKeyvalTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkKeyvalTrigger(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkKeyvalTrigger(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_slistautoptr_cleanup_GtkKeyvalTrigger(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_queueautoptr_cleanup_GtkKeyvalTrigger(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
    }
}
pub const GtkKeyvalTriggerClass_autoptr = ?*GtkKeyvalTriggerClass;
pub const GtkKeyvalTriggerClass_listautoptr = [*c]GList;
pub const GtkKeyvalTriggerClass_slistautoptr = [*c]GSList;
pub const GtkKeyvalTriggerClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkKeyvalTriggerClass(arg__ptr: ?*GtkKeyvalTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkKeyvalTriggerClass(arg__ptr: [*c]?*GtkKeyvalTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkKeyvalTriggerClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkKeyvalTriggerClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkKeyvalTriggerClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkKeyvalTriggerClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_KEYVAL_TRIGGER(arg_ptr: gpointer) callconv(.C) ?*GtkKeyvalTrigger {
    var ptr = arg_ptr;
    return @as(?*GtkKeyvalTrigger, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_keyval_trigger_get_type())))));
}
pub fn GTK_KEYVAL_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkKeyvalTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkKeyvalTriggerClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_keyval_trigger_get_type())))));
}
pub fn GTK_IS_KEYVAL_TRIGGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_keyval_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_KEYVAL_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_keyval_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_KEYVAL_TRIGGER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkKeyvalTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkKeyvalTriggerClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_keyval_trigger_new(keyval: guint, modifiers: GdkModifierType) ?*GtkShortcutTrigger;
pub extern fn gtk_keyval_trigger_get_modifiers(self: ?*GtkKeyvalTrigger) GdkModifierType;
pub extern fn gtk_keyval_trigger_get_keyval(self: ?*GtkKeyvalTrigger) guint;
pub extern fn gtk_mnemonic_trigger_get_type() GType;
pub const struct__GtkMnemonicTrigger = opaque {};
pub const GtkMnemonicTrigger = struct__GtkMnemonicTrigger;
pub const struct__GtkMnemonicTriggerClass = opaque {};
pub const GtkMnemonicTriggerClass = struct__GtkMnemonicTriggerClass;
pub const GtkMnemonicTrigger_autoptr = ?*GtkMnemonicTrigger;
pub const GtkMnemonicTrigger_listautoptr = [*c]GList;
pub const GtkMnemonicTrigger_slistautoptr = [*c]GSList;
pub const GtkMnemonicTrigger_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMnemonicTrigger(arg__ptr: ?*GtkMnemonicTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutTrigger(@as(?*GtkShortcutTrigger, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMnemonicTrigger(arg__ptr: [*c]?*GtkMnemonicTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMnemonicTrigger(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMnemonicTrigger(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMnemonicTrigger(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMnemonicTrigger(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
    }
}
pub const GtkMnemonicTriggerClass_autoptr = ?*GtkMnemonicTriggerClass;
pub const GtkMnemonicTriggerClass_listautoptr = [*c]GList;
pub const GtkMnemonicTriggerClass_slistautoptr = [*c]GSList;
pub const GtkMnemonicTriggerClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMnemonicTriggerClass(arg__ptr: ?*GtkMnemonicTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkMnemonicTriggerClass(arg__ptr: [*c]?*GtkMnemonicTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkMnemonicTriggerClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkMnemonicTriggerClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkMnemonicTriggerClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkMnemonicTriggerClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_MNEMONIC_TRIGGER(arg_ptr: gpointer) callconv(.C) ?*GtkMnemonicTrigger {
    var ptr = arg_ptr;
    return @as(?*GtkMnemonicTrigger, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_mnemonic_trigger_get_type())))));
}
pub fn GTK_MNEMONIC_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkMnemonicTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkMnemonicTriggerClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_mnemonic_trigger_get_type())))));
}
pub fn GTK_IS_MNEMONIC_TRIGGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_mnemonic_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_MNEMONIC_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_mnemonic_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_MNEMONIC_TRIGGER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkMnemonicTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkMnemonicTriggerClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_mnemonic_trigger_new(keyval: guint) ?*GtkShortcutTrigger;
pub extern fn gtk_mnemonic_trigger_get_keyval(self: ?*GtkMnemonicTrigger) guint;
pub extern fn gtk_alternative_trigger_get_type() GType;
pub const struct__GtkAlternativeTrigger = opaque {};
pub const GtkAlternativeTrigger = struct__GtkAlternativeTrigger;
pub const struct__GtkAlternativeTriggerClass = opaque {};
pub const GtkAlternativeTriggerClass = struct__GtkAlternativeTriggerClass;
pub const GtkAlternativeTrigger_autoptr = ?*GtkAlternativeTrigger;
pub const GtkAlternativeTrigger_listautoptr = [*c]GList;
pub const GtkAlternativeTrigger_slistautoptr = [*c]GSList;
pub const GtkAlternativeTrigger_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAlternativeTrigger(arg__ptr: ?*GtkAlternativeTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkShortcutTrigger(@as(?*GtkShortcutTrigger, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAlternativeTrigger(arg__ptr: [*c]?*GtkAlternativeTrigger) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAlternativeTrigger(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAlternativeTrigger(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAlternativeTrigger(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAlternativeTrigger(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkShortcutTrigger)))))));
    }
}
pub const GtkAlternativeTriggerClass_autoptr = ?*GtkAlternativeTriggerClass;
pub const GtkAlternativeTriggerClass_listautoptr = [*c]GList;
pub const GtkAlternativeTriggerClass_slistautoptr = [*c]GSList;
pub const GtkAlternativeTriggerClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAlternativeTriggerClass(arg__ptr: ?*GtkAlternativeTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkAlternativeTriggerClass(arg__ptr: [*c]?*GtkAlternativeTriggerClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkAlternativeTriggerClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkAlternativeTriggerClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkAlternativeTriggerClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkAlternativeTriggerClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_ALTERNATIVE_TRIGGER(arg_ptr: gpointer) callconv(.C) ?*GtkAlternativeTrigger {
    var ptr = arg_ptr;
    return @as(?*GtkAlternativeTrigger, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_alternative_trigger_get_type())))));
}
pub fn GTK_ALTERNATIVE_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkAlternativeTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkAlternativeTriggerClass, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_class_cast(@as([*c]GTypeClass, @ptrCast(@alignCast(ptr))), gtk_alternative_trigger_get_type())))));
}
pub fn GTK_IS_ALTERNATIVE_TRIGGER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_alternative_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_IS_ALTERNATIVE_TRIGGER_CLASS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __class: [*c]GTypeClass = @as([*c]GTypeClass, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_alternative_trigger_get_type();
        var __r: gboolean = undefined;
        if (!(__class != null)) {
            __r = @as(c_int, 0);
        } else if (__class.*.g_type == __t) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_class_is_a(__class, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_ALTERNATIVE_TRIGGER_GET_CLASS(arg_ptr: gpointer) callconv(.C) ?*GtkAlternativeTriggerClass {
    var ptr = arg_ptr;
    return @as(?*GtkAlternativeTriggerClass, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class));
}
pub extern fn gtk_alternative_trigger_new(first: ?*GtkShortcutTrigger, second: ?*GtkShortcutTrigger) ?*GtkShortcutTrigger;
pub extern fn gtk_alternative_trigger_get_first(self: ?*GtkAlternativeTrigger) ?*GtkShortcutTrigger;
pub extern fn gtk_alternative_trigger_get_second(self: ?*GtkAlternativeTrigger) ?*GtkShortcutTrigger;
pub extern fn gtk_show_uri_full(parent: [*c]GtkWindow, uri: [*c]const u8, timestamp: guint32, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_show_uri_full_finish(parent: [*c]GtkWindow, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_show_uri(parent: [*c]GtkWindow, uri: [*c]const u8, timestamp: guint32) void;
pub const struct__GtkSignalListItemFactory = opaque {};
pub const GtkSignalListItemFactory = struct__GtkSignalListItemFactory;
pub const struct__GtkSignalListItemFactoryClass = opaque {};
pub const GtkSignalListItemFactoryClass = struct__GtkSignalListItemFactoryClass;
pub extern fn gtk_signal_list_item_factory_get_type() GType;
pub extern fn gtk_signal_list_item_factory_new() ?*GtkListItemFactory;
pub extern fn gtk_single_selection_get_type() GType;
pub const struct__GtkSingleSelection = opaque {};
pub const GtkSingleSelection = struct__GtkSingleSelection;
pub const GtkSingleSelectionClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkSingleSelection_autoptr = ?*GtkSingleSelection;
pub const GtkSingleSelection_listautoptr = [*c]GList;
pub const GtkSingleSelection_slistautoptr = [*c]GSList;
pub const GtkSingleSelection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSingleSelection(arg__ptr: ?*GtkSingleSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkSingleSelection(arg__ptr: [*c]?*GtkSingleSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSingleSelection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSingleSelection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSingleSelection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSingleSelection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkSingleSelectionClass_autoptr = [*c]GtkSingleSelectionClass;
pub const GtkSingleSelectionClass_listautoptr = [*c]GList;
pub const GtkSingleSelectionClass_slistautoptr = [*c]GSList;
pub const GtkSingleSelectionClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSingleSelectionClass(arg__ptr: [*c]GtkSingleSelectionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSingleSelectionClass(arg__ptr: [*c][*c]GtkSingleSelectionClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSingleSelectionClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSingleSelectionClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSingleSelectionClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSingleSelectionClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SINGLE_SELECTION(arg_ptr: gpointer) callconv(.C) ?*GtkSingleSelection {
    var ptr = arg_ptr;
    return @as(?*GtkSingleSelection, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_single_selection_get_type())))));
}
pub fn GTK_IS_SINGLE_SELECTION(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_single_selection_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_single_selection_new(model: ?*GListModel) ?*GtkSingleSelection;
pub extern fn gtk_single_selection_get_model(self: ?*GtkSingleSelection) ?*GListModel;
pub extern fn gtk_single_selection_set_model(self: ?*GtkSingleSelection, model: ?*GListModel) void;
pub extern fn gtk_single_selection_get_selected(self: ?*GtkSingleSelection) guint;
pub extern fn gtk_single_selection_set_selected(self: ?*GtkSingleSelection, position: guint) void;
pub extern fn gtk_single_selection_get_selected_item(self: ?*GtkSingleSelection) gpointer;
pub extern fn gtk_single_selection_get_autoselect(self: ?*GtkSingleSelection) gboolean;
pub extern fn gtk_single_selection_set_autoselect(self: ?*GtkSingleSelection, autoselect: gboolean) void;
pub extern fn gtk_single_selection_get_can_unselect(self: ?*GtkSingleSelection) gboolean;
pub extern fn gtk_single_selection_set_can_unselect(self: ?*GtkSingleSelection, can_unselect: gboolean) void;
pub extern fn gtk_slice_list_model_get_type() GType;
pub const struct__GtkSliceListModel = opaque {};
pub const GtkSliceListModel = struct__GtkSliceListModel;
pub const GtkSliceListModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkSliceListModel_autoptr = ?*GtkSliceListModel;
pub const GtkSliceListModel_listautoptr = [*c]GList;
pub const GtkSliceListModel_slistautoptr = [*c]GSList;
pub const GtkSliceListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSliceListModel(arg__ptr: ?*GtkSliceListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkSliceListModel(arg__ptr: [*c]?*GtkSliceListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSliceListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSliceListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSliceListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSliceListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkSliceListModelClass_autoptr = [*c]GtkSliceListModelClass;
pub const GtkSliceListModelClass_listautoptr = [*c]GList;
pub const GtkSliceListModelClass_slistautoptr = [*c]GSList;
pub const GtkSliceListModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSliceListModelClass(arg__ptr: [*c]GtkSliceListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSliceListModelClass(arg__ptr: [*c][*c]GtkSliceListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSliceListModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSliceListModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSliceListModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSliceListModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_SLICE_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkSliceListModel {
    var ptr = arg_ptr;
    return @as(?*GtkSliceListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_slice_list_model_get_type())))));
}
pub fn GTK_IS_SLICE_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_slice_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_slice_list_model_new(model: ?*GListModel, offset: guint, size: guint) ?*GtkSliceListModel;
pub extern fn gtk_slice_list_model_set_model(self: ?*GtkSliceListModel, model: ?*GListModel) void;
pub extern fn gtk_slice_list_model_get_model(self: ?*GtkSliceListModel) ?*GListModel;
pub extern fn gtk_slice_list_model_set_offset(self: ?*GtkSliceListModel, offset: guint) void;
pub extern fn gtk_slice_list_model_get_offset(self: ?*GtkSliceListModel) guint;
pub extern fn gtk_slice_list_model_set_size(self: ?*GtkSliceListModel, size: guint) void;
pub extern fn gtk_slice_list_model_get_size(self: ?*GtkSliceListModel) guint;
pub const struct__GtkStack = opaque {};
pub const GtkStack = struct__GtkStack;
pub const struct__GtkStackPage = opaque {};
pub const GtkStackPage = struct__GtkStackPage;
pub const GTK_STACK_TRANSITION_TYPE_NONE: c_int = 0;
pub const GTK_STACK_TRANSITION_TYPE_CROSSFADE: c_int = 1;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT: c_int = 2;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT: c_int = 3;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_UP: c_int = 4;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN: c_int = 5;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT: c_int = 6;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN: c_int = 7;
pub const GTK_STACK_TRANSITION_TYPE_OVER_UP: c_int = 8;
pub const GTK_STACK_TRANSITION_TYPE_OVER_DOWN: c_int = 9;
pub const GTK_STACK_TRANSITION_TYPE_OVER_LEFT: c_int = 10;
pub const GTK_STACK_TRANSITION_TYPE_OVER_RIGHT: c_int = 11;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_UP: c_int = 12;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_DOWN: c_int = 13;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_LEFT: c_int = 14;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT: c_int = 15;
pub const GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN: c_int = 16;
pub const GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP: c_int = 17;
pub const GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT: c_int = 18;
pub const GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT: c_int = 19;
pub const GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT: c_int = 20;
pub const GTK_STACK_TRANSITION_TYPE_ROTATE_RIGHT: c_int = 21;
pub const GTK_STACK_TRANSITION_TYPE_ROTATE_LEFT_RIGHT: c_int = 22;
pub const GtkStackTransitionType = c_uint;
pub extern fn gtk_stack_page_get_type() GType;
pub extern fn gtk_stack_page_get_child(self: ?*GtkStackPage) [*c]GtkWidget;
pub extern fn gtk_stack_page_get_visible(self: ?*GtkStackPage) gboolean;
pub extern fn gtk_stack_page_set_visible(self: ?*GtkStackPage, visible: gboolean) void;
pub extern fn gtk_stack_page_get_needs_attention(self: ?*GtkStackPage) gboolean;
pub extern fn gtk_stack_page_set_needs_attention(self: ?*GtkStackPage, setting: gboolean) void;
pub extern fn gtk_stack_page_get_use_underline(self: ?*GtkStackPage) gboolean;
pub extern fn gtk_stack_page_set_use_underline(self: ?*GtkStackPage, setting: gboolean) void;
pub extern fn gtk_stack_page_get_name(self: ?*GtkStackPage) [*c]const u8;
pub extern fn gtk_stack_page_set_name(self: ?*GtkStackPage, setting: [*c]const u8) void;
pub extern fn gtk_stack_page_get_title(self: ?*GtkStackPage) [*c]const u8;
pub extern fn gtk_stack_page_set_title(self: ?*GtkStackPage, setting: [*c]const u8) void;
pub extern fn gtk_stack_page_get_icon_name(self: ?*GtkStackPage) [*c]const u8;
pub extern fn gtk_stack_page_set_icon_name(self: ?*GtkStackPage, setting: [*c]const u8) void;
pub extern fn gtk_stack_get_type() GType;
pub extern fn gtk_stack_new() [*c]GtkWidget;
pub extern fn gtk_stack_add_child(stack: ?*GtkStack, child: [*c]GtkWidget) ?*GtkStackPage;
pub extern fn gtk_stack_add_named(stack: ?*GtkStack, child: [*c]GtkWidget, name: [*c]const u8) ?*GtkStackPage;
pub extern fn gtk_stack_add_titled(stack: ?*GtkStack, child: [*c]GtkWidget, name: [*c]const u8, title: [*c]const u8) ?*GtkStackPage;
pub extern fn gtk_stack_remove(stack: ?*GtkStack, child: [*c]GtkWidget) void;
pub extern fn gtk_stack_get_page(stack: ?*GtkStack, child: [*c]GtkWidget) ?*GtkStackPage;
pub extern fn gtk_stack_get_child_by_name(stack: ?*GtkStack, name: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_stack_set_visible_child(stack: ?*GtkStack, child: [*c]GtkWidget) void;
pub extern fn gtk_stack_get_visible_child(stack: ?*GtkStack) [*c]GtkWidget;
pub extern fn gtk_stack_set_visible_child_name(stack: ?*GtkStack, name: [*c]const u8) void;
pub extern fn gtk_stack_get_visible_child_name(stack: ?*GtkStack) [*c]const u8;
pub extern fn gtk_stack_set_visible_child_full(stack: ?*GtkStack, name: [*c]const u8, transition: GtkStackTransitionType) void;
pub extern fn gtk_stack_set_hhomogeneous(stack: ?*GtkStack, hhomogeneous: gboolean) void;
pub extern fn gtk_stack_get_hhomogeneous(stack: ?*GtkStack) gboolean;
pub extern fn gtk_stack_set_vhomogeneous(stack: ?*GtkStack, vhomogeneous: gboolean) void;
pub extern fn gtk_stack_get_vhomogeneous(stack: ?*GtkStack) gboolean;
pub extern fn gtk_stack_set_transition_duration(stack: ?*GtkStack, duration: guint) void;
pub extern fn gtk_stack_get_transition_duration(stack: ?*GtkStack) guint;
pub extern fn gtk_stack_set_transition_type(stack: ?*GtkStack, transition: GtkStackTransitionType) void;
pub extern fn gtk_stack_get_transition_type(stack: ?*GtkStack) GtkStackTransitionType;
pub extern fn gtk_stack_get_transition_running(stack: ?*GtkStack) gboolean;
pub extern fn gtk_stack_set_interpolate_size(stack: ?*GtkStack, interpolate_size: gboolean) void;
pub extern fn gtk_stack_get_interpolate_size(stack: ?*GtkStack) gboolean;
pub extern fn gtk_stack_get_pages(stack: ?*GtkStack) ?*GtkSelectionModel;
pub const GtkStack_autoptr = ?*GtkStack;
pub const GtkStack_listautoptr = [*c]GList;
pub const GtkStack_slistautoptr = [*c]GSList;
pub const GtkStack_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStack(arg__ptr: ?*GtkStack) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStack(arg__ptr: [*c]?*GtkStack) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStack(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStack(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStack(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStack(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkStackSidebar = opaque {};
pub const GtkStackSidebar = struct__GtkStackSidebar;
pub extern fn gtk_stack_sidebar_get_type() GType;
pub extern fn gtk_stack_sidebar_new() [*c]GtkWidget;
pub extern fn gtk_stack_sidebar_set_stack(self: ?*GtkStackSidebar, stack: ?*GtkStack) void;
pub extern fn gtk_stack_sidebar_get_stack(self: ?*GtkStackSidebar) ?*GtkStack;
pub const GtkStackSidebar_autoptr = ?*GtkStackSidebar;
pub const GtkStackSidebar_listautoptr = [*c]GList;
pub const GtkStackSidebar_slistautoptr = [*c]GSList;
pub const GtkStackSidebar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStackSidebar(arg__ptr: ?*GtkStackSidebar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStackSidebar(arg__ptr: [*c]?*GtkStackSidebar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStackSidebar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStackSidebar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStackSidebar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStackSidebar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkSizeGroup = extern struct {
    parent_instance: GObject,
};
pub const GtkSizeGroup = struct__GtkSizeGroup;
pub extern fn gtk_size_group_get_type() GType;
pub extern fn gtk_size_group_new(mode: GtkSizeGroupMode) [*c]GtkSizeGroup;
pub extern fn gtk_size_group_set_mode(size_group: [*c]GtkSizeGroup, mode: GtkSizeGroupMode) void;
pub extern fn gtk_size_group_get_mode(size_group: [*c]GtkSizeGroup) GtkSizeGroupMode;
pub extern fn gtk_size_group_add_widget(size_group: [*c]GtkSizeGroup, widget: [*c]GtkWidget) void;
pub extern fn gtk_size_group_remove_widget(size_group: [*c]GtkSizeGroup, widget: [*c]GtkWidget) void;
pub extern fn gtk_size_group_get_widgets(size_group: [*c]GtkSizeGroup) [*c]GSList;
pub const GtkSizeGroup_autoptr = [*c]GtkSizeGroup;
pub const GtkSizeGroup_listautoptr = [*c]GList;
pub const GtkSizeGroup_slistautoptr = [*c]GSList;
pub const GtkSizeGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSizeGroup(arg__ptr: [*c]GtkSizeGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSizeGroup(arg__ptr: [*c][*c]GtkSizeGroup) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSizeGroup(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSizeGroup(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSizeGroup(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSizeGroup(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkRequestedSize = extern struct {
    data: gpointer,
    minimum_size: c_int,
    natural_size: c_int,
};
pub const GtkRequestedSize = struct__GtkRequestedSize;
pub extern fn gtk_distribute_natural_allocation(extra_space: c_int, n_requested_sizes: guint, sizes: [*c]GtkRequestedSize) c_int;
pub const GTK_UPDATE_ALWAYS: c_int = 0;
pub const GTK_UPDATE_IF_VALID: c_int = 1;
pub const GtkSpinButtonUpdatePolicy = c_uint;
pub const GTK_SPIN_STEP_FORWARD: c_int = 0;
pub const GTK_SPIN_STEP_BACKWARD: c_int = 1;
pub const GTK_SPIN_PAGE_FORWARD: c_int = 2;
pub const GTK_SPIN_PAGE_BACKWARD: c_int = 3;
pub const GTK_SPIN_HOME: c_int = 4;
pub const GTK_SPIN_END: c_int = 5;
pub const GTK_SPIN_USER_DEFINED: c_int = 6;
pub const GtkSpinType = c_uint;
pub const struct__GtkSpinButton = opaque {};
pub const GtkSpinButton = struct__GtkSpinButton;
pub extern fn gtk_spin_button_get_type() GType;
pub extern fn gtk_spin_button_configure(spin_button: ?*GtkSpinButton, adjustment: [*c]GtkAdjustment, climb_rate: f64, digits: guint) void;
pub extern fn gtk_spin_button_new(adjustment: [*c]GtkAdjustment, climb_rate: f64, digits: guint) [*c]GtkWidget;
pub extern fn gtk_spin_button_new_with_range(min: f64, max: f64, step: f64) [*c]GtkWidget;
pub extern fn gtk_spin_button_set_adjustment(spin_button: ?*GtkSpinButton, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_spin_button_get_adjustment(spin_button: ?*GtkSpinButton) [*c]GtkAdjustment;
pub extern fn gtk_spin_button_set_digits(spin_button: ?*GtkSpinButton, digits: guint) void;
pub extern fn gtk_spin_button_get_digits(spin_button: ?*GtkSpinButton) guint;
pub extern fn gtk_spin_button_set_increments(spin_button: ?*GtkSpinButton, step: f64, page: f64) void;
pub extern fn gtk_spin_button_get_increments(spin_button: ?*GtkSpinButton, step: [*c]f64, page: [*c]f64) void;
pub extern fn gtk_spin_button_set_range(spin_button: ?*GtkSpinButton, min: f64, max: f64) void;
pub extern fn gtk_spin_button_get_range(spin_button: ?*GtkSpinButton, min: [*c]f64, max: [*c]f64) void;
pub extern fn gtk_spin_button_get_value(spin_button: ?*GtkSpinButton) f64;
pub extern fn gtk_spin_button_get_value_as_int(spin_button: ?*GtkSpinButton) c_int;
pub extern fn gtk_spin_button_set_value(spin_button: ?*GtkSpinButton, value: f64) void;
pub extern fn gtk_spin_button_set_update_policy(spin_button: ?*GtkSpinButton, policy: GtkSpinButtonUpdatePolicy) void;
pub extern fn gtk_spin_button_get_update_policy(spin_button: ?*GtkSpinButton) GtkSpinButtonUpdatePolicy;
pub extern fn gtk_spin_button_set_numeric(spin_button: ?*GtkSpinButton, numeric: gboolean) void;
pub extern fn gtk_spin_button_get_numeric(spin_button: ?*GtkSpinButton) gboolean;
pub extern fn gtk_spin_button_spin(spin_button: ?*GtkSpinButton, direction: GtkSpinType, increment: f64) void;
pub extern fn gtk_spin_button_set_wrap(spin_button: ?*GtkSpinButton, wrap: gboolean) void;
pub extern fn gtk_spin_button_get_wrap(spin_button: ?*GtkSpinButton) gboolean;
pub extern fn gtk_spin_button_set_snap_to_ticks(spin_button: ?*GtkSpinButton, snap_to_ticks: gboolean) void;
pub extern fn gtk_spin_button_get_snap_to_ticks(spin_button: ?*GtkSpinButton) gboolean;
pub extern fn gtk_spin_button_set_climb_rate(spin_button: ?*GtkSpinButton, climb_rate: f64) void;
pub extern fn gtk_spin_button_get_climb_rate(spin_button: ?*GtkSpinButton) f64;
pub extern fn gtk_spin_button_update(spin_button: ?*GtkSpinButton) void;
pub const GtkSpinButton_autoptr = ?*GtkSpinButton;
pub const GtkSpinButton_listautoptr = [*c]GList;
pub const GtkSpinButton_slistautoptr = [*c]GSList;
pub const GtkSpinButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSpinButton(arg__ptr: ?*GtkSpinButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSpinButton(arg__ptr: [*c]?*GtkSpinButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSpinButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSpinButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSpinButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSpinButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkSpinner = opaque {};
pub const GtkSpinner = struct__GtkSpinner;
pub extern fn gtk_spinner_get_type() GType;
pub extern fn gtk_spinner_new() [*c]GtkWidget;
pub extern fn gtk_spinner_start(spinner: ?*GtkSpinner) void;
pub extern fn gtk_spinner_stop(spinner: ?*GtkSpinner) void;
pub extern fn gtk_spinner_set_spinning(spinner: ?*GtkSpinner, spinning: gboolean) void;
pub extern fn gtk_spinner_get_spinning(spinner: ?*GtkSpinner) gboolean;
pub const GtkSpinner_autoptr = ?*GtkSpinner;
pub const GtkSpinner_listautoptr = [*c]GList;
pub const GtkSpinner_slistautoptr = [*c]GSList;
pub const GtkSpinner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSpinner(arg__ptr: ?*GtkSpinner) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSpinner(arg__ptr: [*c]?*GtkSpinner) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSpinner(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSpinner(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSpinner(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSpinner(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkStackSwitcher = opaque {};
pub const GtkStackSwitcher = struct__GtkStackSwitcher;
pub extern fn gtk_stack_switcher_get_type() GType;
pub extern fn gtk_stack_switcher_new() [*c]GtkWidget;
pub extern fn gtk_stack_switcher_set_stack(switcher: ?*GtkStackSwitcher, stack: ?*GtkStack) void;
pub extern fn gtk_stack_switcher_get_stack(switcher: ?*GtkStackSwitcher) ?*GtkStack;
pub const GtkStackSwitcher_autoptr = ?*GtkStackSwitcher;
pub const GtkStackSwitcher_listautoptr = [*c]GList;
pub const GtkStackSwitcher_slistautoptr = [*c]GSList;
pub const GtkStackSwitcher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStackSwitcher(arg__ptr: ?*GtkStackSwitcher) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStackSwitcher(arg__ptr: [*c]?*GtkStackSwitcher) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStackSwitcher(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStackSwitcher(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStackSwitcher(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStackSwitcher(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkStatusbar = opaque {};
pub const GtkStatusbar = struct__GtkStatusbar;
pub extern fn gtk_statusbar_get_type() GType;
pub extern fn gtk_statusbar_new() [*c]GtkWidget;
pub extern fn gtk_statusbar_get_context_id(statusbar: ?*GtkStatusbar, context_description: [*c]const u8) guint;
pub extern fn gtk_statusbar_push(statusbar: ?*GtkStatusbar, context_id: guint, text: [*c]const u8) guint;
pub extern fn gtk_statusbar_pop(statusbar: ?*GtkStatusbar, context_id: guint) void;
pub extern fn gtk_statusbar_remove(statusbar: ?*GtkStatusbar, context_id: guint, message_id: guint) void;
pub extern fn gtk_statusbar_remove_all(statusbar: ?*GtkStatusbar, context_id: guint) void;
pub const GtkStatusbar_autoptr = ?*GtkStatusbar;
pub const GtkStatusbar_listautoptr = [*c]GList;
pub const GtkStatusbar_slistautoptr = [*c]GSList;
pub const GtkStatusbar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStatusbar(arg__ptr: ?*GtkStatusbar) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStatusbar(arg__ptr: [*c]?*GtkStatusbar) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStatusbar(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStatusbar(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStatusbar(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStatusbar(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_string_object_get_type() GType;
pub const struct__GtkStringObject = opaque {};
pub const GtkStringObject = struct__GtkStringObject;
pub const GtkStringObjectClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkStringObject_autoptr = ?*GtkStringObject;
pub const GtkStringObject_listautoptr = [*c]GList;
pub const GtkStringObject_slistautoptr = [*c]GSList;
pub const GtkStringObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringObject(arg__ptr: ?*GtkStringObject) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkStringObject(arg__ptr: [*c]?*GtkStringObject) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringObject(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringObject(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringObject(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringObject(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkStringObjectClass_autoptr = [*c]GtkStringObjectClass;
pub const GtkStringObjectClass_listautoptr = [*c]GList;
pub const GtkStringObjectClass_slistautoptr = [*c]GSList;
pub const GtkStringObjectClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringObjectClass(arg__ptr: [*c]GtkStringObjectClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStringObjectClass(arg__ptr: [*c][*c]GtkStringObjectClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringObjectClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringObjectClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringObjectClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringObjectClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_STRING_OBJECT(arg_ptr: gpointer) callconv(.C) ?*GtkStringObject {
    var ptr = arg_ptr;
    return @as(?*GtkStringObject, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_string_object_get_type())))));
}
pub fn GTK_IS_STRING_OBJECT(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_string_object_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_string_object_new(string: [*c]const u8) ?*GtkStringObject;
pub extern fn gtk_string_object_get_string(self: ?*GtkStringObject) [*c]const u8;
pub extern fn gtk_string_list_get_type() GType;
pub const struct__GtkStringList = opaque {};
pub const GtkStringList = struct__GtkStringList;
pub const GtkStringListClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkStringList_autoptr = ?*GtkStringList;
pub const GtkStringList_listautoptr = [*c]GList;
pub const GtkStringList_slistautoptr = [*c]GSList;
pub const GtkStringList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringList(arg__ptr: ?*GtkStringList) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkStringList(arg__ptr: [*c]?*GtkStringList) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringList(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringList(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringList(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringList(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkStringListClass_autoptr = [*c]GtkStringListClass;
pub const GtkStringListClass_listautoptr = [*c]GList;
pub const GtkStringListClass_slistautoptr = [*c]GSList;
pub const GtkStringListClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringListClass(arg__ptr: [*c]GtkStringListClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStringListClass(arg__ptr: [*c][*c]GtkStringListClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringListClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringListClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringListClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringListClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_STRING_LIST(arg_ptr: gpointer) callconv(.C) ?*GtkStringList {
    var ptr = arg_ptr;
    return @as(?*GtkStringList, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_string_list_get_type())))));
}
pub fn GTK_IS_STRING_LIST(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_string_list_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_string_list_new(strings: [*c]const [*c]const u8) ?*GtkStringList;
pub extern fn gtk_string_list_append(self: ?*GtkStringList, string: [*c]const u8) void;
pub extern fn gtk_string_list_take(self: ?*GtkStringList, string: [*c]u8) void;
pub extern fn gtk_string_list_remove(self: ?*GtkStringList, position: guint) void;
pub extern fn gtk_string_list_splice(self: ?*GtkStringList, position: guint, n_removals: guint, additions: [*c]const [*c]const u8) void;
pub extern fn gtk_string_list_get_string(self: ?*GtkStringList, position: guint) [*c]const u8;
pub extern fn gtk_string_sorter_get_type() GType;
pub const struct__GtkStringSorter = opaque {};
pub const GtkStringSorter = struct__GtkStringSorter;
pub const GtkStringSorterClass = extern struct {
    parent_class: GtkSorterClass,
};
pub const GtkStringSorter_autoptr = ?*GtkStringSorter;
pub const GtkStringSorter_listautoptr = [*c]GList;
pub const GtkStringSorter_slistautoptr = [*c]GSList;
pub const GtkStringSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringSorter(arg__ptr: ?*GtkStringSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkSorter(@as([*c]GtkSorter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkStringSorter(arg__ptr: [*c]?*GtkStringSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
    }
}
pub const GtkStringSorterClass_autoptr = [*c]GtkStringSorterClass;
pub const GtkStringSorterClass_listautoptr = [*c]GList;
pub const GtkStringSorterClass_slistautoptr = [*c]GSList;
pub const GtkStringSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStringSorterClass(arg__ptr: [*c]GtkStringSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStringSorterClass(arg__ptr: [*c][*c]GtkStringSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStringSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStringSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStringSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStringSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_STRING_SORTER(arg_ptr: gpointer) callconv(.C) ?*GtkStringSorter {
    var ptr = arg_ptr;
    return @as(?*GtkStringSorter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_string_sorter_get_type())))));
}
pub fn GTK_IS_STRING_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_string_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_string_sorter_new(expression: ?*GtkExpression) ?*GtkStringSorter;
pub extern fn gtk_string_sorter_get_expression(self: ?*GtkStringSorter) ?*GtkExpression;
pub extern fn gtk_string_sorter_set_expression(self: ?*GtkStringSorter, expression: ?*GtkExpression) void;
pub extern fn gtk_string_sorter_get_ignore_case(self: ?*GtkStringSorter) gboolean;
pub extern fn gtk_string_sorter_set_ignore_case(self: ?*GtkStringSorter, ignore_case: gboolean) void;
pub const GTK_COLLATION_NONE: c_int = 0;
pub const GTK_COLLATION_UNICODE: c_int = 1;
pub const GTK_COLLATION_FILENAME: c_int = 2;
pub const GtkCollation = c_uint;
pub extern fn gtk_string_sorter_set_collation(self: ?*GtkStringSorter, collation: GtkCollation) void;
pub extern fn gtk_string_sorter_get_collation(self: ?*GtkStringSorter) GtkCollation;
pub const struct__GtkStyleProvider = opaque {};
pub const GtkStyleProvider = struct__GtkStyleProvider;
pub extern fn gtk_style_provider_get_type() GType;
pub const GtkStyleProvider_autoptr = ?*GtkStyleProvider;
pub const GtkStyleProvider_listautoptr = [*c]GList;
pub const GtkStyleProvider_slistautoptr = [*c]GSList;
pub const GtkStyleProvider_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStyleProvider(arg__ptr: ?*GtkStyleProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStyleProvider(arg__ptr: [*c]?*GtkStyleProvider) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStyleProvider(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStyleProvider(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStyleProvider(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStyleProvider(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_style_context_add_provider_for_display(display: ?*GdkDisplay, provider: ?*GtkStyleProvider, priority: guint) void;
pub extern fn gtk_style_context_remove_provider_for_display(display: ?*GdkDisplay, provider: ?*GtkStyleProvider) void;
pub const struct__GtkStyleContextClass = extern struct {
    parent_class: GObjectClass,
    changed: ?*const fn ([*c]GtkStyleContext) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkStyleContextClass = struct__GtkStyleContextClass;
pub extern fn gtk_style_context_get_type() GType;
pub extern fn gtk_style_context_add_provider(context: [*c]GtkStyleContext, provider: ?*GtkStyleProvider, priority: guint) void;
pub extern fn gtk_style_context_remove_provider(context: [*c]GtkStyleContext, provider: ?*GtkStyleProvider) void;
pub extern fn gtk_style_context_save(context: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_restore(context: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_set_state(context: [*c]GtkStyleContext, flags: GtkStateFlags) void;
pub extern fn gtk_style_context_get_state(context: [*c]GtkStyleContext) GtkStateFlags;
pub extern fn gtk_style_context_set_scale(context: [*c]GtkStyleContext, scale: c_int) void;
pub extern fn gtk_style_context_get_scale(context: [*c]GtkStyleContext) c_int;
pub extern fn gtk_style_context_add_class(context: [*c]GtkStyleContext, class_name: [*c]const u8) void;
pub extern fn gtk_style_context_remove_class(context: [*c]GtkStyleContext, class_name: [*c]const u8) void;
pub extern fn gtk_style_context_has_class(context: [*c]GtkStyleContext, class_name: [*c]const u8) gboolean;
pub extern fn gtk_style_context_set_display(context: [*c]GtkStyleContext, display: ?*GdkDisplay) void;
pub extern fn gtk_style_context_get_display(context: [*c]GtkStyleContext) ?*GdkDisplay;
pub extern fn gtk_style_context_lookup_color(context: [*c]GtkStyleContext, color_name: [*c]const u8, color: [*c]GdkRGBA) gboolean;
pub extern fn gtk_style_context_get_color(context: [*c]GtkStyleContext, color: [*c]GdkRGBA) void;
pub extern fn gtk_style_context_get_border(context: [*c]GtkStyleContext, border: [*c]GtkBorder) void;
pub extern fn gtk_style_context_get_padding(context: [*c]GtkStyleContext, padding: [*c]GtkBorder) void;
pub extern fn gtk_style_context_get_margin(context: [*c]GtkStyleContext, margin: [*c]GtkBorder) void;
pub const GTK_STYLE_CONTEXT_PRINT_NONE: c_int = 0;
pub const GTK_STYLE_CONTEXT_PRINT_RECURSE: c_int = 1;
pub const GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE: c_int = 2;
pub const GTK_STYLE_CONTEXT_PRINT_SHOW_CHANGE: c_int = 4;
pub const GtkStyleContextPrintFlags = c_uint;
pub extern fn gtk_style_context_to_string(context: [*c]GtkStyleContext, flags: GtkStyleContextPrintFlags) [*c]u8;
pub const GtkStyleContext_autoptr = [*c]GtkStyleContext;
pub const GtkStyleContext_listautoptr = [*c]GList;
pub const GtkStyleContext_slistautoptr = [*c]GSList;
pub const GtkStyleContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStyleContext(arg__ptr: [*c]GtkStyleContext) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkStyleContext(arg__ptr: [*c][*c]GtkStyleContext) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkStyleContext(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkStyleContext(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkStyleContext(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkStyleContext(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkSwitch = opaque {};
pub const GtkSwitch = struct__GtkSwitch;
pub extern fn gtk_switch_get_type() GType;
pub extern fn gtk_switch_new() [*c]GtkWidget;
pub extern fn gtk_switch_set_active(self: ?*GtkSwitch, is_active: gboolean) void;
pub extern fn gtk_switch_get_active(self: ?*GtkSwitch) gboolean;
pub extern fn gtk_switch_set_state(self: ?*GtkSwitch, state: gboolean) void;
pub extern fn gtk_switch_get_state(self: ?*GtkSwitch) gboolean;
pub const GtkSwitch_autoptr = ?*GtkSwitch;
pub const GtkSwitch_listautoptr = [*c]GList;
pub const GtkSwitch_slistautoptr = [*c]GSList;
pub const GtkSwitch_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSwitch(arg__ptr: ?*GtkSwitch) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSwitch(arg__ptr: [*c]?*GtkSwitch) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSwitch(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSwitch(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSwitch(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSwitch(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_symbolic_paintable_get_type() GType;
pub const struct__GtkSymbolicPaintable = opaque {};
pub const GtkSymbolicPaintable = struct__GtkSymbolicPaintable;
pub const struct__GtkSymbolicPaintableInterface = extern struct {
    g_iface: GTypeInterface,
    snapshot_symbolic: ?*const fn (?*GtkSymbolicPaintable, ?*GdkSnapshot, f64, f64, [*c]const GdkRGBA, gsize) callconv(.C) void,
};
pub const GtkSymbolicPaintableInterface = struct__GtkSymbolicPaintableInterface;
pub const GtkSymbolicPaintable_autoptr = ?*GtkSymbolicPaintable;
pub const GtkSymbolicPaintable_listautoptr = [*c]GList;
pub const GtkSymbolicPaintable_slistautoptr = [*c]GSList;
pub const GtkSymbolicPaintable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSymbolicPaintable(arg__ptr: ?*GtkSymbolicPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GdkPaintable(@as(?*GdkPaintable, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkSymbolicPaintable(arg__ptr: [*c]?*GtkSymbolicPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkSymbolicPaintable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkSymbolicPaintable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GdkPaintable)))))));
}
pub fn glib_slistautoptr_cleanup_GtkSymbolicPaintable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GdkPaintable)))))));
}
pub fn glib_queueautoptr_cleanup_GtkSymbolicPaintable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GdkPaintable)))))));
    }
}
pub fn GTK_SYMBOLIC_PAINTABLE(arg_ptr: gpointer) callconv(.C) ?*GtkSymbolicPaintable {
    var ptr = arg_ptr;
    return @as(?*GtkSymbolicPaintable, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_symbolic_paintable_get_type())))));
}
pub fn GTK_IS_SYMBOLIC_PAINTABLE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_symbolic_paintable_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub fn GTK_SYMBOLIC_PAINTABLE_GET_IFACE(arg_ptr: gpointer) callconv(.C) [*c]GtkSymbolicPaintableInterface {
    var ptr = arg_ptr;
    return @as([*c]GtkSymbolicPaintableInterface, @ptrCast(@alignCast(g_type_interface_peek(@as(gpointer, @ptrCast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))).*.g_class)), gtk_symbolic_paintable_get_type()))));
}
pub extern fn gtk_symbolic_paintable_snapshot_symbolic(paintable: ?*GtkSymbolicPaintable, snapshot: ?*GdkSnapshot, width: f64, height: f64, colors: [*c]const GdkRGBA, n_colors: gsize) void;
pub const struct__GtkText = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkText = struct__GtkText;
pub extern fn gtk_text_get_type() GType;
pub extern fn gtk_text_new() [*c]GtkWidget;
pub extern fn gtk_text_new_with_buffer(buffer: [*c]GtkEntryBuffer) [*c]GtkWidget;
pub extern fn gtk_text_get_buffer(self: [*c]GtkText) [*c]GtkEntryBuffer;
pub extern fn gtk_text_set_buffer(self: [*c]GtkText, buffer: [*c]GtkEntryBuffer) void;
pub extern fn gtk_text_set_visibility(self: [*c]GtkText, visible: gboolean) void;
pub extern fn gtk_text_get_visibility(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_set_invisible_char(self: [*c]GtkText, ch: gunichar) void;
pub extern fn gtk_text_get_invisible_char(self: [*c]GtkText) gunichar;
pub extern fn gtk_text_unset_invisible_char(self: [*c]GtkText) void;
pub extern fn gtk_text_set_overwrite_mode(self: [*c]GtkText, overwrite: gboolean) void;
pub extern fn gtk_text_get_overwrite_mode(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_set_max_length(self: [*c]GtkText, length: c_int) void;
pub extern fn gtk_text_get_max_length(self: [*c]GtkText) c_int;
pub extern fn gtk_text_get_text_length(self: [*c]GtkText) guint16;
pub extern fn gtk_text_set_activates_default(self: [*c]GtkText, activates: gboolean) void;
pub extern fn gtk_text_get_activates_default(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_get_placeholder_text(self: [*c]GtkText) [*c]const u8;
pub extern fn gtk_text_set_placeholder_text(self: [*c]GtkText, text: [*c]const u8) void;
pub extern fn gtk_text_set_input_purpose(self: [*c]GtkText, purpose: GtkInputPurpose) void;
pub extern fn gtk_text_get_input_purpose(self: [*c]GtkText) GtkInputPurpose;
pub extern fn gtk_text_set_input_hints(self: [*c]GtkText, hints: GtkInputHints) void;
pub extern fn gtk_text_get_input_hints(self: [*c]GtkText) GtkInputHints;
pub extern fn gtk_text_set_attributes(self: [*c]GtkText, attrs: ?*PangoAttrList) void;
pub extern fn gtk_text_get_attributes(self: [*c]GtkText) ?*PangoAttrList;
pub extern fn gtk_text_set_tabs(self: [*c]GtkText, tabs: ?*PangoTabArray) void;
pub extern fn gtk_text_get_tabs(self: [*c]GtkText) ?*PangoTabArray;
pub extern fn gtk_text_grab_focus_without_selecting(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_set_extra_menu(self: [*c]GtkText, model: [*c]GMenuModel) void;
pub extern fn gtk_text_get_extra_menu(self: [*c]GtkText) [*c]GMenuModel;
pub extern fn gtk_text_set_enable_emoji_completion(self: [*c]GtkText, enable_emoji_completion: gboolean) void;
pub extern fn gtk_text_get_enable_emoji_completion(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_set_propagate_text_width(self: [*c]GtkText, propagate_text_width: gboolean) void;
pub extern fn gtk_text_get_propagate_text_width(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_set_truncate_multiline(self: [*c]GtkText, truncate_multiline: gboolean) void;
pub extern fn gtk_text_get_truncate_multiline(self: [*c]GtkText) gboolean;
pub extern fn gtk_text_compute_cursor_extents(self: [*c]GtkText, position: gsize, strong: [*c]graphene_rect_t, weak: [*c]graphene_rect_t) void;
pub const struct__GtkTextIter = extern struct {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: c_int,
    dummy4: c_int,
    dummy5: c_int,
    dummy6: c_int,
    dummy7: c_int,
    dummy8: c_int,
    dummy9: gpointer,
    dummy10: gpointer,
    dummy11: c_int,
    dummy12: c_int,
    dummy13: c_int,
    dummy14: gpointer,
};
pub const GtkTextIter = struct__GtkTextIter;
pub const struct__GtkTextTagTable = opaque {};
pub const GtkTextTagTable = struct__GtkTextTagTable;
pub const struct__GtkTextTagPrivate = opaque {};
pub const GtkTextTagPrivate = struct__GtkTextTagPrivate;
pub const struct__GtkTextTag = extern struct {
    parent_instance: GObject,
    priv: ?*GtkTextTagPrivate,
};
pub const GtkTextTag = struct__GtkTextTag;
pub const struct__GtkTextTagClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GtkTextTagClass = struct__GtkTextTagClass;
pub extern fn gtk_text_tag_get_type() GType;
pub extern fn gtk_text_tag_new(name: [*c]const u8) [*c]GtkTextTag;
pub extern fn gtk_text_tag_get_priority(tag: [*c]GtkTextTag) c_int;
pub extern fn gtk_text_tag_set_priority(tag: [*c]GtkTextTag, priority: c_int) void;
pub extern fn gtk_text_tag_changed(tag: [*c]GtkTextTag, size_changed: gboolean) void;
pub const GtkTextTag_autoptr = [*c]GtkTextTag;
pub const GtkTextTag_listautoptr = [*c]GList;
pub const GtkTextTag_slistautoptr = [*c]GSList;
pub const GtkTextTag_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextTag(arg__ptr: [*c]GtkTextTag) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTextTag(arg__ptr: [*c][*c]GtkTextTag) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextTag(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextTag(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextTag(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextTag(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkTextTagTableForeach = ?*const fn ([*c]GtkTextTag, gpointer) callconv(.C) void;
pub extern fn gtk_text_tag_table_get_type() GType;
pub extern fn gtk_text_tag_table_new() ?*GtkTextTagTable;
pub extern fn gtk_text_tag_table_add(table: ?*GtkTextTagTable, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_tag_table_remove(table: ?*GtkTextTagTable, tag: [*c]GtkTextTag) void;
pub extern fn gtk_text_tag_table_lookup(table: ?*GtkTextTagTable, name: [*c]const u8) [*c]GtkTextTag;
pub extern fn gtk_text_tag_table_foreach(table: ?*GtkTextTagTable, func: GtkTextTagTableForeach, data: gpointer) void;
pub extern fn gtk_text_tag_table_get_size(table: ?*GtkTextTagTable) c_int;
pub const GtkTextTagTable_autoptr = ?*GtkTextTagTable;
pub const GtkTextTagTable_listautoptr = [*c]GList;
pub const GtkTextTagTable_slistautoptr = [*c]GSList;
pub const GtkTextTagTable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextTagTable(arg__ptr: ?*GtkTextTagTable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTextTagTable(arg__ptr: [*c]?*GtkTextTagTable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextTagTable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextTagTable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextTagTable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextTagTable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkTextChildAnchor = extern struct {
    parent_instance: GObject,
    segment: gpointer,
};
pub const GtkTextChildAnchor = struct__GtkTextChildAnchor;
pub const struct__GtkTextChildAnchorClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkTextChildAnchorClass = struct__GtkTextChildAnchorClass;
pub extern fn gtk_text_child_anchor_get_type() GType;
pub extern fn gtk_text_child_anchor_new() [*c]GtkTextChildAnchor;
pub extern fn gtk_text_child_anchor_new_with_replacement(character: [*c]const u8) [*c]GtkTextChildAnchor;
pub extern fn gtk_text_child_anchor_get_widgets(anchor: [*c]GtkTextChildAnchor, out_len: [*c]guint) [*c][*c]GtkWidget;
pub extern fn gtk_text_child_anchor_get_deleted(anchor: [*c]GtkTextChildAnchor) gboolean;
pub const GtkTextChildAnchor_autoptr = [*c]GtkTextChildAnchor;
pub const GtkTextChildAnchor_listautoptr = [*c]GList;
pub const GtkTextChildAnchor_slistautoptr = [*c]GSList;
pub const GtkTextChildAnchor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextChildAnchor(arg__ptr: [*c]GtkTextChildAnchor) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTextChildAnchor(arg__ptr: [*c][*c]GtkTextChildAnchor) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextChildAnchor(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextChildAnchor(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextChildAnchor(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextChildAnchor(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_TEXT_SEARCH_VISIBLE_ONLY: c_int = 1;
pub const GTK_TEXT_SEARCH_TEXT_ONLY: c_int = 2;
pub const GTK_TEXT_SEARCH_CASE_INSENSITIVE: c_int = 4;
pub const GtkTextSearchFlags = c_uint;
pub const struct__GtkTextBufferPrivate = opaque {};
pub const GtkTextBufferPrivate = struct__GtkTextBufferPrivate;
pub const struct__GtkTextBuffer = extern struct {
    parent_instance: GObject,
    priv: ?*GtkTextBufferPrivate,
};
pub const GtkTextBuffer = struct__GtkTextBuffer;
pub extern fn gtk_text_iter_get_buffer(iter: [*c]const GtkTextIter) [*c]GtkTextBuffer;
pub extern fn gtk_text_iter_copy(iter: [*c]const GtkTextIter) [*c]GtkTextIter;
pub extern fn gtk_text_iter_free(iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_iter_assign(iter: [*c]GtkTextIter, other: [*c]const GtkTextIter) void;
pub extern fn gtk_text_iter_get_type() GType;
pub extern fn gtk_text_iter_get_offset(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_line(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_line_offset(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_line_index(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_visible_line_offset(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_visible_line_index(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_char(iter: [*c]const GtkTextIter) gunichar;
pub extern fn gtk_text_iter_get_slice(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]u8;
pub extern fn gtk_text_iter_get_text(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]u8;
pub extern fn gtk_text_iter_get_visible_slice(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]u8;
pub extern fn gtk_text_iter_get_visible_text(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]u8;
pub extern fn gtk_text_iter_get_paintable(iter: [*c]const GtkTextIter) ?*GdkPaintable;
pub extern fn gtk_text_iter_get_marks(iter: [*c]const GtkTextIter) [*c]GSList;
pub extern fn gtk_text_iter_get_child_anchor(iter: [*c]const GtkTextIter) [*c]GtkTextChildAnchor;
pub extern fn gtk_text_iter_get_toggled_tags(iter: [*c]const GtkTextIter, toggled_on: gboolean) [*c]GSList;
pub extern fn gtk_text_iter_starts_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_ends_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_toggles_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_has_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_get_tags(iter: [*c]const GtkTextIter) [*c]GSList;
pub extern fn gtk_text_iter_editable(iter: [*c]const GtkTextIter, default_setting: gboolean) gboolean;
pub extern fn gtk_text_iter_can_insert(iter: [*c]const GtkTextIter, default_editability: gboolean) gboolean;
pub extern fn gtk_text_iter_starts_word(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_ends_word(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_inside_word(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_starts_sentence(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_ends_sentence(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_inside_sentence(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_starts_line(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_ends_line(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_is_cursor_position(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_get_chars_in_line(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_bytes_in_line(iter: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_get_language(iter: [*c]const GtkTextIter) ?*PangoLanguage;
pub extern fn gtk_text_iter_is_end(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_is_start(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_char(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_char(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_chars(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_chars(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_lines(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_lines(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_word_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_word_start(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_word_ends(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_word_starts(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_visible_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_visible_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_visible_lines(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_visible_lines(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_visible_word_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_visible_word_start(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_visible_word_ends(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_visible_word_starts(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_sentence_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_sentence_start(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_sentence_ends(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_sentence_starts(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_cursor_positions(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_cursor_positions(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_forward_visible_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_visible_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_visible_cursor_positions(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_backward_visible_cursor_positions(iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_iter_set_offset(iter: [*c]GtkTextIter, char_offset: c_int) void;
pub extern fn gtk_text_iter_set_line(iter: [*c]GtkTextIter, line_number: c_int) void;
pub extern fn gtk_text_iter_set_line_offset(iter: [*c]GtkTextIter, char_on_line: c_int) void;
pub extern fn gtk_text_iter_set_line_index(iter: [*c]GtkTextIter, byte_on_line: c_int) void;
pub extern fn gtk_text_iter_forward_to_end(iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_iter_forward_to_line_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_set_visible_line_offset(iter: [*c]GtkTextIter, char_on_line: c_int) void;
pub extern fn gtk_text_iter_set_visible_line_index(iter: [*c]GtkTextIter, byte_on_line: c_int) void;
pub extern fn gtk_text_iter_forward_to_tag_toggle(iter: [*c]GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_backward_to_tag_toggle(iter: [*c]GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub const GtkTextCharPredicate = ?*const fn (gunichar, gpointer) callconv(.C) gboolean;
pub extern fn gtk_text_iter_forward_find_char(iter: [*c]GtkTextIter, pred: GtkTextCharPredicate, user_data: gpointer, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_find_char(iter: [*c]GtkTextIter, pred: GtkTextCharPredicate, user_data: gpointer, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_search(iter: [*c]const GtkTextIter, str: [*c]const u8, flags: GtkTextSearchFlags, match_start: [*c]GtkTextIter, match_end: [*c]GtkTextIter, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_search(iter: [*c]const GtkTextIter, str: [*c]const u8, flags: GtkTextSearchFlags, match_start: [*c]GtkTextIter, match_end: [*c]GtkTextIter, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_equal(lhs: [*c]const GtkTextIter, rhs: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_compare(lhs: [*c]const GtkTextIter, rhs: [*c]const GtkTextIter) c_int;
pub extern fn gtk_text_iter_in_range(iter: [*c]const GtkTextIter, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_order(first: [*c]GtkTextIter, second: [*c]GtkTextIter) void;
pub const GtkTextIter_autoptr = [*c]GtkTextIter;
pub const GtkTextIter_listautoptr = [*c]GList;
pub const GtkTextIter_slistautoptr = [*c]GSList;
pub const GtkTextIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextIter(arg__ptr: [*c]GtkTextIter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        gtk_text_iter_free(_ptr);
    }
}
pub fn glib_autoptr_cleanup_GtkTextIter(arg__ptr: [*c][*c]GtkTextIter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextIter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextIter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_text_iter_free)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextIter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_text_iter_free)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextIter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&gtk_text_iter_free)))))));
    }
}
pub const struct__GtkTextMark = extern struct {
    parent_instance: GObject,
    segment: gpointer,
};
pub const GtkTextMark = struct__GtkTextMark;
pub const struct__GtkTextMarkClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GtkTextMarkClass = struct__GtkTextMarkClass;
pub extern fn gtk_text_mark_get_type() GType;
pub extern fn gtk_text_mark_new(name: [*c]const u8, left_gravity: gboolean) [*c]GtkTextMark;
pub extern fn gtk_text_mark_set_visible(mark: [*c]GtkTextMark, setting: gboolean) void;
pub extern fn gtk_text_mark_get_visible(mark: [*c]GtkTextMark) gboolean;
pub extern fn gtk_text_mark_get_name(mark: [*c]GtkTextMark) [*c]const u8;
pub extern fn gtk_text_mark_get_deleted(mark: [*c]GtkTextMark) gboolean;
pub extern fn gtk_text_mark_get_buffer(mark: [*c]GtkTextMark) [*c]GtkTextBuffer;
pub extern fn gtk_text_mark_get_left_gravity(mark: [*c]GtkTextMark) gboolean;
pub const GtkTextMark_autoptr = [*c]GtkTextMark;
pub const GtkTextMark_listautoptr = [*c]GList;
pub const GtkTextMark_slistautoptr = [*c]GSList;
pub const GtkTextMark_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextMark(arg__ptr: [*c]GtkTextMark) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTextMark(arg__ptr: [*c][*c]GtkTextMark) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextMark(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextMark(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextMark(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextMark(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkTextBufferClass = extern struct {
    parent_class: GObjectClass,
    insert_text: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextIter, [*c]const u8, c_int) callconv(.C) void,
    insert_paintable: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextIter, ?*GdkPaintable) callconv(.C) void,
    insert_child_anchor: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextIter, [*c]GtkTextChildAnchor) callconv(.C) void,
    delete_range: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextIter, [*c]GtkTextIter) callconv(.C) void,
    changed: ?*const fn ([*c]GtkTextBuffer) callconv(.C) void,
    modified_changed: ?*const fn ([*c]GtkTextBuffer) callconv(.C) void,
    mark_set: ?*const fn ([*c]GtkTextBuffer, [*c]const GtkTextIter, [*c]GtkTextMark) callconv(.C) void,
    mark_deleted: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextMark) callconv(.C) void,
    apply_tag: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextTag, [*c]const GtkTextIter, [*c]const GtkTextIter) callconv(.C) void,
    remove_tag: ?*const fn ([*c]GtkTextBuffer, [*c]GtkTextTag, [*c]const GtkTextIter, [*c]const GtkTextIter) callconv(.C) void,
    begin_user_action: ?*const fn ([*c]GtkTextBuffer) callconv(.C) void,
    end_user_action: ?*const fn ([*c]GtkTextBuffer) callconv(.C) void,
    paste_done: ?*const fn ([*c]GtkTextBuffer, ?*GdkClipboard) callconv(.C) void,
    undo: ?*const fn ([*c]GtkTextBuffer) callconv(.C) void,
    redo: ?*const fn ([*c]GtkTextBuffer) callconv(.C) void,
    _gtk_reserved1: ?*const fn () callconv(.C) void,
    _gtk_reserved2: ?*const fn () callconv(.C) void,
    _gtk_reserved3: ?*const fn () callconv(.C) void,
    _gtk_reserved4: ?*const fn () callconv(.C) void,
};
pub const GtkTextBufferClass = struct__GtkTextBufferClass;
pub extern fn gtk_text_buffer_get_type() GType;
pub extern fn gtk_text_buffer_new(table: ?*GtkTextTagTable) [*c]GtkTextBuffer;
pub extern fn gtk_text_buffer_get_line_count(buffer: [*c]GtkTextBuffer) c_int;
pub extern fn gtk_text_buffer_get_char_count(buffer: [*c]GtkTextBuffer) c_int;
pub extern fn gtk_text_buffer_get_tag_table(buffer: [*c]GtkTextBuffer) ?*GtkTextTagTable;
pub extern fn gtk_text_buffer_set_text(buffer: [*c]GtkTextBuffer, text: [*c]const u8, len: c_int) void;
pub extern fn gtk_text_buffer_insert(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const u8, len: c_int) void;
pub extern fn gtk_text_buffer_insert_at_cursor(buffer: [*c]GtkTextBuffer, text: [*c]const u8, len: c_int) void;
pub extern fn gtk_text_buffer_insert_interactive(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const u8, len: c_int, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_insert_interactive_at_cursor(buffer: [*c]GtkTextBuffer, text: [*c]const u8, len: c_int, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_insert_range(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_insert_range_interactive(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_insert_with_tags(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const u8, len: c_int, first_tag: [*c]GtkTextTag, ...) void;
pub extern fn gtk_text_buffer_insert_with_tags_by_name(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const u8, len: c_int, first_tag_name: [*c]const u8, ...) void;
pub extern fn gtk_text_buffer_insert_markup(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, markup: [*c]const u8, len: c_int) void;
pub extern fn gtk_text_buffer_delete(buffer: [*c]GtkTextBuffer, start: [*c]GtkTextIter, end: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_delete_interactive(buffer: [*c]GtkTextBuffer, start_iter: [*c]GtkTextIter, end_iter: [*c]GtkTextIter, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_backspace(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, interactive: gboolean, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_get_text(buffer: [*c]GtkTextBuffer, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, include_hidden_chars: gboolean) [*c]u8;
pub extern fn gtk_text_buffer_get_slice(buffer: [*c]GtkTextBuffer, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, include_hidden_chars: gboolean) [*c]u8;
pub extern fn gtk_text_buffer_insert_paintable(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, paintable: ?*GdkPaintable) void;
pub extern fn gtk_text_buffer_insert_child_anchor(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, anchor: [*c]GtkTextChildAnchor) void;
pub extern fn gtk_text_buffer_create_child_anchor(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter) [*c]GtkTextChildAnchor;
pub extern fn gtk_text_buffer_add_mark(buffer: [*c]GtkTextBuffer, mark: [*c]GtkTextMark, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_create_mark(buffer: [*c]GtkTextBuffer, mark_name: [*c]const u8, where: [*c]const GtkTextIter, left_gravity: gboolean) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_move_mark(buffer: [*c]GtkTextBuffer, mark: [*c]GtkTextMark, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_delete_mark(buffer: [*c]GtkTextBuffer, mark: [*c]GtkTextMark) void;
pub extern fn gtk_text_buffer_get_mark(buffer: [*c]GtkTextBuffer, name: [*c]const u8) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_move_mark_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const u8, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_delete_mark_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const u8) void;
pub extern fn gtk_text_buffer_get_insert(buffer: [*c]GtkTextBuffer) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_get_selection_bound(buffer: [*c]GtkTextBuffer) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_place_cursor(buffer: [*c]GtkTextBuffer, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_select_range(buffer: [*c]GtkTextBuffer, ins: [*c]const GtkTextIter, bound: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_apply_tag(buffer: [*c]GtkTextBuffer, tag: [*c]GtkTextTag, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_remove_tag(buffer: [*c]GtkTextBuffer, tag: [*c]GtkTextTag, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_apply_tag_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const u8, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_remove_tag_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const u8, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_remove_all_tags(buffer: [*c]GtkTextBuffer, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_create_tag(buffer: [*c]GtkTextBuffer, tag_name: [*c]const u8, first_property_name: [*c]const u8, ...) [*c]GtkTextTag;
pub extern fn gtk_text_buffer_get_iter_at_line_offset(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, line_number: c_int, char_offset: c_int) gboolean;
pub extern fn gtk_text_buffer_get_iter_at_line_index(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, line_number: c_int, byte_index: c_int) gboolean;
pub extern fn gtk_text_buffer_get_iter_at_offset(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, char_offset: c_int) void;
pub extern fn gtk_text_buffer_get_iter_at_line(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, line_number: c_int) gboolean;
pub extern fn gtk_text_buffer_get_start_iter(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_get_end_iter(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_get_bounds(buffer: [*c]GtkTextBuffer, start: [*c]GtkTextIter, end: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_get_iter_at_mark(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, mark: [*c]GtkTextMark) void;
pub extern fn gtk_text_buffer_get_iter_at_child_anchor(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, anchor: [*c]GtkTextChildAnchor) void;
pub extern fn gtk_text_buffer_get_modified(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_set_modified(buffer: [*c]GtkTextBuffer, setting: gboolean) void;
pub extern fn gtk_text_buffer_get_has_selection(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_add_selection_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GdkClipboard) void;
pub extern fn gtk_text_buffer_remove_selection_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GdkClipboard) void;
pub extern fn gtk_text_buffer_cut_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GdkClipboard, default_editable: gboolean) void;
pub extern fn gtk_text_buffer_copy_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GdkClipboard) void;
pub extern fn gtk_text_buffer_paste_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GdkClipboard, override_location: [*c]GtkTextIter, default_editable: gboolean) void;
pub extern fn gtk_text_buffer_get_selection_bounds(buffer: [*c]GtkTextBuffer, start: [*c]GtkTextIter, end: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_buffer_delete_selection(buffer: [*c]GtkTextBuffer, interactive: gboolean, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_get_selection_content(buffer: [*c]GtkTextBuffer) [*c]GdkContentProvider;
pub extern fn gtk_text_buffer_get_can_undo(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_get_can_redo(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_get_enable_undo(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_set_enable_undo(buffer: [*c]GtkTextBuffer, enable_undo: gboolean) void;
pub extern fn gtk_text_buffer_get_max_undo_levels(buffer: [*c]GtkTextBuffer) guint;
pub extern fn gtk_text_buffer_set_max_undo_levels(buffer: [*c]GtkTextBuffer, max_undo_levels: guint) void;
pub extern fn gtk_text_buffer_undo(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_redo(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_begin_irreversible_action(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_end_irreversible_action(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_begin_user_action(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_end_user_action(buffer: [*c]GtkTextBuffer) void;
pub const GtkTextBuffer_autoptr = [*c]GtkTextBuffer;
pub const GtkTextBuffer_listautoptr = [*c]GList;
pub const GtkTextBuffer_slistautoptr = [*c]GSList;
pub const GtkTextBuffer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextBuffer(arg__ptr: [*c]GtkTextBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTextBuffer(arg__ptr: [*c][*c]GtkTextBuffer) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextBuffer(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextBuffer(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextBuffer(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextBuffer(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GTK_TEXT_WINDOW_WIDGET: c_int = 1;
pub const GTK_TEXT_WINDOW_TEXT: c_int = 2;
pub const GTK_TEXT_WINDOW_LEFT: c_int = 3;
pub const GTK_TEXT_WINDOW_RIGHT: c_int = 4;
pub const GTK_TEXT_WINDOW_TOP: c_int = 5;
pub const GTK_TEXT_WINDOW_BOTTOM: c_int = 6;
pub const GtkTextWindowType = c_uint;
pub const GTK_TEXT_VIEW_LAYER_BELOW_TEXT: c_int = 0;
pub const GTK_TEXT_VIEW_LAYER_ABOVE_TEXT: c_int = 1;
pub const GtkTextViewLayer = c_uint;
pub const GTK_TEXT_EXTEND_SELECTION_WORD: c_int = 0;
pub const GTK_TEXT_EXTEND_SELECTION_LINE: c_int = 1;
pub const GtkTextExtendSelection = c_uint;
pub const struct__GtkTextViewPrivate = opaque {};
pub const GtkTextViewPrivate = struct__GtkTextViewPrivate;
pub const struct__GtkTextView = extern struct {
    parent_instance: GtkWidget,
    priv: ?*GtkTextViewPrivate,
};
pub const GtkTextView = struct__GtkTextView;
pub const struct__GtkTextViewClass = extern struct {
    parent_class: GtkWidgetClass,
    move_cursor: ?*const fn ([*c]GtkTextView, GtkMovementStep, c_int, gboolean) callconv(.C) void,
    set_anchor: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    insert_at_cursor: ?*const fn ([*c]GtkTextView, [*c]const u8) callconv(.C) void,
    delete_from_cursor: ?*const fn ([*c]GtkTextView, GtkDeleteType, c_int) callconv(.C) void,
    backspace: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    cut_clipboard: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    copy_clipboard: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    paste_clipboard: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    toggle_overwrite: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    create_buffer: ?*const fn ([*c]GtkTextView) callconv(.C) [*c]GtkTextBuffer,
    snapshot_layer: ?*const fn ([*c]GtkTextView, GtkTextViewLayer, ?*GtkSnapshot) callconv(.C) void,
    extend_selection: ?*const fn ([*c]GtkTextView, GtkTextExtendSelection, [*c]const GtkTextIter, [*c]GtkTextIter, [*c]GtkTextIter) callconv(.C) gboolean,
    insert_emoji: ?*const fn ([*c]GtkTextView) callconv(.C) void,
    padding: [8]gpointer,
};
pub const GtkTextViewClass = struct__GtkTextViewClass;
pub extern fn gtk_text_view_get_type() GType;
pub extern fn gtk_text_view_new() [*c]GtkWidget;
pub extern fn gtk_text_view_new_with_buffer(buffer: [*c]GtkTextBuffer) [*c]GtkWidget;
pub extern fn gtk_text_view_set_buffer(text_view: [*c]GtkTextView, buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_view_get_buffer(text_view: [*c]GtkTextView) [*c]GtkTextBuffer;
pub extern fn gtk_text_view_scroll_to_iter(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, within_margin: f64, use_align: gboolean, xalign: f64, yalign: f64) gboolean;
pub extern fn gtk_text_view_scroll_to_mark(text_view: [*c]GtkTextView, mark: [*c]GtkTextMark, within_margin: f64, use_align: gboolean, xalign: f64, yalign: f64) void;
pub extern fn gtk_text_view_scroll_mark_onscreen(text_view: [*c]GtkTextView, mark: [*c]GtkTextMark) void;
pub extern fn gtk_text_view_move_mark_onscreen(text_view: [*c]GtkTextView, mark: [*c]GtkTextMark) gboolean;
pub extern fn gtk_text_view_place_cursor_onscreen(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_get_visible_rect(text_view: [*c]GtkTextView, visible_rect: [*c]GdkRectangle) void;
pub extern fn gtk_text_view_set_cursor_visible(text_view: [*c]GtkTextView, setting: gboolean) void;
pub extern fn gtk_text_view_get_cursor_visible(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_reset_cursor_blink(text_view: [*c]GtkTextView) void;
pub extern fn gtk_text_view_get_cursor_locations(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter, strong: [*c]GdkRectangle, weak: [*c]GdkRectangle) void;
pub extern fn gtk_text_view_get_iter_location(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter, location: [*c]GdkRectangle) void;
pub extern fn gtk_text_view_get_iter_at_location(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, x: c_int, y: c_int) gboolean;
pub extern fn gtk_text_view_get_iter_at_position(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, trailing: [*c]c_int, x: c_int, y: c_int) gboolean;
pub extern fn gtk_text_view_get_line_yrange(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter, y: [*c]c_int, height: [*c]c_int) void;
pub extern fn gtk_text_view_get_line_at_y(text_view: [*c]GtkTextView, target_iter: [*c]GtkTextIter, y: c_int, line_top: [*c]c_int) void;
pub extern fn gtk_text_view_buffer_to_window_coords(text_view: [*c]GtkTextView, win: GtkTextWindowType, buffer_x: c_int, buffer_y: c_int, window_x: [*c]c_int, window_y: [*c]c_int) void;
pub extern fn gtk_text_view_window_to_buffer_coords(text_view: [*c]GtkTextView, win: GtkTextWindowType, window_x: c_int, window_y: c_int, buffer_x: [*c]c_int, buffer_y: [*c]c_int) void;
pub extern fn gtk_text_view_forward_display_line(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_backward_display_line(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_forward_display_line_end(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_backward_display_line_start(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_starts_display_line(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_view_move_visually(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, count: c_int) gboolean;
pub extern fn gtk_text_view_im_context_filter_keypress(text_view: [*c]GtkTextView, event: ?*GdkEvent) gboolean;
pub extern fn gtk_text_view_reset_im_context(text_view: [*c]GtkTextView) void;
pub extern fn gtk_text_view_get_gutter(text_view: [*c]GtkTextView, win: GtkTextWindowType) [*c]GtkWidget;
pub extern fn gtk_text_view_set_gutter(text_view: [*c]GtkTextView, win: GtkTextWindowType, widget: [*c]GtkWidget) void;
pub extern fn gtk_text_view_add_child_at_anchor(text_view: [*c]GtkTextView, child: [*c]GtkWidget, anchor: [*c]GtkTextChildAnchor) void;
pub extern fn gtk_text_view_add_overlay(text_view: [*c]GtkTextView, child: [*c]GtkWidget, xpos: c_int, ypos: c_int) void;
pub extern fn gtk_text_view_move_overlay(text_view: [*c]GtkTextView, child: [*c]GtkWidget, xpos: c_int, ypos: c_int) void;
pub extern fn gtk_text_view_remove(text_view: [*c]GtkTextView, child: [*c]GtkWidget) void;
pub extern fn gtk_text_view_set_wrap_mode(text_view: [*c]GtkTextView, wrap_mode: GtkWrapMode) void;
pub extern fn gtk_text_view_get_wrap_mode(text_view: [*c]GtkTextView) GtkWrapMode;
pub extern fn gtk_text_view_set_editable(text_view: [*c]GtkTextView, setting: gboolean) void;
pub extern fn gtk_text_view_get_editable(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_overwrite(text_view: [*c]GtkTextView, overwrite: gboolean) void;
pub extern fn gtk_text_view_get_overwrite(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_accepts_tab(text_view: [*c]GtkTextView, accepts_tab: gboolean) void;
pub extern fn gtk_text_view_get_accepts_tab(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_pixels_above_lines(text_view: [*c]GtkTextView, pixels_above_lines: c_int) void;
pub extern fn gtk_text_view_get_pixels_above_lines(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_pixels_below_lines(text_view: [*c]GtkTextView, pixels_below_lines: c_int) void;
pub extern fn gtk_text_view_get_pixels_below_lines(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_pixels_inside_wrap(text_view: [*c]GtkTextView, pixels_inside_wrap: c_int) void;
pub extern fn gtk_text_view_get_pixels_inside_wrap(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_justification(text_view: [*c]GtkTextView, justification: GtkJustification) void;
pub extern fn gtk_text_view_get_justification(text_view: [*c]GtkTextView) GtkJustification;
pub extern fn gtk_text_view_set_left_margin(text_view: [*c]GtkTextView, left_margin: c_int) void;
pub extern fn gtk_text_view_get_left_margin(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_right_margin(text_view: [*c]GtkTextView, right_margin: c_int) void;
pub extern fn gtk_text_view_get_right_margin(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_top_margin(text_view: [*c]GtkTextView, top_margin: c_int) void;
pub extern fn gtk_text_view_get_top_margin(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_bottom_margin(text_view: [*c]GtkTextView, bottom_margin: c_int) void;
pub extern fn gtk_text_view_get_bottom_margin(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_indent(text_view: [*c]GtkTextView, indent: c_int) void;
pub extern fn gtk_text_view_get_indent(text_view: [*c]GtkTextView) c_int;
pub extern fn gtk_text_view_set_tabs(text_view: [*c]GtkTextView, tabs: ?*PangoTabArray) void;
pub extern fn gtk_text_view_get_tabs(text_view: [*c]GtkTextView) ?*PangoTabArray;
pub extern fn gtk_text_view_set_input_purpose(text_view: [*c]GtkTextView, purpose: GtkInputPurpose) void;
pub extern fn gtk_text_view_get_input_purpose(text_view: [*c]GtkTextView) GtkInputPurpose;
pub extern fn gtk_text_view_set_input_hints(text_view: [*c]GtkTextView, hints: GtkInputHints) void;
pub extern fn gtk_text_view_get_input_hints(text_view: [*c]GtkTextView) GtkInputHints;
pub extern fn gtk_text_view_set_monospace(text_view: [*c]GtkTextView, monospace: gboolean) void;
pub extern fn gtk_text_view_get_monospace(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_extra_menu(text_view: [*c]GtkTextView, model: [*c]GMenuModel) void;
pub extern fn gtk_text_view_get_extra_menu(text_view: [*c]GtkTextView) [*c]GMenuModel;
pub extern fn gtk_text_view_get_rtl_context(text_view: [*c]GtkTextView) ?*PangoContext;
pub extern fn gtk_text_view_get_ltr_context(text_view: [*c]GtkTextView) ?*PangoContext;
pub const GtkTextView_autoptr = [*c]GtkTextView;
pub const GtkTextView_listautoptr = [*c]GList;
pub const GtkTextView_slistautoptr = [*c]GSList;
pub const GtkTextView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextView(arg__ptr: [*c]GtkTextView) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTextView(arg__ptr: [*c][*c]GtkTextView) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTextView(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTextView(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTextView(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTextView(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_test_accessible_has_role(accessible: ?*GtkAccessible, role: GtkAccessibleRole) gboolean;
pub extern fn gtk_test_accessible_has_property(accessible: ?*GtkAccessible, property: GtkAccessibleProperty) gboolean;
pub extern fn gtk_test_accessible_has_relation(accessible: ?*GtkAccessible, relation: GtkAccessibleRelation) gboolean;
pub extern fn gtk_test_accessible_has_state(accessible: ?*GtkAccessible, state: GtkAccessibleState) gboolean;
pub extern fn gtk_test_accessible_check_property(accessible: ?*GtkAccessible, property: GtkAccessibleProperty, ...) [*c]u8;
pub extern fn gtk_test_accessible_check_relation(accessible: ?*GtkAccessible, relation: GtkAccessibleRelation, ...) [*c]u8;
pub extern fn gtk_test_accessible_check_state(accessible: ?*GtkAccessible, state: GtkAccessibleState, ...) [*c]u8;
pub extern fn gtk_test_accessible_assertion_message_role(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, accessible: ?*GtkAccessible, expected_role: GtkAccessibleRole, actual_role: GtkAccessibleRole) void;
pub extern fn gtk_test_init(argcp: [*c]c_int, argvp: [*c][*c][*c]u8, ...) void;
pub extern fn gtk_test_register_all_types() void;
pub extern fn gtk_test_list_all_types(n_types: [*c]guint) [*c]const GType;
pub extern fn gtk_test_widget_wait_for_draw(widget: [*c]GtkWidget) void;
pub extern fn gtk_tree_row_data_get_type() GType;
pub const struct__GtkTreeDragSource = opaque {};
pub const GtkTreeDragSource = struct__GtkTreeDragSource;
pub const struct__GtkTreeDragSourceIface = extern struct {
    g_iface: GTypeInterface,
    row_draggable: ?*const fn (?*GtkTreeDragSource, ?*GtkTreePath) callconv(.C) gboolean,
    drag_data_get: ?*const fn (?*GtkTreeDragSource, ?*GtkTreePath) callconv(.C) [*c]GdkContentProvider,
    drag_data_delete: ?*const fn (?*GtkTreeDragSource, ?*GtkTreePath) callconv(.C) gboolean,
};
pub const GtkTreeDragSourceIface = struct__GtkTreeDragSourceIface;
pub extern fn gtk_tree_drag_source_get_type() GType;
pub extern fn gtk_tree_drag_source_row_draggable(drag_source: ?*GtkTreeDragSource, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_drag_source_drag_data_delete(drag_source: ?*GtkTreeDragSource, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_drag_source_drag_data_get(drag_source: ?*GtkTreeDragSource, path: ?*GtkTreePath) [*c]GdkContentProvider;
pub const struct__GtkTreeDragDest = opaque {};
pub const GtkTreeDragDest = struct__GtkTreeDragDest;
pub const struct__GtkTreeDragDestIface = extern struct {
    g_iface: GTypeInterface,
    drag_data_received: ?*const fn (?*GtkTreeDragDest, ?*GtkTreePath, [*c]const GValue) callconv(.C) gboolean,
    row_drop_possible: ?*const fn (?*GtkTreeDragDest, ?*GtkTreePath, [*c]const GValue) callconv(.C) gboolean,
};
pub const GtkTreeDragDestIface = struct__GtkTreeDragDestIface;
pub extern fn gtk_tree_drag_dest_get_type() GType;
pub extern fn gtk_tree_drag_dest_drag_data_received(drag_dest: ?*GtkTreeDragDest, dest: ?*GtkTreePath, value: [*c]const GValue) gboolean;
pub extern fn gtk_tree_drag_dest_row_drop_possible(drag_dest: ?*GtkTreeDragDest, dest_path: ?*GtkTreePath, value: [*c]const GValue) gboolean;
pub extern fn gtk_tree_create_row_drag_content(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath) [*c]GdkContentProvider;
pub extern fn gtk_tree_get_row_drag_data(value: [*c]const GValue, tree_model: [*c]?*GtkTreeModel, path: [*c]?*GtkTreePath) gboolean;
pub const GtkTreeDragDest_autoptr = ?*GtkTreeDragDest;
pub const GtkTreeDragDest_listautoptr = [*c]GList;
pub const GtkTreeDragDest_slistautoptr = [*c]GSList;
pub const GtkTreeDragDest_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeDragDest(arg__ptr: ?*GtkTreeDragDest) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeDragDest(arg__ptr: [*c]?*GtkTreeDragDest) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeDragDest(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeDragDest(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeDragDest(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeDragDest(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkTreeDragSource_autoptr = ?*GtkTreeDragSource;
pub const GtkTreeDragSource_listautoptr = [*c]GList;
pub const GtkTreeDragSource_slistautoptr = [*c]GSList;
pub const GtkTreeDragSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeDragSource(arg__ptr: ?*GtkTreeDragSource) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeDragSource(arg__ptr: [*c]?*GtkTreeDragSource) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeDragSource(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeDragSource(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeDragSource(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeDragSource(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_tree_list_model_get_type() GType;
pub const struct__GtkTreeListModel = opaque {};
pub const GtkTreeListModel = struct__GtkTreeListModel;
pub const GtkTreeListModelClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkTreeListModel_autoptr = ?*GtkTreeListModel;
pub const GtkTreeListModel_listautoptr = [*c]GList;
pub const GtkTreeListModel_slistautoptr = [*c]GSList;
pub const GtkTreeListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeListModel(arg__ptr: ?*GtkTreeListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeListModel(arg__ptr: [*c]?*GtkTreeListModel) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeListModel(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeListModel(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeListModel(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeListModel(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkTreeListModelClass_autoptr = [*c]GtkTreeListModelClass;
pub const GtkTreeListModelClass_listautoptr = [*c]GList;
pub const GtkTreeListModelClass_slistautoptr = [*c]GSList;
pub const GtkTreeListModelClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeListModelClass(arg__ptr: [*c]GtkTreeListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeListModelClass(arg__ptr: [*c][*c]GtkTreeListModelClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeListModelClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeListModelClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeListModelClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeListModelClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_TREE_LIST_MODEL(arg_ptr: gpointer) callconv(.C) ?*GtkTreeListModel {
    var ptr = arg_ptr;
    return @as(?*GtkTreeListModel, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_tree_list_model_get_type())))));
}
pub fn GTK_IS_TREE_LIST_MODEL(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_tree_list_model_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_tree_list_row_get_type() GType;
pub const struct__GtkTreeListRow = opaque {};
pub const GtkTreeListRow = struct__GtkTreeListRow;
pub const GtkTreeListRowClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkTreeListRow_autoptr = ?*GtkTreeListRow;
pub const GtkTreeListRow_listautoptr = [*c]GList;
pub const GtkTreeListRow_slistautoptr = [*c]GSList;
pub const GtkTreeListRow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeListRow(arg__ptr: ?*GtkTreeListRow) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeListRow(arg__ptr: [*c]?*GtkTreeListRow) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeListRow(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeListRow(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeListRow(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeListRow(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkTreeListRowClass_autoptr = [*c]GtkTreeListRowClass;
pub const GtkTreeListRowClass_listautoptr = [*c]GList;
pub const GtkTreeListRowClass_slistautoptr = [*c]GSList;
pub const GtkTreeListRowClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeListRowClass(arg__ptr: [*c]GtkTreeListRowClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeListRowClass(arg__ptr: [*c][*c]GtkTreeListRowClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeListRowClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeListRowClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeListRowClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeListRowClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_TREE_LIST_ROW(arg_ptr: gpointer) callconv(.C) ?*GtkTreeListRow {
    var ptr = arg_ptr;
    return @as(?*GtkTreeListRow, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_tree_list_row_get_type())))));
}
pub fn GTK_IS_TREE_LIST_ROW(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_tree_list_row_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub const GtkTreeListModelCreateModelFunc = ?*const fn (gpointer, gpointer) callconv(.C) ?*GListModel;
pub extern fn gtk_tree_list_model_new(root: ?*GListModel, passthrough: gboolean, autoexpand: gboolean, create_func: GtkTreeListModelCreateModelFunc, user_data: gpointer, user_destroy: GDestroyNotify) ?*GtkTreeListModel;
pub extern fn gtk_tree_list_model_get_model(self: ?*GtkTreeListModel) ?*GListModel;
pub extern fn gtk_tree_list_model_get_passthrough(self: ?*GtkTreeListModel) gboolean;
pub extern fn gtk_tree_list_model_set_autoexpand(self: ?*GtkTreeListModel, autoexpand: gboolean) void;
pub extern fn gtk_tree_list_model_get_autoexpand(self: ?*GtkTreeListModel) gboolean;
pub extern fn gtk_tree_list_model_get_child_row(self: ?*GtkTreeListModel, position: guint) ?*GtkTreeListRow;
pub extern fn gtk_tree_list_model_get_row(self: ?*GtkTreeListModel, position: guint) ?*GtkTreeListRow;
pub extern fn gtk_tree_list_row_get_item(self: ?*GtkTreeListRow) gpointer;
pub extern fn gtk_tree_list_row_set_expanded(self: ?*GtkTreeListRow, expanded: gboolean) void;
pub extern fn gtk_tree_list_row_get_expanded(self: ?*GtkTreeListRow) gboolean;
pub extern fn gtk_tree_list_row_is_expandable(self: ?*GtkTreeListRow) gboolean;
pub extern fn gtk_tree_list_row_get_position(self: ?*GtkTreeListRow) guint;
pub extern fn gtk_tree_list_row_get_depth(self: ?*GtkTreeListRow) guint;
pub extern fn gtk_tree_list_row_get_children(self: ?*GtkTreeListRow) ?*GListModel;
pub extern fn gtk_tree_list_row_get_parent(self: ?*GtkTreeListRow) ?*GtkTreeListRow;
pub extern fn gtk_tree_list_row_get_child_row(self: ?*GtkTreeListRow, position: guint) ?*GtkTreeListRow;
pub extern fn gtk_tree_expander_get_type() GType;
pub const struct__GtkTreeExpander = opaque {};
pub const GtkTreeExpander = struct__GtkTreeExpander;
pub const GtkTreeExpanderClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkTreeExpander_autoptr = ?*GtkTreeExpander;
pub const GtkTreeExpander_listautoptr = [*c]GList;
pub const GtkTreeExpander_slistautoptr = [*c]GSList;
pub const GtkTreeExpander_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeExpander(arg__ptr: ?*GtkTreeExpander) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeExpander(arg__ptr: [*c]?*GtkTreeExpander) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeExpander(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeExpander(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeExpander(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeExpander(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkTreeExpanderClass_autoptr = [*c]GtkTreeExpanderClass;
pub const GtkTreeExpanderClass_listautoptr = [*c]GList;
pub const GtkTreeExpanderClass_slistautoptr = [*c]GSList;
pub const GtkTreeExpanderClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeExpanderClass(arg__ptr: [*c]GtkTreeExpanderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeExpanderClass(arg__ptr: [*c][*c]GtkTreeExpanderClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeExpanderClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeExpanderClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeExpanderClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeExpanderClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_TREE_EXPANDER(arg_ptr: gpointer) callconv(.C) ?*GtkTreeExpander {
    var ptr = arg_ptr;
    return @as(?*GtkTreeExpander, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_tree_expander_get_type())))));
}
pub fn GTK_IS_TREE_EXPANDER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_tree_expander_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_tree_expander_new() [*c]GtkWidget;
pub extern fn gtk_tree_expander_get_child(self: ?*GtkTreeExpander) [*c]GtkWidget;
pub extern fn gtk_tree_expander_set_child(self: ?*GtkTreeExpander, child: [*c]GtkWidget) void;
pub extern fn gtk_tree_expander_get_item(self: ?*GtkTreeExpander) gpointer;
pub extern fn gtk_tree_expander_get_list_row(self: ?*GtkTreeExpander) ?*GtkTreeListRow;
pub extern fn gtk_tree_expander_set_list_row(self: ?*GtkTreeExpander, list_row: ?*GtkTreeListRow) void;
pub extern fn gtk_tree_expander_get_indent_for_depth(self: ?*GtkTreeExpander) gboolean;
pub extern fn gtk_tree_expander_set_indent_for_depth(self: ?*GtkTreeExpander, indent_for_depth: gboolean) void;
pub extern fn gtk_tree_expander_get_indent_for_icon(self: ?*GtkTreeExpander) gboolean;
pub extern fn gtk_tree_expander_set_indent_for_icon(self: ?*GtkTreeExpander, indent_for_icon: gboolean) void;
pub extern fn gtk_tree_expander_get_hide_expander(self: ?*GtkTreeExpander) gboolean;
pub extern fn gtk_tree_expander_set_hide_expander(self: ?*GtkTreeExpander, hide_expander: gboolean) void;
pub extern fn gtk_tree_list_row_sorter_get_type() GType;
pub const struct__GtkTreeListRowSorter = opaque {};
pub const GtkTreeListRowSorter = struct__GtkTreeListRowSorter;
pub const GtkTreeListRowSorterClass = extern struct {
    parent_class: GtkSorterClass,
};
pub const GtkTreeListRowSorter_autoptr = ?*GtkTreeListRowSorter;
pub const GtkTreeListRowSorter_listautoptr = [*c]GList;
pub const GtkTreeListRowSorter_slistautoptr = [*c]GSList;
pub const GtkTreeListRowSorter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeListRowSorter(arg__ptr: ?*GtkTreeListRowSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkSorter(@as([*c]GtkSorter, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeListRowSorter(arg__ptr: [*c]?*GtkTreeListRowSorter) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeListRowSorter(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeListRowSorter(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeListRowSorter(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeListRowSorter(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkSorter)))))));
    }
}
pub const GtkTreeListRowSorterClass_autoptr = [*c]GtkTreeListRowSorterClass;
pub const GtkTreeListRowSorterClass_listautoptr = [*c]GList;
pub const GtkTreeListRowSorterClass_slistautoptr = [*c]GSList;
pub const GtkTreeListRowSorterClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeListRowSorterClass(arg__ptr: [*c]GtkTreeListRowSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeListRowSorterClass(arg__ptr: [*c][*c]GtkTreeListRowSorterClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeListRowSorterClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeListRowSorterClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeListRowSorterClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeListRowSorterClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_TREE_LIST_ROW_SORTER(arg_ptr: gpointer) callconv(.C) ?*GtkTreeListRowSorter {
    var ptr = arg_ptr;
    return @as(?*GtkTreeListRowSorter, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_tree_list_row_sorter_get_type())))));
}
pub fn GTK_IS_TREE_LIST_ROW_SORTER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_tree_list_row_sorter_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_tree_list_row_sorter_new(sorter: [*c]GtkSorter) ?*GtkTreeListRowSorter;
pub extern fn gtk_tree_list_row_sorter_get_sorter(self: ?*GtkTreeListRowSorter) [*c]GtkSorter;
pub extern fn gtk_tree_list_row_sorter_set_sorter(self: ?*GtkTreeListRowSorter, sorter: [*c]GtkSorter) void;
pub const struct__GtkTreeModelSortPrivate = opaque {};
pub const GtkTreeModelSortPrivate = struct__GtkTreeModelSortPrivate;
pub const struct__GtkTreeModelSort = extern struct {
    parent: GObject,
    priv: ?*GtkTreeModelSortPrivate,
};
pub const GtkTreeModelSort = struct__GtkTreeModelSort;
pub const struct__GtkTreeModelSortClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GtkTreeModelSortClass = struct__GtkTreeModelSortClass;
pub extern fn gtk_tree_model_sort_get_type() GType;
pub extern fn gtk_tree_model_sort_new_with_model(child_model: ?*GtkTreeModel) ?*GtkTreeModel;
pub extern fn gtk_tree_model_sort_get_model(tree_model: [*c]GtkTreeModelSort) ?*GtkTreeModel;
pub extern fn gtk_tree_model_sort_convert_child_path_to_path(tree_model_sort: [*c]GtkTreeModelSort, child_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_sort_convert_child_iter_to_iter(tree_model_sort: [*c]GtkTreeModelSort, sort_iter: [*c]GtkTreeIter, child_iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_sort_convert_path_to_child_path(tree_model_sort: [*c]GtkTreeModelSort, sorted_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_sort_convert_iter_to_child_iter(tree_model_sort: [*c]GtkTreeModelSort, child_iter: [*c]GtkTreeIter, sorted_iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_sort_reset_default_sort_func(tree_model_sort: [*c]GtkTreeModelSort) void;
pub extern fn gtk_tree_model_sort_clear_cache(tree_model_sort: [*c]GtkTreeModelSort) void;
pub extern fn gtk_tree_model_sort_iter_is_valid(tree_model_sort: [*c]GtkTreeModelSort, iter: [*c]GtkTreeIter) gboolean;
pub const GtkTreeModelSort_autoptr = [*c]GtkTreeModelSort;
pub const GtkTreeModelSort_listautoptr = [*c]GList;
pub const GtkTreeModelSort_slistautoptr = [*c]GSList;
pub const GtkTreeModelSort_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeModelSort(arg__ptr: [*c]GtkTreeModelSort) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeModelSort(arg__ptr: [*c][*c]GtkTreeModelSort) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeModelSort(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeModelSort(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeModelSort(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeModelSort(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const GtkTreeSelectionFunc = ?*const fn (?*GtkTreeSelection, ?*GtkTreeModel, ?*GtkTreePath, gboolean, gpointer) callconv(.C) gboolean;
pub const GtkTreeSelectionForeachFunc = ?*const fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter, gpointer) callconv(.C) void;
pub extern fn gtk_tree_selection_get_type() GType;
pub extern fn gtk_tree_selection_set_mode(selection: ?*GtkTreeSelection, @"type": GtkSelectionMode) void;
pub extern fn gtk_tree_selection_get_mode(selection: ?*GtkTreeSelection) GtkSelectionMode;
pub extern fn gtk_tree_selection_set_select_function(selection: ?*GtkTreeSelection, func: GtkTreeSelectionFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_selection_get_user_data(selection: ?*GtkTreeSelection) gpointer;
pub extern fn gtk_tree_selection_get_tree_view(selection: ?*GtkTreeSelection) [*c]GtkTreeView;
pub extern fn gtk_tree_selection_get_select_function(selection: ?*GtkTreeSelection) GtkTreeSelectionFunc;
pub extern fn gtk_tree_selection_get_selected(selection: ?*GtkTreeSelection, model: [*c]?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_selection_get_selected_rows(selection: ?*GtkTreeSelection, model: [*c]?*GtkTreeModel) [*c]GList;
pub extern fn gtk_tree_selection_count_selected_rows(selection: ?*GtkTreeSelection) c_int;
pub extern fn gtk_tree_selection_selected_foreach(selection: ?*GtkTreeSelection, func: GtkTreeSelectionForeachFunc, data: gpointer) void;
pub extern fn gtk_tree_selection_select_path(selection: ?*GtkTreeSelection, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_selection_unselect_path(selection: ?*GtkTreeSelection, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_selection_select_iter(selection: ?*GtkTreeSelection, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_selection_unselect_iter(selection: ?*GtkTreeSelection, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_selection_path_is_selected(selection: ?*GtkTreeSelection, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_selection_iter_is_selected(selection: ?*GtkTreeSelection, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_selection_select_all(selection: ?*GtkTreeSelection) void;
pub extern fn gtk_tree_selection_unselect_all(selection: ?*GtkTreeSelection) void;
pub extern fn gtk_tree_selection_select_range(selection: ?*GtkTreeSelection, start_path: ?*GtkTreePath, end_path: ?*GtkTreePath) void;
pub extern fn gtk_tree_selection_unselect_range(selection: ?*GtkTreeSelection, start_path: ?*GtkTreePath, end_path: ?*GtkTreePath) void;
pub const GtkTreeSelection_autoptr = ?*GtkTreeSelection;
pub const GtkTreeSelection_listautoptr = [*c]GList;
pub const GtkTreeSelection_slistautoptr = [*c]GSList;
pub const GtkTreeSelection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeSelection(arg__ptr: ?*GtkTreeSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeSelection(arg__ptr: [*c]?*GtkTreeSelection) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeSelection(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeSelection(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeSelection(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeSelection(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkTreeStorePrivate = opaque {};
pub const GtkTreeStorePrivate = struct__GtkTreeStorePrivate;
pub const struct__GtkTreeStore = extern struct {
    parent: GObject,
    priv: ?*GtkTreeStorePrivate,
};
pub const GtkTreeStore = struct__GtkTreeStore;
pub const struct__GtkTreeStoreClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GtkTreeStoreClass = struct__GtkTreeStoreClass;
pub extern fn gtk_tree_store_get_type() GType;
pub extern fn gtk_tree_store_new(n_columns: c_int, ...) [*c]GtkTreeStore;
pub extern fn gtk_tree_store_newv(n_columns: c_int, types: [*c]GType) [*c]GtkTreeStore;
pub extern fn gtk_tree_store_set_column_types(tree_store: [*c]GtkTreeStore, n_columns: c_int, types: [*c]GType) void;
pub extern fn gtk_tree_store_set_value(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, column: c_int, value: [*c]GValue) void;
pub extern fn gtk_tree_store_set(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, ...) void;
pub extern fn gtk_tree_store_set_valuesv(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, columns: [*c]c_int, values: [*c]GValue, n_values: c_int) void;
pub extern fn gtk_tree_store_set_valist(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, var_args: [*c]struct___va_list_tag) void;
pub extern fn gtk_tree_store_remove(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_store_insert(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, position: c_int) void;
pub extern fn gtk_tree_store_insert_before(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_insert_after(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_insert_with_values(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, position: c_int, ...) void;
pub extern fn gtk_tree_store_insert_with_valuesv(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, position: c_int, columns: [*c]c_int, values: [*c]GValue, n_values: c_int) void;
pub extern fn gtk_tree_store_prepend(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_append(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_is_ancestor(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, descendant: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_store_iter_depth(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter) c_int;
pub extern fn gtk_tree_store_clear(tree_store: [*c]GtkTreeStore) void;
pub extern fn gtk_tree_store_iter_is_valid(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_store_reorder(tree_store: [*c]GtkTreeStore, parent: [*c]GtkTreeIter, new_order: [*c]c_int) void;
pub extern fn gtk_tree_store_swap(tree_store: [*c]GtkTreeStore, a: [*c]GtkTreeIter, b: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_move_before(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_move_after(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub const GtkTreeStore_autoptr = [*c]GtkTreeStore;
pub const GtkTreeStore_listautoptr = [*c]GList;
pub const GtkTreeStore_slistautoptr = [*c]GSList;
pub const GtkTreeStore_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeStore(arg__ptr: [*c]GtkTreeStore) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkTreeStore(arg__ptr: [*c][*c]GtkTreeStore) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkTreeStore(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeStore(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeStore(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeStore(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_uri_launcher_get_type() GType;
pub const struct__GtkUriLauncher = opaque {};
pub const GtkUriLauncher = struct__GtkUriLauncher;
pub const GtkUriLauncherClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkUriLauncher_autoptr = ?*GtkUriLauncher;
pub const GtkUriLauncher_listautoptr = [*c]GList;
pub const GtkUriLauncher_slistautoptr = [*c]GSList;
pub const GtkUriLauncher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkUriLauncher(arg__ptr: ?*GtkUriLauncher) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkUriLauncher(arg__ptr: [*c]?*GtkUriLauncher) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkUriLauncher(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkUriLauncher(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkUriLauncher(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkUriLauncher(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkUriLauncherClass_autoptr = [*c]GtkUriLauncherClass;
pub const GtkUriLauncherClass_listautoptr = [*c]GList;
pub const GtkUriLauncherClass_slistautoptr = [*c]GSList;
pub const GtkUriLauncherClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkUriLauncherClass(arg__ptr: [*c]GtkUriLauncherClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkUriLauncherClass(arg__ptr: [*c][*c]GtkUriLauncherClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkUriLauncherClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkUriLauncherClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkUriLauncherClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkUriLauncherClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_URI_LAUNCHER(arg_ptr: gpointer) callconv(.C) ?*GtkUriLauncher {
    var ptr = arg_ptr;
    return @as(?*GtkUriLauncher, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_uri_launcher_get_type())))));
}
pub fn GTK_IS_URI_LAUNCHER(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_uri_launcher_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_uri_launcher_new(uri: [*c]const u8) ?*GtkUriLauncher;
pub extern fn gtk_uri_launcher_get_uri(self: ?*GtkUriLauncher) [*c]const u8;
pub extern fn gtk_uri_launcher_set_uri(self: ?*GtkUriLauncher, uri: [*c]const u8) void;
pub extern fn gtk_uri_launcher_launch(self: ?*GtkUriLauncher, parent: [*c]GtkWindow, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_uri_launcher_launch_finish(self: ?*GtkUriLauncher, result: ?*GAsyncResult, @"error": [*c][*c]GError) gboolean;
pub extern fn gtk_get_major_version() guint;
pub extern fn gtk_get_minor_version() guint;
pub extern fn gtk_get_micro_version() guint;
pub extern fn gtk_get_binary_age() guint;
pub extern fn gtk_get_interface_age() guint;
pub extern fn gtk_check_version(required_major: guint, required_minor: guint, required_micro: guint) [*c]const u8;
pub extern fn gtk_video_get_type() GType;
pub const struct__GtkVideo = opaque {};
pub const GtkVideo = struct__GtkVideo;
pub const GtkVideoClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkVideo_autoptr = ?*GtkVideo;
pub const GtkVideo_listautoptr = [*c]GList;
pub const GtkVideo_slistautoptr = [*c]GSList;
pub const GtkVideo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkVideo(arg__ptr: ?*GtkVideo) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkVideo(arg__ptr: [*c]?*GtkVideo) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkVideo(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkVideo(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkVideo(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkVideo(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkVideoClass_autoptr = [*c]GtkVideoClass;
pub const GtkVideoClass_listautoptr = [*c]GList;
pub const GtkVideoClass_slistautoptr = [*c]GSList;
pub const GtkVideoClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkVideoClass(arg__ptr: [*c]GtkVideoClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkVideoClass(arg__ptr: [*c][*c]GtkVideoClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkVideoClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkVideoClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkVideoClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkVideoClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_VIDEO(arg_ptr: gpointer) callconv(.C) ?*GtkVideo {
    var ptr = arg_ptr;
    return @as(?*GtkVideo, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_video_get_type())))));
}
pub fn GTK_IS_VIDEO(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_video_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_video_new() [*c]GtkWidget;
pub extern fn gtk_video_new_for_media_stream(stream: [*c]GtkMediaStream) [*c]GtkWidget;
pub extern fn gtk_video_new_for_file(file: ?*GFile) [*c]GtkWidget;
pub extern fn gtk_video_new_for_filename(filename: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_video_new_for_resource(resource_path: [*c]const u8) [*c]GtkWidget;
pub extern fn gtk_video_get_media_stream(self: ?*GtkVideo) [*c]GtkMediaStream;
pub extern fn gtk_video_set_media_stream(self: ?*GtkVideo, stream: [*c]GtkMediaStream) void;
pub extern fn gtk_video_get_file(self: ?*GtkVideo) ?*GFile;
pub extern fn gtk_video_set_file(self: ?*GtkVideo, file: ?*GFile) void;
pub extern fn gtk_video_set_filename(self: ?*GtkVideo, filename: [*c]const u8) void;
pub extern fn gtk_video_set_resource(self: ?*GtkVideo, resource_path: [*c]const u8) void;
pub extern fn gtk_video_get_autoplay(self: ?*GtkVideo) gboolean;
pub extern fn gtk_video_set_autoplay(self: ?*GtkVideo, autoplay: gboolean) void;
pub extern fn gtk_video_get_loop(self: ?*GtkVideo) gboolean;
pub extern fn gtk_video_set_loop(self: ?*GtkVideo, loop: gboolean) void;
pub const struct__GtkViewport = opaque {};
pub const GtkViewport = struct__GtkViewport;
pub extern fn gtk_viewport_get_type() GType;
pub extern fn gtk_viewport_new(hadjustment: [*c]GtkAdjustment, vadjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_viewport_get_scroll_to_focus(viewport: ?*GtkViewport) gboolean;
pub extern fn gtk_viewport_set_scroll_to_focus(viewport: ?*GtkViewport, scroll_to_focus: gboolean) void;
pub extern fn gtk_viewport_set_child(viewport: ?*GtkViewport, child: [*c]GtkWidget) void;
pub extern fn gtk_viewport_get_child(viewport: ?*GtkViewport) [*c]GtkWidget;
pub extern fn gtk_viewport_scroll_to(viewport: ?*GtkViewport, descendant: [*c]GtkWidget, scroll: ?*GtkScrollInfo) void;
pub const GtkViewport_autoptr = ?*GtkViewport;
pub const GtkViewport_listautoptr = [*c]GList;
pub const GtkViewport_slistautoptr = [*c]GSList;
pub const GtkViewport_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkViewport(arg__ptr: ?*GtkViewport) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkViewport(arg__ptr: [*c]?*GtkViewport) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkViewport(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkViewport(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkViewport(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkViewport(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub const struct__GtkVolumeButton = extern struct {
    parent: GtkScaleButton,
};
pub const GtkVolumeButton = struct__GtkVolumeButton;
pub extern fn gtk_volume_button_get_type() GType;
pub extern fn gtk_volume_button_new() [*c]GtkWidget;
pub const GtkVolumeButton_autoptr = [*c]GtkVolumeButton;
pub const GtkVolumeButton_listautoptr = [*c]GList;
pub const GtkVolumeButton_slistautoptr = [*c]GSList;
pub const GtkVolumeButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkVolumeButton(arg__ptr: [*c]GtkVolumeButton) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_object_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkVolumeButton(arg__ptr: [*c][*c]GtkVolumeButton) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkVolumeButton(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkVolumeButton(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkVolumeButton(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkVolumeButton(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_object_unref)))))));
    }
}
pub extern fn gtk_widget_paintable_get_type() GType;
pub const struct__GtkWidgetPaintable = opaque {};
pub const GtkWidgetPaintable = struct__GtkWidgetPaintable;
pub const GtkWidgetPaintableClass = extern struct {
    parent_class: GObjectClass,
};
pub const GtkWidgetPaintable_autoptr = ?*GtkWidgetPaintable;
pub const GtkWidgetPaintable_listautoptr = [*c]GList;
pub const GtkWidgetPaintable_slistautoptr = [*c]GSList;
pub const GtkWidgetPaintable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWidgetPaintable(arg__ptr: ?*GtkWidgetPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GObject(@as([*c]GObject, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkWidgetPaintable(arg__ptr: [*c]?*GtkWidgetPaintable) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWidgetPaintable(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWidgetPaintable(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWidgetPaintable(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWidgetPaintable(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GObject)))))));
    }
}
pub const GtkWidgetPaintableClass_autoptr = [*c]GtkWidgetPaintableClass;
pub const GtkWidgetPaintableClass_listautoptr = [*c]GList;
pub const GtkWidgetPaintableClass_slistautoptr = [*c]GSList;
pub const GtkWidgetPaintableClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWidgetPaintableClass(arg__ptr: [*c]GtkWidgetPaintableClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkWidgetPaintableClass(arg__ptr: [*c][*c]GtkWidgetPaintableClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWidgetPaintableClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWidgetPaintableClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWidgetPaintableClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWidgetPaintableClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_WIDGET_PAINTABLE(arg_ptr: gpointer) callconv(.C) ?*GtkWidgetPaintable {
    var ptr = arg_ptr;
    return @as(?*GtkWidgetPaintable, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_widget_paintable_get_type())))));
}
pub fn GTK_IS_WIDGET_PAINTABLE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_widget_paintable_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_widget_paintable_new(widget: [*c]GtkWidget) ?*GdkPaintable;
pub extern fn gtk_widget_paintable_get_widget(self: ?*GtkWidgetPaintable) [*c]GtkWidget;
pub extern fn gtk_widget_paintable_set_widget(self: ?*GtkWidgetPaintable, widget: [*c]GtkWidget) void;
pub extern fn gtk_window_controls_get_type() GType;
pub const struct__GtkWindowControls = opaque {};
pub const GtkWindowControls = struct__GtkWindowControls;
pub const GtkWindowControlsClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkWindowControls_autoptr = ?*GtkWindowControls;
pub const GtkWindowControls_listautoptr = [*c]GList;
pub const GtkWindowControls_slistautoptr = [*c]GSList;
pub const GtkWindowControls_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindowControls(arg__ptr: ?*GtkWindowControls) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkWindowControls(arg__ptr: [*c]?*GtkWindowControls) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWindowControls(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWindowControls(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWindowControls(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWindowControls(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkWindowControlsClass_autoptr = [*c]GtkWindowControlsClass;
pub const GtkWindowControlsClass_listautoptr = [*c]GList;
pub const GtkWindowControlsClass_slistautoptr = [*c]GSList;
pub const GtkWindowControlsClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindowControlsClass(arg__ptr: [*c]GtkWindowControlsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkWindowControlsClass(arg__ptr: [*c][*c]GtkWindowControlsClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWindowControlsClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWindowControlsClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWindowControlsClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWindowControlsClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_WINDOW_CONTROLS(arg_ptr: gpointer) callconv(.C) ?*GtkWindowControls {
    var ptr = arg_ptr;
    return @as(?*GtkWindowControls, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_window_controls_get_type())))));
}
pub fn GTK_IS_WINDOW_CONTROLS(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_window_controls_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_window_controls_new(side: GtkPackType) [*c]GtkWidget;
pub extern fn gtk_window_controls_get_side(self: ?*GtkWindowControls) GtkPackType;
pub extern fn gtk_window_controls_set_side(self: ?*GtkWindowControls, side: GtkPackType) void;
pub extern fn gtk_window_controls_get_decoration_layout(self: ?*GtkWindowControls) [*c]const u8;
pub extern fn gtk_window_controls_set_decoration_layout(self: ?*GtkWindowControls, layout: [*c]const u8) void;
pub extern fn gtk_window_controls_get_empty(self: ?*GtkWindowControls) gboolean;
pub extern fn gtk_window_group_get_type() GType;
pub extern fn gtk_window_group_new() [*c]GtkWindowGroup;
pub extern fn gtk_window_group_add_window(window_group: [*c]GtkWindowGroup, window: [*c]GtkWindow) void;
pub extern fn gtk_window_group_remove_window(window_group: [*c]GtkWindowGroup, window: [*c]GtkWindow) void;
pub extern fn gtk_window_group_list_windows(window_group: [*c]GtkWindowGroup) [*c]GList;
pub extern fn gtk_window_handle_get_type() GType;
pub const struct__GtkWindowHandle = opaque {};
pub const GtkWindowHandle = struct__GtkWindowHandle;
pub const GtkWindowHandleClass = extern struct {
    parent_class: GtkWidgetClass,
};
pub const GtkWindowHandle_autoptr = ?*GtkWindowHandle;
pub const GtkWindowHandle_listautoptr = [*c]GList;
pub const GtkWindowHandle_slistautoptr = [*c]GSList;
pub const GtkWindowHandle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindowHandle(arg__ptr: ?*GtkWindowHandle) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        glib_autoptr_clear_GtkWidget(@as([*c]GtkWidget, @ptrCast(@alignCast(_ptr))));
    }
}
pub fn glib_autoptr_cleanup_GtkWindowHandle(arg__ptr: [*c]?*GtkWindowHandle) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWindowHandle(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWindowHandle(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWindowHandle(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWindowHandle(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&glib_autoptr_clear_GtkWidget)))))));
    }
}
pub const GtkWindowHandleClass_autoptr = [*c]GtkWindowHandleClass;
pub const GtkWindowHandleClass_listautoptr = [*c]GList;
pub const GtkWindowHandleClass_slistautoptr = [*c]GSList;
pub const GtkWindowHandleClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindowHandleClass(arg__ptr: [*c]GtkWindowHandleClass) callconv(.C) void {
    var _ptr = arg__ptr;
    if (_ptr != null) {
        g_type_class_unref(@as(gpointer, @ptrCast(_ptr)));
    }
}
pub fn glib_autoptr_cleanup_GtkWindowHandleClass(arg__ptr: [*c][*c]GtkWindowHandleClass) callconv(.C) void {
    var _ptr = arg__ptr;
    glib_autoptr_clear_GtkWindowHandleClass(_ptr.*);
}
pub fn glib_listautoptr_cleanup_GtkWindowHandleClass(arg__l: [*c][*c]GList) callconv(.C) void {
    var _l = arg__l;
    g_list_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_slistautoptr_cleanup_GtkWindowHandleClass(arg__l: [*c][*c]GSList) callconv(.C) void {
    var _l = arg__l;
    g_slist_free_full(_l.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
}
pub fn glib_queueautoptr_cleanup_GtkWindowHandleClass(arg__q: [*c][*c]GQueue) callconv(.C) void {
    var _q = arg__q;
    if (_q.* != null) {
        g_queue_free_full(_q.*, @as(GDestroyNotify, @ptrCast(@alignCast(@as(?*const fn () callconv(.C) void, @ptrCast(@alignCast(&g_type_class_unref)))))));
    }
}
pub fn GTK_WINDOW_HANDLE(arg_ptr: gpointer) callconv(.C) ?*GtkWindowHandle {
    var ptr = arg_ptr;
    return @as(?*GtkWindowHandle, @ptrCast(@as(?*anyopaque, @ptrCast(g_type_check_instance_cast(@as([*c]GTypeInstance, @ptrCast(@alignCast(ptr))), gtk_window_handle_get_type())))));
}
pub fn GTK_IS_WINDOW_HANDLE(arg_ptr: gpointer) callconv(.C) gboolean {
    var ptr = arg_ptr;
    return blk: {
        var __inst: [*c]GTypeInstance = @as([*c]GTypeInstance, @ptrCast(@alignCast(ptr)));
        var __t: GType = gtk_window_handle_get_type();
        var __r: gboolean = undefined;
        if (!(__inst != null)) {
            __r = @as(c_int, 0);
        } else if ((__inst.*.g_class != null) and (__inst.*.g_class.*.g_type == __t)) {
            __r = @intFromBool(!(@as(c_int, 0) != 0));
        } else {
            __r = g_type_check_instance_is_a(__inst, __t);
        }
        break :blk __r;
    };
}
pub extern fn gtk_window_handle_new() [*c]GtkWidget;
pub extern fn gtk_window_handle_get_child(self: ?*GtkWindowHandle) [*c]GtkWidget;
pub extern fn gtk_window_handle_set_child(self: ?*GtkWindowHandle, child: [*c]GtkWidget) void;
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`"); // (no file):80:9
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`"); // (no file):86:9
pub const __FLT16_DENORM_MIN__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):109:9
pub const __FLT16_EPSILON__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):113:9
pub const __FLT16_MAX__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):119:9
pub const __FLT16_MIN__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):122:9
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`"); // (no file):183:9
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`"); // (no file):205:9
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`"); // (no file):213:9
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // (no file):342:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // (no file):343:9
pub const offsetof = @compileError("unable to translate macro: undefined identifier `__builtin_offsetof`"); // /usr/lib/zig/include/stddef.h:111:9
pub const G_GNUC_EXTENSION = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/glib-2.0/glib/gmacros.h:62:9
pub const G_INLINE_FUNC = @compileError("unable to translate C expr: unexpected token 'static'"); // /usr/include/glib-2.0/glib/gmacros.h:157:11
pub const g_macro__has_attribute = @compileError("unable to translate macro: undefined identifier `__has_attribute`"); // /usr/include/glib-2.0/glib/gmacros.h:167:9
pub const G_GNUC_PURE = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:284:9
pub const G_GNUC_MALLOC = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:290:9
pub const G_GNUC_NO_INLINE = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:296:9
pub const G_GNUC_NULL_TERMINATED = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:323:9
pub const g_macro__has_feature = @compileError("unable to translate macro: undefined identifier `__has_feature`"); // /usr/include/glib-2.0/glib/gmacros.h:339:9
pub const g_macro__has_extension = @compileError("unable to translate macro: undefined identifier `__has_extension`"); // /usr/include/glib-2.0/glib/gmacros.h:351:9
pub const G_GNUC_ALLOC_SIZE = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:400:9
pub const G_GNUC_ALLOC_SIZE2 = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:401:9
pub const G_GNUC_PRINTF = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:596:9
pub const G_GNUC_SCANF = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:598:9
pub const G_GNUC_STRFTIME = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:600:9
pub const G_GNUC_FORMAT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:615:9
pub const G_GNUC_NORETURN = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:622:9
pub const G_GNUC_CONST = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:633:9
pub const G_GNUC_UNUSED = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:640:9
pub const G_GNUC_NO_INSTRUMENT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:647:9
pub const G_GNUC_FALLTHROUGH = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:682:9
pub const G_GNUC_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:708:9
pub const G_GNUC_DEPRECATED_FOR = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:737:9
pub const G_GNUC_BEGIN_IGNORE_DEPRECATIONS = @compileError("unable to translate macro: undefined identifier `_Pragma`"); // /usr/include/glib-2.0/glib/gmacros.h:764:9
pub const G_GNUC_END_IGNORE_DEPRECATIONS = @compileError("unable to translate macro: undefined identifier `_Pragma`"); // /usr/include/glib-2.0/glib/gmacros.h:767:9
pub const G_GNUC_MAY_ALIAS = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:787:9
pub const G_GNUC_WARN_UNUSED_RESULT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:811:9
pub const G_STRINGIFY_ARG = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/glib-2.0/glib/gmacros.h:861:9
pub const G_PASTE_ARGS = @compileError("unable to translate C expr: unexpected token '##'"); // /usr/include/glib-2.0/glib/gmacros.h:864:9
pub const G_STATIC_ASSERT = @compileError("unable to translate C expr: unexpected token '_Static_assert'"); // /usr/include/glib-2.0/glib/gmacros.h:870:9
pub const G_STATIC_ASSERT_EXPR = @compileError("unable to translate C expr: expected ')' instead got '['"); // /usr/include/glib-2.0/glib/gmacros.h:878:9
pub const G_STRLOC = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gmacros.h:885:9
pub const G_STRFUNC = @compileError("unable to translate macro: undefined identifier `__func__`"); // /usr/include/glib-2.0/glib/gmacros.h:892:9
pub const G_N_ELEMENTS = @compileError("unable to translate C expr: unexpected token '('"); // /usr/include/glib-2.0/glib/gmacros.h:950:9
pub const G_STRUCT_MEMBER = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/gmacros.h:971:9
pub const G_STMT_START = @compileError("unable to translate C expr: unexpected token 'do'"); // /usr/include/glib-2.0/glib/gmacros.h:984:9
pub const G_STMT_END = @compileError("unable to translate C expr: unexpected token 'while'"); // /usr/include/glib-2.0/glib/gmacros.h:992:9
pub const G_ALIGNOF = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gmacros.h:1020:9
pub const G_CONST_RETURN = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gmacros.h:1045:9
pub const G_NORETURN = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1077:10
pub const G_NORETURN_FUNCPTR = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1111:10
pub const G_ALWAYS_INLINE = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1154:12
pub const G_NO_INLINE = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1210:12
pub const G_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1262:9
pub const G_DEPRECATED_FOR = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1272:9
pub const G_UNAVAILABLE = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1280:9
pub const _GLIB_GNUC_DO_PRAGMA = @compileError("unable to translate macro: undefined identifier `_Pragma`"); // /usr/include/glib-2.0/glib/gmacros.h:1296:9
pub const GLIB_DEPRECATED_MACRO = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/glib-2.0/glib/gmacros.h:1297:9
pub const GLIB_DEPRECATED_MACRO_FOR = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/glib-2.0/glib/gmacros.h:1298:9
pub const GLIB_UNAVAILABLE_MACRO = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/glib-2.0/glib/gmacros.h:1300:9
pub const _GLIB_AUTOPTR_FUNC_NAME = @compileError("unable to translate macro: undefined identifier `glib_autoptr_cleanup_`"); // /usr/include/glib-2.0/glib/gmacros.h:1337:9
pub const _GLIB_AUTOPTR_CLEAR_FUNC_NAME = @compileError("unable to translate macro: undefined identifier `glib_autoptr_clear_`"); // /usr/include/glib-2.0/glib/gmacros.h:1338:9
pub const _GLIB_AUTOPTR_TYPENAME = @compileError("unable to translate macro: undefined identifier `_autoptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1339:9
pub const _GLIB_AUTOPTR_LIST_FUNC_NAME = @compileError("unable to translate macro: undefined identifier `glib_listautoptr_cleanup_`"); // /usr/include/glib-2.0/glib/gmacros.h:1340:9
pub const _GLIB_AUTOPTR_LIST_TYPENAME = @compileError("unable to translate macro: undefined identifier `_listautoptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1341:9
pub const _GLIB_AUTOPTR_SLIST_FUNC_NAME = @compileError("unable to translate macro: undefined identifier `glib_slistautoptr_cleanup_`"); // /usr/include/glib-2.0/glib/gmacros.h:1342:9
pub const _GLIB_AUTOPTR_SLIST_TYPENAME = @compileError("unable to translate macro: undefined identifier `_slistautoptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1343:9
pub const _GLIB_AUTOPTR_QUEUE_FUNC_NAME = @compileError("unable to translate macro: undefined identifier `glib_queueautoptr_cleanup_`"); // /usr/include/glib-2.0/glib/gmacros.h:1344:9
pub const _GLIB_AUTOPTR_QUEUE_TYPENAME = @compileError("unable to translate macro: undefined identifier `_queueautoptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1345:9
pub const _GLIB_AUTO_FUNC_NAME = @compileError("unable to translate macro: undefined identifier `glib_auto_cleanup_`"); // /usr/include/glib-2.0/glib/gmacros.h:1346:9
pub const _GLIB_CLEANUP = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/gmacros.h:1347:9
pub const _GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS = @compileError("unable to translate macro: undefined identifier `_ptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1348:9
pub const G_DEFINE_AUTO_CLEANUP_CLEAR_FUNC = @compileError("unable to translate macro: undefined identifier `_ptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1372:9
pub const G_DEFINE_AUTO_CLEANUP_FREE_FUNC = @compileError("unable to translate macro: undefined identifier `_ptr`"); // /usr/include/glib-2.0/glib/gmacros.h:1376:9
pub const g_autoptr = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gmacros.h:1380:9
pub const g_autolist = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gmacros.h:1381:9
pub const g_autoslist = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gmacros.h:1382:9
pub const g_autoqueue = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gmacros.h:1383:9
pub const g_auto = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gmacros.h:1384:9
pub const G_SIZEOF_MEMBER = @compileError("unable to translate C expr: unexpected token 'sizeof'"); // /usr/include/glib-2.0/glib/gmacros.h:1421:9
pub const __GLIBC_USE = @compileError("unable to translate macro: undefined identifier `__GLIBC_USE_`"); // /usr/include/features.h:188:9
pub const __glibc_has_attribute = @compileError("unable to translate macro: undefined identifier `__has_attribute`"); // /usr/include/sys/cdefs.h:45:10
pub const __glibc_has_extension = @compileError("unable to translate macro: undefined identifier `__has_extension`"); // /usr/include/sys/cdefs.h:55:10
pub const __THROW = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:79:11
pub const __THROWNL = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:80:11
pub const __NTH = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:81:11
pub const __NTHNL = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:82:11
pub const __COLD = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:102:11
pub const __CONCAT = @compileError("unable to translate C expr: unexpected token '##'"); // /usr/include/sys/cdefs.h:131:9
pub const __STRING = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/sys/cdefs.h:132:9
pub const __warnattr = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:216:10
pub const __errordecl = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/sys/cdefs.h:217:10
pub const __flexarr = @compileError("unable to translate C expr: unexpected token '['"); // /usr/include/sys/cdefs.h:225:10
pub const __REDIRECT = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/sys/cdefs.h:256:10
pub const __REDIRECT_NTH = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/sys/cdefs.h:263:11
pub const __REDIRECT_NTHNL = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/sys/cdefs.h:265:11
pub const __ASMNAME2 = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/sys/cdefs.h:269:10
pub const __attribute_malloc__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:298:10
pub const __attribute_alloc_size__ = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:309:10
pub const __attribute_alloc_align__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:315:10
pub const __attribute_pure__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:325:10
pub const __attribute_const__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:332:10
pub const __attribute_maybe_unused__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:338:10
pub const __attribute_used__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:347:10
pub const __attribute_noinline__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:348:10
pub const __attribute_deprecated__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:356:10
pub const __attribute_deprecated_msg__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:366:10
pub const __attribute_format_arg__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:379:10
pub const __attribute_format_strfmon__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:389:10
pub const __attribute_nonnull__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:401:11
pub const __returns_nonnull = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:414:10
pub const __attribute_warn_unused_result__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:423:10
pub const __always_inline = @compileError("unable to translate macro: undefined identifier `__inline`"); // /usr/include/sys/cdefs.h:441:10
pub const __attribute_artificial__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:450:10
pub const __extern_inline = @compileError("unable to translate macro: undefined identifier `__inline`"); // /usr/include/sys/cdefs.h:468:11
pub const __extern_always_inline = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:469:11
pub const __restrict_arr = @compileError("unable to translate macro: undefined identifier `__restrict`"); // /usr/include/sys/cdefs.h:512:10
pub const __attribute_copy__ = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:561:10
pub const __LDBL_REDIR2_DECL = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:638:10
pub const __LDBL_REDIR_DECL = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:639:10
pub const __glibc_macro_warning1 = @compileError("unable to translate macro: undefined identifier `_Pragma`"); // /usr/include/sys/cdefs.h:653:10
pub const __glibc_macro_warning = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/sys/cdefs.h:654:10
pub const __fortified_attr_access = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:699:11
pub const __attr_access = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:700:11
pub const __attr_access_none = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:701:11
pub const __attr_dealloc = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:711:10
pub const __attribute_returns_twice__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:718:10
pub const FLT_EVAL_METHOD = @compileError("unable to translate macro: undefined identifier `__FLT_EVAL_METHOD__`"); // /usr/lib/zig/include/float.h:91:9
pub const FLT_ROUNDS = @compileError("unable to translate macro: undefined identifier `__builtin_flt_rounds`"); // /usr/lib/zig/include/float.h:93:9
pub const G_GNUC_INTERNAL = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/lib/glib-2.0/include/glibconfig.h:146:9
pub const GLIB_SYSDEF_POLLIN = @compileError("unable to translate C expr: unexpected token '='"); // /usr/lib/glib-2.0/include/glibconfig.h:185:9
pub const GLIB_SYSDEF_POLLOUT = @compileError("unable to translate C expr: unexpected token '='"); // /usr/lib/glib-2.0/include/glibconfig.h:186:9
pub const GLIB_SYSDEF_POLLPRI = @compileError("unable to translate C expr: unexpected token '='"); // /usr/lib/glib-2.0/include/glibconfig.h:187:9
pub const GLIB_SYSDEF_POLLHUP = @compileError("unable to translate C expr: unexpected token '='"); // /usr/lib/glib-2.0/include/glibconfig.h:188:9
pub const GLIB_SYSDEF_POLLERR = @compileError("unable to translate C expr: unexpected token '='"); // /usr/lib/glib-2.0/include/glibconfig.h:189:9
pub const GLIB_SYSDEF_POLLNVAL = @compileError("unable to translate C expr: unexpected token '='"); // /usr/lib/glib-2.0/include/glibconfig.h:190:9
pub const _GLIB_EXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/glib/glib-visibility.h:7:11
pub const _GLIB_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/glib-2.0/glib/glib-visibility.h:19:9
pub const GLIB_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/glib-visibility.h:31:9
pub const GLIB_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/glib-visibility.h:32:9
pub const __STD_TYPE = @compileError("unable to translate C expr: unexpected token 'typedef'"); // /usr/include/bits/types.h:137:10
pub const __FSID_T_TYPE = @compileError("unable to translate macro: undefined identifier `__val`"); // /usr/include/bits/typesizes.h:73:9
pub const g_uint_checked_add = @compileError("unable to translate macro: undefined identifier `__builtin_add_overflow`"); // /usr/include/glib-2.0/glib/gtypes.h:461:9
pub const g_uint64_checked_add = @compileError("unable to translate macro: undefined identifier `__builtin_add_overflow`"); // /usr/include/glib-2.0/glib/gtypes.h:466:9
pub const g_size_checked_add = @compileError("unable to translate macro: undefined identifier `__builtin_add_overflow`"); // /usr/include/glib-2.0/glib/gtypes.h:471:9
pub const g_newa = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/galloca.h:131:9
pub const g_newa0 = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/galloca.h:145:9
pub const g_array_index = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/garray.h:69:9
pub const glib_typeof = @compileError("unable to translate macro: undefined identifier `__typeof__`"); // /usr/include/glib-2.0/glib/glib-typeof.h:39:9
pub const va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`"); // /usr/lib/zig/include/stdarg.h:33:9
pub const va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`"); // /usr/lib/zig/include/stdarg.h:35:9
pub const va_arg = @compileError("unable to translate macro: undefined identifier `__builtin_va_arg`"); // /usr/lib/zig/include/stdarg.h:36:9
pub const __va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`"); // /usr/lib/zig/include/stdarg.h:41:9
pub const va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`"); // /usr/lib/zig/include/stdarg.h:46:9
pub const G_DEFINE_QUARK = @compileError("unable to translate macro: undefined identifier `_quark`"); // /usr/include/glib-2.0/glib/gquark.h:51:9
pub const G_DEFINE_EXTENDED_ERROR = @compileError("unable to translate macro: undefined identifier `Private`"); // /usr/include/glib-2.0/glib/gerror.h:74:9
pub const g_memmove = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/glib/gutils.h:314:9
pub const ATEXIT = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/gutils.h:325:9
pub const __CFLOAT32 = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:149:12
pub const __CFLOAT64 = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:160:13
pub const __CFLOAT32X = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:169:12
pub const __CFLOAT64X = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:178:13
pub const __builtin_nansf32 = @compileError("unable to translate macro: undefined identifier `__builtin_nansf`"); // /usr/include/bits/floatn-common.h:221:12
pub const __builtin_huge_valf64 = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`"); // /usr/include/bits/floatn-common.h:255:13
pub const __builtin_inff64 = @compileError("unable to translate macro: undefined identifier `__builtin_inf`"); // /usr/include/bits/floatn-common.h:256:13
pub const __builtin_nanf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nan`"); // /usr/include/bits/floatn-common.h:257:13
pub const __builtin_nansf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nans`"); // /usr/include/bits/floatn-common.h:258:13
pub const __builtin_huge_valf32x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`"); // /usr/include/bits/floatn-common.h:272:12
pub const __builtin_inff32x = @compileError("unable to translate macro: undefined identifier `__builtin_inf`"); // /usr/include/bits/floatn-common.h:273:12
pub const __builtin_nanf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nan`"); // /usr/include/bits/floatn-common.h:274:12
pub const __builtin_nansf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nans`"); // /usr/include/bits/floatn-common.h:275:12
pub const __builtin_huge_valf64x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`"); // /usr/include/bits/floatn-common.h:289:13
pub const __builtin_inff64x = @compileError("unable to translate macro: undefined identifier `__builtin_infl`"); // /usr/include/bits/floatn-common.h:290:13
pub const __builtin_nanf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nanl`"); // /usr/include/bits/floatn-common.h:291:13
pub const __builtin_nansf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nansl`"); // /usr/include/bits/floatn-common.h:292:13
pub const __FD_ZERO = @compileError("unable to translate macro: undefined identifier `__i`"); // /usr/include/bits/select.h:25:9
pub const __FD_SET = @compileError("unable to translate C expr: expected ')' instead got '|='"); // /usr/include/bits/select.h:32:9
pub const __FD_CLR = @compileError("unable to translate C expr: expected ')' instead got '&='"); // /usr/include/bits/select.h:34:9
pub const __PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/bits/struct_mutex.h:56:10
pub const __PTHREAD_RWLOCK_ELISION_EXTRA = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/bits/struct_rwlock.h:40:11
pub const __ONCE_FLAG_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/bits/thread-shared-types.h:113:9
pub const G_WIN32_DLLMAIN_FOR_DLL_NAME = @compileError("unable to translate C expr: expected ')' instead got 'static'"); // /usr/include/glib-2.0/glib/gutils.h:451:10
pub const G_PRIVATE_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/gthread.h:88:9
pub const G_ONCE_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/gthread.h:104:9
pub const G_LOCK_NAME = @compileError("unable to translate macro: undefined identifier `g__`"); // /usr/include/glib-2.0/glib/gthread.h:111:9
pub const G_LOCK_DEFINE_STATIC = @compileError("unable to translate C expr: unexpected token 'static'"); // /usr/include/glib-2.0/glib/gthread.h:112:9
pub const G_LOCK_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/glib-2.0/glib/gthread.h:114:9
pub const g_once = @compileError("unable to translate macro: undefined identifier `__atomic_load_n`"); // /usr/include/glib-2.0/glib/gthread.h:249:10
pub const si_pid = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:128:9
pub const si_uid = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:129:9
pub const si_timerid = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:130:9
pub const si_overrun = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:131:9
pub const si_status = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:132:9
pub const si_utime = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:133:9
pub const si_stime = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:134:9
pub const si_value = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:135:9
pub const si_int = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:136:9
pub const si_ptr = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:137:9
pub const si_addr = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:138:9
pub const si_addr_lsb = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:139:9
pub const si_lower = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:140:9
pub const si_upper = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:141:9
pub const si_pkey = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:142:9
pub const si_band = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:143:9
pub const si_fd = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:144:9
pub const si_call_addr = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:146:10
pub const si_syscall = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:147:10
pub const si_arch = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:148:10
pub const sigev_notify_function = @compileError("unable to translate macro: undefined identifier `_sigev_un`"); // /usr/include/bits/types/sigevent_t.h:45:9
pub const sigev_notify_attributes = @compileError("unable to translate macro: undefined identifier `_sigev_un`"); // /usr/include/bits/types/sigevent_t.h:46:9
pub const sa_handler = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`"); // /usr/include/bits/sigaction.h:39:10
pub const sa_sigaction = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`"); // /usr/include/bits/sigaction.h:40:10
pub const G_BREAKPOINT = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/glib-2.0/glib/gbacktrace.h:59:11
pub const d_fileno = @compileError("unable to translate macro: undefined identifier `d_ino`"); // /usr/include/bits/dirent.h:47:9
pub const _G_NEW = @compileError("unable to translate macro: undefined identifier `g_`"); // /usr/include/glib-2.0/glib/gmem.h:292:9
pub const _G_RENEW = @compileError("unable to translate macro: undefined identifier `g_`"); // /usr/include/glib-2.0/glib/gmem.h:294:9
pub const g_new0 = @compileError("unable to translate macro: undefined identifier `malloc0`"); // /usr/include/glib-2.0/glib/gmem.h:332:9
pub const g_try_new = @compileError("unable to translate macro: undefined identifier `try_malloc`"); // /usr/include/glib-2.0/glib/gmem.h:360:9
pub const g_try_new0 = @compileError("unable to translate macro: undefined identifier `try_malloc0`"); // /usr/include/glib-2.0/glib/gmem.h:375:9
pub const g_try_renew = @compileError("unable to translate macro: undefined identifier `try_realloc`"); // /usr/include/glib-2.0/glib/gmem.h:391:9
pub const G_SOURCE_FUNC = @compileError("unable to translate C expr: expected ')' instead got '('"); // /usr/include/glib-2.0/glib/gmain.h:227:9
pub const g_utf8_next_char = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gunicode.h:799:9
pub const G_VARIANT_TYPE_BOOLEAN = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:50:9
pub const G_VARIANT_TYPE_BYTE = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:57:9
pub const G_VARIANT_TYPE_INT16 = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:64:9
pub const G_VARIANT_TYPE_UINT16 = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:72:9
pub const G_VARIANT_TYPE_INT32 = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:80:9
pub const G_VARIANT_TYPE_UINT32 = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:88:9
pub const G_VARIANT_TYPE_INT64 = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:96:9
pub const G_VARIANT_TYPE_UINT64 = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:106:9
pub const G_VARIANT_TYPE_DOUBLE = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:117:9
pub const G_VARIANT_TYPE_STRING = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:124:9
pub const G_VARIANT_TYPE_OBJECT_PATH = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:137:9
pub const G_VARIANT_TYPE_SIGNATURE = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:149:9
pub const G_VARIANT_TYPE_VARIANT = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:157:9
pub const G_VARIANT_TYPE_HANDLE = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:169:9
pub const G_VARIANT_TYPE_UNIT = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:177:9
pub const G_VARIANT_TYPE_ANY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:185:9
pub const G_VARIANT_TYPE_BASIC = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:193:9
pub const G_VARIANT_TYPE_MAYBE = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:200:9
pub const G_VARIANT_TYPE_ARRAY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:207:9
pub const G_VARIANT_TYPE_TUPLE = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:215:9
pub const G_VARIANT_TYPE_DICT_ENTRY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:223:9
pub const G_VARIANT_TYPE_DICTIONARY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:232:9
pub const G_VARIANT_TYPE_STRING_ARRAY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:239:9
pub const G_VARIANT_TYPE_OBJECT_PATH_ARRAY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:246:9
pub const G_VARIANT_TYPE_BYTESTRING = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:256:9
pub const G_VARIANT_TYPE_BYTESTRING_ARRAY = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:263:9
pub const G_VARIANT_TYPE_VARDICT = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/glib-2.0/glib/gvarianttype.h:273:9
pub const G_VARIANT_BUILDER_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/gvariant.h:367:9
pub const G_VARIANT_DICT_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/gvariant.h:490:9
pub const G_DEBUG_HERE = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gmessages.h:269:9
pub const g_error = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:342:9
pub const g_message = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:348:9
pub const g_critical = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:351:9
pub const g_warning = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:354:9
pub const g_info = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:357:9
pub const g_debug = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:360:9
pub const g_warning_once = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/glib/gmessages.h:489:9
pub const g_warn_if_reached = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gmessages.h:536:9
pub const g_warn_if_fail = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gmessages.h:549:9
pub const g_return_if_fail = @compileError("unable to translate C expr: unexpected token 'if'"); // /usr/include/glib-2.0/glib/gmessages.h:638:9
pub const g_return_val_if_fail = @compileError("unable to translate C expr: unexpected token 'if'"); // /usr/include/glib-2.0/glib/gmessages.h:651:9
pub const g_return_if_reached = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gmessages.h:664:9
pub const g_return_val_if_reached = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gmessages.h:675:9
pub const G_PATH_BUF_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/gpathbuf.h:47:9
pub const G_QUEUE_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/gqueue.h:70:9
pub const g_rc_box_new = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/grcbox.h:68:9
pub const g_rc_box_new0 = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/grcbox.h:70:9
pub const g_atomic_rc_box_new = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/grcbox.h:72:9
pub const g_atomic_rc_box_new0 = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/grcbox.h:74:9
pub const g_scanner_add_symbol = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/glib/gscanner.h:284:10
pub const g_scanner_remove_symbol = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/glib/gscanner.h:287:10
pub const g_scanner_foreach_symbol = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/glib/gscanner.h:290:10
pub const g_slice_new = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/gslice.h:48:10
pub const g_slice_new0 = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/gslice.h:62:11
pub const g_slice_dup = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/gslice.h:78:9
pub const g_slice_free = @compileError("unable to translate C expr: unexpected token 'if'"); // /usr/include/glib-2.0/glib/gslice.h:81:9
pub const g_slice_free_chain = @compileError("unable to translate C expr: unexpected token 'if'"); // /usr/include/glib-2.0/glib/gslice.h:86:9
pub const g_assert_cmpstr = @compileError("unable to translate macro: undefined identifier `__s1`"); // /usr/include/glib-2.0/glib/gtestutils.h:46:9
pub const g_assert_cmpint = @compileError("unable to translate macro: undefined identifier `__n1`"); // /usr/include/glib-2.0/glib/gtestutils.h:53:9
pub const g_assert_cmpuint = @compileError("unable to translate macro: undefined identifier `__n1`"); // /usr/include/glib-2.0/glib/gtestutils.h:59:9
pub const g_assert_cmphex = @compileError("unable to translate macro: undefined identifier `__n1`"); // /usr/include/glib-2.0/glib/gtestutils.h:65:9
pub const g_assert_cmpfloat = @compileError("unable to translate macro: undefined identifier `__n1`"); // /usr/include/glib-2.0/glib/gtestutils.h:91:9
pub const g_assert_cmpfloat_with_epsilon = @compileError("unable to translate macro: undefined identifier `__n1`"); // /usr/include/glib-2.0/glib/gtestutils.h:97:9
pub const g_assert_cmpmem = @compileError("unable to translate macro: undefined identifier `__m1`"); // /usr/include/glib-2.0/glib/gtestutils.h:105:9
pub const g_assert_cmpvariant = @compileError("unable to translate macro: undefined identifier `__v1`"); // /usr/include/glib-2.0/glib/gtestutils.h:141:9
pub const g_assert_cmpstrv = @compileError("unable to translate macro: undefined identifier `__strv1`"); // /usr/include/glib-2.0/glib/gtestutils.h:158:9
pub const g_assert_no_errno = @compileError("unable to translate macro: undefined identifier `__ret`"); // /usr/include/glib-2.0/glib/gtestutils.h:203:9
pub const g_assert_no_error = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:217:9
pub const g_assert_error = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:222:9
pub const g_assert_true = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:227:9
pub const g_assert_false = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:232:9
pub const g_assert_null = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:250:9
pub const g_assert_nonnull = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:254:9
pub const g_assert_not_reached = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:274:9
pub const g_assert = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:275:9
pub const g_test_add = @compileError("unable to translate macro: undefined identifier `add_vtable`"); // /usr/include/glib-2.0/glib/gtestutils.h:432:9
pub const g_test_trap_assert_passed = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:523:10
pub const g_test_trap_assert_failed = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:524:10
pub const g_test_trap_assert_stdout = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:525:10
pub const g_test_trap_assert_stdout_unmatched = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:526:10
pub const g_test_trap_assert_stderr = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:527:10
pub const g_test_trap_assert_stderr_unmatched = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:528:10
pub const g_test_assert_expected_messages = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // /usr/include/glib-2.0/glib/gtestutils.h:759:9
pub const g_chunk_new = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/deprecated/gallocator.h:36:9
pub const g_chunk_new0 = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/glib/deprecated/gallocator.h:37:9
pub const g_main_new = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:52:17
pub const g_main_run = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:62:17
pub const g_main_quit = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:73:9
pub const g_main_destroy = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:83:9
pub const g_main_is_running = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:95:9
pub const g_main_iteration = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:110:9
pub const g_main_pending = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:122:9
pub const g_main_set_poll_func = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gmain.h:133:9
pub const __CPU_ZERO_S = @compileError("unable to translate C expr: unexpected token 'do'"); // /usr/include/bits/cpu-set.h:46:10
pub const __CPU_SET_S = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/bits/cpu-set.h:58:9
pub const __CPU_CLR_S = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/bits/cpu-set.h:65:9
pub const __CPU_ISSET_S = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/bits/cpu-set.h:72:9
pub const __CPU_EQUAL_S = @compileError("unable to translate macro: undefined identifier `__builtin_memcmp`"); // /usr/include/bits/cpu-set.h:84:10
pub const __CPU_OP_S = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/bits/cpu-set.h:99:9
pub const __sched_priority = @compileError("unable to translate macro: undefined identifier `sched_priority`"); // /usr/include/sched.h:48:9
pub const PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/pthread.h:90:9
pub const PTHREAD_RWLOCK_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/pthread.h:114:10
pub const PTHREAD_COND_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/pthread.h:155:9
pub const pthread_cleanup_push = @compileError("unable to translate macro: undefined identifier `__cancel_buf`"); // /usr/include/pthread.h:681:10
pub const pthread_cleanup_pop = @compileError("unable to translate macro: undefined identifier `__cancel_buf`"); // /usr/include/pthread.h:702:10
pub const G_STATIC_MUTEX_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:131:9
pub const g_static_mutex_lock = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:144:9
pub const g_static_mutex_trylock = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:146:9
pub const g_static_mutex_unlock = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:148:9
pub const G_STATIC_REC_MUTEX_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:176:9
pub const G_STATIC_RW_LOCK_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:212:9
pub const G_STATIC_PRIVATE_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/glib/deprecated/gthread.h:248:9
pub const _GDK_GNUC_DO_PRAGMA = @compileError("unable to translate macro: undefined identifier `_Pragma`"); // /usr/include/gtk-4.0/gdk/version/gdkversionmacros.h:35:9
pub const GDK_DEPRECATED_MACRO = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/gtk-4.0/gdk/version/gdkversionmacros.h:36:9
pub const GDK_DEPRECATED_MACRO_FOR = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/gtk-4.0/gdk/version/gdkversionmacros.h:37:9
pub const GDK_UNAVAILABLE_MACRO = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/gtk-4.0/gdk/version/gdkversionmacros.h:39:9
pub const _GDK_EXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/gtk-4.0/gdk/version/gdk-visibility.h:7:11
pub const _GDK_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/gtk-4.0/gdk/version/gdk-visibility.h:19:9
pub const GDK_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gtk-4.0/gdk/version/gdk-visibility.h:31:9
pub const GDK_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gtk-4.0/gdk/version/gdk-visibility.h:32:9
pub const _GOBJECT_EXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/gobject/gobject-visibility.h:7:11
pub const _GOBJECT_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/glib-2.0/gobject/gobject-visibility.h:19:9
pub const GOBJECT_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gobject/gobject-visibility.h:31:9
pub const GOBJECT_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gobject/gobject-visibility.h:32:9
pub const G_TYPE_INSTANCE_GET_PRIVATE = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/gobject/gtype.h:686:9
pub const G_TYPE_CLASS_GET_PRIVATE = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/gobject/gtype.h:704:9
pub const G_DECLARE_FINAL_TYPE = @compileError("unable to translate macro: undefined identifier `_get_type`"); // /usr/include/glib-2.0/gobject/gtype.h:1600:9
pub const G_DECLARE_DERIVABLE_TYPE = @compileError("unable to translate macro: undefined identifier `_get_type`"); // /usr/include/glib-2.0/gobject/gtype.h:1703:9
pub const G_DECLARE_INTERFACE = @compileError("unable to translate macro: undefined identifier `_get_type`"); // /usr/include/glib-2.0/gobject/gtype.h:1795:9
pub const G_DEFINE_TYPE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gtype.h:1826:9
pub const G_DEFINE_TYPE_WITH_CODE = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:1842:9
pub const G_DEFINE_ABSTRACT_TYPE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gtype.h:1883:9
pub const G_DEFINE_ABSTRACT_TYPE_WITH_CODE = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:1902:9
pub const G_DEFINE_FINAL_TYPE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gtype.h:1932:9
pub const G_DEFINE_FINAL_TYPE_WITH_CODE = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:1951:9
pub const G_DEFINE_FINAL_TYPE_WITH_PRIVATE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gobject/gtype.h:1967:9
pub const G_DEFINE_TYPE_EXTENDED = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:2045:9
pub const G_DEFINE_INTERFACE = @compileError("unable to translate C expr: unexpected token ';'"); // /usr/include/glib-2.0/gobject/gtype.h:2070:9
pub const G_DEFINE_INTERFACE_WITH_CODE = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:2091:9
pub const G_IMPLEMENT_INTERFACE = @compileError("unable to translate macro: undefined identifier `g_implement_interface_info`"); // /usr/include/glib-2.0/gobject/gtype.h:2107:9
pub const G_ADD_PRIVATE = @compileError("unable to translate macro: undefined identifier `_private_offset`"); // /usr/include/glib-2.0/gobject/gtype.h:2186:9
pub const G_PRIVATE_OFFSET = @compileError("unable to translate macro: undefined identifier `_private_offset`"); // /usr/include/glib-2.0/gobject/gtype.h:2205:9
pub const _G_DEFINE_TYPE_EXTENDED_CLASS_INIT = @compileError("unable to translate macro: undefined identifier `_class_intern_init`"); // /usr/include/glib-2.0/gobject/gtype.h:2250:9
pub const _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE = @compileError("unable to translate macro: undefined identifier `_init`"); // /usr/include/glib-2.0/gobject/gtype.h:2269:9
pub const _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER = @compileError("unable to translate macro: undefined identifier `static_g_define_type_id`"); // /usr/include/glib-2.0/gobject/gtype.h:2293:9
pub const _G_DEFINE_TYPE_EXTENDED_END = @compileError("unable to translate macro: undefined identifier `g_define_type_id`"); // /usr/include/glib-2.0/gobject/gtype.h:2315:9
pub const _G_DEFINE_TYPE_EXTENDED_BEGIN = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gobject/gtype.h:2324:9
pub const _G_DEFINE_INTERFACE_EXTENDED_BEGIN = @compileError("unable to translate macro: undefined identifier `_default_init`"); // /usr/include/glib-2.0/gobject/gtype.h:2330:9
pub const _G_DEFINE_INTERFACE_EXTENDED_END = @compileError("unable to translate macro: undefined identifier `static_g_define_type_id`"); // /usr/include/glib-2.0/gobject/gtype.h:2351:9
pub const G_DEFINE_BOXED_TYPE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gtype.h:2422:9
pub const G_DEFINE_BOXED_TYPE_WITH_CODE = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:2450:9
pub const _G_DEFINE_BOXED_TYPE_BEGIN = @compileError("unable to translate macro: undefined identifier `_get_type_once`"); // /usr/include/glib-2.0/gobject/gtype.h:2457:9
pub const G_DEFINE_POINTER_TYPE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gtype.h:2531:9
pub const G_DEFINE_POINTER_TYPE_WITH_CODE = @compileError("unable to translate C expr: expected ',' or '}' instead got ';'"); // /usr/include/glib-2.0/gobject/gtype.h:2545:9
pub const _G_DEFINE_POINTER_TYPE_BEGIN = @compileError("unable to translate macro: undefined identifier `_get_type_once`"); // /usr/include/glib-2.0/gobject/gtype.h:2547:9
pub const _G_TYPE_CIC = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/gobject/gtype.h:2647:11
pub const _G_TYPE_CCC = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/gobject/gtype.h:2649:11
pub const _G_TYPE_IGC = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/gobject/gtype.h:2655:9
pub const _G_TYPE_IGI = @compileError("unable to translate C expr: unexpected token ')'"); // /usr/include/glib-2.0/gobject/gtype.h:2656:9
pub const _G_TYPE_CIT = @compileError("unable to translate macro: undefined identifier `__inst`"); // /usr/include/glib-2.0/gobject/gtype.h:2659:11
pub const _G_TYPE_CCT = @compileError("unable to translate macro: undefined identifier `__class`"); // /usr/include/glib-2.0/gobject/gtype.h:2669:11
pub const _G_TYPE_CVH = @compileError("unable to translate macro: undefined identifier `__val`"); // /usr/include/glib-2.0/gobject/gtype.h:2679:11
pub const G_VALUE_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gvalue.h:207:9
pub const G_OBJECT_WARN_INVALID_PSPEC = @compileError("unable to translate macro: undefined identifier `_glib__object`"); // /usr/include/glib-2.0/gobject/gobject.h:683:9
pub const G_DEFINE_ENUM_VALUE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/genums.h:293:9
pub const G_DEFINE_ENUM_TYPE = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/gobject/genums.h:320:9
pub const G_DEFINE_FLAGS_TYPE = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/glib-2.0/gobject/genums.h:363:9
pub const G_DEFINE_DYNAMIC_TYPE = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/glib-2.0/gobject/gtypemodule.h:107:9
pub const G_DEFINE_DYNAMIC_TYPE_EXTENDED = @compileError("unable to translate macro: undefined identifier `_init`"); // /usr/include/glib-2.0/gobject/gtypemodule.h:182:9
pub const G_IMPLEMENT_INTERFACE_DYNAMIC = @compileError("unable to translate macro: undefined identifier `g_implement_interface_info`"); // /usr/include/glib-2.0/gobject/gtypemodule.h:245:9
pub const G_ADD_PRIVATE_DYNAMIC = @compileError("unable to translate macro: undefined identifier `_private_offset`"); // /usr/include/glib-2.0/gobject/gtypemodule.h:267:9
pub const _GIO_EXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/gio/gio-visibility.h:7:11
pub const _GIO_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/glib-2.0/gio/gio-visibility.h:19:9
pub const GIO_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gio/gio-visibility.h:31:9
pub const GIO_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gio/gio-visibility.h:32:9
pub const G_DBUS_ACTION_GROUP_CLASS = @compileError("unable to translate macro: undefined identifier `GDBusActionGroupClass`"); // /usr/include/glib-2.0/gio/gdbusactiongroup.h:37:9
pub const G_DBUS_ACTION_GROUP_GET_CLASS = @compileError("unable to translate macro: undefined identifier `GDBusActionGroupClass`"); // /usr/include/glib-2.0/gio/gdbusactiongroup.h:43:9
pub const _GMODULE_EXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/gmodule/gmodule-visibility.h:7:11
pub const _GMODULE_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/glib-2.0/gmodule/gmodule-visibility.h:19:9
pub const GMODULE_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gmodule/gmodule-visibility.h:31:9
pub const GMODULE_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gmodule/gmodule-visibility.h:32:9
pub const G_MODULE_EXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/glib-2.0/gmodule.h:42:11
pub const G_MODULE_IMPORT = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/glib-2.0/gmodule.h:43:11
pub const G_MODULE_ERROR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/glib-2.0/gmodule.h:74:9
pub const cairo_current_font_extents = @compileError("unable to translate macro: undefined identifier `cairo_current_font_extents_REPLACED_BY_cairo_font_extents`"); // /usr/include/cairo/cairo-deprecated.h:57:9
pub const cairo_get_font_extents = @compileError("unable to translate macro: undefined identifier `cairo_get_font_extents_REPLACED_BY_cairo_font_extents`"); // /usr/include/cairo/cairo-deprecated.h:58:9
pub const cairo_current_operator = @compileError("unable to translate macro: undefined identifier `cairo_current_operator_REPLACED_BY_cairo_get_operator`"); // /usr/include/cairo/cairo-deprecated.h:59:9
pub const cairo_current_tolerance = @compileError("unable to translate macro: undefined identifier `cairo_current_tolerance_REPLACED_BY_cairo_get_tolerance`"); // /usr/include/cairo/cairo-deprecated.h:60:9
pub const cairo_current_point = @compileError("unable to translate macro: undefined identifier `cairo_current_point_REPLACED_BY_cairo_get_current_point`"); // /usr/include/cairo/cairo-deprecated.h:61:9
pub const cairo_current_fill_rule = @compileError("unable to translate macro: undefined identifier `cairo_current_fill_rule_REPLACED_BY_cairo_get_fill_rule`"); // /usr/include/cairo/cairo-deprecated.h:62:9
pub const cairo_current_line_width = @compileError("unable to translate macro: undefined identifier `cairo_current_line_width_REPLACED_BY_cairo_get_line_width`"); // /usr/include/cairo/cairo-deprecated.h:63:9
pub const cairo_current_line_cap = @compileError("unable to translate macro: undefined identifier `cairo_current_line_cap_REPLACED_BY_cairo_get_line_cap`"); // /usr/include/cairo/cairo-deprecated.h:64:9
pub const cairo_current_line_join = @compileError("unable to translate macro: undefined identifier `cairo_current_line_join_REPLACED_BY_cairo_get_line_join`"); // /usr/include/cairo/cairo-deprecated.h:65:9
pub const cairo_current_miter_limit = @compileError("unable to translate macro: undefined identifier `cairo_current_miter_limit_REPLACED_BY_cairo_get_miter_limit`"); // /usr/include/cairo/cairo-deprecated.h:66:9
pub const cairo_current_matrix = @compileError("unable to translate macro: undefined identifier `cairo_current_matrix_REPLACED_BY_cairo_get_matrix`"); // /usr/include/cairo/cairo-deprecated.h:67:9
pub const cairo_current_target_surface = @compileError("unable to translate macro: undefined identifier `cairo_current_target_surface_REPLACED_BY_cairo_get_target`"); // /usr/include/cairo/cairo-deprecated.h:68:9
pub const cairo_get_status = @compileError("unable to translate macro: undefined identifier `cairo_get_status_REPLACED_BY_cairo_status`"); // /usr/include/cairo/cairo-deprecated.h:69:9
pub const cairo_concat_matrix = @compileError("unable to translate macro: undefined identifier `cairo_concat_matrix_REPLACED_BY_cairo_transform`"); // /usr/include/cairo/cairo-deprecated.h:70:9
pub const cairo_scale_font = @compileError("unable to translate macro: undefined identifier `cairo_scale_font_REPLACED_BY_cairo_set_font_size`"); // /usr/include/cairo/cairo-deprecated.h:71:9
pub const cairo_select_font = @compileError("unable to translate macro: undefined identifier `cairo_select_font_REPLACED_BY_cairo_select_font_face`"); // /usr/include/cairo/cairo-deprecated.h:72:9
pub const cairo_transform_font = @compileError("unable to translate macro: undefined identifier `cairo_transform_font_REPLACED_BY_cairo_set_font_matrix`"); // /usr/include/cairo/cairo-deprecated.h:73:9
pub const cairo_transform_point = @compileError("unable to translate macro: undefined identifier `cairo_transform_point_REPLACED_BY_cairo_user_to_device`"); // /usr/include/cairo/cairo-deprecated.h:74:9
pub const cairo_transform_distance = @compileError("unable to translate macro: undefined identifier `cairo_transform_distance_REPLACED_BY_cairo_user_to_device_distance`"); // /usr/include/cairo/cairo-deprecated.h:75:9
pub const cairo_inverse_transform_point = @compileError("unable to translate macro: undefined identifier `cairo_inverse_transform_point_REPLACED_BY_cairo_device_to_user`"); // /usr/include/cairo/cairo-deprecated.h:76:9
pub const cairo_inverse_transform_distance = @compileError("unable to translate macro: undefined identifier `cairo_inverse_transform_distance_REPLACED_BY_cairo_device_to_user_distance`"); // /usr/include/cairo/cairo-deprecated.h:77:9
pub const cairo_init_clip = @compileError("unable to translate macro: undefined identifier `cairo_init_clip_REPLACED_BY_cairo_reset_clip`"); // /usr/include/cairo/cairo-deprecated.h:78:9
pub const cairo_surface_create_for_image = @compileError("unable to translate macro: undefined identifier `cairo_surface_create_for_image_REPLACED_BY_cairo_image_surface_create_for_data`"); // /usr/include/cairo/cairo-deprecated.h:79:9
pub const cairo_default_matrix = @compileError("unable to translate macro: undefined identifier `cairo_default_matrix_REPLACED_BY_cairo_identity_matrix`"); // /usr/include/cairo/cairo-deprecated.h:80:9
pub const cairo_matrix_set_affine = @compileError("unable to translate macro: undefined identifier `cairo_matrix_set_affine_REPLACED_BY_cairo_matrix_init`"); // /usr/include/cairo/cairo-deprecated.h:81:9
pub const cairo_matrix_set_identity = @compileError("unable to translate macro: undefined identifier `cairo_matrix_set_identity_REPLACED_BY_cairo_matrix_init_identity`"); // /usr/include/cairo/cairo-deprecated.h:82:9
pub const cairo_pattern_add_color_stop = @compileError("unable to translate macro: undefined identifier `cairo_pattern_add_color_stop_REPLACED_BY_cairo_pattern_add_color_stop_rgba`"); // /usr/include/cairo/cairo-deprecated.h:83:9
pub const cairo_set_rgb_color = @compileError("unable to translate macro: undefined identifier `cairo_set_rgb_color_REPLACED_BY_cairo_set_source_rgb`"); // /usr/include/cairo/cairo-deprecated.h:84:9
pub const cairo_set_pattern = @compileError("unable to translate macro: undefined identifier `cairo_set_pattern_REPLACED_BY_cairo_set_source`"); // /usr/include/cairo/cairo-deprecated.h:85:9
pub const cairo_xlib_surface_create_for_pixmap_with_visual = @compileError("unable to translate macro: undefined identifier `cairo_xlib_surface_create_for_pixmap_with_visual_REPLACED_BY_cairo_xlib_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:86:9
pub const cairo_xlib_surface_create_for_window_with_visual = @compileError("unable to translate macro: undefined identifier `cairo_xlib_surface_create_for_window_with_visual_REPLACED_BY_cairo_xlib_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:87:9
pub const cairo_xcb_surface_create_for_pixmap_with_visual = @compileError("unable to translate macro: undefined identifier `cairo_xcb_surface_create_for_pixmap_with_visual_REPLACED_BY_cairo_xcb_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:88:9
pub const cairo_xcb_surface_create_for_window_with_visual = @compileError("unable to translate macro: undefined identifier `cairo_xcb_surface_create_for_window_with_visual_REPLACED_BY_cairo_xcb_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:89:9
pub const cairo_ps_surface_set_dpi = @compileError("unable to translate macro: undefined identifier `cairo_ps_surface_set_dpi_REPLACED_BY_cairo_surface_set_fallback_resolution`"); // /usr/include/cairo/cairo-deprecated.h:90:9
pub const cairo_pdf_surface_set_dpi = @compileError("unable to translate macro: undefined identifier `cairo_pdf_surface_set_dpi_REPLACED_BY_cairo_surface_set_fallback_resolution`"); // /usr/include/cairo/cairo-deprecated.h:91:9
pub const cairo_svg_surface_set_dpi = @compileError("unable to translate macro: undefined identifier `cairo_svg_surface_set_dpi_REPLACED_BY_cairo_surface_set_fallback_resolution`"); // /usr/include/cairo/cairo-deprecated.h:92:9
pub const cairo_atsui_font_face_create_for_atsu_font_id = @compileError("unable to translate macro: undefined identifier `cairo_atsui_font_face_create_for_atsu_font_id_REPLACED_BY_cairo_quartz_font_face_create_for_atsu_font_id`"); // /usr/include/cairo/cairo-deprecated.h:93:9
pub const cairo_current_path = @compileError("unable to translate macro: undefined identifier `cairo_current_path_DEPRECATED_BY_cairo_copy_path`"); // /usr/include/cairo/cairo-deprecated.h:95:9
pub const cairo_current_path_flat = @compileError("unable to translate macro: undefined identifier `cairo_current_path_flat_DEPRECATED_BY_cairo_copy_path_flat`"); // /usr/include/cairo/cairo-deprecated.h:96:9
pub const cairo_get_path = @compileError("unable to translate macro: undefined identifier `cairo_get_path_DEPRECATED_BY_cairo_copy_path`"); // /usr/include/cairo/cairo-deprecated.h:97:9
pub const cairo_get_path_flat = @compileError("unable to translate macro: undefined identifier `cairo_get_path_flat_DEPRECATED_BY_cairo_get_path_flat`"); // /usr/include/cairo/cairo-deprecated.h:98:9
pub const cairo_set_alpha = @compileError("unable to translate macro: undefined identifier `cairo_set_alpha_DEPRECATED_BY_cairo_set_source_rgba_OR_cairo_paint_with_alpha`"); // /usr/include/cairo/cairo-deprecated.h:99:9
pub const cairo_show_surface = @compileError("unable to translate macro: undefined identifier `cairo_show_surface_DEPRECATED_BY_cairo_set_source_surface_AND_cairo_paint`"); // /usr/include/cairo/cairo-deprecated.h:100:9
pub const cairo_copy = @compileError("unable to translate macro: undefined identifier `cairo_copy_DEPRECATED_BY_cairo_create_AND_MANY_INDIVIDUAL_FUNCTIONS`"); // /usr/include/cairo/cairo-deprecated.h:101:9
pub const cairo_surface_set_repeat = @compileError("unable to translate macro: undefined identifier `cairo_surface_set_repeat_DEPRECATED_BY_cairo_pattern_set_extend`"); // /usr/include/cairo/cairo-deprecated.h:102:9
pub const cairo_surface_set_matrix = @compileError("unable to translate macro: undefined identifier `cairo_surface_set_matrix_DEPRECATED_BY_cairo_pattern_set_matrix`"); // /usr/include/cairo/cairo-deprecated.h:103:9
pub const cairo_surface_get_matrix = @compileError("unable to translate macro: undefined identifier `cairo_surface_get_matrix_DEPRECATED_BY_cairo_pattern_get_matrix`"); // /usr/include/cairo/cairo-deprecated.h:104:9
pub const cairo_surface_set_filter = @compileError("unable to translate macro: undefined identifier `cairo_surface_set_filter_DEPRECATED_BY_cairo_pattern_set_filter`"); // /usr/include/cairo/cairo-deprecated.h:105:9
pub const cairo_surface_get_filter = @compileError("unable to translate macro: undefined identifier `cairo_surface_get_filter_DEPRECATED_BY_cairo_pattern_get_filter`"); // /usr/include/cairo/cairo-deprecated.h:106:9
pub const cairo_matrix_create = @compileError("unable to translate macro: undefined identifier `cairo_matrix_create_DEPRECATED_BY_cairo_matrix_t`"); // /usr/include/cairo/cairo-deprecated.h:107:9
pub const cairo_matrix_destroy = @compileError("unable to translate macro: undefined identifier `cairo_matrix_destroy_DEPRECATED_BY_cairo_matrix_t`"); // /usr/include/cairo/cairo-deprecated.h:108:9
pub const cairo_matrix_copy = @compileError("unable to translate macro: undefined identifier `cairo_matrix_copy_DEPRECATED_BY_cairo_matrix_t`"); // /usr/include/cairo/cairo-deprecated.h:109:9
pub const cairo_matrix_get_affine = @compileError("unable to translate macro: undefined identifier `cairo_matrix_get_affine_DEPRECATED_BY_cairo_matrix_t`"); // /usr/include/cairo/cairo-deprecated.h:110:9
pub const cairo_set_target_surface = @compileError("unable to translate macro: undefined identifier `cairo_set_target_surface_DEPRECATED_BY_cairo_create`"); // /usr/include/cairo/cairo-deprecated.h:111:9
pub const cairo_set_target_image = @compileError("unable to translate macro: undefined identifier `cairo_set_target_image_DEPRECATED_BY_cairo_image_surface_create_for_data`"); // /usr/include/cairo/cairo-deprecated.h:112:9
pub const cairo_set_target_pdf = @compileError("unable to translate macro: undefined identifier `cairo_set_target_pdf_DEPRECATED_BY_cairo_pdf_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:113:9
pub const cairo_set_target_png = @compileError("unable to translate macro: undefined identifier `cairo_set_target_png_DEPRECATED_BY_cairo_surface_write_to_png`"); // /usr/include/cairo/cairo-deprecated.h:114:9
pub const cairo_set_target_ps = @compileError("unable to translate macro: undefined identifier `cairo_set_target_ps_DEPRECATED_BY_cairo_ps_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:115:9
pub const cairo_set_target_quartz = @compileError("unable to translate macro: undefined identifier `cairo_set_target_quartz_DEPRECATED_BY_cairo_quartz_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:116:9
pub const cairo_set_target_win32 = @compileError("unable to translate macro: undefined identifier `cairo_set_target_win32_DEPRECATED_BY_cairo_win32_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:117:9
pub const cairo_set_target_xcb = @compileError("unable to translate macro: undefined identifier `cairo_set_target_xcb_DEPRECATED_BY_cairo_xcb_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:118:9
pub const cairo_set_target_drawable = @compileError("unable to translate macro: undefined identifier `cairo_set_target_drawable_DEPRECATED_BY_cairo_xlib_surface_create`"); // /usr/include/cairo/cairo-deprecated.h:119:9
pub const cairo_get_status_string = @compileError("unable to translate macro: undefined identifier `cairo_get_status_string_DEPRECATED_BY_cairo_status_AND_cairo_status_to_string`"); // /usr/include/cairo/cairo-deprecated.h:120:9
pub const cairo_status_string = @compileError("unable to translate macro: undefined identifier `cairo_status_string_DEPRECATED_BY_cairo_status_AND_cairo_status_to_string`"); // /usr/include/cairo/cairo-deprecated.h:121:9
pub const _cairo_export = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/cairo/cairo.h:57:10
pub const cairo_public = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/cairo/cairo.h:70:9
pub const CAIRO_VERSION_STRINGIZE_ = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/cairo/cairo.h:85:9
pub const _PANGO_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/pango-1.0/pango/pango-version-macros.h:28:9
pub const PANGO_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/pango-1.0/pango/pango-version-macros.h:386:10
pub const PANGO_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/pango-1.0/pango/pango-version-macros.h:387:10
pub const HB_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/harfbuzz/hb-common.h:37:9
pub const HB_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/harfbuzz/hb-common.h:73:9
pub const HB_DRAW_STATE_DEFAULT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/harfbuzz/hb-draw.h:73:9
pub const HB_SEGMENT_PROPERTIES_DEFAULT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/harfbuzz/hb-buffer.h:225:9
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CURISVE_CONNECTION = @compileError("unable to translate macro: undefined identifier `HB_AAT_LAYOUT_FEATURE_TYPE_CURSIVE_CONNECTION`"); // /usr/include/harfbuzz/hb-deprecated.h:311:9
pub const PANGO_MATRIX_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/pango-1.0/pango/pango-matrix.h:78:9
pub const PANGO_ENGINE_DEFINE_TYPE = @compileError("unable to translate macro: undefined identifier `_type`"); // /usr/include/pango-1.0/pango/pango-engine.h:345:9
pub const PANGO_MODULE_ENTRY = @compileError("unable to translate macro: undefined identifier `script_engine_`"); // /usr/include/pango-1.0/pango/pango-engine.h:448:9
pub const __getc_unlocked_body = @compileError("TODO postfix inc/dec expr"); // /usr/include/bits/types/struct_FILE.h:102:9
pub const __putc_unlocked_body = @compileError("TODO postfix inc/dec expr"); // /usr/include/bits/types/struct_FILE.h:106:9
pub const GDK_DECLARE_INTERNAL_TYPE = @compileError("unable to translate macro: undefined identifier `_get_type`"); // /usr/include/gtk-4.0/gdk/gdktypes.h:117:9
pub const _GDK_PIXBUF_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-features.h:43:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_0_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:343:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_2_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:361:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_4_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:379:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_6_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:397:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_8_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:415:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_10_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:433:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_12_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:451:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_14_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:469:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_16_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:487:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_18_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:505:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_20_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:523:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_22_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:541:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_24_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:559:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_26_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:577:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_28_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:595:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_30_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:613:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_32_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:631:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_34_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:649:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_36_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:667:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_38_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:685:9
pub const GDK_PIXBUF_DEPRECATED_IN_2_40_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/gdk-pixbuf-2.0/gdk-pixbuf/gdk-pixbuf-macros.h:703:9
pub const GDK_CAIRO_ERROR = @compileError("unable to translate macro: undefined identifier `gdk_cairo_error_quark`"); // /usr/include/gtk-4.0/gdk/gdkcairocontext.h:35:9
pub const __DEFAULT_FN_ATTRS = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/lib/zig/include/mmintrin.h:25:9
pub const __DEFAULT_FN_ATTRS_MMX = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/lib/zig/include/xmmintrin.h:36:9
pub const _mm_prefetch = @compileError("unable to translate macro: undefined identifier `__builtin_prefetch`"); // /usr/lib/zig/include/xmmintrin.h:2107:9
pub const _mm_extract_pi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_ext_v4hi`"); // /usr/lib/zig/include/xmmintrin.h:2187:9
pub const _mm_insert_pi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_set_v4hi`"); // /usr/lib/zig/include/xmmintrin.h:2218:9
pub const _mm_shuffle_pi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pshufw`"); // /usr/lib/zig/include/xmmintrin.h:2368:9
pub const _mm_shuffle_ps = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_shufps`"); // /usr/lib/zig/include/xmmintrin.h:2613:9
pub const _MM_ALIGN16 = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/lib/zig/include/xmmintrin.h:2940:9
pub const _MM_TRANSPOSE4_PS = @compileError("unable to translate macro: undefined identifier `tmp3`"); // /usr/lib/zig/include/xmmintrin.h:2980:9
pub const _m_ = @compileError("unable to translate macro: undefined identifier `_mm_`"); // /usr/lib/zig/include/xmmintrin.h:3007:9
pub const _mm_slli_si128 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pslldqi128_byteshift`"); // /usr/lib/zig/include/emmintrin.h:2685:9
pub const _mm_bslli_si128 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pslldqi128_byteshift`"); // /usr/lib/zig/include/emmintrin.h:2689:9
pub const _mm_srli_si128 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_psrldqi128_byteshift`"); // /usr/lib/zig/include/emmintrin.h:2894:9
pub const _mm_bsrli_si128 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_psrldqi128_byteshift`"); // /usr/lib/zig/include/emmintrin.h:2898:9
pub const _mm_extract_epi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_ext_v8hi`"); // /usr/lib/zig/include/emmintrin.h:4160:9
pub const _mm_insert_epi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_set_v8hi`"); // /usr/lib/zig/include/emmintrin.h:4188:9
pub const _mm_shuffle_epi32 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pshufd`"); // /usr/lib/zig/include/emmintrin.h:4239:9
pub const _mm_shufflelo_epi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pshuflw`"); // /usr/lib/zig/include/emmintrin.h:4272:9
pub const _mm_shufflehi_epi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pshufhw`"); // /usr/lib/zig/include/emmintrin.h:4305:9
pub const _mm_shuffle_pd = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_shufpd`"); // /usr/lib/zig/include/emmintrin.h:4651:9
pub const _mm_alignr_epi8 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_palignr128`"); // /usr/lib/zig/include/tmmintrin.h:151:9
pub const _mm_alignr_pi8 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_palignr`"); // /usr/lib/zig/include/tmmintrin.h:174:9
pub const _mm_round_ps = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_roundps`"); // /usr/lib/zig/include/smmintrin.h:239:9
pub const _mm_round_ss = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_roundss`"); // /usr/lib/zig/include/smmintrin.h:280:9
pub const _mm_round_pd = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_roundpd`"); // /usr/lib/zig/include/smmintrin.h:314:9
pub const _mm_round_sd = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_roundsd`"); // /usr/lib/zig/include/smmintrin.h:355:9
pub const _mm_blend_pd = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_blendpd`"); // /usr/lib/zig/include/smmintrin.h:384:9
pub const _mm_blend_ps = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_blendps`"); // /usr/lib/zig/include/smmintrin.h:412:9
pub const _mm_blend_epi16 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pblendw128`"); // /usr/lib/zig/include/smmintrin.h:521:9
pub const _mm_dp_ps = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_dpps`"); // /usr/lib/zig/include/smmintrin.h:596:9
pub const _mm_dp_pd = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_dppd`"); // /usr/lib/zig/include/smmintrin.h:630:9
pub const _mm_insert_ps = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_insertps128`"); // /usr/lib/zig/include/smmintrin.h:838:9
pub const _mm_extract_ps = @compileError("unable to translate macro: undefined identifier `__builtin_bit_cast`"); // /usr/lib/zig/include/smmintrin.h:862:9
pub const _MM_EXTRACT_FLOAT = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_ext_v4sf`"); // /usr/lib/zig/include/smmintrin.h:868:9
pub const _mm_insert_epi8 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_set_v16qi`"); // /usr/lib/zig/include/smmintrin.h:922:9
pub const _mm_insert_epi32 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_set_v4si`"); // /usr/lib/zig/include/smmintrin.h:954:9
pub const _mm_insert_epi64 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_set_v2di`"); // /usr/lib/zig/include/smmintrin.h:985:9
pub const _mm_extract_epi8 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_ext_v16qi`"); // /usr/lib/zig/include/smmintrin.h:1028:9
pub const _mm_extract_epi32 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_ext_v4si`"); // /usr/lib/zig/include/smmintrin.h:1054:9
pub const _mm_extract_epi64 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_vec_ext_v2di`"); // /usr/lib/zig/include/smmintrin.h:1077:9
pub const _mm_mpsadbw_epu8 = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_mpsadbw128`"); // /usr/lib/zig/include/smmintrin.h:1497:9
pub const _mm_cmpistrm = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistrm128`"); // /usr/lib/zig/include/smmintrin.h:1606:9
pub const _mm_cmpistri = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistri128`"); // /usr/lib/zig/include/smmintrin.h:1660:9
pub const _mm_cmpestrm = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestrm128`"); // /usr/lib/zig/include/smmintrin.h:1720:9
pub const _mm_cmpestri = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestri128`"); // /usr/lib/zig/include/smmintrin.h:1779:9
pub const _mm_cmpistra = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistria128`"); // /usr/lib/zig/include/smmintrin.h:1831:9
pub const _mm_cmpistrc = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistric128`"); // /usr/lib/zig/include/smmintrin.h:1880:9
pub const _mm_cmpistro = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistrio128`"); // /usr/lib/zig/include/smmintrin.h:1928:9
pub const _mm_cmpistrs = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistris128`"); // /usr/lib/zig/include/smmintrin.h:1978:9
pub const _mm_cmpistrz = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpistriz128`"); // /usr/lib/zig/include/smmintrin.h:2028:9
pub const _mm_cmpestra = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestria128`"); // /usr/lib/zig/include/smmintrin.h:2082:9
pub const _mm_cmpestrc = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestric128`"); // /usr/lib/zig/include/smmintrin.h:2136:9
pub const _mm_cmpestro = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestrio128`"); // /usr/lib/zig/include/smmintrin.h:2189:9
pub const _mm_cmpestrs = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestris128`"); // /usr/lib/zig/include/smmintrin.h:2244:9
pub const _mm_cmpestrz = @compileError("unable to translate macro: undefined identifier `__builtin_ia32_pcmpestriz128`"); // /usr/lib/zig/include/smmintrin.h:2298:9
pub const _GRAPHENE_PUBLIC = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/graphene-1.0/graphene-macros.h:33:9
pub const GRAPHENE_PRIVATE_FIELD = @compileError("unable to translate macro: undefined identifier `__graphene_private_`"); // /usr/include/graphene-1.0/graphene-macros.h:39:10
pub const GRAPHENE_ALIGN16 = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/graphene-1.0/graphene-macros.h:43:10
pub const GRAPHENE_ALIGNED_DECL = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/graphene-1.0/graphene-macros.h:44:10
pub const _GRAPHENE_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/graphene-1.0/graphene-macros.h:89:9
pub const GRAPHENE_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/graphene-1.0/graphene-version-macros.h:57:10
pub const GRAPHENE_UNAVAILABLE = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/graphene-1.0/graphene-version-macros.h:58:10
pub const HUGE_VAL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`"); // /usr/include/math.h:48:10
pub const HUGE_VALL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`"); // /usr/include/math.h:60:11
pub const __GLIBC_FLT_EVAL_METHOD = @compileError("unable to translate macro: undefined identifier `__FLT_EVAL_METHOD__`"); // /usr/include/bits/flt-eval-method.h:27:11
pub const __SIMD_DECL = @compileError("unable to translate macro: undefined identifier `__DECL_SIMD_`"); // /usr/include/math.h:276:9
pub const __MATHCALL_VEC = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/math.h:278:9
pub const __MATHDECL_VEC = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/math.h:282:9
pub const __MATHDECL = @compileError("unable to translate macro: undefined identifier `__`"); // /usr/include/math.h:288:9
pub const __MATHDECLX = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/math.h:293:9
pub const __MATHDECL_1_IMPL = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/math.h:296:9
pub const __MATHREDIR = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/math.h:305:9
pub const __MATHCALL_NARROW_ARGS_1 = @compileError("unable to translate macro: undefined identifier `_Marg_`"); // /usr/include/math.h:550:9
pub const __MATHCALL_NARROW_ARGS_2 = @compileError("unable to translate macro: undefined identifier `_Marg_`"); // /usr/include/math.h:551:9
pub const __MATHCALL_NARROW_ARGS_3 = @compileError("unable to translate macro: undefined identifier `_Marg_`"); // /usr/include/math.h:552:9
pub const __MATHCALL_NARROW_NORMAL = @compileError("unable to translate macro: undefined identifier `_Mret_`"); // /usr/include/math.h:553:9
pub const __MATHCALL_NARROW_REDIR = @compileError("unable to translate macro: undefined identifier `_Mret_`"); // /usr/include/math.h:555:9
pub const __MATH_TG = @compileError("unable to translate macro: undefined identifier `f`"); // /usr/include/math.h:922:10
pub const fpclassify = @compileError("unable to translate macro: undefined identifier `__builtin_fpclassify`"); // /usr/include/math.h:967:11
pub const isfinite = @compileError("unable to translate macro: undefined identifier `__builtin_isfinite`"); // /usr/include/math.h:994:11
pub const isnormal = @compileError("unable to translate macro: undefined identifier `__builtin_isnormal`"); // /usr/include/math.h:1002:11
pub const isgreater = @compileError("unable to translate macro: undefined identifier `__builtin_isgreater`"); // /usr/include/math.h:1306:11
pub const isgreaterequal = @compileError("unable to translate macro: undefined identifier `__builtin_isgreaterequal`"); // /usr/include/math.h:1307:11
pub const isless = @compileError("unable to translate macro: undefined identifier `__builtin_isless`"); // /usr/include/math.h:1308:11
pub const islessequal = @compileError("unable to translate macro: undefined identifier `__builtin_islessequal`"); // /usr/include/math.h:1309:11
pub const islessgreater = @compileError("unable to translate macro: undefined identifier `__builtin_islessgreater`"); // /usr/include/math.h:1310:11
pub const isunordered = @compileError("unable to translate macro: undefined identifier `__builtin_isunordered`"); // /usr/include/math.h:1311:11
pub const GRAPHENE_RECT_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/graphene-1.0/graphene-rect.h:50:9
pub const GSK_ROUNDED_RECT_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/gtk-4.0/gsk/gskroundedrect.h:39:9
pub const gtk_widget_class_bind_template_callback = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/gtk-4.0/gtk/gtkwidget.h:740:9
pub const gtk_widget_class_bind_template_child = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/gtk-4.0/gtk/gtkwidget.h:759:9
pub const gtk_widget_class_bind_template_child_internal = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/gtk-4.0/gtk/gtkwidget.h:781:9
pub const gtk_widget_class_bind_template_child_private = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/gtk-4.0/gtk/gtkwidget.h:802:9
pub const gtk_widget_class_bind_template_child_internal_private = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/gtk-4.0/gtk/gtkwidget.h:824:9
pub const gtk_builder_cscope_add_callback = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/gtk-4.0/gtk/gtkbuilderscope.h:118:9
pub const GTK_FLOW_BOX_CHILD_GET_CLASS = @compileError("unable to translate macro: undefined identifier `EG_TYPE_FLOW_BOX_CHILD`"); // /usr/include/gtk-4.0/gtk/gtkflowbox.h:49:9
pub const gtk_test_accessible_assert_role = @compileError("unable to translate macro: undefined identifier `__a`"); // /usr/include/gtk-4.0/gtk/gtktestatcontext.h:39:9
pub const gtk_test_accessible_assert_property = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/gtk-4.0/gtk/gtktestatcontext.h:61:9
pub const gtk_test_accessible_assert_relation = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/gtk-4.0/gtk/gtktestatcontext.h:83:9
pub const gtk_test_accessible_assert_state = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/gtk-4.0/gtk/gtktestatcontext.h:105:9
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 16);
pub const __clang_minor__ = @as(c_int, 0);
pub const __clang_patchlevel__ = @as(c_int, 6);
pub const __clang_version__ = "16.0.6 ";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 16.0.6";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_int;
pub const __WINT_TYPE__ = c_uint;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_long;
pub const __INT64_FMTd__ = "ld";
pub const __INT64_FMTi__ = "li";
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulong;
pub const __UINT64_FMTo__ = "lo";
pub const __UINT64_FMTu__ = "lu";
pub const __UINT64_FMTx__ = "lx";
pub const __UINT64_FMTX__ = "lX";
pub const __UINT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __INT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_long;
pub const __INT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "ld";
pub const __INT_LEAST64_FMTi__ = "li";
pub const __UINT_LEAST64_TYPE__ = c_ulong;
pub const __UINT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_LEAST64_FMTo__ = "lo";
pub const __UINT_LEAST64_FMTu__ = "lu";
pub const __UINT_LEAST64_FMTx__ = "lx";
pub const __UINT_LEAST64_FMTX__ = "lX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_long;
pub const __INT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "ld";
pub const __INT_FAST64_FMTi__ = "li";
pub const __UINT_FAST64_TYPE__ = c_ulong;
pub const __UINT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_FAST64_FMTo__ = "lo";
pub const __UINT_FAST64_FMTu__ = "lu";
pub const __UINT_FAST64_FMTx__ = "lx";
pub const __UINT_FAST64_FMTX__ = "lX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __znver1 = @as(c_int, 1);
pub const __znver1__ = @as(c_int, 1);
pub const __tune_znver1__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MWAITX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __SSE4A__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __SHA__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __CLZERO__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const unix = @as(c_int, 1);
pub const __unix = @as(c_int, 1);
pub const __unix__ = @as(c_int, 1);
pub const linux = @as(c_int, 1);
pub const __linux = @as(c_int, 1);
pub const __linux__ = @as(c_int, 1);
pub const __ELF__ = @as(c_int, 1);
pub const __gnu_linux__ = @as(c_int, 1);
pub const __FLOAT128__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __GLIBC_MINOR__ = @as(c_int, 19);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const __GTK_H_INSIDE__ = "";
pub const __GTK_CSS_H_INSIDE__ = "";
pub const __G_LIB_H__ = "";
pub const __GLIB_H_INSIDE__ = "";
pub const __G_ALLOCA_H__ = "";
pub const __G_TYPES_H__ = "";
pub const __GLIBCONFIG_H__ = "";
pub const __G_MACROS_H__ = "";
pub const __STDDEF_H = "";
pub const __need_ptrdiff_t = "";
pub const __need_size_t = "";
pub const __need_wchar_t = "";
pub const __need_NULL = "";
pub const __need_STDDEF_H_misc = "";
pub const _PTRDIFF_T = "";
pub const _SIZE_T = "";
pub const _WCHAR_T = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const __CLANG_MAX_ALIGN_T_DEFINED = "";
pub inline fn G_GNUC_CHECK_VERSION(major: anytype, minor: anytype) @TypeOf((__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor))) {
    return (__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor));
}
pub inline fn G_CXX_STD_CHECK_VERSION(version: anytype) @TypeOf(@as(c_int, 0)) {
    _ = @TypeOf(version);
    return @as(c_int, 0);
}
pub const G_C_STD_VERSION = __STDC_VERSION__;
pub inline fn G_C_STD_CHECK_VERSION(version: anytype) @TypeOf((((((((version >= @as(c_long, 199000)) and (version <= G_C_STD_VERSION)) or ((version == @as(c_int, 89)) and (G_C_STD_VERSION >= @as(c_long, 199000)))) or ((version == @as(c_int, 90)) and (G_C_STD_VERSION >= @as(c_long, 199000)))) or ((version == @as(c_int, 99)) and (G_C_STD_VERSION >= @as(c_long, 199901)))) or ((version == @as(c_int, 11)) and (G_C_STD_VERSION >= @as(c_long, 201112)))) or ((version == @as(c_int, 17)) and (G_C_STD_VERSION >= @as(c_long, 201710)))) or (@as(c_int, 0) != 0)) {
    return (((((((version >= @as(c_long, 199000)) and (version <= G_C_STD_VERSION)) or ((version == @as(c_int, 89)) and (G_C_STD_VERSION >= @as(c_long, 199000)))) or ((version == @as(c_int, 90)) and (G_C_STD_VERSION >= @as(c_long, 199000)))) or ((version == @as(c_int, 99)) and (G_C_STD_VERSION >= @as(c_long, 199901)))) or ((version == @as(c_int, 11)) and (G_C_STD_VERSION >= @as(c_long, 201112)))) or ((version == @as(c_int, 17)) and (G_C_STD_VERSION >= @as(c_long, 201710)))) or (@as(c_int, 0) != 0);
}
pub const G_CAN_INLINE = "";
pub const g_macro__has_builtin = __has_builtin;
pub const G_GNUC_FUNCTION = ("" ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(G_STRFUNC);
pub const G_GNUC_PRETTY_FUNCTION = ("" ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(G_STRFUNC);
pub const G_ANALYZER_ANALYZING = @as(c_int, 0);
pub const G_ANALYZER_NORETURN = "";
pub inline fn G_STRINGIFY(macro_or_string: anytype) @TypeOf(G_STRINGIFY_ARG(macro_or_string)) {
    return G_STRINGIFY_ARG(macro_or_string);
}
pub inline fn G_PASTE(identifier1: anytype, identifier2: anytype) @TypeOf(G_PASTE_ARGS(identifier1, identifier2)) {
    return G_PASTE_ARGS(identifier1, identifier2);
}
pub const G_BEGIN_DECLS = "";
pub const G_END_DECLS = "";
pub const FALSE = @as(c_int, 0);
pub const TRUE = !(FALSE != 0);
pub inline fn MAX(a: anytype, b: anytype) @TypeOf(if (a > b) a else b) {
    return if (a > b) a else b;
}
pub inline fn MIN(a: anytype, b: anytype) @TypeOf(if (a < b) a else b) {
    return if (a < b) a else b;
}
pub inline fn ABS(a: anytype) @TypeOf(if (a < @as(c_int, 0)) -a else a) {
    return if (a < @as(c_int, 0)) -a else a;
}
pub inline fn CLAMP(x: anytype, low: anytype, high: anytype) @TypeOf(if (x > high) high else if (x < low) low else x) {
    return if (x > high) high else if (x < low) low else x;
}
pub inline fn G_APPROX_VALUE(a: anytype, b: anytype, epsilon: anytype) @TypeOf((if (a > b) a - b else b - a) < epsilon) {
    return (if (a > b) a - b else b - a) < epsilon;
}
pub inline fn GPOINTER_TO_SIZE(p: anytype) gsize {
    return @import("std").zig.c_translation.cast(gsize, p);
}
pub inline fn GSIZE_TO_POINTER(s: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast(guintptr, @import("std").zig.c_translation.cast(gsize, s)));
}
pub inline fn G_STRUCT_OFFSET(struct_type: anytype, member: anytype) glong {
    return @import("std").zig.c_translation.cast(glong, offsetof(struct_type, member));
}
pub inline fn G_STRUCT_MEMBER_P(struct_p: anytype, struct_offset: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast([*c]guint8, struct_p) + @import("std").zig.c_translation.cast(glong, struct_offset));
}
pub inline fn G_LIKELY(expr: anytype) @TypeOf(expr) {
    return expr;
}
pub inline fn G_UNLIKELY(expr: anytype) @TypeOf(expr) {
    return expr;
}
pub const G_HAVE_GNUC_VISIBILITY = @as(c_int, 1);
pub const GLIB_DEPRECATED_ENUMERATOR = G_DEPRECATED;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_FOR(f: anytype) @TypeOf(G_DEPRECATED_FOR(f)) {
    return G_DEPRECATED_FOR(f);
}
pub inline fn GLIB_UNAVAILABLE_ENUMERATOR(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GLIB_DEPRECATED_TYPE = G_DEPRECATED;
pub inline fn GLIB_DEPRECATED_TYPE_FOR(f: anytype) @TypeOf(G_DEPRECATED_FOR(f)) {
    return G_DEPRECATED_FOR(f);
}
pub inline fn GLIB_UNAVAILABLE_TYPE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub inline fn _GLIB_DEFINE_AUTOPTR_CHAINUP(ModuleObjName: anytype, ParentName: anytype) @TypeOf(_GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(ModuleObjName, ParentName, _GLIB_AUTOPTR_CLEAR_FUNC_NAME(ParentName))) {
    return _GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(ModuleObjName, ParentName, _GLIB_AUTOPTR_CLEAR_FUNC_NAME(ParentName));
}
pub inline fn G_DEFINE_AUTOPTR_CLEANUP_FUNC(TypeName: anytype, func: anytype) @TypeOf(_GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(TypeName, TypeName, func)) {
    return _GLIB_DEFINE_AUTOPTR_CLEANUP_FUNCS(TypeName, TypeName, func);
}
pub const g_autofree = _GLIB_CLEANUP(g_autoptr_cleanup_generic_gfree);
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const _LIBC_LIMITS_H_ = @as(c_int, 1);
pub const __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION = "";
pub const _FEATURES_H = @as(c_int, 1);
pub const __KERNEL_STRICT_NAMES = "";
pub inline fn __GNUC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub inline fn __glibc_clang_prereq(maj: anytype, min: anytype) @TypeOf(((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _DEFAULT_SOURCE = @as(c_int, 1);
pub const __GLIBC_USE_ISOC2X = @as(c_int, 0);
pub const __USE_ISOC11 = @as(c_int, 1);
pub const __USE_ISOC99 = @as(c_int, 1);
pub const __USE_ISOC95 = @as(c_int, 1);
pub const __USE_POSIX_IMPLICITLY = @as(c_int, 1);
pub const _POSIX_SOURCE = @as(c_int, 1);
pub const _POSIX_C_SOURCE = @as(c_long, 200809);
pub const __USE_POSIX = @as(c_int, 1);
pub const __USE_POSIX2 = @as(c_int, 1);
pub const __USE_POSIX199309 = @as(c_int, 1);
pub const __USE_POSIX199506 = @as(c_int, 1);
pub const __USE_XOPEN2K = @as(c_int, 1);
pub const __USE_XOPEN2K8 = @as(c_int, 1);
pub const _ATFILE_SOURCE = @as(c_int, 1);
pub const __WORDSIZE = @as(c_int, 64);
pub const __WORDSIZE_TIME64_COMPAT32 = @as(c_int, 1);
pub const __SYSCALL_WORDSIZE = @as(c_int, 64);
pub const __TIMESIZE = __WORDSIZE;
pub const __USE_MISC = @as(c_int, 1);
pub const __USE_ATFILE = @as(c_int, 1);
pub const __USE_FORTIFY_LEVEL = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_GETS = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_SCANF = @as(c_int, 0);
pub const __GLIBC_USE_C2X_STRTOL = @as(c_int, 0);
pub const _STDC_PREDEF_H = @as(c_int, 1);
pub const __STDC_IEC_559__ = @as(c_int, 1);
pub const __STDC_IEC_60559_BFP__ = @as(c_long, 201404);
pub const __STDC_IEC_559_COMPLEX__ = @as(c_int, 1);
pub const __STDC_IEC_60559_COMPLEX__ = @as(c_long, 201404);
pub const __STDC_ISO_10646__ = @as(c_long, 201706);
pub const __GNU_LIBRARY__ = @as(c_int, 6);
pub const __GLIBC__ = @as(c_int, 2);
pub inline fn __GLIBC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _SYS_CDEFS_H = @as(c_int, 1);
pub inline fn __glibc_has_builtin(name: anytype) @TypeOf(__has_builtin(name)) {
    return __has_builtin(name);
}
pub const __LEAF = "";
pub const __LEAF_ATTR = "";
pub inline fn __P(args: anytype) @TypeOf(args) {
    return args;
}
pub inline fn __PMT(args: anytype) @TypeOf(args) {
    return args;
}
pub const __ptr_t = ?*anyopaque;
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub inline fn __bos(ptr: anytype) @TypeOf(__builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1))) {
    return __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1));
}
pub inline fn __bos0(ptr: anytype) @TypeOf(__builtin_object_size(ptr, @as(c_int, 0))) {
    return __builtin_object_size(ptr, @as(c_int, 0));
}
pub inline fn __glibc_objsize0(__o: anytype) @TypeOf(__bos0(__o)) {
    return __bos0(__o);
}
pub inline fn __glibc_objsize(__o: anytype) @TypeOf(__bos(__o)) {
    return __bos(__o);
}
pub const __glibc_c99_flexarr_available = @as(c_int, 1);
pub inline fn __ASMNAME(cname: anytype) @TypeOf(__ASMNAME2(__USER_LABEL_PREFIX__, cname)) {
    return __ASMNAME2(__USER_LABEL_PREFIX__, cname);
}
pub const __REDIRECT_FORTIFY = __REDIRECT;
pub const __REDIRECT_FORTIFY_NTH = __REDIRECT_NTH;
pub inline fn __nonnull(params: anytype) @TypeOf(__attribute_nonnull__(params)) {
    return __attribute_nonnull__(params);
}
pub const __wur = "";
pub const __fortify_function = __extern_always_inline ++ __attribute_artificial__;
pub inline fn __glibc_unlikely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 0))) {
    return __builtin_expect(cond, @as(c_int, 0));
}
pub inline fn __glibc_likely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 1))) {
    return __builtin_expect(cond, @as(c_int, 1));
}
pub const __attribute_nonstring__ = "";
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = @as(c_int, 0);
pub inline fn __LDBL_REDIR1(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto) {
    _ = @TypeOf(alias);
    return name ++ proto;
}
pub inline fn __LDBL_REDIR(name: anytype, proto: anytype) @TypeOf(name ++ proto) {
    return name ++ proto;
}
pub inline fn __LDBL_REDIR1_NTH(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = @TypeOf(alias);
    return name ++ proto ++ __THROW;
}
pub inline fn __LDBL_REDIR_NTH(name: anytype, proto: anytype) @TypeOf(name ++ proto ++ __THROW) {
    return name ++ proto ++ __THROW;
}
pub inline fn __REDIRECT_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT(name, proto, alias)) {
    return __REDIRECT(name, proto, alias);
}
pub inline fn __REDIRECT_NTH_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT_NTH(name, proto, alias)) {
    return __REDIRECT_NTH(name, proto, alias);
}
pub const __HAVE_GENERIC_SELECTION = @as(c_int, 1);
pub const __attr_dealloc_free = "";
pub const __stub___compat_bdflush = "";
pub const __stub_chflags = "";
pub const __stub_fchflags = "";
pub const __stub_gtty = "";
pub const __stub_revoke = "";
pub const __stub_setlogin = "";
pub const __stub_sigreturn = "";
pub const __stub_stty = "";
pub const __GLIBC_USE_LIB_EXT2 = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_TYPES_EXT = @as(c_int, 0);
pub const MB_LEN_MAX = @as(c_int, 16);
pub const LLONG_MIN = -LLONG_MAX - @as(c_int, 1);
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const ULLONG_MAX = (LLONG_MAX * @as(c_ulonglong, 2)) + @as(c_int, 1);
pub const _BITS_POSIX1_LIM_H = @as(c_int, 1);
pub const _POSIX_AIO_LISTIO_MAX = @as(c_int, 2);
pub const _POSIX_AIO_MAX = @as(c_int, 1);
pub const _POSIX_ARG_MAX = @as(c_int, 4096);
pub const _POSIX_CHILD_MAX = @as(c_int, 25);
pub const _POSIX_DELAYTIMER_MAX = @as(c_int, 32);
pub const _POSIX_HOST_NAME_MAX = @as(c_int, 255);
pub const _POSIX_LINK_MAX = @as(c_int, 8);
pub const _POSIX_LOGIN_NAME_MAX = @as(c_int, 9);
pub const _POSIX_MAX_CANON = @as(c_int, 255);
pub const _POSIX_MAX_INPUT = @as(c_int, 255);
pub const _POSIX_MQ_OPEN_MAX = @as(c_int, 8);
pub const _POSIX_MQ_PRIO_MAX = @as(c_int, 32);
pub const _POSIX_NAME_MAX = @as(c_int, 14);
pub const _POSIX_NGROUPS_MAX = @as(c_int, 8);
pub const _POSIX_OPEN_MAX = @as(c_int, 20);
pub const _POSIX_PATH_MAX = @as(c_int, 256);
pub const _POSIX_PIPE_BUF = @as(c_int, 512);
pub const _POSIX_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX_RTSIG_MAX = @as(c_int, 8);
pub const _POSIX_SEM_NSEMS_MAX = @as(c_int, 256);
pub const _POSIX_SEM_VALUE_MAX = @as(c_int, 32767);
pub const _POSIX_SIGQUEUE_MAX = @as(c_int, 32);
pub const _POSIX_SSIZE_MAX = @as(c_int, 32767);
pub const _POSIX_STREAM_MAX = @as(c_int, 8);
pub const _POSIX_SYMLINK_MAX = @as(c_int, 255);
pub const _POSIX_SYMLOOP_MAX = @as(c_int, 8);
pub const _POSIX_TIMER_MAX = @as(c_int, 32);
pub const _POSIX_TTY_NAME_MAX = @as(c_int, 9);
pub const _POSIX_TZNAME_MAX = @as(c_int, 6);
pub const _POSIX_CLOCKRES_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 20000000, .decimal);
pub const __undef_NR_OPEN = "";
pub const __undef_LINK_MAX = "";
pub const __undef_OPEN_MAX = "";
pub const __undef_ARG_MAX = "";
pub const _LINUX_LIMITS_H = "";
pub const NR_OPEN = @as(c_int, 1024);
pub const NGROUPS_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const ARG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const LINK_MAX = @as(c_int, 127);
pub const MAX_CANON = @as(c_int, 255);
pub const MAX_INPUT = @as(c_int, 255);
pub const NAME_MAX = @as(c_int, 255);
pub const PATH_MAX = @as(c_int, 4096);
pub const PIPE_BUF = @as(c_int, 4096);
pub const XATTR_NAME_MAX = @as(c_int, 255);
pub const XATTR_SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const XATTR_LIST_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const RTSIG_MAX = @as(c_int, 32);
pub const _POSIX_THREAD_KEYS_MAX = @as(c_int, 128);
pub const PTHREAD_KEYS_MAX = @as(c_int, 1024);
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
pub const _POSIX_THREAD_THREADS_MAX = @as(c_int, 64);
pub const AIO_PRIO_DELTA_MAX = @as(c_int, 20);
pub const PTHREAD_STACK_MIN = @as(c_int, 16384);
pub const DELAYTIMER_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const TTY_NAME_MAX = @as(c_int, 32);
pub const LOGIN_NAME_MAX = @as(c_int, 256);
pub const HOST_NAME_MAX = @as(c_int, 64);
pub const MQ_PRIO_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SEM_VALUE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SSIZE_MAX = LONG_MAX;
pub const _BITS_POSIX2_LIM_H = @as(c_int, 1);
pub const _POSIX2_BC_BASE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_DIM_MAX = @as(c_int, 2048);
pub const _POSIX2_BC_SCALE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_STRING_MAX = @as(c_int, 1000);
pub const _POSIX2_COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const _POSIX2_EXPR_NEST_MAX = @as(c_int, 32);
pub const _POSIX2_LINE_MAX = @as(c_int, 2048);
pub const _POSIX2_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX2_CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const BC_BASE_MAX = _POSIX2_BC_BASE_MAX;
pub const BC_DIM_MAX = _POSIX2_BC_DIM_MAX;
pub const BC_SCALE_MAX = _POSIX2_BC_SCALE_MAX;
pub const BC_STRING_MAX = _POSIX2_BC_STRING_MAX;
pub const COLL_WEIGHTS_MAX = @as(c_int, 255);
pub const EXPR_NEST_MAX = _POSIX2_EXPR_NEST_MAX;
pub const LINE_MAX = _POSIX2_LINE_MAX;
pub const CHARCLASS_NAME_MAX = @as(c_int, 2048);
pub const RE_DUP_MAX = @as(c_int, 0x7fff);
pub const SCHAR_MAX = __SCHAR_MAX__;
pub const SHRT_MAX = __SHRT_MAX__;
pub const INT_MAX = __INT_MAX__;
pub const LONG_MAX = __LONG_MAX__;
pub const SCHAR_MIN = -__SCHAR_MAX__ - @as(c_int, 1);
pub const SHRT_MIN = -__SHRT_MAX__ - @as(c_int, 1);
pub const INT_MIN = -__INT_MAX__ - @as(c_int, 1);
pub const LONG_MIN = -__LONG_MAX__ - @as(c_long, 1);
pub const UCHAR_MAX = (__SCHAR_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const USHRT_MAX = (__SHRT_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const UINT_MAX = (__INT_MAX__ * @as(c_uint, 2)) + @as(c_uint, 1);
pub const ULONG_MAX = (__LONG_MAX__ * @as(c_ulong, 2)) + @as(c_ulong, 1);
pub const CHAR_BIT = __CHAR_BIT__;
pub const CHAR_MIN = SCHAR_MIN;
pub const CHAR_MAX = __SCHAR_MAX__;
pub const __CLANG_FLOAT_H = "";
pub const FLT_RADIX = __FLT_RADIX__;
pub const FLT_MANT_DIG = __FLT_MANT_DIG__;
pub const DBL_MANT_DIG = __DBL_MANT_DIG__;
pub const LDBL_MANT_DIG = __LDBL_MANT_DIG__;
pub const DECIMAL_DIG = __DECIMAL_DIG__;
pub const FLT_DIG = __FLT_DIG__;
pub const DBL_DIG = __DBL_DIG__;
pub const LDBL_DIG = __LDBL_DIG__;
pub const FLT_MIN_EXP = __FLT_MIN_EXP__;
pub const DBL_MIN_EXP = __DBL_MIN_EXP__;
pub const LDBL_MIN_EXP = __LDBL_MIN_EXP__;
pub const FLT_MIN_10_EXP = __FLT_MIN_10_EXP__;
pub const DBL_MIN_10_EXP = __DBL_MIN_10_EXP__;
pub const LDBL_MIN_10_EXP = __LDBL_MIN_10_EXP__;
pub const FLT_MAX_EXP = __FLT_MAX_EXP__;
pub const DBL_MAX_EXP = __DBL_MAX_EXP__;
pub const LDBL_MAX_EXP = __LDBL_MAX_EXP__;
pub const FLT_MAX_10_EXP = __FLT_MAX_10_EXP__;
pub const DBL_MAX_10_EXP = __DBL_MAX_10_EXP__;
pub const LDBL_MAX_10_EXP = __LDBL_MAX_10_EXP__;
pub const FLT_MAX = __FLT_MAX__;
pub const DBL_MAX = __DBL_MAX__;
pub const LDBL_MAX = __LDBL_MAX__;
pub const FLT_EPSILON = __FLT_EPSILON__;
pub const DBL_EPSILON = __DBL_EPSILON__;
pub const LDBL_EPSILON = __LDBL_EPSILON__;
pub const FLT_MIN = __FLT_MIN__;
pub const DBL_MIN = __DBL_MIN__;
pub const LDBL_MIN = __LDBL_MIN__;
pub const FLT_TRUE_MIN = __FLT_DENORM_MIN__;
pub const DBL_TRUE_MIN = __DBL_DENORM_MIN__;
pub const LDBL_TRUE_MIN = __LDBL_DENORM_MIN__;
pub const FLT_DECIMAL_DIG = __FLT_DECIMAL_DIG__;
pub const DBL_DECIMAL_DIG = __DBL_DECIMAL_DIG__;
pub const LDBL_DECIMAL_DIG = __LDBL_DECIMAL_DIG__;
pub const FLT_HAS_SUBNORM = __FLT_HAS_DENORM__;
pub const DBL_HAS_SUBNORM = __DBL_HAS_DENORM__;
pub const LDBL_HAS_SUBNORM = __LDBL_HAS_DENORM__;
pub const GLIB_HAVE_ALLOCA_H = "";
pub const GLIB_USING_SYSTEM_PRINTF = "";
pub const G_MINFLOAT = FLT_MIN;
pub const G_MAXFLOAT = FLT_MAX;
pub const G_MINDOUBLE = DBL_MIN;
pub const G_MAXDOUBLE = DBL_MAX;
pub const G_MINSHORT = SHRT_MIN;
pub const G_MAXSHORT = SHRT_MAX;
pub const G_MAXUSHORT = USHRT_MAX;
pub const G_MININT = INT_MIN;
pub const G_MAXINT = INT_MAX;
pub const G_MAXUINT = UINT_MAX;
pub const G_MINLONG = LONG_MIN;
pub const G_MAXLONG = LONG_MAX;
pub const G_MAXULONG = ULONG_MAX;
pub const G_GINT16_MODIFIER = "h";
pub const G_GINT16_FORMAT = "hi";
pub const G_GUINT16_FORMAT = "hu";
pub const G_GINT32_MODIFIER = "";
pub const G_GINT32_FORMAT = "i";
pub const G_GUINT32_FORMAT = "u";
pub const G_HAVE_GINT64 = @as(c_int, 1);
pub const G_GINT64_CONSTANT = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const G_GUINT64_CONSTANT = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const G_GINT64_MODIFIER = "l";
pub const G_GINT64_FORMAT = "li";
pub const G_GUINT64_FORMAT = "lu";
pub const GLIB_SIZEOF_VOID_P = @as(c_int, 8);
pub const GLIB_SIZEOF_LONG = @as(c_int, 8);
pub const GLIB_SIZEOF_SIZE_T = @as(c_int, 8);
pub const GLIB_SIZEOF_SSIZE_T = @as(c_int, 8);
pub const G_GSIZE_MODIFIER = "l";
pub const G_GSSIZE_MODIFIER = "l";
pub const G_GSIZE_FORMAT = "lu";
pub const G_GSSIZE_FORMAT = "li";
pub const G_MAXSIZE = G_MAXULONG;
pub const G_MINSSIZE = G_MINLONG;
pub const G_MAXSSIZE = G_MAXLONG;
pub const G_MINOFFSET = G_MININT64;
pub const G_MAXOFFSET = G_MAXINT64;
pub const G_GOFFSET_MODIFIER = G_GINT64_MODIFIER;
pub const G_GOFFSET_FORMAT = G_GINT64_FORMAT;
pub inline fn G_GOFFSET_CONSTANT(val: anytype) @TypeOf(G_GINT64_CONSTANT(val)) {
    return G_GINT64_CONSTANT(val);
}
pub const G_POLLFD_FORMAT = "%d";
pub inline fn GPOINTER_TO_INT(p: anytype) gint {
    return @import("std").zig.c_translation.cast(gint, @import("std").zig.c_translation.cast(glong, p));
}
pub inline fn GPOINTER_TO_UINT(p: anytype) guint {
    return @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.cast(gulong, p));
}
pub inline fn GINT_TO_POINTER(i: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast(glong, i));
}
pub inline fn GUINT_TO_POINTER(u: anytype) gpointer {
    return @import("std").zig.c_translation.cast(gpointer, @import("std").zig.c_translation.cast(gulong, u));
}
pub const G_GINTPTR_MODIFIER = "l";
pub const G_GINTPTR_FORMAT = "li";
pub const G_GUINTPTR_FORMAT = "lu";
pub const GLIB_MAJOR_VERSION = @as(c_int, 2);
pub const GLIB_MINOR_VERSION = @as(c_int, 78);
pub const GLIB_MICRO_VERSION = @as(c_int, 3);
pub const G_OS_UNIX = "";
pub const G_VA_COPY = va_copy;
pub const G_VA_COPY_AS_ARRAY = @as(c_int, 1);
pub const G_HAVE_ISO_VARARGS = @as(c_int, 1);
pub const G_HAVE_GROWING_STACK = @as(c_int, 0);
pub const G_HAVE_GNUC_VARARGS = @as(c_int, 1);
pub const G_THREADS_ENABLED = "";
pub const G_THREADS_IMPL_POSIX = "";
pub const G_ATOMIC_LOCK_FREE = "";
pub inline fn GINT16_TO_LE(val: anytype) gint16 {
    return @import("std").zig.c_translation.cast(gint16, val);
}
pub inline fn GUINT16_TO_LE(val: anytype) guint16 {
    return @import("std").zig.c_translation.cast(guint16, val);
}
pub inline fn GINT16_TO_BE(val: anytype) gint16 {
    return @import("std").zig.c_translation.cast(gint16, GUINT16_SWAP_LE_BE(val));
}
pub inline fn GUINT16_TO_BE(val: anytype) @TypeOf(GUINT16_SWAP_LE_BE(val)) {
    return GUINT16_SWAP_LE_BE(val);
}
pub inline fn GINT32_TO_LE(val: anytype) gint32 {
    return @import("std").zig.c_translation.cast(gint32, val);
}
pub inline fn GUINT32_TO_LE(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, val);
}
pub inline fn GINT32_TO_BE(val: anytype) gint32 {
    return @import("std").zig.c_translation.cast(gint32, GUINT32_SWAP_LE_BE(val));
}
pub inline fn GUINT32_TO_BE(val: anytype) @TypeOf(GUINT32_SWAP_LE_BE(val)) {
    return GUINT32_SWAP_LE_BE(val);
}
pub inline fn GINT64_TO_LE(val: anytype) gint64 {
    return @import("std").zig.c_translation.cast(gint64, val);
}
pub inline fn GUINT64_TO_LE(val: anytype) guint64 {
    return @import("std").zig.c_translation.cast(guint64, val);
}
pub inline fn GINT64_TO_BE(val: anytype) gint64 {
    return @import("std").zig.c_translation.cast(gint64, GUINT64_SWAP_LE_BE(val));
}
pub inline fn GUINT64_TO_BE(val: anytype) @TypeOf(GUINT64_SWAP_LE_BE(val)) {
    return GUINT64_SWAP_LE_BE(val);
}
pub inline fn GLONG_TO_LE(val: anytype) glong {
    return @import("std").zig.c_translation.cast(glong, GINT64_TO_LE(val));
}
pub inline fn GULONG_TO_LE(val: anytype) gulong {
    return @import("std").zig.c_translation.cast(gulong, GUINT64_TO_LE(val));
}
pub inline fn GLONG_TO_BE(val: anytype) glong {
    return @import("std").zig.c_translation.cast(glong, GINT64_TO_BE(val));
}
pub inline fn GULONG_TO_BE(val: anytype) gulong {
    return @import("std").zig.c_translation.cast(gulong, GUINT64_TO_BE(val));
}
pub inline fn GINT_TO_LE(val: anytype) gint {
    return @import("std").zig.c_translation.cast(gint, GINT32_TO_LE(val));
}
pub inline fn GUINT_TO_LE(val: anytype) guint {
    return @import("std").zig.c_translation.cast(guint, GUINT32_TO_LE(val));
}
pub inline fn GINT_TO_BE(val: anytype) gint {
    return @import("std").zig.c_translation.cast(gint, GINT32_TO_BE(val));
}
pub inline fn GUINT_TO_BE(val: anytype) guint {
    return @import("std").zig.c_translation.cast(guint, GUINT32_TO_BE(val));
}
pub inline fn GSIZE_TO_LE(val: anytype) gsize {
    return @import("std").zig.c_translation.cast(gsize, GUINT64_TO_LE(val));
}
pub inline fn GSSIZE_TO_LE(val: anytype) gssize {
    return @import("std").zig.c_translation.cast(gssize, GINT64_TO_LE(val));
}
pub inline fn GSIZE_TO_BE(val: anytype) gsize {
    return @import("std").zig.c_translation.cast(gsize, GUINT64_TO_BE(val));
}
pub inline fn GSSIZE_TO_BE(val: anytype) gssize {
    return @import("std").zig.c_translation.cast(gssize, GINT64_TO_BE(val));
}
pub const G_BYTE_ORDER = G_LITTLE_ENDIAN;
pub const G_MODULE_SUFFIX = "so";
pub const G_PID_FORMAT = "i";
pub const GLIB_SYSDEF_AF_UNIX = @as(c_int, 1);
pub const GLIB_SYSDEF_AF_INET = @as(c_int, 2);
pub const GLIB_SYSDEF_AF_INET6 = @as(c_int, 10);
pub const GLIB_SYSDEF_MSG_OOB = @as(c_int, 1);
pub const GLIB_SYSDEF_MSG_PEEK = @as(c_int, 2);
pub const GLIB_SYSDEF_MSG_DONTROUTE = @as(c_int, 4);
pub const G_DIR_SEPARATOR = '/';
pub const G_DIR_SEPARATOR_S = "/";
pub const G_SEARCHPATH_SEPARATOR = ':';
pub const G_SEARCHPATH_SEPARATOR_S = ":";
pub const __G_VERSION_MACROS_H__ = "";
pub inline fn G_ENCODE_VERSION(major: anytype, minor: anytype) @TypeOf((major << @as(c_int, 16)) | (minor << @as(c_int, 8))) {
    return (major << @as(c_int, 16)) | (minor << @as(c_int, 8));
}
pub const GLIB_VERSION_2_2 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 2));
pub const GLIB_VERSION_2_4 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 4));
pub const GLIB_VERSION_2_6 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 6));
pub const GLIB_VERSION_2_8 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 8));
pub const GLIB_VERSION_2_10 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 10));
pub const GLIB_VERSION_2_12 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 12));
pub const GLIB_VERSION_2_14 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 14));
pub const GLIB_VERSION_2_16 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 16));
pub const GLIB_VERSION_2_18 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 18));
pub const GLIB_VERSION_2_20 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 20));
pub const GLIB_VERSION_2_22 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 22));
pub const GLIB_VERSION_2_24 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 24));
pub const GLIB_VERSION_2_26 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 26));
pub const GLIB_VERSION_2_28 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 28));
pub const GLIB_VERSION_2_30 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 30));
pub const GLIB_VERSION_2_32 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 32));
pub const GLIB_VERSION_2_34 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 34));
pub const GLIB_VERSION_2_36 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 36));
pub const GLIB_VERSION_2_38 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 38));
pub const GLIB_VERSION_2_40 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 40));
pub const GLIB_VERSION_2_42 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 42));
pub const GLIB_VERSION_2_44 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 44));
pub const GLIB_VERSION_2_46 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 46));
pub const GLIB_VERSION_2_48 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 48));
pub const GLIB_VERSION_2_50 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 50));
pub const GLIB_VERSION_2_52 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 52));
pub const GLIB_VERSION_2_54 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 54));
pub const GLIB_VERSION_2_56 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 56));
pub const GLIB_VERSION_2_58 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 58));
pub const GLIB_VERSION_2_60 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 60));
pub const GLIB_VERSION_2_62 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 62));
pub const GLIB_VERSION_2_64 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 64));
pub const GLIB_VERSION_2_66 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 66));
pub const GLIB_VERSION_2_68 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 68));
pub const GLIB_VERSION_2_70 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 70));
pub const GLIB_VERSION_2_72 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 72));
pub const GLIB_VERSION_2_74 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 74));
pub const GLIB_VERSION_2_76 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 76));
pub const GLIB_VERSION_2_78 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 78));
pub const GLIB_VERSION_CUR_STABLE = G_ENCODE_VERSION(GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION);
pub const GLIB_VERSION_PREV_STABLE = G_ENCODE_VERSION(GLIB_MAJOR_VERSION, GLIB_MINOR_VERSION - @as(c_int, 2));
pub const GLIB_VERSION_MIN_REQUIRED = GLIB_VERSION_CUR_STABLE;
pub const GLIB_VERSION_MAX_ALLOWED = GLIB_VERSION_CUR_STABLE;
pub const _GLIB_IMPORT = "";
pub const _GLIB_API = _GLIB_IMPORT;
pub const GLIB_VAR = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_IN_ALL = _GLIB_EXTERN;
pub const GLIB_DEPRECATED = G_DEPRECATED ++ _GLIB_EXTERN;
pub inline fn GLIB_UNAVAILABLE_STATIC_INLINE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GLIB_DEPRECATED_IN_2_26 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_26 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_26 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_26 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_26 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_26 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_26 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_26 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_26 = "";
pub const GLIB_DEPRECATED_IN_2_28 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_28 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_28 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_28 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_28 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_28 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_28 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_28 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_28 = "";
pub const GLIB_DEPRECATED_IN_2_30 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_30 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_30 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_30 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_30 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_30 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_30 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_30 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_30 = "";
pub const GLIB_DEPRECATED_IN_2_32 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_32 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_32 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_32 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_32 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_32 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_32 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_32 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_32 = "";
pub const GLIB_DEPRECATED_IN_2_34 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_34 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_34 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_34 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_34 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_34 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_34 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_34 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_34 = "";
pub const GLIB_DEPRECATED_IN_2_36 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_36 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_36 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_36 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_36 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_36 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_36 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_36 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_36 = "";
pub const GLIB_DEPRECATED_IN_2_38 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_38 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_38 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_38 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_38 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_38 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_38 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_38 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_38 = "";
pub const GLIB_DEPRECATED_IN_2_40 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_40 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_40 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_40 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_40 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_40 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_40 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_40 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_40 = "";
pub const GLIB_DEPRECATED_IN_2_42 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_42 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_42 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_42 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_42 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_42 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_42 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_42 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_42 = "";
pub const GLIB_DEPRECATED_IN_2_44 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_44 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_44 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_44 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_44 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_44 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_44 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_44 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_44 = "";
pub const GLIB_DEPRECATED_IN_2_46 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_46 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_46 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_46 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_46 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_46 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_46 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_46 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_46 = "";
pub const GLIB_DEPRECATED_IN_2_48 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_48 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_48 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_48 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_48 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_48 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_48 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_48 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_48 = "";
pub const GLIB_DEPRECATED_IN_2_50 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_50 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_50 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_50 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_50 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_50 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_50 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_50 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_50 = "";
pub const GLIB_DEPRECATED_IN_2_52 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_52 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_52 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_52 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_52 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_52 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_52 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_52 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_52 = "";
pub const GLIB_DEPRECATED_IN_2_54 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_54 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_54 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_54 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_54 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_54 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_54 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_54 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_54 = "";
pub const GLIB_DEPRECATED_IN_2_56 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_56 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_56 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_56 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_56 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_56 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_56 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_56 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_56 = "";
pub const GLIB_DEPRECATED_IN_2_58 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_58 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_58 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_58 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_58 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_58 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_58 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_58 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_58 = "";
pub const GLIB_DEPRECATED_IN_2_60 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_60 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_60 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_60 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_60 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_60 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_60 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_60 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_60 = "";
pub const GLIB_DEPRECATED_IN_2_62 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_62 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_62 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_62 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_62 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_62 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_62 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_62 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_62 = "";
pub const GLIB_DEPRECATED_IN_2_64 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_64 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_64 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_64 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_64 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_64 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_64 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_64 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_64 = "";
pub const GLIB_DEPRECATED_IN_2_66 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_66 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_66 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_66 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_66 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_66 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_66 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_66 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_66 = "";
pub const GLIB_DEPRECATED_IN_2_68 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_68 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_68 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_68 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_68 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_68 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_68 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_68 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_68 = "";
pub const GLIB_DEPRECATED_IN_2_70 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_70 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_70 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_70 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_70 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_70 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_70 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_70 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_70 = "";
pub const GLIB_DEPRECATED_IN_2_72 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_72 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_72 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_72 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_72 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_72 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_72 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_72 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_72 = "";
pub const GLIB_DEPRECATED_IN_2_74 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_74 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_74 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_74 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_74 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_74 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_74 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_74 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_74 = "";
pub const GLIB_DEPRECATED_IN_2_76 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_76 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_76 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_76 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_76 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_76 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_76 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_76 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_76 = "";
pub const GLIB_DEPRECATED_IN_2_78 = GLIB_DEPRECATED;
pub inline fn GLIB_DEPRECATED_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_FOR(f)) {
    return GLIB_DEPRECATED_FOR(f);
}
pub const GLIB_DEPRECATED_MACRO_IN_2_78 = GLIB_DEPRECATED_MACRO;
pub inline fn GLIB_DEPRECATED_MACRO_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_78 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GLIB_DEPRECATED_ENUMERATOR_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GLIB_DEPRECATED_TYPE_IN_2_78 = GLIB_DEPRECATED_TYPE;
pub inline fn GLIB_DEPRECATED_TYPE_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GLIB_AVAILABLE_IN_2_78 = _GLIB_EXTERN;
pub const GLIB_AVAILABLE_STATIC_INLINE_IN_2_78 = "";
pub const GLIB_AVAILABLE_MACRO_IN_2_78 = "";
pub const GLIB_AVAILABLE_ENUMERATOR_IN_2_78 = "";
pub const GLIB_AVAILABLE_TYPE_IN_2_78 = "";
pub const _TIME_H = @as(c_int, 1);
pub const _BITS_TIME_H = @as(c_int, 1);
pub const _BITS_TYPES_H = @as(c_int, 1);
pub const __S16_TYPE = c_short;
pub const __U16_TYPE = c_ushort;
pub const __S32_TYPE = c_int;
pub const __U32_TYPE = c_uint;
pub const __SLONGWORD_TYPE = c_long;
pub const __ULONGWORD_TYPE = c_ulong;
pub const __SQUAD_TYPE = c_long;
pub const __UQUAD_TYPE = c_ulong;
pub const __SWORD_TYPE = c_long;
pub const __UWORD_TYPE = c_ulong;
pub const __SLONG32_TYPE = c_int;
pub const __ULONG32_TYPE = c_uint;
pub const __S64_TYPE = c_long;
pub const __U64_TYPE = c_ulong;
pub const _BITS_TYPESIZES_H = @as(c_int, 1);
pub const __SYSCALL_SLONG_TYPE = __SLONGWORD_TYPE;
pub const __SYSCALL_ULONG_TYPE = __ULONGWORD_TYPE;
pub const __DEV_T_TYPE = __UQUAD_TYPE;
pub const __UID_T_TYPE = __U32_TYPE;
pub const __GID_T_TYPE = __U32_TYPE;
pub const __INO_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __INO64_T_TYPE = __UQUAD_TYPE;
pub const __MODE_T_TYPE = __U32_TYPE;
pub const __NLINK_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSWORD_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF64_T_TYPE = __SQUAD_TYPE;
pub const __PID_T_TYPE = __S32_TYPE;
pub const __RLIM_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __RLIM64_T_TYPE = __UQUAD_TYPE;
pub const __BLKCNT_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __BLKCNT64_T_TYPE = __SQUAD_TYPE;
pub const __FSBLKCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSBLKCNT64_T_TYPE = __UQUAD_TYPE;
pub const __FSFILCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSFILCNT64_T_TYPE = __UQUAD_TYPE;
pub const __ID_T_TYPE = __U32_TYPE;
pub const __CLOCK_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __TIME_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __USECONDS_T_TYPE = __U32_TYPE;
pub const __SUSECONDS_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __SUSECONDS64_T_TYPE = __SQUAD_TYPE;
pub const __DADDR_T_TYPE = __S32_TYPE;
pub const __KEY_T_TYPE = __S32_TYPE;
pub const __CLOCKID_T_TYPE = __S32_TYPE;
pub const __TIMER_T_TYPE = ?*anyopaque;
pub const __BLKSIZE_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __SSIZE_T_TYPE = __SWORD_TYPE;
pub const __CPU_MASK_TYPE = __SYSCALL_ULONG_TYPE;
pub const __OFF_T_MATCHES_OFF64_T = @as(c_int, 1);
pub const __INO_T_MATCHES_INO64_T = @as(c_int, 1);
pub const __RLIM_T_MATCHES_RLIM64_T = @as(c_int, 1);
pub const __STATFS_MATCHES_STATFS64 = @as(c_int, 1);
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = @as(c_int, 1);
pub const __FD_SETSIZE = @as(c_int, 1024);
pub const _BITS_TIME64_H = @as(c_int, 1);
pub const __TIME64_T_TYPE = __TIME_T_TYPE;
pub const CLOCKS_PER_SEC = @import("std").zig.c_translation.cast(__clock_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const CLOCK_REALTIME = @as(c_int, 0);
pub const CLOCK_MONOTONIC = @as(c_int, 1);
pub const CLOCK_PROCESS_CPUTIME_ID = @as(c_int, 2);
pub const CLOCK_THREAD_CPUTIME_ID = @as(c_int, 3);
pub const CLOCK_MONOTONIC_RAW = @as(c_int, 4);
pub const CLOCK_REALTIME_COARSE = @as(c_int, 5);
pub const CLOCK_MONOTONIC_COARSE = @as(c_int, 6);
pub const CLOCK_BOOTTIME = @as(c_int, 7);
pub const CLOCK_REALTIME_ALARM = @as(c_int, 8);
pub const CLOCK_BOOTTIME_ALARM = @as(c_int, 9);
pub const CLOCK_TAI = @as(c_int, 11);
pub const TIMER_ABSTIME = @as(c_int, 1);
pub const __clock_t_defined = @as(c_int, 1);
pub const __time_t_defined = @as(c_int, 1);
pub const __struct_tm_defined = @as(c_int, 1);
pub const _STRUCT_TIMESPEC = @as(c_int, 1);
pub const _BITS_ENDIAN_H = @as(c_int, 1);
pub const __LITTLE_ENDIAN = @as(c_int, 1234);
pub const __BIG_ENDIAN = @as(c_int, 4321);
pub const __PDP_ENDIAN = @as(c_int, 3412);
pub const _BITS_ENDIANNESS_H = @as(c_int, 1);
pub const __BYTE_ORDER = __LITTLE_ENDIAN;
pub const __FLOAT_WORD_ORDER = __BYTE_ORDER;
pub inline fn __LONG_LONG_PAIR(HI: anytype, LO: anytype) @TypeOf(HI) {
    return blk: {
        _ = @TypeOf(LO);
        break :blk HI;
    };
}
pub const __clockid_t_defined = @as(c_int, 1);
pub const __timer_t_defined = @as(c_int, 1);
pub const __itimerspec_defined = @as(c_int, 1);
pub const __pid_t_defined = "";
pub const _BITS_TYPES_LOCALE_T_H = @as(c_int, 1);
pub const _BITS_TYPES___LOCALE_T_H = @as(c_int, 1);
pub const TIME_UTC = @as(c_int, 1);
pub inline fn __isleap(year: anytype) @TypeOf((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)))) {
    return (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)));
}
pub const G_MININT8 = @import("std").zig.c_translation.cast(gint8, -G_MAXINT8 - @as(c_int, 1));
pub const G_MAXINT8 = @import("std").zig.c_translation.cast(gint8, @as(c_int, 0x7f));
pub const G_MAXUINT8 = @import("std").zig.c_translation.cast(guint8, @as(c_int, 0xff));
pub const G_MININT16 = @import("std").zig.c_translation.cast(gint16, -G_MAXINT16 - @as(c_int, 1));
pub const G_MAXINT16 = @import("std").zig.c_translation.cast(gint16, @as(c_int, 0x7fff));
pub const G_MAXUINT16 = @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hexadecimal));
pub const G_MININT32 = @import("std").zig.c_translation.cast(gint32, -G_MAXINT32 - @as(c_int, 1));
pub const G_MAXINT32 = @import("std").zig.c_translation.cast(gint32, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hexadecimal));
pub const G_MAXUINT32 = @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal));
pub const G_MININT64 = @import("std").zig.c_translation.cast(gint64, -G_MAXINT64 - G_GINT64_CONSTANT(@as(c_int, 1)));
pub const G_MAXINT64 = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffffffffffff, .hexadecimal));
pub const G_MAXUINT64 = G_GUINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffffffffffff, .hexadecimal));
pub const G_E = @as(f64, 2.7182818284590452353602874713526624977572470937000);
pub const G_LN2 = @as(f64, 0.69314718055994530941723212145817656807550013436026);
pub const G_LN10 = @as(f64, 2.3025850929940456840179914546843642076011014886288);
pub const G_PI = @as(f64, 3.1415926535897932384626433832795028841971693993751);
pub const G_PI_2 = @as(f64, 1.5707963267948966192313216916397514420985846996876);
pub const G_PI_4 = @as(f64, 0.78539816339744830961566084581987572104929234984378);
pub const G_SQRT2 = @as(f64, 1.4142135623730950488016887242096980785696718753769);
pub const G_LITTLE_ENDIAN = @as(c_int, 1234);
pub const G_BIG_ENDIAN = @as(c_int, 4321);
pub const G_PDP_ENDIAN = @as(c_int, 3412);
pub inline fn GUINT16_SWAP_LE_BE_CONSTANT(val: anytype) guint16 {
    return @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.cast(guint16, val) >> @as(c_int, 8)) | @import("std").zig.c_translation.cast(guint16, @import("std").zig.c_translation.cast(guint16, val) << @as(c_int, 8)));
}
pub inline fn GUINT32_SWAP_LE_BE_CONSTANT(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @as(c_uint, 0x000000ff))) << @as(c_int, 24)) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @as(c_uint, 0x0000ff00))) << @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal))) >> @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal))) >> @as(c_int, 24)));
}
pub inline fn GUINT64_SWAP_LE_BE_CONSTANT(val: anytype) guint64 {
    return @import("std").zig.c_translation.cast(guint64, ((((((((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@as(c_uint, 0x00000000000000ff)))) << @as(c_int, 56)) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@as(c_uint, 0x000000000000ff00)))) << @as(c_int, 40))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x0000000000ff0000, .hexadecimal)))) << @as(c_int, 24))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00000000ff000000, .hexadecimal)))) << @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x000000ff00000000, .hexadecimal)))) >> @as(c_int, 8))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x0000ff0000000000, .hexadecimal)))) >> @as(c_int, 24))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff000000000000, .hexadecimal)))) >> @as(c_int, 40))) | ((@import("std").zig.c_translation.cast(guint64, val) & @import("std").zig.c_translation.cast(guint64, G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff00000000000000, .hexadecimal)))) >> @as(c_int, 56)));
}
pub inline fn GUINT16_SWAP_LE_BE(val: anytype) @TypeOf(GUINT16_SWAP_LE_BE_CONSTANT(val)) {
    return GUINT16_SWAP_LE_BE_CONSTANT(val);
}
pub inline fn GUINT32_SWAP_LE_BE(val: anytype) @TypeOf(GUINT32_SWAP_LE_BE_CONSTANT(val)) {
    return GUINT32_SWAP_LE_BE_CONSTANT(val);
}
pub inline fn GUINT64_SWAP_LE_BE(val: anytype) @TypeOf(GUINT64_SWAP_LE_BE_CONSTANT(val)) {
    return GUINT64_SWAP_LE_BE_CONSTANT(val);
}
pub inline fn GUINT16_SWAP_LE_PDP(val: anytype) guint16 {
    return @import("std").zig.c_translation.cast(guint16, val);
}
pub inline fn GUINT16_SWAP_BE_PDP(val: anytype) @TypeOf(GUINT16_SWAP_LE_BE(val)) {
    return GUINT16_SWAP_LE_BE(val);
}
pub inline fn GUINT32_SWAP_LE_PDP(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @as(c_uint, 0x0000ffff))) << @as(c_int, 16)) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffff0000, .hexadecimal))) >> @as(c_int, 16)));
}
pub inline fn GUINT32_SWAP_BE_PDP(val: anytype) guint32 {
    return @import("std").zig.c_translation.cast(guint32, ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff00ff, .hexadecimal))) << @as(c_int, 8)) | ((@import("std").zig.c_translation.cast(guint32, val) & @import("std").zig.c_translation.cast(guint32, @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff00ff00, .hexadecimal))) >> @as(c_int, 8)));
}
pub inline fn GINT16_FROM_LE(val: anytype) @TypeOf(GINT16_TO_LE(val)) {
    return GINT16_TO_LE(val);
}
pub inline fn GUINT16_FROM_LE(val: anytype) @TypeOf(GUINT16_TO_LE(val)) {
    return GUINT16_TO_LE(val);
}
pub inline fn GINT16_FROM_BE(val: anytype) @TypeOf(GINT16_TO_BE(val)) {
    return GINT16_TO_BE(val);
}
pub inline fn GUINT16_FROM_BE(val: anytype) @TypeOf(GUINT16_TO_BE(val)) {
    return GUINT16_TO_BE(val);
}
pub inline fn GINT32_FROM_LE(val: anytype) @TypeOf(GINT32_TO_LE(val)) {
    return GINT32_TO_LE(val);
}
pub inline fn GUINT32_FROM_LE(val: anytype) @TypeOf(GUINT32_TO_LE(val)) {
    return GUINT32_TO_LE(val);
}
pub inline fn GINT32_FROM_BE(val: anytype) @TypeOf(GINT32_TO_BE(val)) {
    return GINT32_TO_BE(val);
}
pub inline fn GUINT32_FROM_BE(val: anytype) @TypeOf(GUINT32_TO_BE(val)) {
    return GUINT32_TO_BE(val);
}
pub inline fn GINT64_FROM_LE(val: anytype) @TypeOf(GINT64_TO_LE(val)) {
    return GINT64_TO_LE(val);
}
pub inline fn GUINT64_FROM_LE(val: anytype) @TypeOf(GUINT64_TO_LE(val)) {
    return GUINT64_TO_LE(val);
}
pub inline fn GINT64_FROM_BE(val: anytype) @TypeOf(GINT64_TO_BE(val)) {
    return GINT64_TO_BE(val);
}
pub inline fn GUINT64_FROM_BE(val: anytype) @TypeOf(GUINT64_TO_BE(val)) {
    return GUINT64_TO_BE(val);
}
pub inline fn GLONG_FROM_LE(val: anytype) @TypeOf(GLONG_TO_LE(val)) {
    return GLONG_TO_LE(val);
}
pub inline fn GULONG_FROM_LE(val: anytype) @TypeOf(GULONG_TO_LE(val)) {
    return GULONG_TO_LE(val);
}
pub inline fn GLONG_FROM_BE(val: anytype) @TypeOf(GLONG_TO_BE(val)) {
    return GLONG_TO_BE(val);
}
pub inline fn GULONG_FROM_BE(val: anytype) @TypeOf(GULONG_TO_BE(val)) {
    return GULONG_TO_BE(val);
}
pub inline fn GINT_FROM_LE(val: anytype) @TypeOf(GINT_TO_LE(val)) {
    return GINT_TO_LE(val);
}
pub inline fn GUINT_FROM_LE(val: anytype) @TypeOf(GUINT_TO_LE(val)) {
    return GUINT_TO_LE(val);
}
pub inline fn GINT_FROM_BE(val: anytype) @TypeOf(GINT_TO_BE(val)) {
    return GINT_TO_BE(val);
}
pub inline fn GUINT_FROM_BE(val: anytype) @TypeOf(GUINT_TO_BE(val)) {
    return GUINT_TO_BE(val);
}
pub inline fn GSIZE_FROM_LE(val: anytype) @TypeOf(GSIZE_TO_LE(val)) {
    return GSIZE_TO_LE(val);
}
pub inline fn GSSIZE_FROM_LE(val: anytype) @TypeOf(GSSIZE_TO_LE(val)) {
    return GSSIZE_TO_LE(val);
}
pub inline fn GSIZE_FROM_BE(val: anytype) @TypeOf(GSIZE_TO_BE(val)) {
    return GSIZE_TO_BE(val);
}
pub inline fn GSSIZE_FROM_BE(val: anytype) @TypeOf(GSSIZE_TO_BE(val)) {
    return GSSIZE_TO_BE(val);
}
pub inline fn g_ntohl(val: anytype) @TypeOf(GUINT32_FROM_BE(val)) {
    return GUINT32_FROM_BE(val);
}
pub inline fn g_ntohs(val: anytype) @TypeOf(GUINT16_FROM_BE(val)) {
    return GUINT16_FROM_BE(val);
}
pub inline fn g_htonl(val: anytype) @TypeOf(GUINT32_TO_BE(val)) {
    return GUINT32_TO_BE(val);
}
pub inline fn g_htons(val: anytype) @TypeOf(GUINT16_TO_BE(val)) {
    return GUINT16_TO_BE(val);
}
pub const _GLIB_HAVE_BUILTIN_OVERFLOW_CHECKS = "";
pub inline fn g_uint_checked_mul(dest: anytype, a: anytype, b: anytype) @TypeOf(!(__builtin_mul_overflow(a, b, dest) != 0)) {
    return !(__builtin_mul_overflow(a, b, dest) != 0);
}
pub inline fn g_uint64_checked_mul(dest: anytype, a: anytype, b: anytype) @TypeOf(!(__builtin_mul_overflow(a, b, dest) != 0)) {
    return !(__builtin_mul_overflow(a, b, dest) != 0);
}
pub inline fn g_size_checked_mul(dest: anytype, a: anytype, b: anytype) @TypeOf(!(__builtin_mul_overflow(a, b, dest) != 0)) {
    return !(__builtin_mul_overflow(a, b, dest) != 0);
}
pub const G_IEEE754_FLOAT_BIAS = @as(c_int, 127);
pub const G_IEEE754_DOUBLE_BIAS = @as(c_int, 1023);
pub const G_LOG_2_BASE_10 = @as(f64, 0.30102999566398119521);
pub const _STRING_H = @as(c_int, 1);
pub const _STRINGS_H = @as(c_int, 1);
pub inline fn g_alloca(size: anytype) @TypeOf(alloca(size)) {
    return alloca(size);
}
pub inline fn g_alloca0(size: anytype) @TypeOf(if (size == @as(c_int, 0)) NULL else memset(g_alloca(size), @as(c_int, 0), size)) {
    return if (size == @as(c_int, 0)) NULL else memset(g_alloca(size), @as(c_int, 0), size);
}
pub const __G_ARRAY_H__ = "";
pub inline fn g_array_append_val(a: anytype, v: anytype) @TypeOf(g_array_append_vals(a, &v, @as(c_int, 1))) {
    return g_array_append_vals(a, &v, @as(c_int, 1));
}
pub inline fn g_array_prepend_val(a: anytype, v: anytype) @TypeOf(g_array_prepend_vals(a, &v, @as(c_int, 1))) {
    return g_array_prepend_vals(a, &v, @as(c_int, 1));
}
pub inline fn g_array_insert_val(a: anytype, i: anytype, v: anytype) @TypeOf(g_array_insert_vals(a, i, &v, @as(c_int, 1))) {
    return g_array_insert_vals(a, i, &v, @as(c_int, 1));
}
pub inline fn g_ptr_array_index(array: anytype, index_: anytype) @TypeOf(array.*.pdata[@as(usize, @intCast(index_))]) {
    return array.*.pdata[@as(usize, @intCast(index_))];
}
pub const __G_ASYNCQUEUE_H__ = "";
pub const __G_THREAD_H__ = "";
pub const __G_ATOMIC_H__ = "";
pub const __GLIB_TYPEOF_H__ = "";
pub const __G_ERROR_H__ = "";
pub const __GNUC_VA_LIST = "";
pub const __STDARG_H = "";
pub const _VA_LIST = "";
pub const __G_QUARK_H__ = "";
pub const __G_UTILS_H__ = "";
pub const G_OS_INFO_KEY_NAME = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "NAME";
pub const G_OS_INFO_KEY_PRETTY_NAME = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "PRETTY_NAME";
pub const G_OS_INFO_KEY_VERSION = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "VERSION";
pub const G_OS_INFO_KEY_VERSION_CODENAME = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "VERSION_CODENAME";
pub const G_OS_INFO_KEY_VERSION_ID = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "VERSION_ID";
pub const G_OS_INFO_KEY_ID = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "ID";
pub const G_OS_INFO_KEY_HOME_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "HOME_URL";
pub const G_OS_INFO_KEY_DOCUMENTATION_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "DOCUMENTATION_URL";
pub const G_OS_INFO_KEY_SUPPORT_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "SUPPORT_URL";
pub const G_OS_INFO_KEY_BUG_REPORT_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "BUG_REPORT_URL";
pub const G_OS_INFO_KEY_PRIVACY_POLICY_URL = GLIB_AVAILABLE_MACRO_IN_2_64 ++ "PRIVACY_POLICY_URL";
pub inline fn g_ATEXIT(proc: anytype) @TypeOf(atexit(proc) ++ GLIB_DEPRECATED_MACRO_IN_2_32) {
    return atexit(proc) ++ GLIB_DEPRECATED_MACRO_IN_2_32;
}
pub const _STDLIB_H = @as(c_int, 1);
pub const WNOHANG = @as(c_int, 1);
pub const WUNTRACED = @as(c_int, 2);
pub const WSTOPPED = @as(c_int, 2);
pub const WEXITED = @as(c_int, 4);
pub const WCONTINUED = @as(c_int, 8);
pub const WNOWAIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hexadecimal);
pub const __WNOTHREAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hexadecimal);
pub const __WALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hexadecimal);
pub const __WCLONE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
pub inline fn __WEXITSTATUS(status: anytype) @TypeOf((status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hexadecimal)) >> @as(c_int, 8)) {
    return (status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hexadecimal)) >> @as(c_int, 8);
}
pub inline fn __WTERMSIG(status: anytype) @TypeOf(status & @as(c_int, 0x7f)) {
    return status & @as(c_int, 0x7f);
}
pub inline fn __WSTOPSIG(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    return __WEXITSTATUS(status);
}
pub inline fn __WIFEXITED(status: anytype) @TypeOf(__WTERMSIG(status) == @as(c_int, 0)) {
    return __WTERMSIG(status) == @as(c_int, 0);
}
pub inline fn __WIFSIGNALED(status: anytype) @TypeOf((@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0)) {
    return (@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0);
}
pub inline fn __WIFSTOPPED(status: anytype) @TypeOf((status & @as(c_int, 0xff)) == @as(c_int, 0x7f)) {
    return (status & @as(c_int, 0xff)) == @as(c_int, 0x7f);
}
pub inline fn __WIFCONTINUED(status: anytype) @TypeOf(status == __W_CONTINUED) {
    return status == __W_CONTINUED;
}
pub inline fn __WCOREDUMP(status: anytype) @TypeOf(status & __WCOREFLAG) {
    return status & __WCOREFLAG;
}
pub inline fn __W_EXITCODE(ret: anytype, sig: anytype) @TypeOf((ret << @as(c_int, 8)) | sig) {
    return (ret << @as(c_int, 8)) | sig;
}
pub inline fn __W_STOPCODE(sig: anytype) @TypeOf((sig << @as(c_int, 8)) | @as(c_int, 0x7f)) {
    return (sig << @as(c_int, 8)) | @as(c_int, 0x7f);
}
pub const __W_CONTINUED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hexadecimal);
pub const __WCOREFLAG = @as(c_int, 0x80);
pub inline fn WEXITSTATUS(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    return __WEXITSTATUS(status);
}
pub inline fn WTERMSIG(status: anytype) @TypeOf(__WTERMSIG(status)) {
    return __WTERMSIG(status);
}
pub inline fn WSTOPSIG(status: anytype) @TypeOf(__WSTOPSIG(status)) {
    return __WSTOPSIG(status);
}
pub inline fn WIFEXITED(status: anytype) @TypeOf(__WIFEXITED(status)) {
    return __WIFEXITED(status);
}
pub inline fn WIFSIGNALED(status: anytype) @TypeOf(__WIFSIGNALED(status)) {
    return __WIFSIGNALED(status);
}
pub inline fn WIFSTOPPED(status: anytype) @TypeOf(__WIFSTOPPED(status)) {
    return __WIFSTOPPED(status);
}
pub inline fn WIFCONTINUED(status: anytype) @TypeOf(__WIFCONTINUED(status)) {
    return __WIFCONTINUED(status);
}
pub const _BITS_FLOATN_H = "";
pub const __HAVE_FLOAT128 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128 = @as(c_int, 0);
pub const __HAVE_FLOAT64X = @as(c_int, 1);
pub const __HAVE_FLOAT64X_LONG_DOUBLE = @as(c_int, 1);
pub const _BITS_FLOATN_COMMON_H = "";
pub const __HAVE_FLOAT16 = @as(c_int, 0);
pub const __HAVE_FLOAT32 = @as(c_int, 1);
pub const __HAVE_FLOAT64 = @as(c_int, 1);
pub const __HAVE_FLOAT32X = @as(c_int, 1);
pub const __HAVE_FLOAT128X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT16 = __HAVE_FLOAT16;
pub const __HAVE_DISTINCT_FLOAT32 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT32X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128X = __HAVE_FLOAT128X;
pub const __HAVE_FLOAT128_UNLIKE_LDBL = (__HAVE_DISTINCT_FLOAT128 != 0) and (__LDBL_MANT_DIG__ != @as(c_int, 113));
pub const __HAVE_FLOATN_NOT_TYPEDEF = @as(c_int, 0);
pub const __f32 = @import("std").zig.c_translation.Macros.F_SUFFIX;
pub inline fn __f64(x: anytype) @TypeOf(x) {
    return x;
}
pub inline fn __f32x(x: anytype) @TypeOf(x) {
    return x;
}
pub const __f64x = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn __builtin_huge_valf32() @TypeOf(__builtin_huge_valf()) {
    return __builtin_huge_valf();
}
pub inline fn __builtin_inff32() @TypeOf(__builtin_inff()) {
    return __builtin_inff();
}
pub inline fn __builtin_nanf32(x: anytype) @TypeOf(__builtin_nanf(x)) {
    return __builtin_nanf(x);
}
pub const __ldiv_t_defined = @as(c_int, 1);
pub const __lldiv_t_defined = @as(c_int, 1);
pub const RAND_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const EXIT_FAILURE = @as(c_int, 1);
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const MB_CUR_MAX = __ctype_get_mb_cur_max();
pub const _SYS_TYPES_H = @as(c_int, 1);
pub const __u_char_defined = "";
pub const __ino_t_defined = "";
pub const __dev_t_defined = "";
pub const __gid_t_defined = "";
pub const __mode_t_defined = "";
pub const __nlink_t_defined = "";
pub const __uid_t_defined = "";
pub const __off_t_defined = "";
pub const __id_t_defined = "";
pub const __ssize_t_defined = "";
pub const __daddr_t_defined = "";
pub const __key_t_defined = "";
pub const _BITS_STDINT_INTN_H = @as(c_int, 1);
pub const __BIT_TYPES_DEFINED__ = @as(c_int, 1);
pub const _ENDIAN_H = @as(c_int, 1);
pub const LITTLE_ENDIAN = __LITTLE_ENDIAN;
pub const BIG_ENDIAN = __BIG_ENDIAN;
pub const PDP_ENDIAN = __PDP_ENDIAN;
pub const BYTE_ORDER = __BYTE_ORDER;
pub const _BITS_BYTESWAP_H = @as(c_int, 1);
pub inline fn __bswap_constant_16(x: anytype) __uint16_t {
    return @import("std").zig.c_translation.cast(__uint16_t, ((x >> @as(c_int, 8)) & @as(c_int, 0xff)) | ((x & @as(c_int, 0xff)) << @as(c_int, 8)));
}
pub inline fn __bswap_constant_32(x: anytype) @TypeOf(((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24))) {
    return ((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24));
}
pub inline fn __bswap_constant_64(x: anytype) @TypeOf(((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56))) {
    return ((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56));
}
pub const _BITS_UINTN_IDENTITY_H = @as(c_int, 1);
pub inline fn htobe16(x: anytype) @TypeOf(__bswap_16(x)) {
    return __bswap_16(x);
}
pub inline fn htole16(x: anytype) @TypeOf(__uint16_identity(x)) {
    return __uint16_identity(x);
}
pub inline fn be16toh(x: anytype) @TypeOf(__bswap_16(x)) {
    return __bswap_16(x);
}
pub inline fn le16toh(x: anytype) @TypeOf(__uint16_identity(x)) {
    return __uint16_identity(x);
}
pub inline fn htobe32(x: anytype) @TypeOf(__bswap_32(x)) {
    return __bswap_32(x);
}
pub inline fn htole32(x: anytype) @TypeOf(__uint32_identity(x)) {
    return __uint32_identity(x);
}
pub inline fn be32toh(x: anytype) @TypeOf(__bswap_32(x)) {
    return __bswap_32(x);
}
pub inline fn le32toh(x: anytype) @TypeOf(__uint32_identity(x)) {
    return __uint32_identity(x);
}
pub inline fn htobe64(x: anytype) @TypeOf(__bswap_64(x)) {
    return __bswap_64(x);
}
pub inline fn htole64(x: anytype) @TypeOf(__uint64_identity(x)) {
    return __uint64_identity(x);
}
pub inline fn be64toh(x: anytype) @TypeOf(__bswap_64(x)) {
    return __bswap_64(x);
}
pub inline fn le64toh(x: anytype) @TypeOf(__uint64_identity(x)) {
    return __uint64_identity(x);
}
pub const _SYS_SELECT_H = @as(c_int, 1);
pub inline fn __FD_ISSET(d: anytype, s: anytype) @TypeOf((__FDS_BITS(s)[@as(usize, @intCast(__FD_ELT(d)))] & __FD_MASK(d)) != @as(c_int, 0)) {
    return (__FDS_BITS(s)[@as(usize, @intCast(__FD_ELT(d)))] & __FD_MASK(d)) != @as(c_int, 0);
}
pub const __sigset_t_defined = @as(c_int, 1);
pub const ____sigset_t_defined = "";
pub const _SIGSET_NWORDS = @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 1024), @as(c_int, 8) * @import("std").zig.c_translation.sizeof(c_ulong));
pub const __timeval_defined = @as(c_int, 1);
pub const __suseconds_t_defined = "";
pub const __NFDBITS = @as(c_int, 8) * @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.sizeof(__fd_mask));
pub inline fn __FD_ELT(d: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS)) {
    return @import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS);
}
pub inline fn __FD_MASK(d: anytype) __fd_mask {
    return @import("std").zig.c_translation.cast(__fd_mask, @as(c_ulong, 1) << @import("std").zig.c_translation.MacroArithmetic.rem(d, __NFDBITS));
}
pub inline fn __FDS_BITS(set: anytype) @TypeOf(set.*.__fds_bits) {
    return set.*.__fds_bits;
}
pub const FD_SETSIZE = __FD_SETSIZE;
pub const NFDBITS = __NFDBITS;
pub inline fn FD_SET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_SET(fd, fdsetp)) {
    return __FD_SET(fd, fdsetp);
}
pub inline fn FD_CLR(fd: anytype, fdsetp: anytype) @TypeOf(__FD_CLR(fd, fdsetp)) {
    return __FD_CLR(fd, fdsetp);
}
pub inline fn FD_ISSET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_ISSET(fd, fdsetp)) {
    return __FD_ISSET(fd, fdsetp);
}
pub inline fn FD_ZERO(fdsetp: anytype) @TypeOf(__FD_ZERO(fdsetp)) {
    return __FD_ZERO(fdsetp);
}
pub const __blksize_t_defined = "";
pub const __blkcnt_t_defined = "";
pub const __fsblkcnt_t_defined = "";
pub const __fsfilcnt_t_defined = "";
pub const _BITS_PTHREADTYPES_COMMON_H = @as(c_int, 1);
pub const _THREAD_SHARED_TYPES_H = @as(c_int, 1);
pub const _BITS_PTHREADTYPES_ARCH_H = @as(c_int, 1);
pub const __SIZEOF_PTHREAD_MUTEX_T = @as(c_int, 40);
pub const __SIZEOF_PTHREAD_ATTR_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_RWLOCK_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_BARRIER_T = @as(c_int, 32);
pub const __SIZEOF_PTHREAD_MUTEXATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_COND_T = @as(c_int, 48);
pub const __SIZEOF_PTHREAD_CONDATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_BARRIERATTR_T = @as(c_int, 4);
pub const __LOCK_ALIGNMENT = "";
pub const __ONCE_ALIGNMENT = "";
pub const _BITS_ATOMIC_WIDE_COUNTER_H = "";
pub const _THREAD_MUTEX_INTERNAL_H = @as(c_int, 1);
pub const __PTHREAD_MUTEX_HAVE_PREV = @as(c_int, 1);
pub const _RWLOCK_INTERNAL_H = "";
pub inline fn __PTHREAD_RWLOCK_INITIALIZER(__flags: anytype) @TypeOf(__flags) {
    return blk: {
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @TypeOf(__PTHREAD_RWLOCK_ELISION_EXTRA);
        _ = @as(c_int, 0);
        break :blk __flags;
    };
}
pub const __have_pthread_attr_t = @as(c_int, 1);
pub const _ALLOCA_H = @as(c_int, 1);
pub const __COMPAR_FN_T = "";
pub inline fn g_abort() @TypeOf(abort()) {
    return abort();
}
pub const G_THREAD_ERROR = g_thread_error_quark();
pub inline fn G_LOCK_DEFINE(name: anytype) @TypeOf((GMutex ++ G_LOCK_NAME)(name)) {
    return (GMutex ++ G_LOCK_NAME)(name);
}
pub inline fn G_LOCK(name: anytype) @TypeOf(g_mutex_lock(&G_LOCK_NAME(name))) {
    return g_mutex_lock(&G_LOCK_NAME(name));
}
pub inline fn G_UNLOCK(name: anytype) @TypeOf(g_mutex_unlock(&G_LOCK_NAME(name))) {
    return g_mutex_unlock(&G_LOCK_NAME(name));
}
pub inline fn G_TRYLOCK(name: anytype) @TypeOf(g_mutex_trylock(&G_LOCK_NAME(name))) {
    return g_mutex_trylock(&G_LOCK_NAME(name));
}
pub const __G_BACKTRACE_H__ = "";
pub const _SIGNAL_H = "";
pub const _BITS_SIGNUM_GENERIC_H = @as(c_int, 1);
pub const SIG_ERR = @import("std").zig.c_translation.cast(__sighandler_t, -@as(c_int, 1));
pub const SIG_DFL = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 0));
pub const SIG_IGN = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 1));
pub const SIGINT = @as(c_int, 2);
pub const SIGILL = @as(c_int, 4);
pub const SIGABRT = @as(c_int, 6);
pub const SIGFPE = @as(c_int, 8);
pub const SIGSEGV = @as(c_int, 11);
pub const SIGTERM = @as(c_int, 15);
pub const SIGHUP = @as(c_int, 1);
pub const SIGQUIT = @as(c_int, 3);
pub const SIGTRAP = @as(c_int, 5);
pub const SIGKILL = @as(c_int, 9);
pub const SIGPIPE = @as(c_int, 13);
pub const SIGALRM = @as(c_int, 14);
pub const SIGIO = SIGPOLL;
pub const SIGIOT = SIGABRT;
pub const SIGCLD = SIGCHLD;
pub const _BITS_SIGNUM_ARCH_H = @as(c_int, 1);
pub const SIGSTKFLT = @as(c_int, 16);
pub const SIGPWR = @as(c_int, 30);
pub const SIGBUS = @as(c_int, 7);
pub const SIGSYS = @as(c_int, 31);
pub const SIGURG = @as(c_int, 23);
pub const SIGSTOP = @as(c_int, 19);
pub const SIGTSTP = @as(c_int, 20);
pub const SIGCONT = @as(c_int, 18);
pub const SIGCHLD = @as(c_int, 17);
pub const SIGTTIN = @as(c_int, 21);
pub const SIGTTOU = @as(c_int, 22);
pub const SIGPOLL = @as(c_int, 29);
pub const SIGXFSZ = @as(c_int, 25);
pub const SIGXCPU = @as(c_int, 24);
pub const SIGVTALRM = @as(c_int, 26);
pub const SIGPROF = @as(c_int, 27);
pub const SIGUSR1 = @as(c_int, 10);
pub const SIGUSR2 = @as(c_int, 12);
pub const SIGWINCH = @as(c_int, 28);
pub const __SIGRTMIN = @as(c_int, 32);
pub const __SIGRTMAX = @as(c_int, 64);
pub const _NSIG = __SIGRTMAX + @as(c_int, 1);
pub const __sig_atomic_t_defined = @as(c_int, 1);
pub const __siginfo_t_defined = @as(c_int, 1);
pub const ____sigval_t_defined = "";
pub const __SI_MAX_SIZE = @as(c_int, 128);
pub const __SI_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SI_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGINFO_ARCH_H = @as(c_int, 1);
pub const __SI_ALIGNMENT = "";
pub const __SI_BAND_TYPE = c_long;
pub const __SI_CLOCK_T = __clock_t;
pub const __SI_ERRNO_THEN_CODE = @as(c_int, 1);
pub const __SI_HAVE_SIGSYS = @as(c_int, 1);
pub const __SI_SIGFAULT_ADDL = "";
pub const _BITS_SIGINFO_CONSTS_H = @as(c_int, 1);
pub const __SI_ASYNCIO_AFTER_SIGIO = @as(c_int, 1);
pub const __sigval_t_defined = "";
pub const __sigevent_t_defined = @as(c_int, 1);
pub const __SIGEV_MAX_SIZE = @as(c_int, 64);
pub const __SIGEV_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SIGEV_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGEVENT_CONSTS_H = @as(c_int, 1);
pub inline fn sigmask(sig: anytype) @TypeOf(__glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))))) {
    return __glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))));
}
pub const NSIG = _NSIG;
pub const _BITS_SIGACTION_H = @as(c_int, 1);
pub const SA_NOCLDSTOP = @as(c_int, 1);
pub const SA_NOCLDWAIT = @as(c_int, 2);
pub const SA_SIGINFO = @as(c_int, 4);
pub const SA_ONSTACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hexadecimal);
pub const SA_RESTART = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hexadecimal);
pub const SA_NODEFER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hexadecimal);
pub const SA_RESETHAND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
pub const SA_INTERRUPT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hexadecimal);
pub const SA_NOMASK = SA_NODEFER;
pub const SA_ONESHOT = SA_RESETHAND;
pub const SA_STACK = SA_ONSTACK;
pub const SIG_BLOCK = @as(c_int, 0);
pub const SIG_UNBLOCK = @as(c_int, 1);
pub const SIG_SETMASK = @as(c_int, 2);
pub const _BITS_SIGCONTEXT_H = @as(c_int, 1);
pub const FP_XSTATE_MAGIC1 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505853, .hexadecimal);
pub const FP_XSTATE_MAGIC2 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505845, .hexadecimal);
pub const FP_XSTATE_MAGIC2_SIZE = @import("std").zig.c_translation.sizeof(FP_XSTATE_MAGIC2);
pub const __stack_t_defined = @as(c_int, 1);
pub const _SYS_UCONTEXT_H = @as(c_int, 1);
pub inline fn __ctx(fld: anytype) @TypeOf(fld) {
    return fld;
}
pub const __NGREG = @as(c_int, 23);
pub const NGREG = __NGREG;
pub const _BITS_SIGSTACK_H = @as(c_int, 1);
pub const MINSIGSTKSZ = @as(c_int, 2048);
pub const SIGSTKSZ = @as(c_int, 8192);
pub const _BITS_SS_FLAGS_H = @as(c_int, 1);
pub const __sigstack_defined = @as(c_int, 1);
pub const _BITS_SIGTHREAD_H = @as(c_int, 1);
pub const SIGRTMIN = __libc_current_sigrtmin();
pub const SIGRTMAX = __libc_current_sigrtmax();
pub const __G_BASE64_H__ = "";
pub const __G_BITLOCK_H__ = "";
pub const __G_BOOKMARK_FILE_H__ = "";
pub const __G_DATE_TIME_H__ = "";
pub const __G_TIME_ZONE_H__ = "";
pub const G_TIME_SPAN_DAY = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 86400000000, .decimal));
pub const G_TIME_SPAN_HOUR = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 3600000000, .decimal));
pub const G_TIME_SPAN_MINUTE = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 60000000, .decimal));
pub const G_TIME_SPAN_SECOND = G_GINT64_CONSTANT(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const G_TIME_SPAN_MILLISECOND = G_GINT64_CONSTANT(@as(c_int, 1000));
pub const G_BOOKMARK_FILE_ERROR = g_bookmark_file_error_quark();
pub const __G_BYTES_H__ = "";
pub const __G_CHARSET_H__ = "";
pub const __G_CHECKSUM_H__ = "";
pub const __G_CONVERT_H__ = "";
pub const G_CONVERT_ERROR = g_convert_error_quark();
pub const __G_DATASET_H__ = "";
pub const G_DATALIST_FLAGS_MASK = @as(c_int, 0x3);
pub inline fn g_datalist_id_set_data(dl: anytype, q: anytype, d: anytype) @TypeOf(g_datalist_id_set_data_full(dl, q, d, NULL)) {
    return g_datalist_id_set_data_full(dl, q, d, NULL);
}
pub inline fn g_datalist_id_remove_data(dl: anytype, q: anytype) @TypeOf(g_datalist_id_set_data(dl, q, NULL)) {
    return g_datalist_id_set_data(dl, q, NULL);
}
pub inline fn g_datalist_set_data_full(dl: anytype, k: anytype, d: anytype, f: anytype) @TypeOf(g_datalist_id_set_data_full(dl, g_quark_from_string(k), d, f)) {
    return g_datalist_id_set_data_full(dl, g_quark_from_string(k), d, f);
}
pub inline fn g_datalist_remove_no_notify(dl: anytype, k: anytype) @TypeOf(g_datalist_id_remove_no_notify(dl, g_quark_try_string(k))) {
    return g_datalist_id_remove_no_notify(dl, g_quark_try_string(k));
}
pub inline fn g_datalist_set_data(dl: anytype, k: anytype, d: anytype) @TypeOf(g_datalist_set_data_full(dl, k, d, NULL)) {
    return g_datalist_set_data_full(dl, k, d, NULL);
}
pub inline fn g_datalist_remove_data(dl: anytype, k: anytype) @TypeOf(g_datalist_id_set_data(dl, g_quark_try_string(k), NULL)) {
    return g_datalist_id_set_data(dl, g_quark_try_string(k), NULL);
}
pub inline fn g_dataset_id_set_data(l: anytype, k: anytype, d: anytype) @TypeOf(g_dataset_id_set_data_full(l, k, d, NULL)) {
    return g_dataset_id_set_data_full(l, k, d, NULL);
}
pub inline fn g_dataset_id_remove_data(l: anytype, k: anytype) @TypeOf(g_dataset_id_set_data(l, k, NULL)) {
    return g_dataset_id_set_data(l, k, NULL);
}
pub inline fn g_dataset_get_data(l: anytype, k: anytype) @TypeOf(g_dataset_id_get_data(l, g_quark_try_string(k))) {
    return g_dataset_id_get_data(l, g_quark_try_string(k));
}
pub inline fn g_dataset_set_data_full(l: anytype, k: anytype, d: anytype, f: anytype) @TypeOf(g_dataset_id_set_data_full(l, g_quark_from_string(k), d, f)) {
    return g_dataset_id_set_data_full(l, g_quark_from_string(k), d, f);
}
pub inline fn g_dataset_remove_no_notify(l: anytype, k: anytype) @TypeOf(g_dataset_id_remove_no_notify(l, g_quark_try_string(k))) {
    return g_dataset_id_remove_no_notify(l, g_quark_try_string(k));
}
pub inline fn g_dataset_set_data(l: anytype, k: anytype, d: anytype) @TypeOf(g_dataset_set_data_full(l, k, d, NULL)) {
    return g_dataset_set_data_full(l, k, d, NULL);
}
pub inline fn g_dataset_remove_data(l: anytype, k: anytype) @TypeOf(g_dataset_id_set_data(l, g_quark_try_string(k), NULL)) {
    return g_dataset_id_set_data(l, g_quark_try_string(k), NULL);
}
pub const __G_DATE_H__ = "";
pub const G_DATE_BAD_JULIAN = @as(c_uint, 0);
pub const G_DATE_BAD_DAY = @as(c_uint, 0);
pub const G_DATE_BAD_YEAR = @as(c_uint, 0);
pub const g_date_weekday = (g_date_get_weekday ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_weekday);
pub const g_date_month = (g_date_get_month ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_month);
pub const g_date_year = (g_date_get_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_year);
pub const g_date_day = (g_date_get_day ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_day);
pub const g_date_julian = (g_date_get_julian ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_julian);
pub const g_date_day_of_year = (g_date_get_day_of_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_day_of_year);
pub const g_date_monday_week_of_year = (g_date_get_monday_week_of_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_monday_week_of_year);
pub const g_date_sunday_week_of_year = (g_date_get_sunday_week_of_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_sunday_week_of_year);
pub const g_date_days_in_month = (g_date_get_days_in_month ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_days_in_month);
pub const g_date_monday_weeks_in_year = (g_date_get_monday_weeks_in_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_monday_weeks_in_year);
pub const g_date_sunday_weeks_in_year = (g_date_get_sunday_weeks_in_year ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_date_get_sunday_weeks_in_year);
pub const __G_DIR_H__ = "";
pub const _DIRENT_H = @as(c_int, 1);
pub const _DIRENT_HAVE_D_RECLEN = "";
pub const _DIRENT_HAVE_D_OFF = "";
pub const _DIRENT_HAVE_D_TYPE = "";
pub const _DIRENT_MATCHES_DIRENT64 = @as(c_int, 1);
pub inline fn _D_EXACT_NAMLEN(d: anytype) @TypeOf(strlen(d.*.d_name)) {
    return strlen(d.*.d_name);
}
pub inline fn _D_ALLOC_NAMLEN(d: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]u8, d) + d.*.d_reclen) - (&d.*.d_name[@as(usize, @intCast(@as(c_int, 0)))])) {
    return (@import("std").zig.c_translation.cast([*c]u8, d) + d.*.d_reclen) - (&d.*.d_name[@as(usize, @intCast(@as(c_int, 0)))]);
}
pub inline fn IFTODT(mode: anytype) @TypeOf((mode & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal)) >> @as(c_int, 12)) {
    return (mode & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal)) >> @as(c_int, 12);
}
pub inline fn DTTOIF(dirtype: anytype) @TypeOf(dirtype << @as(c_int, 12)) {
    return dirtype << @as(c_int, 12);
}
pub const MAXNAMLEN = NAME_MAX;
pub const __G_ENVIRON_H__ = "";
pub const __G_FILEUTILS_H__ = "";
pub const G_FILE_ERROR = g_file_error_quark();
pub inline fn G_IS_DIR_SEPARATOR(c: anytype) @TypeOf(c == G_DIR_SEPARATOR) {
    return c == G_DIR_SEPARATOR;
}
pub const g_dirname = (g_path_get_dirname ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_path_get_dirname);
pub const __G_GETTEXT_H__ = "";
pub const __G_HASH_H__ = "";
pub const __G_LIST_H__ = "";
pub const __G_MEM_H__ = "";
pub const G_MEM_ALIGN = GLIB_SIZEOF_LONG;
pub inline fn g_new(struct_type: anytype, n_structs: anytype) @TypeOf(_G_NEW(struct_type, n_structs, malloc)) {
    return _G_NEW(struct_type, n_structs, malloc);
}
pub inline fn g_renew(struct_type: anytype, mem: anytype, n_structs: anytype) @TypeOf(_G_RENEW(struct_type, mem, n_structs, realloc)) {
    return _G_RENEW(struct_type, mem, n_structs, realloc);
}
pub const __G_NODE_H__ = "";
pub inline fn G_NODE_IS_ROOT(node: anytype) @TypeOf(((@import("std").zig.c_translation.cast([*c]GNode, node).*.parent == NULL) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.prev == NULL)) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.next == NULL)) {
    return ((@import("std").zig.c_translation.cast([*c]GNode, node).*.parent == NULL) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.prev == NULL)) and (@import("std").zig.c_translation.cast([*c]GNode, node).*.next == NULL);
}
pub inline fn G_NODE_IS_LEAF(node: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GNode, node).*.children == NULL) {
    return @import("std").zig.c_translation.cast([*c]GNode, node).*.children == NULL;
}
pub inline fn g_node_append(parent: anytype, node: anytype) @TypeOf(g_node_insert_before(parent, NULL, node)) {
    return g_node_insert_before(parent, NULL, node);
}
pub inline fn g_node_insert_data(parent: anytype, position: anytype, data: anytype) @TypeOf(g_node_insert(parent, position, g_node_new(data))) {
    return g_node_insert(parent, position, g_node_new(data));
}
pub inline fn g_node_insert_data_after(parent: anytype, sibling: anytype, data: anytype) @TypeOf(g_node_insert_after(parent, sibling, g_node_new(data))) {
    return g_node_insert_after(parent, sibling, g_node_new(data));
}
pub inline fn g_node_insert_data_before(parent: anytype, sibling: anytype, data: anytype) @TypeOf(g_node_insert_before(parent, sibling, g_node_new(data))) {
    return g_node_insert_before(parent, sibling, g_node_new(data));
}
pub inline fn g_node_prepend_data(parent: anytype, data: anytype) @TypeOf(g_node_prepend(parent, g_node_new(data))) {
    return g_node_prepend(parent, g_node_new(data));
}
pub inline fn g_node_append_data(parent: anytype, data: anytype) @TypeOf(g_node_insert_before(parent, NULL, g_node_new(data))) {
    return g_node_insert_before(parent, NULL, g_node_new(data));
}
pub inline fn g_node_prev_sibling(node: anytype) @TypeOf(if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.prev else NULL) {
    return if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.prev else NULL;
}
pub inline fn g_node_next_sibling(node: anytype) @TypeOf(if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.next else NULL) {
    return if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.next else NULL;
}
pub inline fn g_node_first_child(node: anytype) @TypeOf(if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.children else NULL) {
    return if (node) @import("std").zig.c_translation.cast([*c]GNode, node).*.children else NULL;
}
pub const g_list_free1 = g_list_free_1;
pub inline fn g_list_previous(list: anytype) @TypeOf(if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.prev else NULL) {
    return if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.prev else NULL;
}
pub inline fn g_list_next(list: anytype) @TypeOf(if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.next else NULL) {
    return if (list) @import("std").zig.c_translation.cast([*c]GList, list).*.next else NULL;
}
pub inline fn g_hash_table_freeze(hash_table: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = @TypeOf(hash_table);
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub inline fn g_hash_table_thaw(hash_table: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = @TypeOf(hash_table);
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub const __G_HMAC_H__ = "";
pub const __G_HOOK_H__ = "";
pub const G_HOOK_FLAG_USER_SHIFT = @as(c_int, 4);
pub inline fn G_HOOK(hook: anytype) [*c]GHook {
    return @import("std").zig.c_translation.cast([*c]GHook, hook);
}
pub inline fn G_HOOK_FLAGS(hook: anytype) @TypeOf(G_HOOK(hook).*.flags) {
    return G_HOOK(hook).*.flags;
}
pub inline fn G_HOOK_ACTIVE(hook: anytype) @TypeOf((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != @as(c_int, 0)) {
    return (G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != @as(c_int, 0);
}
pub inline fn G_HOOK_IN_CALL(hook: anytype) @TypeOf((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_IN_CALL) != @as(c_int, 0)) {
    return (G_HOOK_FLAGS(hook) & G_HOOK_FLAG_IN_CALL) != @as(c_int, 0);
}
pub inline fn G_HOOK_IS_VALID(hook: anytype) @TypeOf((G_HOOK(hook).*.hook_id != @as(c_int, 0)) and ((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != 0)) {
    return (G_HOOK(hook).*.hook_id != @as(c_int, 0)) and ((G_HOOK_FLAGS(hook) & G_HOOK_FLAG_ACTIVE) != 0);
}
pub inline fn G_HOOK_IS_UNLINKED(hook: anytype) @TypeOf((((G_HOOK(hook).*.next == NULL) and (G_HOOK(hook).*.prev == NULL)) and (G_HOOK(hook).*.hook_id == @as(c_int, 0))) and (G_HOOK(hook).*.ref_count == @as(c_int, 0))) {
    return (((G_HOOK(hook).*.next == NULL) and (G_HOOK(hook).*.prev == NULL)) and (G_HOOK(hook).*.hook_id == @as(c_int, 0))) and (G_HOOK(hook).*.ref_count == @as(c_int, 0));
}
pub inline fn g_hook_append(hook_list: anytype, hook: anytype) @TypeOf(g_hook_insert_before(hook_list, NULL, hook)) {
    return g_hook_insert_before(hook_list, NULL, hook);
}
pub const __G_HOST_UTILS_H__ = "";
pub const __G_IOCHANNEL_H__ = "";
pub const __G_MAIN_H__ = "";
pub const __G_POLL_H__ = "";
pub const __G_SLIST_H__ = "";
pub const g_slist_free1 = g_slist_free_1;
pub inline fn g_slist_next(slist: anytype) @TypeOf(if (slist) @import("std").zig.c_translation.cast([*c]GSList, slist).*.next else NULL) {
    return if (slist) @import("std").zig.c_translation.cast([*c]GSList, slist).*.next else NULL;
}
pub const G_PRIORITY_HIGH = -@as(c_int, 100);
pub const G_PRIORITY_DEFAULT = @as(c_int, 0);
pub const G_PRIORITY_HIGH_IDLE = @as(c_int, 100);
pub const G_PRIORITY_DEFAULT_IDLE = @as(c_int, 200);
pub const G_PRIORITY_LOW = @as(c_int, 300);
pub const G_SOURCE_REMOVE = FALSE;
pub const G_SOURCE_CONTINUE = TRUE;
pub const __G_STRING_H__ = "";
pub const __G_UNICODE_H__ = "";
pub const G_UNICODE_COMBINING_MARK = (G_UNICODE_SPACING_MARK ++ GLIB_DEPRECATED_MACRO_IN_2_30_FOR)(G_UNICODE_SPACING_MARK);
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH = @as(c_int, 18);
pub const __G_STRFUNCS_H__ = "";
pub inline fn g_ascii_isalnum(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_ALNUM) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_ALNUM) != @as(c_int, 0);
}
pub inline fn g_ascii_isalpha(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_ALPHA) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_ALPHA) != @as(c_int, 0);
}
pub inline fn g_ascii_iscntrl(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_CNTRL) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_CNTRL) != @as(c_int, 0);
}
pub inline fn g_ascii_isdigit(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_DIGIT) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_DIGIT) != @as(c_int, 0);
}
pub inline fn g_ascii_isgraph(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_GRAPH) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_GRAPH) != @as(c_int, 0);
}
pub inline fn g_ascii_islower(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_LOWER) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_LOWER) != @as(c_int, 0);
}
pub inline fn g_ascii_isprint(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_PRINT) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_PRINT) != @as(c_int, 0);
}
pub inline fn g_ascii_ispunct(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_PUNCT) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_PUNCT) != @as(c_int, 0);
}
pub inline fn g_ascii_isspace(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_SPACE) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_SPACE) != @as(c_int, 0);
}
pub inline fn g_ascii_isupper(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_UPPER) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_UPPER) != @as(c_int, 0);
}
pub inline fn g_ascii_isxdigit(c: anytype) @TypeOf((g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_XDIGIT) != @as(c_int, 0)) {
    return (g_ascii_table[@as(usize, @intCast(@import("std").zig.c_translation.cast(guchar, c)))] & G_ASCII_XDIGIT) != @as(c_int, 0);
}
pub const G_STR_DELIMITERS = "_-|> <.";
pub inline fn _G_STR_NONNULL(x: anytype) @TypeOf(x + @intFromBool(!(x != 0))) {
    return x + @intFromBool(!(x != 0));
}
pub const G_ASCII_DTOSTR_BUF_SIZE = @as(c_int, 29) + @as(c_int, 10);
pub inline fn g_strstrip(string: anytype) @TypeOf(g_strchomp(g_strchug(string))) {
    return g_strchomp(g_strchug(string));
}
pub const G_NUMBER_PARSER_ERROR = g_number_parser_error_quark();
pub const g_string_sprintf = (g_string_printf ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_string_printf);
pub const g_string_sprintfa = (g_string_append_printf ++ GLIB_DEPRECATED_MACRO_IN_2_26_FOR)(g_string_append_printf);
pub const G_IO_CHANNEL_ERROR = g_io_channel_error_quark();
pub const __G_KEY_FILE_H__ = "";
pub const G_KEY_FILE_ERROR = g_key_file_error_quark();
pub const G_KEY_FILE_DESKTOP_GROUP = "Desktop Entry";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE = "Type";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION = "Version";
pub const G_KEY_FILE_DESKTOP_KEY_NAME = "Name";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME = "GenericName";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY = "NoDisplay";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT = "Comment";
pub const G_KEY_FILE_DESKTOP_KEY_ICON = "Icon";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN = "Hidden";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = "OnlyShowIn";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = "NotShowIn";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC = "TryExec";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC = "Exec";
pub const G_KEY_FILE_DESKTOP_KEY_PATH = "Path";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL = "Terminal";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE = "MimeType";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES = "Categories";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = "StartupNotify";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = "StartupWMClass";
pub const G_KEY_FILE_DESKTOP_KEY_URL = "URL";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE = "DBusActivatable";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS = "Actions";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION = "Application";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK = "Link";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY = "Directory";
pub const __G_MAPPED_FILE_H__ = "";
pub const __G_MARKUP_H__ = "";
pub const G_MARKUP_ERROR = g_markup_error_quark();
pub const __G_MESSAGES_H__ = "";
pub const __G_VARIANT_H__ = "";
pub const __G_VARIANT_TYPE_H__ = "";
pub inline fn G_VARIANT_TYPE(type_string: anytype) @TypeOf(g_variant_type_checked_(type_string)) {
    return g_variant_type_checked_(type_string);
}
pub const G_VARIANT_PARSE_ERROR = g_variant_parse_error_quark();
pub const G_LOG_LEVEL_USER_SHIFT = @as(c_int, 8);
pub const G_LOG_FATAL_MASK = G_LOG_FLAG_RECURSION | G_LOG_LEVEL_ERROR;
pub const G_LOG_DOMAIN = @import("std").zig.c_translation.cast([*c]gchar, @as(c_int, 0));
pub const __G_OPTION_H__ = "";
pub const G_OPTION_ERROR = g_option_error_quark();
pub const G_OPTION_REMAINING = "";
pub const G_OPTION_ENTRY_NULL = @import("std").mem.zeroInit(GLIB_AVAILABLE_MACRO_IN_2_70, .{ NULL, @as(c_int, 0), @as(c_int, 0), @as(c_int, 0), NULL, NULL, NULL });
pub const __G_PATTERN_H__ = "";
pub const __G_PRIMES_H__ = "";
pub const __G_QSORT_H__ = "";
pub const __G_QUEUE_H__ = "";
pub const __G_RAND_H__ = "";
pub inline fn g_rand_boolean(rand_: anytype) @TypeOf((g_rand_int(rand_) & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0)) {
    return (g_rand_int(rand_) & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0);
}
pub inline fn g_random_boolean() @TypeOf((g_random_int() & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0)) {
    return (g_random_int() & (@as(c_int, 1) << @as(c_int, 15))) != @as(c_int, 0);
}
pub const __GREFCOUNT_H__ = "";
pub const G_REF_COUNT_INIT = -(@as(c_int, 1) ++ GLIB_AVAILABLE_MACRO_IN_2_78);
pub const G_ATOMIC_REF_COUNT_INIT = @as(c_int, 1) ++ GLIB_AVAILABLE_MACRO_IN_2_78;
pub const __G_REGEX_H__ = "";
pub const G_REGEX_ERROR = g_regex_error_quark();
pub const __G_SCANNER_H__ = "";
pub const G_CSET_A_2_Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
pub const G_CSET_a_2_z = "abcdefghijklmnopqrstuvwxyz";
pub const G_CSET_DIGITS = "0123456789";
pub const G_CSET_LATINC = "\xc0\xc1\xc2\xc3\xc4\xc5\xc6" ++ "\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0" ++ "\xd1\xd2\xd3\xd4\xd5\xd6" ++ "\xd8\xd9\xda\xdb\xdc\xdd\xde";
pub const G_CSET_LATINS = "\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6" ++ "\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0" ++ "\xf1\xf2\xf3\xf4\xf5\xf6" ++ "\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
pub inline fn g_scanner_freeze_symbol_table(scanner: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = @TypeOf(scanner);
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub inline fn g_scanner_thaw_symbol_table(scanner: anytype) @TypeOf(@import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26) {
    _ = @TypeOf(scanner);
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0)) ++ GLIB_DEPRECATED_MACRO_IN_2_26;
}
pub const __G_SEQUENCE_H__ = "";
pub const __G_SHELL_H__ = "";
pub const G_SHELL_ERROR = g_shell_error_quark();
pub const __G_SLICE_H__ = "";
pub const __G_SPAWN_H__ = "";
pub const G_SPAWN_ERROR = g_spawn_error_quark();
pub const G_SPAWN_EXIT_ERROR = g_spawn_exit_error_quark();
pub const __G_STRINGCHUNK_H__ = "";
pub const __G_STRVBUILDER_H__ = "";
pub const __G_TEST_UTILS_H__ = "";
pub const _ERRNO_H = @as(c_int, 1);
pub const _BITS_ERRNO_H = @as(c_int, 1);
pub const _ASM_GENERIC_ERRNO_H = "";
pub const _ASM_GENERIC_ERRNO_BASE_H = "";
pub const EPERM = @as(c_int, 1);
pub const ENOENT = @as(c_int, 2);
pub const ESRCH = @as(c_int, 3);
pub const EINTR = @as(c_int, 4);
pub const EIO = @as(c_int, 5);
pub const ENXIO = @as(c_int, 6);
pub const E2BIG = @as(c_int, 7);
pub const ENOEXEC = @as(c_int, 8);
pub const EBADF = @as(c_int, 9);
pub const ECHILD = @as(c_int, 10);
pub const EAGAIN = @as(c_int, 11);
pub const ENOMEM = @as(c_int, 12);
pub const EACCES = @as(c_int, 13);
pub const EFAULT = @as(c_int, 14);
pub const ENOTBLK = @as(c_int, 15);
pub const EBUSY = @as(c_int, 16);
pub const EEXIST = @as(c_int, 17);
pub const EXDEV = @as(c_int, 18);
pub const ENODEV = @as(c_int, 19);
pub const ENOTDIR = @as(c_int, 20);
pub const EISDIR = @as(c_int, 21);
pub const EINVAL = @as(c_int, 22);
pub const ENFILE = @as(c_int, 23);
pub const EMFILE = @as(c_int, 24);
pub const ENOTTY = @as(c_int, 25);
pub const ETXTBSY = @as(c_int, 26);
pub const EFBIG = @as(c_int, 27);
pub const ENOSPC = @as(c_int, 28);
pub const ESPIPE = @as(c_int, 29);
pub const EROFS = @as(c_int, 30);
pub const EMLINK = @as(c_int, 31);
pub const EPIPE = @as(c_int, 32);
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const EDEADLK = @as(c_int, 35);
pub const ENAMETOOLONG = @as(c_int, 36);
pub const ENOLCK = @as(c_int, 37);
pub const ENOSYS = @as(c_int, 38);
pub const ENOTEMPTY = @as(c_int, 39);
pub const ELOOP = @as(c_int, 40);
pub const EWOULDBLOCK = EAGAIN;
pub const ENOMSG = @as(c_int, 42);
pub const EIDRM = @as(c_int, 43);
pub const ECHRNG = @as(c_int, 44);
pub const EL2NSYNC = @as(c_int, 45);
pub const EL3HLT = @as(c_int, 46);
pub const EL3RST = @as(c_int, 47);
pub const ELNRNG = @as(c_int, 48);
pub const EUNATCH = @as(c_int, 49);
pub const ENOCSI = @as(c_int, 50);
pub const EL2HLT = @as(c_int, 51);
pub const EBADE = @as(c_int, 52);
pub const EBADR = @as(c_int, 53);
pub const EXFULL = @as(c_int, 54);
pub const ENOANO = @as(c_int, 55);
pub const EBADRQC = @as(c_int, 56);
pub const EBADSLT = @as(c_int, 57);
pub const EDEADLOCK = EDEADLK;
pub const EBFONT = @as(c_int, 59);
pub const ENOSTR = @as(c_int, 60);
pub const ENODATA = @as(c_int, 61);
pub const ETIME = @as(c_int, 62);
pub const ENOSR = @as(c_int, 63);
pub const ENONET = @as(c_int, 64);
pub const ENOPKG = @as(c_int, 65);
pub const EREMOTE = @as(c_int, 66);
pub const ENOLINK = @as(c_int, 67);
pub const EADV = @as(c_int, 68);
pub const ESRMNT = @as(c_int, 69);
pub const ECOMM = @as(c_int, 70);
pub const EPROTO = @as(c_int, 71);
pub const EMULTIHOP = @as(c_int, 72);
pub const EDOTDOT = @as(c_int, 73);
pub const EBADMSG = @as(c_int, 74);
pub const EOVERFLOW = @as(c_int, 75);
pub const ENOTUNIQ = @as(c_int, 76);
pub const EBADFD = @as(c_int, 77);
pub const EREMCHG = @as(c_int, 78);
pub const ELIBACC = @as(c_int, 79);
pub const ELIBBAD = @as(c_int, 80);
pub const ELIBSCN = @as(c_int, 81);
pub const ELIBMAX = @as(c_int, 82);
pub const ELIBEXEC = @as(c_int, 83);
pub const EILSEQ = @as(c_int, 84);
pub const ERESTART = @as(c_int, 85);
pub const ESTRPIPE = @as(c_int, 86);
pub const EUSERS = @as(c_int, 87);
pub const ENOTSOCK = @as(c_int, 88);
pub const EDESTADDRREQ = @as(c_int, 89);
pub const EMSGSIZE = @as(c_int, 90);
pub const EPROTOTYPE = @as(c_int, 91);
pub const ENOPROTOOPT = @as(c_int, 92);
pub const EPROTONOSUPPORT = @as(c_int, 93);
pub const ESOCKTNOSUPPORT = @as(c_int, 94);
pub const EOPNOTSUPP = @as(c_int, 95);
pub const EPFNOSUPPORT = @as(c_int, 96);
pub const EAFNOSUPPORT = @as(c_int, 97);
pub const EADDRINUSE = @as(c_int, 98);
pub const EADDRNOTAVAIL = @as(c_int, 99);
pub const ENETDOWN = @as(c_int, 100);
pub const ENETUNREACH = @as(c_int, 101);
pub const ENETRESET = @as(c_int, 102);
pub const ECONNABORTED = @as(c_int, 103);
pub const ECONNRESET = @as(c_int, 104);
pub const ENOBUFS = @as(c_int, 105);
pub const EISCONN = @as(c_int, 106);
pub const ENOTCONN = @as(c_int, 107);
pub const ESHUTDOWN = @as(c_int, 108);
pub const ETOOMANYREFS = @as(c_int, 109);
pub const ETIMEDOUT = @as(c_int, 110);
pub const ECONNREFUSED = @as(c_int, 111);
pub const EHOSTDOWN = @as(c_int, 112);
pub const EHOSTUNREACH = @as(c_int, 113);
pub const EALREADY = @as(c_int, 114);
pub const EINPROGRESS = @as(c_int, 115);
pub const ESTALE = @as(c_int, 116);
pub const EUCLEAN = @as(c_int, 117);
pub const ENOTNAM = @as(c_int, 118);
pub const ENAVAIL = @as(c_int, 119);
pub const EISNAM = @as(c_int, 120);
pub const EREMOTEIO = @as(c_int, 121);
pub const EDQUOT = @as(c_int, 122);
pub const ENOMEDIUM = @as(c_int, 123);
pub const EMEDIUMTYPE = @as(c_int, 124);
pub const ECANCELED = @as(c_int, 125);
pub const ENOKEY = @as(c_int, 126);
pub const EKEYEXPIRED = @as(c_int, 127);
pub const EKEYREVOKED = @as(c_int, 128);
pub const EKEYREJECTED = @as(c_int, 129);
pub const EOWNERDEAD = @as(c_int, 130);
pub const ENOTRECOVERABLE = @as(c_int, 131);
pub const ERFKILL = @as(c_int, 132);
pub const EHWPOISON = @as(c_int, 133);
pub const ENOTSUP = EOPNOTSUPP;
pub const errno = __errno_location().*;
pub const G_TEST_OPTION_ISOLATE_DIRS = "isolate_dirs";
pub inline fn g_test_initialized() @TypeOf(g_test_config_vars.*.test_initialized) {
    return g_test_config_vars.*.test_initialized;
}
pub inline fn g_test_quick() @TypeOf(g_test_config_vars.*.test_quick) {
    return g_test_config_vars.*.test_quick;
}
pub inline fn g_test_slow() @TypeOf(!(g_test_config_vars.*.test_quick != 0)) {
    return !(g_test_config_vars.*.test_quick != 0);
}
pub inline fn g_test_thorough() @TypeOf(!(g_test_config_vars.*.test_quick != 0)) {
    return !(g_test_config_vars.*.test_quick != 0);
}
pub inline fn g_test_perf() @TypeOf(g_test_config_vars.*.test_perf) {
    return g_test_config_vars.*.test_perf;
}
pub inline fn g_test_verbose() @TypeOf(g_test_config_vars.*.test_verbose) {
    return g_test_config_vars.*.test_verbose;
}
pub inline fn g_test_quiet() @TypeOf(g_test_config_vars.*.test_quiet) {
    return g_test_config_vars.*.test_quiet;
}
pub inline fn g_test_undefined() @TypeOf(g_test_config_vars.*.test_undefined) {
    return g_test_config_vars.*.test_undefined;
}
pub inline fn g_test_queue_unref(gobject: anytype) @TypeOf(g_test_queue_destroy(g_object_unref, gobject)) {
    return g_test_queue_destroy(g_object_unref, gobject);
}
pub inline fn g_test_rand_bit() @TypeOf(@as(c_int, 0) != (g_test_rand_int() & (@as(c_int, 1) << @as(c_int, 15)))) {
    return @as(c_int, 0) != (g_test_rand_int() & (@as(c_int, 1) << @as(c_int, 15)));
}
pub const __G_THREADPOOL_H__ = "";
pub const __G_TIMER_H__ = "";
pub const G_USEC_PER_SEC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal);
pub const __G_TRASH_STACK_H__ = "";
pub const __G_TREE_H__ = "";
pub const G_URI_ERROR = g_uri_error_quark() ++ GLIB_AVAILABLE_MACRO_IN_2_66;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS = ":/?#[]@";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = "!$&'()*+,;=";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT = G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS ++ ":@";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH = G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT ++ "/";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO = G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS ++ ":";
pub const __G_UUID_H__ = "";
pub const __G_VERSION_H__ = "";
pub inline fn GLIB_CHECK_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf(((GLIB_MAJOR_VERSION > major) or ((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION > minor))) or (((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION == minor)) and (GLIB_MICRO_VERSION >= micro))) {
    return ((GLIB_MAJOR_VERSION > major) or ((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION > minor))) or (((GLIB_MAJOR_VERSION == major) and (GLIB_MINOR_VERSION == minor)) and (GLIB_MICRO_VERSION >= micro));
}
pub const __G_ALLOCATOR_H__ = "";
pub const G_ALLOC_ONLY = @as(c_int, 1);
pub const G_ALLOC_AND_FREE = @as(c_int, 2);
pub const G_ALLOCATOR_LIST = @as(c_int, 1);
pub const G_ALLOCATOR_SLIST = @as(c_int, 2);
pub const G_ALLOCATOR_NODE = @as(c_int, 3);
pub inline fn g_chunk_free(mem: anytype, mem_chunk: anytype) @TypeOf(g_mem_chunk_free(mem_chunk, mem)) {
    return g_mem_chunk_free(mem_chunk, mem);
}
pub inline fn g_mem_chunk_create(@"type": anytype, x: anytype, y: anytype) @TypeOf(g_mem_chunk_new(NULL, @import("std").zig.c_translation.sizeof(@"type"), @as(c_int, 0), @as(c_int, 0))) {
    _ = @TypeOf(@"type");
    _ = @TypeOf(x);
    _ = @TypeOf(y);
    return g_mem_chunk_new(NULL, @import("std").zig.c_translation.sizeof(@"type"), @as(c_int, 0), @as(c_int, 0));
}
pub const __G_CACHE_H__ = "";
pub const __G_COMPLETION_H__ = "";
pub const __G_DEPRECATED_MAIN_H__ = "";
pub const __G_REL_H__ = "";
pub const __G_DEPRECATED_THREAD_H__ = "";
pub const _PTHREAD_H = @as(c_int, 1);
pub const _SCHED_H = @as(c_int, 1);
pub const _BITS_SCHED_H = @as(c_int, 1);
pub const SCHED_OTHER = @as(c_int, 0);
pub const SCHED_FIFO = @as(c_int, 1);
pub const SCHED_RR = @as(c_int, 2);
pub const _BITS_TYPES_STRUCT_SCHED_PARAM = @as(c_int, 1);
pub const _BITS_CPU_SET_H = @as(c_int, 1);
pub const __CPU_SETSIZE = @as(c_int, 1024);
pub const __NCPUBITS = @as(c_int, 8) * @import("std").zig.c_translation.sizeof(__cpu_mask);
pub inline fn __CPUELT(cpu: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(cpu, __NCPUBITS)) {
    return @import("std").zig.c_translation.MacroArithmetic.div(cpu, __NCPUBITS);
}
pub inline fn __CPUMASK(cpu: anytype) @TypeOf(@import("std").zig.c_translation.cast(__cpu_mask, @as(c_int, 1)) << @import("std").zig.c_translation.MacroArithmetic.rem(cpu, __NCPUBITS)) {
    return @import("std").zig.c_translation.cast(__cpu_mask, @as(c_int, 1)) << @import("std").zig.c_translation.MacroArithmetic.rem(cpu, __NCPUBITS);
}
pub inline fn __CPU_COUNT_S(setsize: anytype, cpusetp: anytype) @TypeOf(__sched_cpucount(setsize, cpusetp)) {
    return __sched_cpucount(setsize, cpusetp);
}
pub inline fn __CPU_ALLOC_SIZE(count: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div((count + __NCPUBITS) - @as(c_int, 1), __NCPUBITS) * @import("std").zig.c_translation.sizeof(__cpu_mask)) {
    return @import("std").zig.c_translation.MacroArithmetic.div((count + __NCPUBITS) - @as(c_int, 1), __NCPUBITS) * @import("std").zig.c_translation.sizeof(__cpu_mask);
}
pub inline fn __CPU_ALLOC(count: anytype) @TypeOf(__sched_cpualloc(count)) {
    return __sched_cpualloc(count);
}
pub inline fn __CPU_FREE(cpuset: anytype) @TypeOf(__sched_cpufree(cpuset)) {
    return __sched_cpufree(cpuset);
}
pub const _BITS_SETJMP_H = @as(c_int, 1);
pub const __jmp_buf_tag_defined = @as(c_int, 1);
pub const PTHREAD_CANCELED = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const PTHREAD_ONCE_INIT = @as(c_int, 0);
pub const PTHREAD_BARRIER_SERIAL_THREAD = -@as(c_int, 1);
pub const __cleanup_fct_attribute = "";
pub inline fn __sigsetjmp_cancel(env: anytype, savemask: anytype) @TypeOf(__sigsetjmp(@import("std").zig.c_translation.cast([*c]struct___jmp_buf_tag, @import("std").zig.c_translation.cast(?*anyopaque, env)), savemask)) {
    return __sigsetjmp(@import("std").zig.c_translation.cast([*c]struct___jmp_buf_tag, @import("std").zig.c_translation.cast(?*anyopaque, env)), savemask);
}
pub const g_static_mutex_get_mutex = g_static_mutex_get_mutex_impl ++ GLIB_DEPRECATED_MACRO_IN_2_32;
pub inline fn g_thread_supported() @TypeOf(@as(c_int, 1) ++ GLIB_DEPRECATED_MACRO_IN_2_32) {
    return @as(c_int, 1) ++ GLIB_DEPRECATED_MACRO_IN_2_32;
}
pub const GDK_DEPRECATED_ENUMERATOR = G_DEPRECATED;
pub inline fn GDK_DEPRECATED_ENUMERATOR_FOR(f: anytype) @TypeOf(G_DEPRECATED_FOR(f)) {
    return G_DEPRECATED_FOR(f);
}
pub inline fn GDK_UNAVAILABLE_ENUMERATOR(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GDK_DEPRECATED_TYPE = G_DEPRECATED;
pub inline fn GDK_DEPRECATED_TYPE_FOR(f: anytype) @TypeOf(G_DEPRECATED_FOR(f)) {
    return G_DEPRECATED_FOR(f);
}
pub inline fn GDK_UNAVAILABLE_TYPE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GDK_MAJOR_VERSION = @as(c_int, 4);
pub const GDK_MINOR_VERSION = @as(c_int, 12);
pub const GDK_MICRO_VERSION = @as(c_int, 4);
pub const GDK_VERSION_4_0 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 0));
pub const GDK_VERSION_4_2 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 2));
pub const GDK_VERSION_4_4 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 4));
pub const GDK_VERSION_4_6 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 6));
pub const GDK_VERSION_4_8 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 8));
pub const GDK_VERSION_4_10 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 10));
pub const GDK_VERSION_4_12 = G_ENCODE_VERSION(@as(c_int, 4), @as(c_int, 12));
pub const GDK_VERSION_CUR_STABLE = G_ENCODE_VERSION(GDK_MAJOR_VERSION, GDK_MINOR_VERSION);
pub const GDK_VERSION_PREV_STABLE = G_ENCODE_VERSION(GDK_MAJOR_VERSION, GDK_MINOR_VERSION - @as(c_int, 2));
pub const GDK_VERSION_MIN_REQUIRED = GDK_VERSION_CUR_STABLE;
pub const GDK_VERSION_MAX_ALLOWED = GDK_VERSION_MIN_REQUIRED;
pub const _GDK_IMPORT = "";
pub const _GDK_API = _GDK_IMPORT;
pub const GDK_VAR = _GDK_EXTERN;
pub const GDK_AVAILABLE_IN_ALL = _GDK_EXTERN;
pub const GDK_DEPRECATED = G_DEPRECATED ++ _GDK_EXTERN;
pub inline fn GDK_UNAVAILABLE_STATIC_INLINE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GDK_DEPRECATED_IN_4_0 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_0_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_0 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_0_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_0 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_0_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_0 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_0_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_0 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_0 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_0 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_0 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_0 = "";
pub const GDK_DEPRECATED_IN_4_2 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_2_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_2 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_2_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_2 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_2_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_2 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_2_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_2 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_2 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_2 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_2 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_2 = "";
pub const GDK_DEPRECATED_IN_4_4 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_4_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_4 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_4_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_4 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_4_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_4 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_4_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_4 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_4 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_4 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_4 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_4 = "";
pub const GDK_DEPRECATED_IN_4_6 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_6_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_6 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_6_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_6 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_6_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_6 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_6_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_6 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_6 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_6 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_6 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_6 = "";
pub const GDK_DEPRECATED_IN_4_8 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_8_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_8 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_8_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_8 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_8_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_8 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_8_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_8 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_8 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_8 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_8 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_8 = "";
pub const GDK_DEPRECATED_IN_4_10 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_10_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_10 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_10_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_10 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_10_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_10 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_10_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_10 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_10 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_10 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_10 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_10 = "";
pub const GDK_DEPRECATED_IN_4_12 = GDK_DEPRECATED;
pub inline fn GDK_DEPRECATED_IN_4_12_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_FOR(f)) {
    return GDK_DEPRECATED_FOR(f);
}
pub const GDK_DEPRECATED_MACRO_IN_4_12 = GDK_DEPRECATED_MACRO;
pub inline fn GDK_DEPRECATED_MACRO_IN_4_12_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_MACRO_FOR(f)) {
    return GDK_DEPRECATED_MACRO_FOR(f);
}
pub const GDK_DEPRECATED_ENUMERATOR_IN_4_12 = GDK_DEPRECATED_ENUMERATOR;
pub inline fn GDK_DEPRECATED_ENUMERATOR_IN_4_12_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GDK_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GDK_DEPRECATED_TYPE_IN_4_12 = GDK_DEPRECATED_TYPE;
pub inline fn GDK_DEPRECATED_TYPE_IN_4_12_FOR(f: anytype) @TypeOf(GDK_DEPRECATED_TYPE_FOR(f)) {
    return GDK_DEPRECATED_TYPE_FOR(f);
}
pub const GDK_AVAILABLE_IN_4_12 = _GDK_EXTERN;
pub const GDK_AVAILABLE_STATIC_INLINE_IN_4_12 = "";
pub const GDK_AVAILABLE_MACRO_IN_4_12 = "";
pub const GDK_AVAILABLE_ENUMERATOR_IN_4_12 = "";
pub const GDK_AVAILABLE_TYPE_IN_4_12 = "";
pub const __GTK_CSS_ENUM_TYPES_H__ = "";
pub const __GLIB_GOBJECT_H__ = "";
pub const __GLIB_GOBJECT_H_INSIDE__ = "";
pub const __G_BINDING_H__ = "";
pub const __G_OBJECT_H__ = "";
pub const __G_TYPE_H__ = "";
pub const _GOBJECT_IMPORT = "";
pub const _GOBJECT_API = _GOBJECT_IMPORT;
pub const GOBJECT_VAR = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_IN_ALL = _GOBJECT_EXTERN;
pub const GOBJECT_DEPRECATED = G_DEPRECATED ++ _GOBJECT_EXTERN;
pub inline fn GOBJECT_UNAVAILABLE_STATIC_INLINE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GOBJECT_DEPRECATED_IN_2_26 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_26_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_26 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_26 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_26 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_26 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_26 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_26 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_26 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_26 = "";
pub const GOBJECT_DEPRECATED_IN_2_28 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_28_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_28 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_28 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_28 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_28 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_28 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_28 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_28 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_28 = "";
pub const GOBJECT_DEPRECATED_IN_2_30 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_30_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_30 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_30 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_30 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_30 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_30 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_30 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_30 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_30 = "";
pub const GOBJECT_DEPRECATED_IN_2_32 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_32_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_32 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_32 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_32 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_32 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_32 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_32 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_32 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_32 = "";
pub const GOBJECT_DEPRECATED_IN_2_34 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_34_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_34 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_34 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_34 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_34 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_34 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_34 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_34 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_34 = "";
pub const GOBJECT_DEPRECATED_IN_2_36 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_36_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_36 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_36 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_36 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_36 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_36 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_36 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_36 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_36 = "";
pub const GOBJECT_DEPRECATED_IN_2_38 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_38_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_38 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_38 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_38 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_38 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_38 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_38 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_38 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_38 = "";
pub const GOBJECT_DEPRECATED_IN_2_40 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_40_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_40 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_40 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_40 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_40 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_40 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_40 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_40 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_40 = "";
pub const GOBJECT_DEPRECATED_IN_2_42 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_42_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_42 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_42 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_42 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_42 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_42 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_42 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_42 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_42 = "";
pub const GOBJECT_DEPRECATED_IN_2_44 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_44_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_44 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_44 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_44 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_44 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_44 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_44 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_44 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_44 = "";
pub const GOBJECT_DEPRECATED_IN_2_46 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_46_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_46 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_46 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_46 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_46 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_46 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_46 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_46 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_46 = "";
pub const GOBJECT_DEPRECATED_IN_2_48 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_48_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_48 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_48 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_48 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_48 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_48 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_48 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_48 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_48 = "";
pub const GOBJECT_DEPRECATED_IN_2_50 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_50_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_50 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_50 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_50 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_50 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_50 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_50 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_50 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_50 = "";
pub const GOBJECT_DEPRECATED_IN_2_52 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_52_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_52 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_52 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_52 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_52 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_52 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_52 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_52 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_52 = "";
pub const GOBJECT_DEPRECATED_IN_2_54 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_54_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_54 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_54 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_54 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_54 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_54 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_54 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_54 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_54 = "";
pub const GOBJECT_DEPRECATED_IN_2_56 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_56_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_56 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_56 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_56 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_56 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_56 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_56 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_56 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_56 = "";
pub const GOBJECT_DEPRECATED_IN_2_58 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_58_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_58 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_58 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_58 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_58 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_58 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_58 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_58 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_58 = "";
pub const GOBJECT_DEPRECATED_IN_2_60 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_60_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_60 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_60 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_60 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_60 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_60 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_60 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_60 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_60 = "";
pub const GOBJECT_DEPRECATED_IN_2_62 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_62_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_62 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_62 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_62 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_62 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_62 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_62 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_62 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_62 = "";
pub const GOBJECT_DEPRECATED_IN_2_64 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_64_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_64 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_64 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_64 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_64 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_64 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_64 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_64 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_64 = "";
pub const GOBJECT_DEPRECATED_IN_2_66 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_66_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_66 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_66 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_66 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_66 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_66 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_66 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_66 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_66 = "";
pub const GOBJECT_DEPRECATED_IN_2_68 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_68_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_68 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_68 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_68 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_68 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_68 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_68 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_68 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_68 = "";
pub const GOBJECT_DEPRECATED_IN_2_70 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_70_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_70 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_70 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_70 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_70 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_70 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_70 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_70 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_70 = "";
pub const GOBJECT_DEPRECATED_IN_2_72 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_72_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_72 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_72 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_72 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_72 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_72 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_72 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_72 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_72 = "";
pub const GOBJECT_DEPRECATED_IN_2_74 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_74_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_74 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_74 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_74 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_74 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_74 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_74 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_74 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_74 = "";
pub const GOBJECT_DEPRECATED_IN_2_76 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_76_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_76 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_76 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_76 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_76 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_76 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_76 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_76 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_76 = "";
pub const GOBJECT_DEPRECATED_IN_2_78 = GOBJECT_DEPRECATED;
pub inline fn GOBJECT_DEPRECATED_IN_2_78_FOR(f: anytype) @TypeOf(GOBJECT_DEPRECATED_FOR(f)) {
    return GOBJECT_DEPRECATED_FOR(f);
}
pub const GOBJECT_DEPRECATED_MACRO_IN_2_78 = GLIB_DEPRECATED_MACRO;
pub inline fn GOBJECT_DEPRECATED_MACRO_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GOBJECT_DEPRECATED_ENUMERATOR_IN_2_78 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GOBJECT_DEPRECATED_ENUMERATOR_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GOBJECT_DEPRECATED_TYPE_IN_2_78 = GLIB_DEPRECATED_TYPE;
pub inline fn GOBJECT_DEPRECATED_TYPE_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GOBJECT_AVAILABLE_IN_2_78 = _GOBJECT_EXTERN;
pub const GOBJECT_AVAILABLE_STATIC_INLINE_IN_2_78 = "";
pub const GOBJECT_AVAILABLE_MACRO_IN_2_78 = "";
pub const GOBJECT_AVAILABLE_ENUMERATOR_IN_2_78 = "";
pub const GOBJECT_AVAILABLE_TYPE_IN_2_78 = "";
pub inline fn G_TYPE_FUNDAMENTAL(@"type": anytype) @TypeOf(g_type_fundamental(@"type")) {
    return g_type_fundamental(@"type");
}
pub const G_TYPE_FUNDAMENTAL_SHIFT = @as(c_int, 2);
pub const G_TYPE_FUNDAMENTAL_MAX = @as(c_int, 255) << G_TYPE_FUNDAMENTAL_SHIFT;
pub const G_TYPE_INVALID = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 0));
pub const G_TYPE_NONE = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 1));
pub const G_TYPE_INTERFACE = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 2));
pub const G_TYPE_CHAR = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 3));
pub const G_TYPE_UCHAR = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 4));
pub const G_TYPE_BOOLEAN = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 5));
pub const G_TYPE_INT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 6));
pub const G_TYPE_UINT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 7));
pub const G_TYPE_LONG = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 8));
pub const G_TYPE_ULONG = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 9));
pub const G_TYPE_INT64 = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 10));
pub const G_TYPE_UINT64 = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 11));
pub const G_TYPE_ENUM = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 12));
pub const G_TYPE_FLAGS = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 13));
pub const G_TYPE_FLOAT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 14));
pub const G_TYPE_DOUBLE = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 15));
pub const G_TYPE_STRING = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 16));
pub const G_TYPE_POINTER = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 17));
pub const G_TYPE_BOXED = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 18));
pub const G_TYPE_PARAM = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 19));
pub const G_TYPE_OBJECT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 20));
pub const G_TYPE_VARIANT = G_TYPE_MAKE_FUNDAMENTAL(@as(c_int, 21));
pub inline fn G_TYPE_MAKE_FUNDAMENTAL(x: anytype) GType {
    return @import("std").zig.c_translation.cast(GType, x << G_TYPE_FUNDAMENTAL_SHIFT);
}
pub const G_TYPE_RESERVED_GLIB_FIRST = @as(c_int, 22);
pub const G_TYPE_RESERVED_GLIB_LAST = @as(c_int, 31);
pub const G_TYPE_RESERVED_BSE_FIRST = @as(c_int, 32);
pub const G_TYPE_RESERVED_BSE_LAST = @as(c_int, 48);
pub const G_TYPE_RESERVED_USER_FIRST = @as(c_int, 49);
pub inline fn G_TYPE_IS_FUNDAMENTAL(@"type": anytype) @TypeOf(@"type" <= G_TYPE_FUNDAMENTAL_MAX) {
    return @"type" <= G_TYPE_FUNDAMENTAL_MAX;
}
pub inline fn G_TYPE_IS_DERIVED(@"type": anytype) @TypeOf(@"type" > G_TYPE_FUNDAMENTAL_MAX) {
    return @"type" > G_TYPE_FUNDAMENTAL_MAX;
}
pub inline fn G_TYPE_IS_INTERFACE(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_INTERFACE) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_INTERFACE;
}
pub inline fn G_TYPE_IS_CLASSED(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_CLASSED)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_CLASSED);
}
pub inline fn G_TYPE_IS_INSTANTIATABLE(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_INSTANTIATABLE)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_INSTANTIATABLE);
}
pub inline fn G_TYPE_IS_DERIVABLE(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_DERIVABLE)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_DERIVABLE);
}
pub inline fn G_TYPE_IS_DEEP_DERIVABLE(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_DEEP_DERIVABLE)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_DEEP_DERIVABLE);
}
pub inline fn G_TYPE_IS_ABSTRACT(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_ABSTRACT)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_ABSTRACT);
}
pub inline fn G_TYPE_IS_VALUE_ABSTRACT(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_VALUE_ABSTRACT)) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_VALUE_ABSTRACT);
}
pub inline fn G_TYPE_IS_VALUE_TYPE(@"type": anytype) @TypeOf(g_type_check_is_value_type(@"type")) {
    return g_type_check_is_value_type(@"type");
}
pub inline fn G_TYPE_HAS_VALUE_TABLE(@"type": anytype) @TypeOf(g_type_value_table_peek(@"type") != NULL) {
    return g_type_value_table_peek(@"type") != NULL;
}
pub inline fn G_TYPE_IS_FINAL(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_FINAL) ++ GOBJECT_AVAILABLE_MACRO_IN_2_70) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_FINAL) ++ GOBJECT_AVAILABLE_MACRO_IN_2_70;
}
pub inline fn G_TYPE_IS_DEPRECATED(@"type": anytype) @TypeOf(g_type_test_flags(@"type", G_TYPE_FLAG_DEPRECATED) ++ GOBJECT_AVAILABLE_MACRO_IN_2_76) {
    return g_type_test_flags(@"type", G_TYPE_FLAG_DEPRECATED) ++ GOBJECT_AVAILABLE_MACRO_IN_2_76;
}
pub inline fn G_TYPE_CHECK_INSTANCE(instance: anytype) @TypeOf(_G_TYPE_CHI(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance))) {
    return _G_TYPE_CHI(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance));
}
pub inline fn G_TYPE_CHECK_INSTANCE_CAST(instance: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_CIC(instance, g_type, c_type)) {
    return _G_TYPE_CIC(instance, g_type, c_type);
}
pub inline fn G_TYPE_CHECK_INSTANCE_TYPE(instance: anytype, g_type: anytype) @TypeOf(_G_TYPE_CIT(instance, g_type)) {
    return _G_TYPE_CIT(instance, g_type);
}
pub inline fn G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(instance: anytype, g_type: anytype) @TypeOf(_G_TYPE_CIFT(instance, g_type)) {
    return _G_TYPE_CIFT(instance, g_type);
}
pub inline fn G_TYPE_INSTANCE_GET_CLASS(instance: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_IGC(instance, g_type, c_type)) {
    return _G_TYPE_IGC(instance, g_type, c_type);
}
pub inline fn G_TYPE_INSTANCE_GET_INTERFACE(instance: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_IGI(instance, g_type, c_type)) {
    return _G_TYPE_IGI(instance, g_type, c_type);
}
pub inline fn G_TYPE_CHECK_CLASS_CAST(g_class: anytype, g_type: anytype, c_type: anytype) @TypeOf(_G_TYPE_CCC(g_class, g_type, c_type)) {
    return _G_TYPE_CCC(g_class, g_type, c_type);
}
pub inline fn G_TYPE_CHECK_CLASS_TYPE(g_class: anytype, g_type: anytype) @TypeOf(_G_TYPE_CCT(g_class, g_type)) {
    return _G_TYPE_CCT(g_class, g_type);
}
pub inline fn G_TYPE_CHECK_VALUE(value: anytype) @TypeOf(_G_TYPE_CHV(value)) {
    return _G_TYPE_CHV(value);
}
pub inline fn G_TYPE_CHECK_VALUE_TYPE(value: anytype, g_type: anytype) @TypeOf(_G_TYPE_CVH(value, g_type)) {
    return _G_TYPE_CVH(value, g_type);
}
pub inline fn G_TYPE_FROM_INSTANCE(instance: anytype) @TypeOf(G_TYPE_FROM_CLASS(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance).*.g_class)) {
    return G_TYPE_FROM_CLASS(@import("std").zig.c_translation.cast([*c]GTypeInstance, instance).*.g_class);
}
pub inline fn G_TYPE_FROM_CLASS(g_class: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GTypeClass, g_class).*.g_type) {
    return @import("std").zig.c_translation.cast([*c]GTypeClass, g_class).*.g_type;
}
pub inline fn G_TYPE_FROM_INTERFACE(g_iface: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GTypeInterface, g_iface).*.g_type) {
    return @import("std").zig.c_translation.cast([*c]GTypeInterface, g_iface).*.g_type;
}
pub inline fn G_DEFINE_TYPE_WITH_PRIVATE(TN: anytype, t_n: anytype, T_P: anytype) @TypeOf(G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, @as(c_int, 0), G_ADD_PRIVATE(TN))) {
    return G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, @as(c_int, 0), G_ADD_PRIVATE(TN));
}
pub inline fn G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(TN: anytype, t_n: anytype, T_P: anytype) @TypeOf(G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, G_ADD_PRIVATE(TN))) {
    return G_DEFINE_TYPE_EXTENDED(TN, t_n, T_P, G_TYPE_FLAG_ABSTRACT, G_ADD_PRIVATE(TN));
}
pub inline fn G_PRIVATE_FIELD_P(TypeName: anytype, inst: anytype, field_name: anytype) @TypeOf(G_STRUCT_MEMBER_P(inst, G_PRIVATE_OFFSET(TypeName, field_name))) {
    return G_STRUCT_MEMBER_P(inst, G_PRIVATE_OFFSET(TypeName, field_name));
}
pub inline fn G_PRIVATE_FIELD(TypeName: anytype, inst: anytype, field_type: anytype, field_name: anytype) @TypeOf(G_STRUCT_MEMBER(field_type, inst, G_PRIVATE_OFFSET(TypeName, field_name))) {
    return G_STRUCT_MEMBER(field_type, inst, G_PRIVATE_OFFSET(TypeName, field_name));
}
pub inline fn _G_TYPE_CHI(ip: anytype) @TypeOf(g_type_check_instance(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip))) {
    return g_type_check_instance(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip));
}
pub inline fn _G_TYPE_CHV(vl: anytype) @TypeOf(g_type_check_value(@import("std").zig.c_translation.cast([*c]GValue, vl))) {
    return g_type_check_value(@import("std").zig.c_translation.cast([*c]GValue, vl));
}
pub inline fn _G_TYPE_CIFT(ip: anytype, ft: anytype) @TypeOf(g_type_check_instance_is_fundamentally_a(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip), ft)) {
    return g_type_check_instance_is_fundamentally_a(@import("std").zig.c_translation.cast([*c]GTypeInstance, ip), ft);
}
pub const G_TYPE_FLAG_RESERVED_ID_BIT = @import("std").zig.c_translation.cast(GType, @as(c_int, 1) << @as(c_int, 0));
pub const __G_VALUE_H__ = "";
pub inline fn G_TYPE_IS_VALUE(@"type": anytype) @TypeOf(g_type_check_is_value_type(@"type")) {
    return g_type_check_is_value_type(@"type");
}
pub inline fn G_IS_VALUE(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE(value)) {
    return G_TYPE_CHECK_VALUE(value);
}
pub inline fn G_VALUE_TYPE(value: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GValue, value).*.g_type) {
    return @import("std").zig.c_translation.cast([*c]GValue, value).*.g_type;
}
pub inline fn G_VALUE_TYPE_NAME(value: anytype) @TypeOf(g_type_name(G_VALUE_TYPE(value))) {
    return g_type_name(G_VALUE_TYPE(value));
}
pub inline fn G_VALUE_HOLDS(value: anytype, @"type": anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, @"type")) {
    return G_TYPE_CHECK_VALUE_TYPE(value, @"type");
}
pub const G_VALUE_NOCOPY_CONTENTS = @as(c_int, 1) << @as(c_int, 27);
pub const G_VALUE_INTERNED_STRING = @as(c_int, 1) << @as(c_int, 28) ++ GOBJECT_AVAILABLE_MACRO_IN_2_66;
pub const __G_PARAM_H__ = "";
pub inline fn G_TYPE_IS_PARAM(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_PARAM) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_PARAM;
}
pub inline fn G_PARAM_SPEC(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM, GParamSpec)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM, GParamSpec);
}
pub inline fn G_IS_PARAM_SPEC(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(pspec, G_TYPE_PARAM)) {
    return G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(pspec, G_TYPE_PARAM);
}
pub inline fn G_PARAM_SPEC_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(pclass, G_TYPE_PARAM, GParamSpecClass)) {
    return G_TYPE_CHECK_CLASS_CAST(pclass, G_TYPE_PARAM, GParamSpecClass);
}
pub inline fn G_IS_PARAM_SPEC_CLASS(pclass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(pclass, G_TYPE_PARAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(pclass, G_TYPE_PARAM);
}
pub inline fn G_PARAM_SPEC_GET_CLASS(pspec: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(pspec, G_TYPE_PARAM, GParamSpecClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(pspec, G_TYPE_PARAM, GParamSpecClass);
}
pub inline fn G_PARAM_SPEC_TYPE(pspec: anytype) @TypeOf(G_TYPE_FROM_INSTANCE(pspec)) {
    return G_TYPE_FROM_INSTANCE(pspec);
}
pub inline fn G_PARAM_SPEC_TYPE_NAME(pspec: anytype) @TypeOf(g_type_name(G_PARAM_SPEC_TYPE(pspec))) {
    return g_type_name(G_PARAM_SPEC_TYPE(pspec));
}
pub inline fn G_PARAM_SPEC_VALUE_TYPE(pspec: anytype) @TypeOf(G_PARAM_SPEC(pspec).*.value_type) {
    return G_PARAM_SPEC(pspec).*.value_type;
}
pub inline fn G_VALUE_HOLDS_PARAM(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_PARAM)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_PARAM);
}
pub const G_PARAM_STATIC_STRINGS = (G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK) | G_PARAM_STATIC_BLURB;
pub const G_PARAM_MASK = @as(c_int, 0x000000ff);
pub const G_PARAM_USER_SHIFT = @as(c_int, 8);
pub const __G_CLOSURE_H__ = "";
pub inline fn G_CLOSURE_NEEDS_MARSHAL(closure: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GClosure, closure).*.marshal == NULL) {
    return @import("std").zig.c_translation.cast([*c]GClosure, closure).*.marshal == NULL;
}
pub inline fn G_CLOSURE_N_NOTIFIERS(cl: anytype) @TypeOf(((cl.*.n_guards << @as(c_long, 1)) + cl.*.n_fnotifiers) + cl.*.n_inotifiers) {
    return ((cl.*.n_guards << @as(c_long, 1)) + cl.*.n_fnotifiers) + cl.*.n_inotifiers;
}
pub inline fn G_CCLOSURE_SWAP_DATA(cclosure: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]GClosure, cclosure).*.derivative_flag) {
    return @import("std").zig.c_translation.cast([*c]GClosure, cclosure).*.derivative_flag;
}
pub inline fn G_CALLBACK(f: anytype) GCallback {
    return @import("std").zig.c_translation.cast(GCallback, f);
}
pub const __G_SIGNAL_H__ = "";
pub const __G_MARSHAL_H__ = "";
pub const g_cclosure_marshal_BOOL__FLAGS = g_cclosure_marshal_BOOLEAN__FLAGS;
pub const g_cclosure_marshal_BOOL__BOXED_BOXED = g_cclosure_marshal_BOOLEAN__BOXED_BOXED;
pub const G_SIGNAL_FLAGS_MASK = @as(c_int, 0x1ff);
pub const G_SIGNAL_MATCH_MASK = @as(c_int, 0x3f);
pub const G_SIGNAL_TYPE_STATIC_SCOPE = G_TYPE_FLAG_RESERVED_ID_BIT;
pub inline fn g_signal_connect(instance: anytype, detailed_signal: anytype, c_handler: anytype, data: anytype) @TypeOf(g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, @import("std").zig.c_translation.cast(GConnectFlags, @as(c_int, 0)))) {
    return g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, @import("std").zig.c_translation.cast(GConnectFlags, @as(c_int, 0)));
}
pub inline fn g_signal_connect_after(instance: anytype, detailed_signal: anytype, c_handler: anytype, data: anytype) @TypeOf(g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_AFTER)) {
    return g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_AFTER);
}
pub inline fn g_signal_connect_swapped(instance: anytype, detailed_signal: anytype, c_handler: anytype, data: anytype) @TypeOf(g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_SWAPPED)) {
    return g_signal_connect_data(instance, detailed_signal, c_handler, data, NULL, G_CONNECT_SWAPPED);
}
pub inline fn g_signal_handlers_disconnect_by_func(instance: anytype, func: anytype, data: anytype) @TypeOf(g_signal_handlers_disconnect_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data)) {
    return g_signal_handlers_disconnect_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data);
}
pub inline fn g_signal_handlers_disconnect_by_data(instance: anytype, data: anytype) @TypeOf(g_signal_handlers_disconnect_matched(instance, G_SIGNAL_MATCH_DATA, @as(c_int, 0), @as(c_int, 0), NULL, NULL, data)) {
    return g_signal_handlers_disconnect_matched(instance, G_SIGNAL_MATCH_DATA, @as(c_int, 0), @as(c_int, 0), NULL, NULL, data);
}
pub inline fn g_signal_handlers_block_by_func(instance: anytype, func: anytype, data: anytype) @TypeOf(g_signal_handlers_block_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data)) {
    return g_signal_handlers_block_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data);
}
pub inline fn g_signal_handlers_unblock_by_func(instance: anytype, func: anytype, data: anytype) @TypeOf(g_signal_handlers_unblock_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data)) {
    return g_signal_handlers_unblock_matched(instance, @import("std").zig.c_translation.cast(GSignalMatchType, G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA), @as(c_int, 0), @as(c_int, 0), NULL, func, data);
}
pub const __G_BOXED_H__ = "";
pub const __GLIB_TYPES_H__ = "";
pub const G_TYPE_DATE = g_date_get_type();
pub const G_TYPE_STRV = g_strv_get_type();
pub const G_TYPE_GSTRING = g_gstring_get_type();
pub const G_TYPE_HASH_TABLE = g_hash_table_get_type();
pub const G_TYPE_REGEX = g_regex_get_type();
pub const G_TYPE_MATCH_INFO = g_match_info_get_type();
pub const G_TYPE_ARRAY = g_array_get_type();
pub const G_TYPE_BYTE_ARRAY = g_byte_array_get_type();
pub const G_TYPE_PTR_ARRAY = g_ptr_array_get_type();
pub const G_TYPE_BYTES = g_bytes_get_type();
pub const G_TYPE_VARIANT_TYPE = g_variant_type_get_gtype();
pub const G_TYPE_ERROR = g_error_get_type();
pub const G_TYPE_DATE_TIME = g_date_time_get_type();
pub const G_TYPE_TIME_ZONE = g_time_zone_get_type();
pub const G_TYPE_IO_CHANNEL = g_io_channel_get_type();
pub const G_TYPE_IO_CONDITION = g_io_condition_get_type();
pub const G_TYPE_VARIANT_BUILDER = g_variant_builder_get_type();
pub const G_TYPE_VARIANT_DICT = g_variant_dict_get_type();
pub const G_TYPE_MAIN_LOOP = g_main_loop_get_type();
pub const G_TYPE_MAIN_CONTEXT = g_main_context_get_type();
pub const G_TYPE_SOURCE = g_source_get_type();
pub const G_TYPE_POLLFD = g_pollfd_get_type();
pub const G_TYPE_MARKUP_PARSE_CONTEXT = g_markup_parse_context_get_type();
pub const G_TYPE_KEY_FILE = g_key_file_get_type();
pub const G_TYPE_MAPPED_FILE = g_mapped_file_get_type();
pub const G_TYPE_THREAD = g_thread_get_type();
pub const G_TYPE_CHECKSUM = g_checksum_get_type();
pub const G_TYPE_OPTION_GROUP = g_option_group_get_type();
pub const G_TYPE_URI = g_uri_get_type();
pub const G_TYPE_TREE = g_tree_get_type();
pub const G_TYPE_PATTERN_SPEC = g_pattern_spec_get_type();
pub const G_TYPE_BOOKMARK_FILE = g_bookmark_file_get_type();
pub inline fn G_TYPE_IS_BOXED(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_BOXED) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_BOXED;
}
pub inline fn G_VALUE_HOLDS_BOXED(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOXED)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOXED);
}
pub const G_TYPE_CLOSURE = g_closure_get_type();
pub const G_TYPE_VALUE = g_value_get_type();
pub inline fn G_TYPE_IS_OBJECT(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_OBJECT) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_OBJECT;
}
pub inline fn G_OBJECT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_OBJECT, GObject)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_OBJECT, GObject);
}
pub inline fn G_OBJECT_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_OBJECT, GObjectClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_OBJECT, GObjectClass);
}
pub inline fn G_IS_OBJECT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(object, G_TYPE_OBJECT)) {
    return G_TYPE_CHECK_INSTANCE_FUNDAMENTAL_TYPE(object, G_TYPE_OBJECT);
}
pub inline fn G_IS_OBJECT_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_OBJECT)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_OBJECT);
}
pub inline fn G_OBJECT_GET_CLASS(object: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_OBJECT, GObjectClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_OBJECT, GObjectClass);
}
pub inline fn G_OBJECT_TYPE(object: anytype) @TypeOf(G_TYPE_FROM_INSTANCE(object)) {
    return G_TYPE_FROM_INSTANCE(object);
}
pub inline fn G_OBJECT_TYPE_NAME(object: anytype) @TypeOf(g_type_name(G_OBJECT_TYPE(object))) {
    return g_type_name(G_OBJECT_TYPE(object));
}
pub inline fn G_OBJECT_CLASS_TYPE(class: anytype) @TypeOf(G_TYPE_FROM_CLASS(class)) {
    return G_TYPE_FROM_CLASS(class);
}
pub inline fn G_OBJECT_CLASS_NAME(class: anytype) @TypeOf(g_type_name(G_OBJECT_CLASS_TYPE(class))) {
    return g_type_name(G_OBJECT_CLASS_TYPE(class));
}
pub inline fn G_VALUE_HOLDS_OBJECT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_OBJECT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_OBJECT);
}
pub const G_TYPE_INITIALLY_UNOWNED = g_initially_unowned_get_type();
pub inline fn G_INITIALLY_UNOWNED(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnowned)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnowned);
}
pub inline fn G_INITIALLY_UNOWNED_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass);
}
pub inline fn G_IS_INITIALLY_UNOWNED(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, G_TYPE_INITIALLY_UNOWNED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, G_TYPE_INITIALLY_UNOWNED);
}
pub inline fn G_IS_INITIALLY_UNOWNED_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_INITIALLY_UNOWNED)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_INITIALLY_UNOWNED);
}
pub inline fn G_INITIALLY_UNOWNED_GET_CLASS(object: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(object, G_TYPE_INITIALLY_UNOWNED, GInitiallyUnownedClass);
}
pub inline fn G_OBJECT_WARN_INVALID_PROPERTY_ID(object: anytype, property_id: anytype, pspec: anytype) @TypeOf(G_OBJECT_WARN_INVALID_PSPEC(object, "property", property_id, pspec)) {
    return G_OBJECT_WARN_INVALID_PSPEC(object, "property", property_id, pspec);
}
pub const G_TYPE_BINDING_FLAGS = g_binding_flags_get_type();
pub const G_TYPE_BINDING = g_binding_get_type();
pub inline fn G_BINDING(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING, GBinding)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING, GBinding);
}
pub inline fn G_IS_BINDING(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING);
}
pub const __G_BINDING_GROUP_H__ = "";
pub inline fn G_BINDING_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING_GROUP, GBindingGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_BINDING_GROUP, GBindingGroup);
}
pub inline fn G_IS_BINDING_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_BINDING_GROUP);
}
pub const G_TYPE_BINDING_GROUP = g_binding_group_get_type();
pub const __G_ENUMS_H__ = "";
pub inline fn G_TYPE_IS_ENUM(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_ENUM) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_ENUM;
}
pub inline fn G_ENUM_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_ENUM, GEnumClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_ENUM, GEnumClass);
}
pub inline fn G_IS_ENUM_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_ENUM)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_ENUM);
}
pub inline fn G_ENUM_CLASS_TYPE(class: anytype) @TypeOf(G_TYPE_FROM_CLASS(class)) {
    return G_TYPE_FROM_CLASS(class);
}
pub inline fn G_ENUM_CLASS_TYPE_NAME(class: anytype) @TypeOf(g_type_name(G_ENUM_CLASS_TYPE(class))) {
    return g_type_name(G_ENUM_CLASS_TYPE(class));
}
pub inline fn G_TYPE_IS_FLAGS(@"type": anytype) @TypeOf(G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_FLAGS) {
    return G_TYPE_FUNDAMENTAL(@"type") == G_TYPE_FLAGS;
}
pub inline fn G_FLAGS_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_FLAGS, GFlagsClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_FLAGS, GFlagsClass);
}
pub inline fn G_IS_FLAGS_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_FLAGS)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_FLAGS);
}
pub inline fn G_FLAGS_CLASS_TYPE(class: anytype) @TypeOf(G_TYPE_FROM_CLASS(class)) {
    return G_TYPE_FROM_CLASS(class);
}
pub inline fn G_FLAGS_CLASS_TYPE_NAME(class: anytype) @TypeOf(g_type_name(G_FLAGS_CLASS_TYPE(class))) {
    return g_type_name(G_FLAGS_CLASS_TYPE(class));
}
pub inline fn G_VALUE_HOLDS_ENUM(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ENUM)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ENUM);
}
pub inline fn G_VALUE_HOLDS_FLAGS(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLAGS)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLAGS);
}
pub const __GOBJECT_ENUM_TYPES_H__ = "";
pub const G_TYPE_UNICODE_TYPE = g_unicode_type_get_type();
pub const G_TYPE_UNICODE_BREAK_TYPE = g_unicode_break_type_get_type();
pub const G_TYPE_UNICODE_SCRIPT = g_unicode_script_get_type();
pub const G_TYPE_NORMALIZE_MODE = g_normalize_mode_get_type();
pub const __G_PARAMSPECS_H__ = "";
pub const G_TYPE_PARAM_CHAR = g_param_spec_types[@as(usize, @intCast(@as(c_int, 0)))];
pub inline fn G_IS_PARAM_SPEC_CHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_CHAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_CHAR);
}
pub inline fn G_PARAM_SPEC_CHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_CHAR, GParamSpecChar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_CHAR, GParamSpecChar);
}
pub const G_TYPE_PARAM_UCHAR = g_param_spec_types[@as(usize, @intCast(@as(c_int, 1)))];
pub inline fn G_IS_PARAM_SPEC_UCHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UCHAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UCHAR);
}
pub inline fn G_PARAM_SPEC_UCHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UCHAR, GParamSpecUChar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UCHAR, GParamSpecUChar);
}
pub const G_TYPE_PARAM_BOOLEAN = g_param_spec_types[@as(usize, @intCast(@as(c_int, 2)))];
pub inline fn G_IS_PARAM_SPEC_BOOLEAN(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOOLEAN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOOLEAN);
}
pub inline fn G_PARAM_SPEC_BOOLEAN(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOOLEAN, GParamSpecBoolean)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOOLEAN, GParamSpecBoolean);
}
pub const G_TYPE_PARAM_INT = g_param_spec_types[@as(usize, @intCast(@as(c_int, 3)))];
pub inline fn G_IS_PARAM_SPEC_INT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT);
}
pub inline fn G_PARAM_SPEC_INT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT, GParamSpecInt)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT, GParamSpecInt);
}
pub const G_TYPE_PARAM_UINT = g_param_spec_types[@as(usize, @intCast(@as(c_int, 4)))];
pub inline fn G_IS_PARAM_SPEC_UINT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT);
}
pub inline fn G_PARAM_SPEC_UINT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT, GParamSpecUInt)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT, GParamSpecUInt);
}
pub const G_TYPE_PARAM_LONG = g_param_spec_types[@as(usize, @intCast(@as(c_int, 5)))];
pub inline fn G_IS_PARAM_SPEC_LONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_LONG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_LONG);
}
pub inline fn G_PARAM_SPEC_LONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_LONG, GParamSpecLong)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_LONG, GParamSpecLong);
}
pub const G_TYPE_PARAM_ULONG = g_param_spec_types[@as(usize, @intCast(@as(c_int, 6)))];
pub inline fn G_IS_PARAM_SPEC_ULONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ULONG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ULONG);
}
pub inline fn G_PARAM_SPEC_ULONG(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ULONG, GParamSpecULong)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ULONG, GParamSpecULong);
}
pub const G_TYPE_PARAM_INT64 = g_param_spec_types[@as(usize, @intCast(@as(c_int, 7)))];
pub inline fn G_IS_PARAM_SPEC_INT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT64)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_INT64);
}
pub inline fn G_PARAM_SPEC_INT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT64, GParamSpecInt64)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_INT64, GParamSpecInt64);
}
pub const G_TYPE_PARAM_UINT64 = g_param_spec_types[@as(usize, @intCast(@as(c_int, 8)))];
pub inline fn G_IS_PARAM_SPEC_UINT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT64)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UINT64);
}
pub inline fn G_PARAM_SPEC_UINT64(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT64, GParamSpecUInt64)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UINT64, GParamSpecUInt64);
}
pub const G_TYPE_PARAM_UNICHAR = g_param_spec_types[@as(usize, @intCast(@as(c_int, 9)))];
pub inline fn G_PARAM_SPEC_UNICHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UNICHAR, GParamSpecUnichar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_UNICHAR, GParamSpecUnichar);
}
pub inline fn G_IS_PARAM_SPEC_UNICHAR(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UNICHAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_UNICHAR);
}
pub const G_TYPE_PARAM_ENUM = g_param_spec_types[@as(usize, @intCast(@as(c_int, 10)))];
pub inline fn G_IS_PARAM_SPEC_ENUM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ENUM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_ENUM);
}
pub inline fn G_PARAM_SPEC_ENUM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ENUM, GParamSpecEnum)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_ENUM, GParamSpecEnum);
}
pub const G_TYPE_PARAM_FLAGS = g_param_spec_types[@as(usize, @intCast(@as(c_int, 11)))];
pub inline fn G_IS_PARAM_SPEC_FLAGS(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLAGS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLAGS);
}
pub inline fn G_PARAM_SPEC_FLAGS(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLAGS, GParamSpecFlags)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLAGS, GParamSpecFlags);
}
pub const G_TYPE_PARAM_FLOAT = g_param_spec_types[@as(usize, @intCast(@as(c_int, 12)))];
pub inline fn G_IS_PARAM_SPEC_FLOAT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLOAT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_FLOAT);
}
pub inline fn G_PARAM_SPEC_FLOAT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLOAT, GParamSpecFloat)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_FLOAT, GParamSpecFloat);
}
pub const G_TYPE_PARAM_DOUBLE = g_param_spec_types[@as(usize, @intCast(@as(c_int, 13)))];
pub inline fn G_IS_PARAM_SPEC_DOUBLE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_DOUBLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_DOUBLE);
}
pub inline fn G_PARAM_SPEC_DOUBLE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_DOUBLE, GParamSpecDouble)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_DOUBLE, GParamSpecDouble);
}
pub const G_TYPE_PARAM_STRING = g_param_spec_types[@as(usize, @intCast(@as(c_int, 14)))];
pub inline fn G_IS_PARAM_SPEC_STRING(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_STRING)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_STRING);
}
pub inline fn G_PARAM_SPEC_STRING(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_STRING, GParamSpecString)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_STRING, GParamSpecString);
}
pub const G_TYPE_PARAM_PARAM = g_param_spec_types[@as(usize, @intCast(@as(c_int, 15)))];
pub inline fn G_IS_PARAM_SPEC_PARAM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_PARAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_PARAM);
}
pub inline fn G_PARAM_SPEC_PARAM(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_PARAM, GParamSpecParam)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_PARAM, GParamSpecParam);
}
pub const G_TYPE_PARAM_BOXED = g_param_spec_types[@as(usize, @intCast(@as(c_int, 16)))];
pub inline fn G_IS_PARAM_SPEC_BOXED(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOXED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_BOXED);
}
pub inline fn G_PARAM_SPEC_BOXED(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOXED, GParamSpecBoxed)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_BOXED, GParamSpecBoxed);
}
pub const G_TYPE_PARAM_POINTER = g_param_spec_types[@as(usize, @intCast(@as(c_int, 17)))];
pub inline fn G_IS_PARAM_SPEC_POINTER(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_POINTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_POINTER);
}
pub inline fn G_PARAM_SPEC_POINTER(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_POINTER, GParamSpecPointer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_POINTER, GParamSpecPointer);
}
pub const G_TYPE_PARAM_VALUE_ARRAY = g_param_spec_types[@as(usize, @intCast(@as(c_int, 18)))] ++ GOBJECT_DEPRECATED_MACRO_IN_2_32;
pub inline fn G_IS_PARAM_SPEC_VALUE_ARRAY(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VALUE_ARRAY) ++ GOBJECT_DEPRECATED_MACRO_IN_2_32) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VALUE_ARRAY) ++ GOBJECT_DEPRECATED_MACRO_IN_2_32;
}
pub inline fn G_PARAM_SPEC_VALUE_ARRAY(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VALUE_ARRAY, GParamSpecValueArray) ++ GOBJECT_DEPRECATED_MACRO_IN_2_32) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VALUE_ARRAY, GParamSpecValueArray) ++ GOBJECT_DEPRECATED_MACRO_IN_2_32;
}
pub const G_TYPE_PARAM_OBJECT = g_param_spec_types[@as(usize, @intCast(@as(c_int, 19)))];
pub inline fn G_IS_PARAM_SPEC_OBJECT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OBJECT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OBJECT);
}
pub inline fn G_PARAM_SPEC_OBJECT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OBJECT, GParamSpecObject)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OBJECT, GParamSpecObject);
}
pub const G_TYPE_PARAM_OVERRIDE = g_param_spec_types[@as(usize, @intCast(@as(c_int, 20)))];
pub inline fn G_IS_PARAM_SPEC_OVERRIDE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OVERRIDE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_OVERRIDE);
}
pub inline fn G_PARAM_SPEC_OVERRIDE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OVERRIDE, GParamSpecOverride)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_OVERRIDE, GParamSpecOverride);
}
pub const G_TYPE_PARAM_GTYPE = g_param_spec_types[@as(usize, @intCast(@as(c_int, 21)))];
pub inline fn G_IS_PARAM_SPEC_GTYPE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_GTYPE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_GTYPE);
}
pub inline fn G_PARAM_SPEC_GTYPE(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_GTYPE, GParamSpecGType)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_GTYPE, GParamSpecGType);
}
pub const G_TYPE_PARAM_VARIANT = g_param_spec_types[@as(usize, @intCast(@as(c_int, 22)))];
pub inline fn G_IS_PARAM_SPEC_VARIANT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VARIANT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(pspec, G_TYPE_PARAM_VARIANT);
}
pub inline fn G_PARAM_SPEC_VARIANT(pspec: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VARIANT, GParamSpecVariant)) {
    return G_TYPE_CHECK_INSTANCE_CAST(pspec, G_TYPE_PARAM_VARIANT, GParamSpecVariant);
}
pub const __G_SIGNAL_GROUP_H__ = "";
pub inline fn G_SIGNAL_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SIGNAL_GROUP, GSignalGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SIGNAL_GROUP, GSignalGroup);
}
pub inline fn G_IS_SIGNAL_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SIGNAL_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SIGNAL_GROUP);
}
pub const G_TYPE_SIGNAL_GROUP = g_signal_group_get_type();
pub const __G_SOURCECLOSURE_H__ = "";
pub const __G_TYPE_MODULE_H__ = "";
pub const G_TYPE_TYPE_MODULE = g_type_module_get_type();
pub inline fn G_TYPE_MODULE(module: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(module, G_TYPE_TYPE_MODULE, GTypeModule)) {
    return G_TYPE_CHECK_INSTANCE_CAST(module, G_TYPE_TYPE_MODULE, GTypeModule);
}
pub inline fn G_TYPE_MODULE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TYPE_MODULE, GTypeModuleClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TYPE_MODULE, GTypeModuleClass);
}
pub inline fn G_IS_TYPE_MODULE(module: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(module, G_TYPE_TYPE_MODULE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(module, G_TYPE_TYPE_MODULE);
}
pub inline fn G_IS_TYPE_MODULE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TYPE_MODULE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TYPE_MODULE);
}
pub inline fn G_TYPE_MODULE_GET_CLASS(module: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(module, G_TYPE_TYPE_MODULE, GTypeModuleClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(module, G_TYPE_TYPE_MODULE, GTypeModuleClass);
}
pub const __G_TYPE_PLUGIN_H__ = "";
pub const G_TYPE_TYPE_PLUGIN = g_type_plugin_get_type();
pub inline fn G_TYPE_PLUGIN(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TYPE_PLUGIN, GTypePlugin)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TYPE_PLUGIN, GTypePlugin);
}
pub inline fn G_TYPE_PLUGIN_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(vtable, G_TYPE_TYPE_PLUGIN, GTypePluginClass)) {
    return G_TYPE_CHECK_CLASS_CAST(vtable, G_TYPE_TYPE_PLUGIN, GTypePluginClass);
}
pub inline fn G_IS_TYPE_PLUGIN(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TYPE_PLUGIN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TYPE_PLUGIN);
}
pub inline fn G_IS_TYPE_PLUGIN_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(vtable, G_TYPE_TYPE_PLUGIN)) {
    return G_TYPE_CHECK_CLASS_TYPE(vtable, G_TYPE_TYPE_PLUGIN);
}
pub inline fn G_TYPE_PLUGIN_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TYPE_PLUGIN, GTypePluginClass)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TYPE_PLUGIN, GTypePluginClass);
}
pub const __G_VALUE_ARRAY_H__ = "";
pub const G_TYPE_VALUE_ARRAY = (g_value_array_get_type() ++ GOBJECT_DEPRECATED_MACRO_IN_2_32_FOR)(G_TYPE_ARRAY);
pub const __G_VALUETYPES_H__ = "";
pub inline fn G_VALUE_HOLDS_CHAR(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_CHAR)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_CHAR);
}
pub inline fn G_VALUE_HOLDS_UCHAR(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UCHAR)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UCHAR);
}
pub inline fn G_VALUE_HOLDS_BOOLEAN(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOOLEAN)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_BOOLEAN);
}
pub inline fn G_VALUE_HOLDS_INT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT);
}
pub inline fn G_VALUE_HOLDS_UINT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT);
}
pub inline fn G_VALUE_HOLDS_LONG(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_LONG)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_LONG);
}
pub inline fn G_VALUE_HOLDS_ULONG(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ULONG)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_ULONG);
}
pub inline fn G_VALUE_HOLDS_INT64(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT64)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_INT64);
}
pub inline fn G_VALUE_HOLDS_UINT64(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT64)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_UINT64);
}
pub inline fn G_VALUE_HOLDS_FLOAT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLOAT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_FLOAT);
}
pub inline fn G_VALUE_HOLDS_DOUBLE(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_DOUBLE)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_DOUBLE);
}
pub inline fn G_VALUE_HOLDS_STRING(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_STRING)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_STRING);
}
pub inline fn G_VALUE_IS_INTERNED_STRING(value: anytype) @TypeOf((G_VALUE_HOLDS_STRING(value) != 0) and ((value.*.data[@as(usize, @intCast(@as(c_int, 1)))].v_uint & G_VALUE_INTERNED_STRING) != 0) ++ GOBJECT_AVAILABLE_MACRO_IN_2_66) {
    return (G_VALUE_HOLDS_STRING(value) != 0) and ((value.*.data[@as(usize, @intCast(@as(c_int, 1)))].v_uint & G_VALUE_INTERNED_STRING) != 0) ++ GOBJECT_AVAILABLE_MACRO_IN_2_66;
}
pub inline fn G_VALUE_HOLDS_POINTER(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_POINTER)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_POINTER);
}
pub const G_TYPE_GTYPE = g_gtype_get_type();
pub inline fn G_VALUE_HOLDS_GTYPE(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_GTYPE)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_GTYPE);
}
pub inline fn G_VALUE_HOLDS_VARIANT(value: anytype) @TypeOf(G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_VARIANT)) {
    return G_TYPE_CHECK_VALUE_TYPE(value, G_TYPE_VARIANT);
}
pub const GTK_TYPE_CSS_PARSER_ERROR = gtk_css_parser_error_get_type();
pub const GTK_TYPE_CSS_PARSER_WARNING = gtk_css_parser_warning_get_type();
pub const GTK_CSS_PARSER_ERROR = gtk_css_parser_error_quark();
pub const GTK_CSS_PARSER_WARNING = gtk_css_parser_warning_quark();
pub const __G_IO_H__ = "";
pub const __GIO_GIO_H_INSIDE__ = "";
pub const __GIO_TYPES_H__ = "";
pub const __GIO_ENUMS_H__ = "";
pub const _GIO_IMPORT = "";
pub const _GIO_API = _GIO_IMPORT;
pub const GIO_VAR = _GIO_EXTERN;
pub const GIO_AVAILABLE_IN_ALL = _GIO_EXTERN;
pub const GIO_DEPRECATED = G_DEPRECATED ++ _GIO_EXTERN;
pub inline fn GIO_UNAVAILABLE_STATIC_INLINE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GIO_DEPRECATED_IN_2_26 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_26_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_26 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_26 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_26 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_26 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_26 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_26 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_26 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_26 = "";
pub const GIO_DEPRECATED_IN_2_28 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_28_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_28 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_28 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_28 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_28 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_28 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_28 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_28 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_28 = "";
pub const GIO_DEPRECATED_IN_2_30 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_30_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_30 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_30 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_30 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_30 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_30 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_30 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_30 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_30 = "";
pub const GIO_DEPRECATED_IN_2_32 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_32_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_32 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_32 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_32 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_32 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_32 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_32 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_32 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_32 = "";
pub const GIO_DEPRECATED_IN_2_34 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_34_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_34 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_34 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_34 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_34 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_34 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_34 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_34 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_34 = "";
pub const GIO_DEPRECATED_IN_2_36 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_36_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_36 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_36 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_36 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_36 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_36 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_36 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_36 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_36 = "";
pub const GIO_DEPRECATED_IN_2_38 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_38_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_38 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_38 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_38 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_38 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_38 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_38 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_38 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_38 = "";
pub const GIO_DEPRECATED_IN_2_40 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_40_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_40 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_40 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_40 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_40 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_40 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_40 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_40 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_40 = "";
pub const GIO_DEPRECATED_IN_2_42 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_42_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_42 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_42 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_42 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_42 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_42 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_42 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_42 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_42 = "";
pub const GIO_DEPRECATED_IN_2_44 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_44_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_44 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_44 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_44 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_44 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_44 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_44 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_44 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_44 = "";
pub const GIO_DEPRECATED_IN_2_46 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_46_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_46 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_46 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_46 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_46 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_46 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_46 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_46 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_46 = "";
pub const GIO_DEPRECATED_IN_2_48 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_48_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_48 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_48 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_48 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_48 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_48 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_48 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_48 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_48 = "";
pub const GIO_DEPRECATED_IN_2_50 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_50_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_50 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_50 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_50 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_50 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_50 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_50 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_50 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_50 = "";
pub const GIO_DEPRECATED_IN_2_52 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_52_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_52 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_52 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_52 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_52 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_52 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_52 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_52 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_52 = "";
pub const GIO_DEPRECATED_IN_2_54 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_54_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_54 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_54 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_54 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_54 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_54 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_54 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_54 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_54 = "";
pub const GIO_DEPRECATED_IN_2_56 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_56_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_56 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_56 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_56 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_56 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_56 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_56 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_56 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_56 = "";
pub const GIO_DEPRECATED_IN_2_58 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_58_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_58 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_58 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_58 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_58 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_58 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_58 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_58 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_58 = "";
pub const GIO_DEPRECATED_IN_2_60 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_60_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_60 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_60 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_60 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_60 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_60 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_60 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_60 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_60 = "";
pub const GIO_DEPRECATED_IN_2_62 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_62_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_62 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_62 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_62 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_62 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_62 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_62 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_62 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_62 = "";
pub const GIO_DEPRECATED_IN_2_64 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_64_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_64 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_64 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_64 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_64 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_64 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_64 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_64 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_64 = "";
pub const GIO_DEPRECATED_IN_2_66 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_66_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_66 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_66 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_66 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_66 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_66 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_66 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_66 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_66 = "";
pub const GIO_DEPRECATED_IN_2_68 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_68_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_68 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_68 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_68 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_68 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_68 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_68 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_68 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_68 = "";
pub const GIO_DEPRECATED_IN_2_70 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_70_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_70 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_70 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_70 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_70 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_70 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_70 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_70 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_70 = "";
pub const GIO_DEPRECATED_IN_2_72 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_72_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_72 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_72 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_72 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_72 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_72 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_72 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_72 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_72 = "";
pub const GIO_DEPRECATED_IN_2_74 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_74_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_74 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_74 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_74 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_74 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_74 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_74 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_74 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_74 = "";
pub const GIO_DEPRECATED_IN_2_76 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_76_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_76 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_76 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_76 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_76 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_76 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_76 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_76 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_76 = "";
pub const GIO_DEPRECATED_IN_2_78 = GIO_DEPRECATED;
pub inline fn GIO_DEPRECATED_IN_2_78_FOR(f: anytype) @TypeOf(GIO_DEPRECATED_FOR(f)) {
    return GIO_DEPRECATED_FOR(f);
}
pub const GIO_DEPRECATED_MACRO_IN_2_78 = GLIB_DEPRECATED_MACRO;
pub inline fn GIO_DEPRECATED_MACRO_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GIO_DEPRECATED_ENUMERATOR_IN_2_78 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GIO_DEPRECATED_ENUMERATOR_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GIO_DEPRECATED_TYPE_IN_2_78 = GLIB_DEPRECATED_TYPE;
pub inline fn GIO_DEPRECATED_TYPE_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GIO_AVAILABLE_IN_2_78 = _GIO_EXTERN;
pub const GIO_AVAILABLE_STATIC_INLINE_IN_2_78 = "";
pub const GIO_AVAILABLE_MACRO_IN_2_78 = "";
pub const GIO_AVAILABLE_ENUMERATOR_IN_2_78 = "";
pub const GIO_AVAILABLE_TYPE_IN_2_78 = "";
pub const __G_ACTION_H__ = "";
pub const G_TYPE_ACTION = g_action_get_type();
pub inline fn G_ACTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_ACTION, GAction)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_ACTION, GAction);
}
pub inline fn G_IS_ACTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_ACTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_ACTION);
}
pub inline fn G_ACTION_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_ACTION, GActionInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_ACTION, GActionInterface);
}
pub const __G_ACTION_GROUP_H__ = "";
pub const G_TYPE_ACTION_GROUP = g_action_group_get_type();
pub inline fn G_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_ACTION_GROUP, GActionGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_ACTION_GROUP, GActionGroup);
}
pub inline fn G_IS_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_ACTION_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_ACTION_GROUP);
}
pub inline fn G_ACTION_GROUP_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_ACTION_GROUP, GActionGroupInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_ACTION_GROUP, GActionGroupInterface);
}
pub const __G_ACTION_GROUP_EXPORTER_H__ = "";
pub const __G_ACTION_MAP_H__ = "";
pub const G_TYPE_ACTION_MAP = g_action_map_get_type();
pub inline fn G_ACTION_MAP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_ACTION_MAP, GActionMap)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_ACTION_MAP, GActionMap);
}
pub inline fn G_IS_ACTION_MAP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_ACTION_MAP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_ACTION_MAP);
}
pub inline fn G_ACTION_MAP_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_ACTION_MAP, GActionMapInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_ACTION_MAP, GActionMapInterface);
}
pub const __G_APP_INFO_H__ = "";
pub const G_TYPE_APP_INFO = g_app_info_get_type();
pub inline fn G_APP_INFO(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_APP_INFO, GAppInfo)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_APP_INFO, GAppInfo);
}
pub inline fn G_IS_APP_INFO(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_APP_INFO)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_APP_INFO);
}
pub inline fn G_APP_INFO_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_APP_INFO, GAppInfoIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_APP_INFO, GAppInfoIface);
}
pub const G_TYPE_APP_LAUNCH_CONTEXT = g_app_launch_context_get_type();
pub inline fn G_APP_LAUNCH_CONTEXT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContext);
}
pub inline fn G_APP_LAUNCH_CONTEXT_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass);
}
pub inline fn G_IS_APP_LAUNCH_CONTEXT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_APP_LAUNCH_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_APP_LAUNCH_CONTEXT);
}
pub inline fn G_IS_APP_LAUNCH_CONTEXT_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_APP_LAUNCH_CONTEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_APP_LAUNCH_CONTEXT);
}
pub inline fn G_APP_LAUNCH_CONTEXT_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_APP_LAUNCH_CONTEXT, GAppLaunchContextClass);
}
pub const G_TYPE_APP_INFO_MONITOR = g_app_info_monitor_get_type();
pub inline fn G_APP_INFO_MONITOR(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_APP_INFO_MONITOR, GAppInfoMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_APP_INFO_MONITOR, GAppInfoMonitor);
}
pub inline fn G_IS_APP_INFO_MONITOR(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_APP_INFO_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_APP_INFO_MONITOR);
}
pub const __G_APPLICATION_H__ = "";
pub const G_TYPE_APPLICATION = g_application_get_type();
pub inline fn G_APPLICATION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_APPLICATION, GApplication)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_APPLICATION, GApplication);
}
pub inline fn G_APPLICATION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_APPLICATION, GApplicationClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_APPLICATION, GApplicationClass);
}
pub inline fn G_IS_APPLICATION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_APPLICATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_APPLICATION);
}
pub inline fn G_IS_APPLICATION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_APPLICATION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_APPLICATION);
}
pub inline fn G_APPLICATION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_APPLICATION, GApplicationClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_APPLICATION, GApplicationClass);
}
pub const __G_APPLICATION_COMMAND_LINE_H__ = "";
pub const G_TYPE_APPLICATION_COMMAND_LINE = g_application_command_line_get_type();
pub inline fn G_APPLICATION_COMMAND_LINE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLine)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLine);
}
pub inline fn G_APPLICATION_COMMAND_LINE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLineClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLineClass);
}
pub inline fn G_IS_APPLICATION_COMMAND_LINE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_APPLICATION_COMMAND_LINE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_APPLICATION_COMMAND_LINE);
}
pub inline fn G_IS_APPLICATION_COMMAND_LINE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_APPLICATION_COMMAND_LINE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_APPLICATION_COMMAND_LINE);
}
pub inline fn G_APPLICATION_COMMAND_LINE_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLineClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_APPLICATION_COMMAND_LINE, GApplicationCommandLineClass);
}
pub const __G_ASYNC_INITABLE_H__ = "";
pub const __G_INITABLE_H__ = "";
pub const G_TYPE_INITABLE = g_initable_get_type();
pub inline fn G_INITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_INITABLE, GInitable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_INITABLE, GInitable);
}
pub inline fn G_IS_INITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_INITABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_INITABLE);
}
pub inline fn G_INITABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_INITABLE, GInitableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_INITABLE, GInitableIface);
}
pub inline fn G_TYPE_IS_INITABLE(@"type": anytype) @TypeOf(g_type_is_a(@"type", G_TYPE_INITABLE)) {
    return g_type_is_a(@"type", G_TYPE_INITABLE);
}
pub const G_TYPE_ASYNC_INITABLE = g_async_initable_get_type();
pub inline fn G_ASYNC_INITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_ASYNC_INITABLE, GAsyncInitable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_ASYNC_INITABLE, GAsyncInitable);
}
pub inline fn G_IS_ASYNC_INITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_ASYNC_INITABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_ASYNC_INITABLE);
}
pub inline fn G_ASYNC_INITABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_ASYNC_INITABLE, GAsyncInitableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_ASYNC_INITABLE, GAsyncInitableIface);
}
pub inline fn G_TYPE_IS_ASYNC_INITABLE(@"type": anytype) @TypeOf(g_type_is_a(@"type", G_TYPE_ASYNC_INITABLE)) {
    return g_type_is_a(@"type", G_TYPE_ASYNC_INITABLE);
}
pub const __G_ASYNC_RESULT_H__ = "";
pub const G_TYPE_ASYNC_RESULT = g_async_result_get_type();
pub inline fn G_ASYNC_RESULT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_ASYNC_RESULT, GAsyncResult)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_ASYNC_RESULT, GAsyncResult);
}
pub inline fn G_IS_ASYNC_RESULT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_ASYNC_RESULT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_ASYNC_RESULT);
}
pub inline fn G_ASYNC_RESULT_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_ASYNC_RESULT, GAsyncResultIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_ASYNC_RESULT, GAsyncResultIface);
}
pub const __G_BUFFERED_INPUT_STREAM_H__ = "";
pub const __G_FILTER_INPUT_STREAM_H__ = "";
pub const __G_INPUT_STREAM_H__ = "";
pub const G_TYPE_INPUT_STREAM = g_input_stream_get_type();
pub inline fn G_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INPUT_STREAM, GInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INPUT_STREAM, GInputStream);
}
pub inline fn G_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INPUT_STREAM, GInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INPUT_STREAM, GInputStreamClass);
}
pub inline fn G_IS_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INPUT_STREAM);
}
pub inline fn G_IS_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INPUT_STREAM);
}
pub inline fn G_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INPUT_STREAM, GInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INPUT_STREAM, GInputStreamClass);
}
pub const G_TYPE_FILTER_INPUT_STREAM = g_filter_input_stream_get_type();
pub inline fn G_FILTER_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILTER_INPUT_STREAM, GFilterInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILTER_INPUT_STREAM, GFilterInputStream);
}
pub inline fn G_FILTER_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass);
}
pub inline fn G_IS_FILTER_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILTER_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILTER_INPUT_STREAM);
}
pub inline fn G_IS_FILTER_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILTER_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILTER_INPUT_STREAM);
}
pub inline fn G_FILTER_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILTER_INPUT_STREAM, GFilterInputStreamClass);
}
pub const G_TYPE_BUFFERED_INPUT_STREAM = g_buffered_input_stream_get_type();
pub inline fn G_BUFFERED_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStream);
}
pub inline fn G_BUFFERED_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass);
}
pub inline fn G_IS_BUFFERED_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_BUFFERED_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_BUFFERED_INPUT_STREAM);
}
pub inline fn G_IS_BUFFERED_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_BUFFERED_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_BUFFERED_INPUT_STREAM);
}
pub inline fn G_BUFFERED_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_BUFFERED_INPUT_STREAM, GBufferedInputStreamClass);
}
pub const __G_BUFFERED_OUTPUT_STREAM_H__ = "";
pub const __G_FILTER_OUTPUT_STREAM_H__ = "";
pub const __G_OUTPUT_STREAM_H__ = "";
pub const G_TYPE_OUTPUT_STREAM = g_output_stream_get_type();
pub inline fn G_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_OUTPUT_STREAM, GOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_OUTPUT_STREAM, GOutputStream);
}
pub inline fn G_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_OUTPUT_STREAM, GOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_OUTPUT_STREAM, GOutputStreamClass);
}
pub inline fn G_IS_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_OUTPUT_STREAM);
}
pub inline fn G_IS_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_OUTPUT_STREAM);
}
pub inline fn G_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_OUTPUT_STREAM, GOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_OUTPUT_STREAM, GOutputStreamClass);
}
pub const G_TYPE_FILTER_OUTPUT_STREAM = g_filter_output_stream_get_type();
pub inline fn G_FILTER_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStream);
}
pub inline fn G_FILTER_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass);
}
pub inline fn G_IS_FILTER_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILTER_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILTER_OUTPUT_STREAM);
}
pub inline fn G_IS_FILTER_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILTER_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILTER_OUTPUT_STREAM);
}
pub inline fn G_FILTER_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILTER_OUTPUT_STREAM, GFilterOutputStreamClass);
}
pub const G_TYPE_BUFFERED_OUTPUT_STREAM = g_buffered_output_stream_get_type();
pub inline fn G_BUFFERED_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStream);
}
pub inline fn G_BUFFERED_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass);
}
pub inline fn G_IS_BUFFERED_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_BUFFERED_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_BUFFERED_OUTPUT_STREAM);
}
pub inline fn G_IS_BUFFERED_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_BUFFERED_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_BUFFERED_OUTPUT_STREAM);
}
pub inline fn G_BUFFERED_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_BUFFERED_OUTPUT_STREAM, GBufferedOutputStreamClass);
}
pub const __G_BYTES_ICON_H__ = "";
pub const G_TYPE_BYTES_ICON = g_bytes_icon_get_type();
pub inline fn G_BYTES_ICON(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_BYTES_ICON, GBytesIcon)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_BYTES_ICON, GBytesIcon);
}
pub inline fn G_IS_BYTES_ICON(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_BYTES_ICON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_BYTES_ICON);
}
pub const __G_CANCELLABLE_H__ = "";
pub const G_TYPE_CANCELLABLE = g_cancellable_get_type();
pub inline fn G_CANCELLABLE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CANCELLABLE, GCancellable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CANCELLABLE, GCancellable);
}
pub inline fn G_CANCELLABLE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CANCELLABLE, GCancellableClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CANCELLABLE, GCancellableClass);
}
pub inline fn G_IS_CANCELLABLE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CANCELLABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CANCELLABLE);
}
pub inline fn G_IS_CANCELLABLE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CANCELLABLE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CANCELLABLE);
}
pub inline fn G_CANCELLABLE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CANCELLABLE, GCancellableClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CANCELLABLE, GCancellableClass);
}
pub const __G_CHARSET_CONVERTER_H__ = "";
pub const __G_CONVERTER_H__ = "";
pub const G_TYPE_CONVERTER = g_converter_get_type();
pub inline fn G_CONVERTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_CONVERTER, GConverter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_CONVERTER, GConverter);
}
pub inline fn G_IS_CONVERTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_CONVERTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_CONVERTER);
}
pub inline fn G_CONVERTER_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_CONVERTER, GConverterIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_CONVERTER, GConverterIface);
}
pub const G_TYPE_CHARSET_CONVERTER = g_charset_converter_get_type();
pub inline fn G_CHARSET_CONVERTER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CHARSET_CONVERTER, GCharsetConverter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CHARSET_CONVERTER, GCharsetConverter);
}
pub inline fn G_CHARSET_CONVERTER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass);
}
pub inline fn G_IS_CHARSET_CONVERTER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CHARSET_CONVERTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CHARSET_CONVERTER);
}
pub inline fn G_IS_CHARSET_CONVERTER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CHARSET_CONVERTER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CHARSET_CONVERTER);
}
pub inline fn G_CHARSET_CONVERTER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CHARSET_CONVERTER, GCharsetConverterClass);
}
pub const __G_CONTENT_TYPE_H__ = "";
pub const __G_CONVERTER_INPUT_STREAM_H__ = "";
pub const G_TYPE_CONVERTER_INPUT_STREAM = g_converter_input_stream_get_type();
pub inline fn G_CONVERTER_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStream);
}
pub inline fn G_CONVERTER_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass);
}
pub inline fn G_IS_CONVERTER_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CONVERTER_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CONVERTER_INPUT_STREAM);
}
pub inline fn G_IS_CONVERTER_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CONVERTER_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CONVERTER_INPUT_STREAM);
}
pub inline fn G_CONVERTER_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CONVERTER_INPUT_STREAM, GConverterInputStreamClass);
}
pub const __G_CONVERTER_OUTPUT_STREAM_H__ = "";
pub const G_TYPE_CONVERTER_OUTPUT_STREAM = g_converter_output_stream_get_type();
pub inline fn G_CONVERTER_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStream);
}
pub inline fn G_CONVERTER_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass);
}
pub inline fn G_IS_CONVERTER_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CONVERTER_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CONVERTER_OUTPUT_STREAM);
}
pub inline fn G_IS_CONVERTER_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CONVERTER_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CONVERTER_OUTPUT_STREAM);
}
pub inline fn G_CONVERTER_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CONVERTER_OUTPUT_STREAM, GConverterOutputStreamClass);
}
pub const __G_CREDENTIALS_H__ = "";
pub const _UNISTD_H = @as(c_int, 1);
pub const _POSIX_VERSION = @as(c_long, 200809);
pub const __POSIX2_THIS_VERSION = @as(c_long, 200809);
pub const _POSIX2_VERSION = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_VERSION = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_BIND = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_DEV = __POSIX2_THIS_VERSION;
pub const _POSIX2_SW_DEV = __POSIX2_THIS_VERSION;
pub const _POSIX2_LOCALEDEF = __POSIX2_THIS_VERSION;
pub const _XOPEN_VERSION = @as(c_int, 700);
pub const _XOPEN_XCU_VERSION = @as(c_int, 4);
pub const _XOPEN_XPG2 = @as(c_int, 1);
pub const _XOPEN_XPG3 = @as(c_int, 1);
pub const _XOPEN_XPG4 = @as(c_int, 1);
pub const _XOPEN_UNIX = @as(c_int, 1);
pub const _XOPEN_ENH_I18N = @as(c_int, 1);
pub const _XOPEN_LEGACY = @as(c_int, 1);
pub const _BITS_POSIX_OPT_H = @as(c_int, 1);
pub const _POSIX_JOB_CONTROL = @as(c_int, 1);
pub const _POSIX_SAVED_IDS = @as(c_int, 1);
pub const _POSIX_PRIORITY_SCHEDULING = @as(c_long, 200809);
pub const _POSIX_SYNCHRONIZED_IO = @as(c_long, 200809);
pub const _POSIX_FSYNC = @as(c_long, 200809);
pub const _POSIX_MAPPED_FILES = @as(c_long, 200809);
pub const _POSIX_MEMLOCK = @as(c_long, 200809);
pub const _POSIX_MEMLOCK_RANGE = @as(c_long, 200809);
pub const _POSIX_MEMORY_PROTECTION = @as(c_long, 200809);
pub const _POSIX_CHOWN_RESTRICTED = @as(c_int, 0);
pub const _POSIX_VDISABLE = '\x00';
pub const _POSIX_NO_TRUNC = @as(c_int, 1);
pub const _XOPEN_REALTIME = @as(c_int, 1);
pub const _XOPEN_REALTIME_THREADS = @as(c_int, 1);
pub const _XOPEN_SHM = @as(c_int, 1);
pub const _POSIX_THREADS = @as(c_long, 200809);
pub const _POSIX_REENTRANT_FUNCTIONS = @as(c_int, 1);
pub const _POSIX_THREAD_SAFE_FUNCTIONS = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIORITY_SCHEDULING = @as(c_long, 200809);
pub const _POSIX_THREAD_ATTR_STACKSIZE = @as(c_long, 200809);
pub const _POSIX_THREAD_ATTR_STACKADDR = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIO_INHERIT = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIO_PROTECT = @as(c_long, 200809);
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT = @as(c_long, 200809);
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT = -@as(c_int, 1);
pub const _POSIX_SEMAPHORES = @as(c_long, 200809);
pub const _POSIX_REALTIME_SIGNALS = @as(c_long, 200809);
pub const _POSIX_ASYNCHRONOUS_IO = @as(c_long, 200809);
pub const _POSIX_ASYNC_IO = @as(c_int, 1);
pub const _LFS_ASYNCHRONOUS_IO = @as(c_int, 1);
pub const _POSIX_PRIORITIZED_IO = @as(c_long, 200809);
pub const _LFS64_ASYNCHRONOUS_IO = @as(c_int, 1);
pub const _LFS_LARGEFILE = @as(c_int, 1);
pub const _LFS64_LARGEFILE = @as(c_int, 1);
pub const _LFS64_STDIO = @as(c_int, 1);
pub const _POSIX_SHARED_MEMORY_OBJECTS = @as(c_long, 200809);
pub const _POSIX_CPUTIME = @as(c_int, 0);
pub const _POSIX_THREAD_CPUTIME = @as(c_int, 0);
pub const _POSIX_REGEXP = @as(c_int, 1);
pub const _POSIX_READER_WRITER_LOCKS = @as(c_long, 200809);
pub const _POSIX_SHELL = @as(c_int, 1);
pub const _POSIX_TIMEOUTS = @as(c_long, 200809);
pub const _POSIX_SPIN_LOCKS = @as(c_long, 200809);
pub const _POSIX_SPAWN = @as(c_long, 200809);
pub const _POSIX_TIMERS = @as(c_long, 200809);
pub const _POSIX_BARRIERS = @as(c_long, 200809);
pub const _POSIX_MESSAGE_PASSING = @as(c_long, 200809);
pub const _POSIX_THREAD_PROCESS_SHARED = @as(c_long, 200809);
pub const _POSIX_MONOTONIC_CLOCK = @as(c_int, 0);
pub const _POSIX_CLOCK_SELECTION = @as(c_long, 200809);
pub const _POSIX_ADVISORY_INFO = @as(c_long, 200809);
pub const _POSIX_IPV6 = @as(c_long, 200809);
pub const _POSIX_RAW_SOCKETS = @as(c_long, 200809);
pub const _POSIX2_CHAR_TERM = @as(c_long, 200809);
pub const _POSIX_SPORADIC_SERVER = -@as(c_int, 1);
pub const _POSIX_THREAD_SPORADIC_SERVER = -@as(c_int, 1);
pub const _POSIX_TRACE = -@as(c_int, 1);
pub const _POSIX_TRACE_EVENT_FILTER = -@as(c_int, 1);
pub const _POSIX_TRACE_INHERIT = -@as(c_int, 1);
pub const _POSIX_TRACE_LOG = -@as(c_int, 1);
pub const _POSIX_TYPED_MEMORY_OBJECTS = -@as(c_int, 1);
pub const _POSIX_V7_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _POSIX_V6_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _XBS5_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _POSIX_V7_LP64_OFF64 = @as(c_int, 1);
pub const _POSIX_V6_LP64_OFF64 = @as(c_int, 1);
pub const _XBS5_LP64_OFF64 = @as(c_int, 1);
pub const __ILP32_OFF32_CFLAGS = "-m32";
pub const __ILP32_OFF32_LDFLAGS = "-m32";
pub const __ILP32_OFFBIG_CFLAGS = "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64";
pub const __ILP32_OFFBIG_LDFLAGS = "-m32";
pub const __LP64_OFF64_CFLAGS = "-m64";
pub const __LP64_OFF64_LDFLAGS = "-m64";
pub const STDIN_FILENO = @as(c_int, 0);
pub const STDOUT_FILENO = @as(c_int, 1);
pub const STDERR_FILENO = @as(c_int, 2);
pub const __useconds_t_defined = "";
pub const __intptr_t_defined = "";
pub const __socklen_t_defined = "";
pub const R_OK = @as(c_int, 4);
pub const W_OK = @as(c_int, 2);
pub const X_OK = @as(c_int, 1);
pub const F_OK = @as(c_int, 0);
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const L_SET = SEEK_SET;
pub const L_INCR = SEEK_CUR;
pub const L_XTND = SEEK_END;
pub const _SC_PAGE_SIZE = _SC_PAGESIZE;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = _CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = _CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = _CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _GETOPT_POSIX_H = @as(c_int, 1);
pub const _GETOPT_CORE_H = @as(c_int, 1);
pub const F_ULOCK = @as(c_int, 0);
pub const F_LOCK = @as(c_int, 1);
pub const F_TLOCK = @as(c_int, 2);
pub const F_TEST = @as(c_int, 3);
pub const G_TYPE_CREDENTIALS = g_credentials_get_type();
pub inline fn G_CREDENTIALS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CREDENTIALS, GCredentials)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_CREDENTIALS, GCredentials);
}
pub inline fn G_CREDENTIALS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CREDENTIALS, GCredentialsClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_CREDENTIALS, GCredentialsClass);
}
pub inline fn G_CREDENTIALS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CREDENTIALS, GCredentialsClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_CREDENTIALS, GCredentialsClass);
}
pub inline fn G_IS_CREDENTIALS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CREDENTIALS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_CREDENTIALS);
}
pub inline fn G_IS_CREDENTIALS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CREDENTIALS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_CREDENTIALS);
}
pub const __G_DATAGRAM_BASED_H__ = "";
pub const G_TYPE_DATAGRAM_BASED = g_datagram_based_get_type();
pub inline fn G_DATAGRAM_BASED(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DATAGRAM_BASED, GDatagramBased)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DATAGRAM_BASED, GDatagramBased);
}
pub inline fn G_IS_DATAGRAM_BASED(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DATAGRAM_BASED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DATAGRAM_BASED);
}
pub inline fn G_DATAGRAM_BASED_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DATAGRAM_BASED, GDatagramBasedInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DATAGRAM_BASED, GDatagramBasedInterface);
}
pub inline fn G_TYPE_IS_DATAGRAM_BASED(@"type": anytype) @TypeOf(g_type_is_a(@"type", G_TYPE_DATAGRAM_BASED)) {
    return g_type_is_a(@"type", G_TYPE_DATAGRAM_BASED);
}
pub const __G_DATA_INPUT_STREAM_H__ = "";
pub const G_TYPE_DATA_INPUT_STREAM = g_data_input_stream_get_type();
pub inline fn G_DATA_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DATA_INPUT_STREAM, GDataInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DATA_INPUT_STREAM, GDataInputStream);
}
pub inline fn G_DATA_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass);
}
pub inline fn G_IS_DATA_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DATA_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DATA_INPUT_STREAM);
}
pub inline fn G_IS_DATA_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DATA_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DATA_INPUT_STREAM);
}
pub inline fn G_DATA_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DATA_INPUT_STREAM, GDataInputStreamClass);
}
pub const __G_DATA_OUTPUT_STREAM_H__ = "";
pub const G_TYPE_DATA_OUTPUT_STREAM = g_data_output_stream_get_type();
pub inline fn G_DATA_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStream);
}
pub inline fn G_DATA_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass);
}
pub inline fn G_IS_DATA_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DATA_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DATA_OUTPUT_STREAM);
}
pub inline fn G_IS_DATA_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DATA_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DATA_OUTPUT_STREAM);
}
pub inline fn G_DATA_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DATA_OUTPUT_STREAM, GDataOutputStreamClass);
}
pub const __G_DBUS_ACTION_GROUP_H__ = "";
pub const G_TYPE_DBUS_ACTION_GROUP = g_dbus_action_group_get_type();
pub inline fn G_DBUS_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DBUS_ACTION_GROUP, GDBusActionGroup);
}
pub inline fn G_IS_DBUS_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DBUS_ACTION_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DBUS_ACTION_GROUP);
}
pub inline fn G_IS_DBUS_ACTION_GROUP_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_DBUS_ACTION_GROUP)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_DBUS_ACTION_GROUP);
}
pub const __G_DBUS_ADDRESS_H__ = "";
pub const __G_DBUS_AUTH_OBSERVER_H__ = "";
pub const G_TYPE_DBUS_AUTH_OBSERVER = g_dbus_auth_observer_get_type();
pub inline fn G_DBUS_AUTH_OBSERVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_AUTH_OBSERVER, GDBusAuthObserver)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_AUTH_OBSERVER, GDBusAuthObserver);
}
pub inline fn G_IS_DBUS_AUTH_OBSERVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_AUTH_OBSERVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_AUTH_OBSERVER);
}
pub const __G_DBUS_CONNECTION_H__ = "";
pub const G_TYPE_DBUS_CONNECTION = g_dbus_connection_get_type();
pub inline fn G_DBUS_CONNECTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_CONNECTION, GDBusConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_CONNECTION, GDBusConnection);
}
pub inline fn G_IS_DBUS_CONNECTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_CONNECTION);
}
pub const __G_DBUS_ERROR_H__ = "";
pub const G_DBUS_ERROR = g_dbus_error_quark();
pub const __G_DBUS_INTERFACE_H__ = "";
pub const G_TYPE_DBUS_INTERFACE = g_dbus_interface_get_type();
pub inline fn G_DBUS_INTERFACE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_INTERFACE, GDBusInterface)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_INTERFACE, GDBusInterface);
}
pub inline fn G_IS_DBUS_INTERFACE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_INTERFACE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_INTERFACE);
}
pub inline fn G_DBUS_INTERFACE_GET_IFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DBUS_INTERFACE, GDBusInterfaceIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DBUS_INTERFACE, GDBusInterfaceIface);
}
pub const __G_DBUS_INTERFACE_SKELETON_H__ = "";
pub const G_TYPE_DBUS_INTERFACE_SKELETON = g_dbus_interface_skeleton_get_type();
pub inline fn G_DBUS_INTERFACE_SKELETON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeleton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeleton);
}
pub inline fn G_DBUS_INTERFACE_SKELETON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass);
}
pub inline fn G_DBUS_INTERFACE_SKELETON_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_INTERFACE_SKELETON, GDBusInterfaceSkeletonClass);
}
pub inline fn G_IS_DBUS_INTERFACE_SKELETON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_INTERFACE_SKELETON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_INTERFACE_SKELETON);
}
pub inline fn G_IS_DBUS_INTERFACE_SKELETON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_INTERFACE_SKELETON)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_INTERFACE_SKELETON);
}
pub const __G_DBUS_INTROSPECTION_H__ = "";
pub const G_TYPE_DBUS_NODE_INFO = g_dbus_node_info_get_type();
pub const G_TYPE_DBUS_INTERFACE_INFO = g_dbus_interface_info_get_type();
pub const G_TYPE_DBUS_METHOD_INFO = g_dbus_method_info_get_type();
pub const G_TYPE_DBUS_SIGNAL_INFO = g_dbus_signal_info_get_type();
pub const G_TYPE_DBUS_PROPERTY_INFO = g_dbus_property_info_get_type();
pub const G_TYPE_DBUS_ARG_INFO = g_dbus_arg_info_get_type();
pub const G_TYPE_DBUS_ANNOTATION_INFO = g_dbus_annotation_info_get_type();
pub const __G_DBUS_MENU_MODEL_H__ = "";
pub const G_TYPE_DBUS_MENU_MODEL = g_dbus_menu_model_get_type();
pub inline fn G_DBUS_MENU_MODEL(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DBUS_MENU_MODEL, GDBusMenuModel)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DBUS_MENU_MODEL, GDBusMenuModel);
}
pub inline fn G_IS_DBUS_MENU_MODEL(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DBUS_MENU_MODEL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DBUS_MENU_MODEL);
}
pub const __G_DBUS_MESSAGE_H__ = "";
pub const G_TYPE_DBUS_MESSAGE = g_dbus_message_get_type();
pub inline fn G_DBUS_MESSAGE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_MESSAGE, GDBusMessage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_MESSAGE, GDBusMessage);
}
pub inline fn G_IS_DBUS_MESSAGE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_MESSAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_MESSAGE);
}
pub const __G_DBUS_METHOD_INVOCATION_H__ = "";
pub const G_TYPE_DBUS_METHOD_INVOCATION = g_dbus_method_invocation_get_type();
pub inline fn G_DBUS_METHOD_INVOCATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_METHOD_INVOCATION, GDBusMethodInvocation)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_METHOD_INVOCATION, GDBusMethodInvocation);
}
pub inline fn G_IS_DBUS_METHOD_INVOCATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_METHOD_INVOCATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_METHOD_INVOCATION);
}
pub const G_DBUS_METHOD_INVOCATION_HANDLED = TRUE ++ GIO_AVAILABLE_MACRO_IN_2_68;
pub const G_DBUS_METHOD_INVOCATION_UNHANDLED = FALSE ++ GIO_AVAILABLE_MACRO_IN_2_68;
pub const __G_DBUS_NAME_OWNING_H__ = "";
pub const __G_DBUS_NAME_WATCHING_H__ = "";
pub const __G_DBUS_OBJECT_H__ = "";
pub const G_TYPE_DBUS_OBJECT = g_dbus_object_get_type();
pub inline fn G_DBUS_OBJECT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT, GDBusObject)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT, GDBusObject);
}
pub inline fn G_IS_DBUS_OBJECT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT);
}
pub inline fn G_DBUS_OBJECT_GET_IFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DBUS_OBJECT, GDBusObjectIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DBUS_OBJECT, GDBusObjectIface);
}
pub const __G_DBUS_OBJECT_MANAGER_H__ = "";
pub const G_TYPE_DBUS_OBJECT_MANAGER = g_dbus_object_manager_get_type();
pub inline fn G_DBUS_OBJECT_MANAGER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManager)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManager);
}
pub inline fn G_IS_DBUS_OBJECT_MANAGER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_MANAGER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_MANAGER);
}
pub inline fn G_DBUS_OBJECT_MANAGER_GET_IFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManagerIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DBUS_OBJECT_MANAGER, GDBusObjectManagerIface);
}
pub const __G_DBUS_OBJECT_MANAGER_CLIENT_H__ = "";
pub const G_TYPE_DBUS_OBJECT_MANAGER_CLIENT = g_dbus_object_manager_client_get_type();
pub inline fn G_DBUS_OBJECT_MANAGER_CLIENT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClient)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClient);
}
pub inline fn G_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass);
}
pub inline fn G_DBUS_OBJECT_MANAGER_CLIENT_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT, GDBusObjectManagerClientClass);
}
pub inline fn G_IS_DBUS_OBJECT_MANAGER_CLIENT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);
}
pub inline fn G_IS_DBUS_OBJECT_MANAGER_CLIENT_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);
}
pub const __G_DBUS_OBJECT_MANAGER_SERVER_H__ = "";
pub const G_TYPE_DBUS_OBJECT_MANAGER_SERVER = g_dbus_object_manager_server_get_type();
pub inline fn G_DBUS_OBJECT_MANAGER_SERVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServer);
}
pub inline fn G_DBUS_OBJECT_MANAGER_SERVER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass);
}
pub inline fn G_DBUS_OBJECT_MANAGER_SERVER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_MANAGER_SERVER, GDBusObjectManagerServerClass);
}
pub inline fn G_IS_DBUS_OBJECT_MANAGER_SERVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_MANAGER_SERVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_MANAGER_SERVER);
}
pub inline fn G_IS_DBUS_OBJECT_MANAGER_SERVER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_MANAGER_SERVER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_MANAGER_SERVER);
}
pub const __G_DBUS_OBJECT_PROXY_H__ = "";
pub const G_TYPE_DBUS_OBJECT_PROXY = g_dbus_object_proxy_get_type();
pub inline fn G_DBUS_OBJECT_PROXY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxy)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxy);
}
pub inline fn G_DBUS_OBJECT_PROXY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass);
}
pub inline fn G_DBUS_OBJECT_PROXY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_PROXY, GDBusObjectProxyClass);
}
pub inline fn G_IS_DBUS_OBJECT_PROXY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_PROXY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_PROXY);
}
pub inline fn G_IS_DBUS_OBJECT_PROXY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_PROXY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_PROXY);
}
pub const __G_DBUS_OBJECT_SKELETON_H__ = "";
pub const G_TYPE_DBUS_OBJECT_SKELETON = g_dbus_object_skeleton_get_type();
pub inline fn G_DBUS_OBJECT_SKELETON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeleton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeleton);
}
pub inline fn G_DBUS_OBJECT_SKELETON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass);
}
pub inline fn G_DBUS_OBJECT_SKELETON_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_OBJECT_SKELETON, GDBusObjectSkeletonClass);
}
pub inline fn G_IS_DBUS_OBJECT_SKELETON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_SKELETON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_OBJECT_SKELETON);
}
pub inline fn G_IS_DBUS_OBJECT_SKELETON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_SKELETON)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_OBJECT_SKELETON);
}
pub const __G_DBUS_PROXY_H__ = "";
pub const G_TYPE_DBUS_PROXY = g_dbus_proxy_get_type();
pub inline fn G_DBUS_PROXY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_PROXY, GDBusProxy)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_PROXY, GDBusProxy);
}
pub inline fn G_DBUS_PROXY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_PROXY, GDBusProxyClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_DBUS_PROXY, GDBusProxyClass);
}
pub inline fn G_DBUS_PROXY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_PROXY, GDBusProxyClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_DBUS_PROXY, GDBusProxyClass);
}
pub inline fn G_IS_DBUS_PROXY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_PROXY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_PROXY);
}
pub inline fn G_IS_DBUS_PROXY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_PROXY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_DBUS_PROXY);
}
pub const __G_DBUS_SERVER_H__ = "";
pub const G_TYPE_DBUS_SERVER = g_dbus_server_get_type();
pub inline fn G_DBUS_SERVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_SERVER, GDBusServer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DBUS_SERVER, GDBusServer);
}
pub inline fn G_IS_DBUS_SERVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_SERVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DBUS_SERVER);
}
pub const __G_DBUS_UTILS_H__ = "";
pub const __G_DEBUG_CONTROLLER_H__ = "";
pub const G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME = "gio-debug-controller";
pub const G_TYPE_DEBUG_CONTROLLER = g_debug_controller_get_type();
pub inline fn G_DEBUG_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DEBUG_CONTROLLER, GDebugController)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_DEBUG_CONTROLLER, GDebugController);
}
pub inline fn G_IS_DEBUG_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DEBUG_CONTROLLER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_DEBUG_CONTROLLER);
}
pub inline fn G_DEBUG_CONTROLLER_GET_INTERFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DEBUG_CONTROLLER, GDebugControllerInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_DEBUG_CONTROLLER, GDebugControllerInterface);
}
pub const __G_DEBUG_CONTROLLER_DBUS_H__ = "";
pub const G_TYPE_DEBUG_CONTROLLER_DBUS = g_debug_controller_dbus_get_type();
pub const __G_DRIVE_H__ = "";
pub const G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device";
pub const G_TYPE_DRIVE = g_drive_get_type();
pub inline fn G_DRIVE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_DRIVE, GDrive)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_DRIVE, GDrive);
}
pub inline fn G_IS_DRIVE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_DRIVE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_DRIVE);
}
pub inline fn G_DRIVE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_DRIVE, GDriveIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_DRIVE, GDriveIface);
}
pub const __G_DTLS_CLIENT_CONNECTION_H__ = "";
pub const __G_DTLS_CONNECTION_H__ = "";
pub const G_TYPE_DTLS_CONNECTION = g_dtls_connection_get_type();
pub inline fn G_DTLS_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DTLS_CONNECTION, GDtlsConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DTLS_CONNECTION, GDtlsConnection);
}
pub inline fn G_IS_DTLS_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DTLS_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DTLS_CONNECTION);
}
pub inline fn G_DTLS_CONNECTION_GET_INTERFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DTLS_CONNECTION, GDtlsConnectionInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DTLS_CONNECTION, GDtlsConnectionInterface);
}
pub const G_TYPE_DTLS_CLIENT_CONNECTION = g_dtls_client_connection_get_type();
pub inline fn G_DTLS_CLIENT_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnection);
}
pub inline fn G_IS_DTLS_CLIENT_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DTLS_CLIENT_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DTLS_CLIENT_CONNECTION);
}
pub inline fn G_DTLS_CLIENT_CONNECTION_GET_INTERFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnectionInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DTLS_CLIENT_CONNECTION, GDtlsClientConnectionInterface);
}
pub const __G_DTLS_SERVER_CONNECTION_H__ = "";
pub const G_TYPE_DTLS_SERVER_CONNECTION = g_dtls_server_connection_get_type();
pub inline fn G_DTLS_SERVER_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnection);
}
pub inline fn G_IS_DTLS_SERVER_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DTLS_SERVER_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_DTLS_SERVER_CONNECTION);
}
pub inline fn G_DTLS_SERVER_CONNECTION_GET_INTERFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnectionInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_DTLS_SERVER_CONNECTION, GDtlsServerConnectionInterface);
}
pub const __G_EMBLEMED_ICON_H__ = "";
pub const __G_ICON_H__ = "";
pub const G_TYPE_ICON = g_icon_get_type();
pub inline fn G_ICON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_ICON, GIcon)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_ICON, GIcon);
}
pub inline fn G_IS_ICON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_ICON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_ICON);
}
pub inline fn G_ICON_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_ICON, GIconIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_ICON, GIconIface);
}
pub const __G_EMBLEM_H__ = "";
pub const G_TYPE_EMBLEM = g_emblem_get_type();
pub inline fn G_EMBLEM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_EMBLEM, GEmblem)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_EMBLEM, GEmblem);
}
pub inline fn G_EMBLEM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_EMBLEM, GEmblemClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_EMBLEM, GEmblemClass);
}
pub inline fn G_IS_EMBLEM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_EMBLEM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_EMBLEM);
}
pub inline fn G_IS_EMBLEM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_EMBLEM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_EMBLEM);
}
pub inline fn G_EMBLEM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_EMBLEM, GEmblemClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_EMBLEM, GEmblemClass);
}
pub const G_TYPE_EMBLEMED_ICON = g_emblemed_icon_get_type();
pub inline fn G_EMBLEMED_ICON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_EMBLEMED_ICON, GEmblemedIcon)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_EMBLEMED_ICON, GEmblemedIcon);
}
pub inline fn G_EMBLEMED_ICON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_EMBLEMED_ICON, GEmblemedIconClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_EMBLEMED_ICON, GEmblemedIconClass);
}
pub inline fn G_IS_EMBLEMED_ICON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_EMBLEMED_ICON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_EMBLEMED_ICON);
}
pub inline fn G_IS_EMBLEMED_ICON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_EMBLEMED_ICON)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_EMBLEMED_ICON);
}
pub inline fn G_EMBLEMED_ICON_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_EMBLEMED_ICON, GEmblemedIconClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_EMBLEMED_ICON, GEmblemedIconClass);
}
pub const __G_FILE_H__ = "";
pub const G_TYPE_FILE = g_file_get_type();
pub inline fn G_FILE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_FILE, GFile)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_FILE, GFile);
}
pub inline fn G_IS_FILE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_FILE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_FILE);
}
pub inline fn G_FILE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_FILE, GFileIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_FILE, GFileIface);
}
pub const __G_FILE_ATTRIBUTE_H__ = "";
pub const G_TYPE_FILE_ATTRIBUTE_INFO_LIST = g_file_attribute_info_list_get_type();
pub const __G_FILE_ENUMERATOR_H__ = "";
pub const G_TYPE_FILE_ENUMERATOR = g_file_enumerator_get_type();
pub inline fn G_FILE_ENUMERATOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_ENUMERATOR, GFileEnumerator)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_ENUMERATOR, GFileEnumerator);
}
pub inline fn G_FILE_ENUMERATOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass);
}
pub inline fn G_IS_FILE_ENUMERATOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_ENUMERATOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_ENUMERATOR);
}
pub inline fn G_IS_FILE_ENUMERATOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_ENUMERATOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_ENUMERATOR);
}
pub inline fn G_FILE_ENUMERATOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_ENUMERATOR, GFileEnumeratorClass);
}
pub const __G_FILE_ICON_H__ = "";
pub const G_TYPE_FILE_ICON = g_file_icon_get_type();
pub inline fn G_FILE_ICON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_ICON, GFileIcon)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_ICON, GFileIcon);
}
pub inline fn G_FILE_ICON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_ICON, GFileIconClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_ICON, GFileIconClass);
}
pub inline fn G_IS_FILE_ICON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_ICON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_ICON);
}
pub inline fn G_IS_FILE_ICON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_ICON)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_ICON);
}
pub inline fn G_FILE_ICON_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_ICON, GFileIconClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_ICON, GFileIconClass);
}
pub const __G_FILE_INFO_H__ = "";
pub const G_TYPE_FILE_INFO = g_file_info_get_type();
pub inline fn G_FILE_INFO(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_INFO, GFileInfo)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_INFO, GFileInfo);
}
pub inline fn G_FILE_INFO_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_INFO, GFileInfoClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_INFO, GFileInfoClass);
}
pub inline fn G_IS_FILE_INFO(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_INFO)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_INFO);
}
pub inline fn G_IS_FILE_INFO_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_INFO)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_INFO);
}
pub inline fn G_FILE_INFO_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_INFO, GFileInfoClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_INFO, GFileInfoClass);
}
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE = "standard::type";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = "standard::is-hidden";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP = "standard::is-backup";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = "standard::is-symlink";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = "standard::is-virtual";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = "standard::is-volatile";
pub const G_FILE_ATTRIBUTE_STANDARD_NAME = "standard::name";
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = "standard::display-name";
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME = "standard::edit-name";
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME = "standard::copy-name";
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION = "standard::description";
pub const G_FILE_ATTRIBUTE_STANDARD_ICON = "standard::icon";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = "standard::symbolic-icon";
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = "standard::content-type";
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = "standard::fast-content-type";
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE = "standard::size";
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = "standard::allocated-size";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = "standard::symlink-target";
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI = "standard::target-uri";
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER = "standard::sort-order";
pub const G_FILE_ATTRIBUTE_ETAG_VALUE = "etag::value";
pub const G_FILE_ATTRIBUTE_ID_FILE = "id::file";
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM = "id::filesystem";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ = "access::can-read";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE = "access::can-write";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = "access::can-execute";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE = "access::can-delete";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH = "access::can-trash";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME = "access::can-rename";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = "mountable::can-mount";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = "mountable::can-unmount";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = "mountable::can-eject";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = "mountable::unix-device";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = "mountable::unix-device-file";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = "mountable::hal-udi";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START = "mountable::can-start";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = "mountable::can-start-degraded";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = "mountable::can-stop";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = "mountable::start-stop-type";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = "mountable::can-poll";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = "mountable::is-media-check-automatic";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED = "time::modified";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC = "time::modified-usec";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC = "time::modified-nsec";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS = "time::access";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC = "time::access-usec";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC = "time::access-nsec";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED = "time::changed";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC = "time::changed-usec";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_NSEC = "time::changed-nsec";
pub const G_FILE_ATTRIBUTE_TIME_CREATED = "time::created";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC = "time::created-usec";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_NSEC = "time::created-nsec";
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE = "unix::device";
pub const G_FILE_ATTRIBUTE_UNIX_INODE = "unix::inode";
pub const G_FILE_ATTRIBUTE_UNIX_MODE = "unix::mode";
pub const G_FILE_ATTRIBUTE_UNIX_NLINK = "unix::nlink";
pub const G_FILE_ATTRIBUTE_UNIX_UID = "unix::uid";
pub const G_FILE_ATTRIBUTE_UNIX_GID = "unix::gid";
pub const G_FILE_ATTRIBUTE_UNIX_RDEV = "unix::rdev";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = "unix::block-size";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS = "unix::blocks";
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = "unix::is-mountpoint";
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE = "dos::is-archive";
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM = "dos::is-system";
pub const G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = "dos::is-mountpoint";
pub const G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = "dos::reparse-point-tag";
pub const G_FILE_ATTRIBUTE_OWNER_USER = "owner::user";
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL = "owner::user-real";
pub const G_FILE_ATTRIBUTE_OWNER_GROUP = "owner::group";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH = "thumbnail::path";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED = "thumbnail::failed";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = "thumbnail::is-valid";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL = "thumbnail::path-normal";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL = "thumbnail::failed-normal";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL = "thumbnail::is-valid-normal";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE = "thumbnail::path-large";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE = "thumbnail::failed-large";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE = "thumbnail::is-valid-large";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE = "thumbnail::path-xlarge";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE = "thumbnail::failed-xlarge";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE = "thumbnail::is-valid-xlarge";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE = "thumbnail::path-xxlarge";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE = "thumbnail::failed-xxlarge";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE = "thumbnail::is-valid-xxlarge";
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON = "preview::icon";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE = "filesystem::size";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE = "filesystem::free";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED = "filesystem::used";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE = "filesystem::type";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY = "filesystem::readonly";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = "filesystem::use-preview";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE = "filesystem::remote";
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND = "gvfs::backend";
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT = "selinux::context";
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT = "trash::item-count";
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH = "trash::orig-path";
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE = "trash::deletion-date";
pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED = "recent::modified";
pub const G_TYPE_FILE_ATTRIBUTE_MATCHER = g_file_attribute_matcher_get_type();
pub const __G_FILE_INPUT_STREAM_H__ = "";
pub const G_TYPE_FILE_INPUT_STREAM = g_file_input_stream_get_type();
pub inline fn G_FILE_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_INPUT_STREAM, GFileInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_INPUT_STREAM, GFileInputStream);
}
pub inline fn G_FILE_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass);
}
pub inline fn G_IS_FILE_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_INPUT_STREAM);
}
pub inline fn G_IS_FILE_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_INPUT_STREAM);
}
pub inline fn G_FILE_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_INPUT_STREAM, GFileInputStreamClass);
}
pub const __G_FILE_IO_STREAM_H__ = "";
pub const __G_IO_STREAM_H__ = "";
pub const __G_IO_ERROR_H__ = "";
pub const G_IO_ERROR = g_io_error_quark();
pub const G_TYPE_IO_STREAM = g_io_stream_get_type();
pub inline fn G_IO_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_IO_STREAM, GIOStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_IO_STREAM, GIOStream);
}
pub inline fn G_IO_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_IO_STREAM, GIOStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_IO_STREAM, GIOStreamClass);
}
pub inline fn G_IS_IO_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_IO_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_IO_STREAM);
}
pub inline fn G_IS_IO_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_IO_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_IO_STREAM);
}
pub inline fn G_IO_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_IO_STREAM, GIOStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_IO_STREAM, GIOStreamClass);
}
pub const G_TYPE_FILE_IO_STREAM = g_file_io_stream_get_type();
pub inline fn G_FILE_IO_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_IO_STREAM, GFileIOStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_IO_STREAM, GFileIOStream);
}
pub inline fn G_FILE_IO_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_IO_STREAM, GFileIOStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_IO_STREAM, GFileIOStreamClass);
}
pub inline fn G_IS_FILE_IO_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_IO_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_IO_STREAM);
}
pub inline fn G_IS_FILE_IO_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_IO_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_IO_STREAM);
}
pub inline fn G_FILE_IO_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_IO_STREAM, GFileIOStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_IO_STREAM, GFileIOStreamClass);
}
pub const __G_FILE_MONITOR_H__ = "";
pub const G_TYPE_FILE_MONITOR = g_file_monitor_get_type();
pub inline fn G_FILE_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_MONITOR, GFileMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_MONITOR, GFileMonitor);
}
pub inline fn G_FILE_MONITOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_MONITOR, GFileMonitorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_MONITOR, GFileMonitorClass);
}
pub inline fn G_IS_FILE_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_MONITOR);
}
pub inline fn G_IS_FILE_MONITOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_MONITOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_MONITOR);
}
pub inline fn G_FILE_MONITOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_MONITOR, GFileMonitorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_MONITOR, GFileMonitorClass);
}
pub const __G_FILENAME_COMPLETER_H__ = "";
pub const G_TYPE_FILENAME_COMPLETER = g_filename_completer_get_type();
pub inline fn G_FILENAME_COMPLETER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILENAME_COMPLETER, GFilenameCompleter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILENAME_COMPLETER, GFilenameCompleter);
}
pub inline fn G_FILENAME_COMPLETER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass);
}
pub inline fn G_FILENAME_COMPLETER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILENAME_COMPLETER, GFilenameCompleterClass);
}
pub inline fn G_IS_FILENAME_COMPLETER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILENAME_COMPLETER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILENAME_COMPLETER);
}
pub inline fn G_IS_FILENAME_COMPLETER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILENAME_COMPLETER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILENAME_COMPLETER);
}
pub const __G_FILE_OUTPUT_STREAM_H__ = "";
pub const G_TYPE_FILE_OUTPUT_STREAM = g_file_output_stream_get_type();
pub inline fn G_FILE_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStream);
}
pub inline fn G_FILE_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass);
}
pub inline fn G_IS_FILE_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_FILE_OUTPUT_STREAM);
}
pub inline fn G_IS_FILE_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_FILE_OUTPUT_STREAM);
}
pub inline fn G_FILE_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_FILE_OUTPUT_STREAM, GFileOutputStreamClass);
}
pub const __G_INET_ADDRESS_H__ = "";
pub const G_TYPE_INET_ADDRESS = g_inet_address_get_type();
pub inline fn G_INET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INET_ADDRESS, GInetAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INET_ADDRESS, GInetAddress);
}
pub inline fn G_INET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INET_ADDRESS, GInetAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INET_ADDRESS, GInetAddressClass);
}
pub inline fn G_IS_INET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INET_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INET_ADDRESS);
}
pub inline fn G_IS_INET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INET_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INET_ADDRESS);
}
pub inline fn G_INET_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INET_ADDRESS, GInetAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INET_ADDRESS, GInetAddressClass);
}
pub const __G_INET_ADDRESS_MASK_H__ = "";
pub const G_TYPE_INET_ADDRESS_MASK = g_inet_address_mask_get_type();
pub inline fn G_INET_ADDRESS_MASK(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INET_ADDRESS_MASK, GInetAddressMask)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INET_ADDRESS_MASK, GInetAddressMask);
}
pub inline fn G_INET_ADDRESS_MASK_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass);
}
pub inline fn G_IS_INET_ADDRESS_MASK(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INET_ADDRESS_MASK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INET_ADDRESS_MASK);
}
pub inline fn G_IS_INET_ADDRESS_MASK_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INET_ADDRESS_MASK)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INET_ADDRESS_MASK);
}
pub inline fn G_INET_ADDRESS_MASK_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INET_ADDRESS_MASK, GInetAddressMaskClass);
}
pub const __G_INET_SOCKET_ADDRESS_H__ = "";
pub const __G_SOCKET_ADDRESS_H__ = "";
pub const G_TYPE_SOCKET_ADDRESS = g_socket_address_get_type();
pub inline fn G_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SOCKET_ADDRESS, GSocketAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SOCKET_ADDRESS, GSocketAddress);
}
pub inline fn G_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SOCKET_ADDRESS, GSocketAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SOCKET_ADDRESS, GSocketAddressClass);
}
pub inline fn G_IS_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SOCKET_ADDRESS);
}
pub inline fn G_IS_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SOCKET_ADDRESS);
}
pub inline fn G_SOCKET_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SOCKET_ADDRESS, GSocketAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SOCKET_ADDRESS, GSocketAddressClass);
}
pub const G_TYPE_INET_SOCKET_ADDRESS = g_inet_socket_address_get_type();
pub inline fn G_INET_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddress);
}
pub inline fn G_INET_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass);
}
pub inline fn G_IS_INET_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INET_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_INET_SOCKET_ADDRESS);
}
pub inline fn G_IS_INET_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INET_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_INET_SOCKET_ADDRESS);
}
pub inline fn G_INET_SOCKET_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_INET_SOCKET_ADDRESS, GInetSocketAddressClass);
}
pub const __GIO_ENUM_TYPES_H__ = "";
pub const G_TYPE_APP_INFO_CREATE_FLAGS = g_app_info_create_flags_get_type();
pub const G_TYPE_CONVERTER_FLAGS = g_converter_flags_get_type();
pub const G_TYPE_CONVERTER_RESULT = g_converter_result_get_type();
pub const G_TYPE_DATA_STREAM_BYTE_ORDER = g_data_stream_byte_order_get_type();
pub const G_TYPE_DATA_STREAM_NEWLINE_TYPE = g_data_stream_newline_type_get_type();
pub const G_TYPE_FILE_ATTRIBUTE_TYPE = g_file_attribute_type_get_type();
pub const G_TYPE_FILE_ATTRIBUTE_INFO_FLAGS = g_file_attribute_info_flags_get_type();
pub const G_TYPE_FILE_ATTRIBUTE_STATUS = g_file_attribute_status_get_type();
pub const G_TYPE_FILE_QUERY_INFO_FLAGS = g_file_query_info_flags_get_type();
pub const G_TYPE_FILE_CREATE_FLAGS = g_file_create_flags_get_type();
pub const G_TYPE_FILE_MEASURE_FLAGS = g_file_measure_flags_get_type();
pub const G_TYPE_MOUNT_MOUNT_FLAGS = g_mount_mount_flags_get_type();
pub const G_TYPE_MOUNT_UNMOUNT_FLAGS = g_mount_unmount_flags_get_type();
pub const G_TYPE_DRIVE_START_FLAGS = g_drive_start_flags_get_type();
pub const G_TYPE_DRIVE_START_STOP_TYPE = g_drive_start_stop_type_get_type();
pub const G_TYPE_FILE_COPY_FLAGS = g_file_copy_flags_get_type();
pub const G_TYPE_FILE_MONITOR_FLAGS = g_file_monitor_flags_get_type();
pub const G_TYPE_FILE_TYPE = g_file_type_get_type();
pub const G_TYPE_FILESYSTEM_PREVIEW_TYPE = g_filesystem_preview_type_get_type();
pub const G_TYPE_FILE_MONITOR_EVENT = g_file_monitor_event_get_type();
pub const G_TYPE_IO_ERROR_ENUM = g_io_error_enum_get_type();
pub const G_TYPE_ASK_PASSWORD_FLAGS = g_ask_password_flags_get_type();
pub const G_TYPE_PASSWORD_SAVE = g_password_save_get_type();
pub const G_TYPE_MOUNT_OPERATION_RESULT = g_mount_operation_result_get_type();
pub const G_TYPE_OUTPUT_STREAM_SPLICE_FLAGS = g_output_stream_splice_flags_get_type();
pub const G_TYPE_IO_STREAM_SPLICE_FLAGS = g_io_stream_splice_flags_get_type();
pub const G_TYPE_EMBLEM_ORIGIN = g_emblem_origin_get_type();
pub const G_TYPE_RESOLVER_ERROR = g_resolver_error_get_type();
pub const G_TYPE_RESOLVER_RECORD_TYPE = g_resolver_record_type_get_type();
pub const G_TYPE_RESOURCE_ERROR = g_resource_error_get_type();
pub const G_TYPE_RESOURCE_FLAGS = g_resource_flags_get_type();
pub const G_TYPE_RESOURCE_LOOKUP_FLAGS = g_resource_lookup_flags_get_type();
pub const G_TYPE_SOCKET_FAMILY = g_socket_family_get_type();
pub const G_TYPE_SOCKET_TYPE = g_socket_type_get_type();
pub const G_TYPE_SOCKET_MSG_FLAGS = g_socket_msg_flags_get_type();
pub const G_TYPE_SOCKET_PROTOCOL = g_socket_protocol_get_type();
pub const G_TYPE_ZLIB_COMPRESSOR_FORMAT = g_zlib_compressor_format_get_type();
pub const G_TYPE_UNIX_SOCKET_ADDRESS_TYPE = g_unix_socket_address_type_get_type();
pub const G_TYPE_BUS_TYPE = g_bus_type_get_type();
pub const G_TYPE_BUS_NAME_OWNER_FLAGS = g_bus_name_owner_flags_get_type();
pub const G_TYPE_BUS_NAME_WATCHER_FLAGS = g_bus_name_watcher_flags_get_type();
pub const G_TYPE_DBUS_PROXY_FLAGS = g_dbus_proxy_flags_get_type();
pub const G_TYPE_DBUS_ERROR = g_dbus_error_get_type();
pub const G_TYPE_DBUS_CONNECTION_FLAGS = g_dbus_connection_flags_get_type();
pub const G_TYPE_DBUS_CAPABILITY_FLAGS = g_dbus_capability_flags_get_type();
pub const G_TYPE_DBUS_CALL_FLAGS = g_dbus_call_flags_get_type();
pub const G_TYPE_DBUS_MESSAGE_TYPE = g_dbus_message_type_get_type();
pub const G_TYPE_DBUS_MESSAGE_FLAGS = g_dbus_message_flags_get_type();
pub const G_TYPE_DBUS_MESSAGE_HEADER_FIELD = g_dbus_message_header_field_get_type();
pub const G_TYPE_DBUS_PROPERTY_INFO_FLAGS = g_dbus_property_info_flags_get_type();
pub const G_TYPE_DBUS_SUBTREE_FLAGS = g_dbus_subtree_flags_get_type();
pub const G_TYPE_DBUS_SERVER_FLAGS = g_dbus_server_flags_get_type();
pub const G_TYPE_DBUS_SIGNAL_FLAGS = g_dbus_signal_flags_get_type();
pub const G_TYPE_DBUS_SEND_MESSAGE_FLAGS = g_dbus_send_message_flags_get_type();
pub const G_TYPE_CREDENTIALS_TYPE = g_credentials_type_get_type();
pub const G_TYPE_DBUS_MESSAGE_BYTE_ORDER = g_dbus_message_byte_order_get_type();
pub const G_TYPE_APPLICATION_FLAGS = g_application_flags_get_type();
pub const G_TYPE_TLS_ERROR = g_tls_error_get_type();
pub const G_TYPE_TLS_CERTIFICATE_FLAGS = g_tls_certificate_flags_get_type();
pub const G_TYPE_TLS_AUTHENTICATION_MODE = g_tls_authentication_mode_get_type();
pub const G_TYPE_TLS_CHANNEL_BINDING_TYPE = g_tls_channel_binding_type_get_type();
pub const G_TYPE_TLS_CHANNEL_BINDING_ERROR = g_tls_channel_binding_error_get_type();
pub const G_TYPE_TLS_REHANDSHAKE_MODE = g_tls_rehandshake_mode_get_type();
pub const G_TYPE_TLS_PASSWORD_FLAGS = g_tls_password_flags_get_type();
pub const G_TYPE_TLS_INTERACTION_RESULT = g_tls_interaction_result_get_type();
pub const G_TYPE_DBUS_INTERFACE_SKELETON_FLAGS = g_dbus_interface_skeleton_flags_get_type();
pub const G_TYPE_DBUS_OBJECT_MANAGER_CLIENT_FLAGS = g_dbus_object_manager_client_flags_get_type();
pub const G_TYPE_TLS_DATABASE_VERIFY_FLAGS = g_tls_database_verify_flags_get_type();
pub const G_TYPE_TLS_DATABASE_LOOKUP_FLAGS = g_tls_database_lookup_flags_get_type();
pub const G_TYPE_TLS_CERTIFICATE_REQUEST_FLAGS = g_tls_certificate_request_flags_get_type();
pub const G_TYPE_TLS_PROTOCOL_VERSION = g_tls_protocol_version_get_type();
pub const G_TYPE_IO_MODULE_SCOPE_FLAGS = g_io_module_scope_flags_get_type();
pub const G_TYPE_SOCKET_CLIENT_EVENT = g_socket_client_event_get_type();
pub const G_TYPE_SOCKET_LISTENER_EVENT = g_socket_listener_event_get_type();
pub const G_TYPE_TEST_DBUS_FLAGS = g_test_dbus_flags_get_type();
pub const G_TYPE_SUBPROCESS_FLAGS = g_subprocess_flags_get_type();
pub const G_TYPE_NOTIFICATION_PRIORITY = g_notification_priority_get_type();
pub const G_TYPE_NETWORK_CONNECTIVITY = g_network_connectivity_get_type();
pub const G_TYPE_POLLABLE_RETURN = g_pollable_return_get_type();
pub const G_TYPE_MEMORY_MONITOR_WARNING_LEVEL = g_memory_monitor_warning_level_get_type();
pub const G_TYPE_RESOLVER_NAME_LOOKUP_FLAGS = g_resolver_name_lookup_flags_get_type();
pub const G_TYPE_SETTINGS_BIND_FLAGS = g_settings_bind_flags_get_type();
pub const __G_IO_MODULE_H__ = "";
pub const __GMODULE_H__ = "";
pub const _GMODULE_IMPORT = "";
pub const _GMODULE_API = _GMODULE_IMPORT;
pub const GMODULE_VAR = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_IN_ALL = _GMODULE_EXTERN;
pub const GMODULE_DEPRECATED = G_DEPRECATED ++ _GMODULE_EXTERN;
pub inline fn GMODULE_UNAVAILABLE_STATIC_INLINE(maj: anytype, min: anytype) @TypeOf(G_UNAVAILABLE(maj, min)) {
    return G_UNAVAILABLE(maj, min);
}
pub const GMODULE_DEPRECATED_IN_2_26 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_26_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_26 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_26 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_26 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_26_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_26 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_26 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_26 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_26 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_26 = "";
pub const GMODULE_DEPRECATED_IN_2_28 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_28_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_28 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_28 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_28 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_28_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_28 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_28 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_28 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_28 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_28 = "";
pub const GMODULE_DEPRECATED_IN_2_30 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_30_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_30 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_30 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_30 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_30_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_30 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_30 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_30 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_30 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_30 = "";
pub const GMODULE_DEPRECATED_IN_2_32 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_32_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_32 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_32 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_32 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_32_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_32 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_32 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_32 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_32 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_32 = "";
pub const GMODULE_DEPRECATED_IN_2_34 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_34_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_34 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_34 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_34 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_34_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_34 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_34 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_34 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_34 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_34 = "";
pub const GMODULE_DEPRECATED_IN_2_36 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_36_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_36 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_36 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_36 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_36_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_36 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_36 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_36 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_36 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_36 = "";
pub const GMODULE_DEPRECATED_IN_2_38 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_38_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_38 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_38 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_38 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_38_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_38 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_38 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_38 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_38 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_38 = "";
pub const GMODULE_DEPRECATED_IN_2_40 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_40_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_40 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_40 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_40 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_40_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_40 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_40 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_40 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_40 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_40 = "";
pub const GMODULE_DEPRECATED_IN_2_42 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_42_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_42 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_42 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_42 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_42_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_42 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_42 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_42 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_42 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_42 = "";
pub const GMODULE_DEPRECATED_IN_2_44 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_44_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_44 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_44 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_44 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_44_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_44 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_44 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_44 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_44 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_44 = "";
pub const GMODULE_DEPRECATED_IN_2_46 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_46_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_46 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_46 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_46 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_46_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_46 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_46 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_46 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_46 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_46 = "";
pub const GMODULE_DEPRECATED_IN_2_48 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_48_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_48 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_48 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_48 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_48_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_48 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_48 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_48 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_48 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_48 = "";
pub const GMODULE_DEPRECATED_IN_2_50 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_50_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_50 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_50 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_50 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_50_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_50 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_50 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_50 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_50 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_50 = "";
pub const GMODULE_DEPRECATED_IN_2_52 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_52_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_52 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_52 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_52 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_52_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_52 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_52 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_52 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_52 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_52 = "";
pub const GMODULE_DEPRECATED_IN_2_54 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_54_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_54 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_54 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_54 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_54_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_54 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_54 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_54 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_54 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_54 = "";
pub const GMODULE_DEPRECATED_IN_2_56 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_56_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_56 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_56 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_56 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_56_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_56 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_56 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_56 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_56 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_56 = "";
pub const GMODULE_DEPRECATED_IN_2_58 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_58_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_58 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_58 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_58 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_58_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_58 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_58 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_58 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_58 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_58 = "";
pub const GMODULE_DEPRECATED_IN_2_60 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_60_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_60 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_60 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_60 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_60_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_60 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_60 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_60 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_60 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_60 = "";
pub const GMODULE_DEPRECATED_IN_2_62 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_62_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_62 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_62 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_62 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_62_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_62 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_62 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_62 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_62 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_62 = "";
pub const GMODULE_DEPRECATED_IN_2_64 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_64_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_64 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_64 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_64 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_64_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_64 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_64 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_64 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_64 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_64 = "";
pub const GMODULE_DEPRECATED_IN_2_66 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_66_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_66 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_66 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_66 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_66_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_66 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_66 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_66 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_66 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_66 = "";
pub const GMODULE_DEPRECATED_IN_2_68 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_68_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_68 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_68 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_68 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_68_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_68 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_68 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_68 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_68 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_68 = "";
pub const GMODULE_DEPRECATED_IN_2_70 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_70_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_70 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_70 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_70 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_70_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_70 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_70 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_70 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_70 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_70 = "";
pub const GMODULE_DEPRECATED_IN_2_72 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_72_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_72 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_72 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_72 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_72_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_72 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_72 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_72 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_72 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_72 = "";
pub const GMODULE_DEPRECATED_IN_2_74 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_74_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_74 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_74 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_74 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_74_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_74 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_74 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_74 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_74 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_74 = "";
pub const GMODULE_DEPRECATED_IN_2_76 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_76_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_76 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_76 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_76 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_76_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_76 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_76 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_76 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_76 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_76 = "";
pub const GMODULE_DEPRECATED_IN_2_78 = GMODULE_DEPRECATED;
pub inline fn GMODULE_DEPRECATED_IN_2_78_FOR(f: anytype) @TypeOf(GMODULE_DEPRECATED_FOR(f)) {
    return GMODULE_DEPRECATED_FOR(f);
}
pub const GMODULE_DEPRECATED_MACRO_IN_2_78 = GLIB_DEPRECATED_MACRO;
pub inline fn GMODULE_DEPRECATED_MACRO_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_MACRO_FOR(f)) {
    return GLIB_DEPRECATED_MACRO_FOR(f);
}
pub const GMODULE_DEPRECATED_ENUMERATOR_IN_2_78 = GLIB_DEPRECATED_ENUMERATOR;
pub inline fn GMODULE_DEPRECATED_ENUMERATOR_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_ENUMERATOR_FOR(f)) {
    return GLIB_DEPRECATED_ENUMERATOR_FOR(f);
}
pub const GMODULE_DEPRECATED_TYPE_IN_2_78 = GLIB_DEPRECATED_TYPE;
pub inline fn GMODULE_DEPRECATED_TYPE_IN_2_78_FOR(f: anytype) @TypeOf(GLIB_DEPRECATED_TYPE_FOR(f)) {
    return GLIB_DEPRECATED_TYPE_FOR(f);
}
pub const GMODULE_AVAILABLE_IN_2_78 = _GMODULE_EXTERN;
pub const GMODULE_AVAILABLE_STATIC_INLINE_IN_2_78 = "";
pub const GMODULE_AVAILABLE_MACRO_IN_2_78 = "";
pub const GMODULE_AVAILABLE_ENUMERATOR_IN_2_78 = "";
pub const GMODULE_AVAILABLE_TYPE_IN_2_78 = "";
pub const G_IO_TYPE_MODULE = g_io_module_get_type();
pub inline fn G_IO_MODULE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_IO_TYPE_MODULE, GIOModule)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_IO_TYPE_MODULE, GIOModule);
}
pub inline fn G_IO_MODULE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_IO_TYPE_MODULE, GIOModuleClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_IO_TYPE_MODULE, GIOModuleClass);
}
pub inline fn G_IO_IS_MODULE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_IO_TYPE_MODULE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_IO_TYPE_MODULE);
}
pub inline fn G_IO_IS_MODULE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_IO_TYPE_MODULE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_IO_TYPE_MODULE);
}
pub inline fn G_IO_MODULE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_IO_TYPE_MODULE, GIOModuleClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_IO_TYPE_MODULE, GIOModuleClass);
}
pub const __G_IO_SCHEDULER_H__ = "";
pub const __G_LIST_MODEL_H__ = "";
pub const G_TYPE_LIST_MODEL = g_list_model_get_type();
pub const __G_LIST_STORE_H__ = "";
pub const G_TYPE_LIST_STORE = g_list_store_get_type();
pub const __G_LOADABLE_ICON_H__ = "";
pub const G_TYPE_LOADABLE_ICON = g_loadable_icon_get_type();
pub inline fn G_LOADABLE_ICON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_LOADABLE_ICON, GLoadableIcon)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_LOADABLE_ICON, GLoadableIcon);
}
pub inline fn G_IS_LOADABLE_ICON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_LOADABLE_ICON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_LOADABLE_ICON);
}
pub inline fn G_LOADABLE_ICON_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_LOADABLE_ICON, GLoadableIconIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_LOADABLE_ICON, GLoadableIconIface);
}
pub const __G_MEMORY_INPUT_STREAM_H__ = "";
pub const G_TYPE_MEMORY_INPUT_STREAM = g_memory_input_stream_get_type();
pub inline fn G_MEMORY_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStream);
}
pub inline fn G_MEMORY_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass);
}
pub inline fn G_IS_MEMORY_INPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MEMORY_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MEMORY_INPUT_STREAM);
}
pub inline fn G_IS_MEMORY_INPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_MEMORY_INPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_MEMORY_INPUT_STREAM);
}
pub inline fn G_MEMORY_INPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_MEMORY_INPUT_STREAM, GMemoryInputStreamClass);
}
pub const __G_MEMORY_MONITOR_H__ = "";
pub const G_MEMORY_MONITOR_EXTENSION_POINT_NAME = "gio-memory-monitor";
pub const G_TYPE_MEMORY_MONITOR = g_memory_monitor_get_type();
pub inline fn G_MEMORY_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MEMORY_MONITOR, GMemoryMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MEMORY_MONITOR, GMemoryMonitor);
}
pub inline fn G_IS_MEMORY_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MEMORY_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MEMORY_MONITOR);
}
pub inline fn G_MEMORY_MONITOR_GET_INTERFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_MEMORY_MONITOR, GMemoryMonitorInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_MEMORY_MONITOR, GMemoryMonitorInterface);
}
pub const __G_MEMORY_OUTPUT_STREAM_H__ = "";
pub const G_TYPE_MEMORY_OUTPUT_STREAM = g_memory_output_stream_get_type();
pub inline fn G_MEMORY_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStream);
}
pub inline fn G_MEMORY_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass);
}
pub inline fn G_IS_MEMORY_OUTPUT_STREAM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MEMORY_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MEMORY_OUTPUT_STREAM);
}
pub inline fn G_IS_MEMORY_OUTPUT_STREAM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_MEMORY_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_MEMORY_OUTPUT_STREAM);
}
pub inline fn G_MEMORY_OUTPUT_STREAM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_MEMORY_OUTPUT_STREAM, GMemoryOutputStreamClass);
}
pub const __G_MENU_H__ = "";
pub const __G_MENU_MODEL_H__ = "";
pub const G_MENU_ATTRIBUTE_ACTION = "action";
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE = "action-namespace";
pub const G_MENU_ATTRIBUTE_TARGET = "target";
pub const G_MENU_ATTRIBUTE_LABEL = "label";
pub const G_MENU_ATTRIBUTE_ICON = "icon";
pub const G_MENU_LINK_SUBMENU = "submenu";
pub const G_MENU_LINK_SECTION = "section";
pub const G_TYPE_MENU_MODEL = g_menu_model_get_type();
pub inline fn G_MENU_MODEL(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_MODEL, GMenuModel)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_MODEL, GMenuModel);
}
pub inline fn G_MENU_MODEL_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_MENU_MODEL, GMenuModelClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_MENU_MODEL, GMenuModelClass);
}
pub inline fn G_IS_MENU_MODEL(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_MODEL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_MODEL);
}
pub inline fn G_IS_MENU_MODEL_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_MENU_MODEL)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_MENU_MODEL);
}
pub inline fn G_MENU_MODEL_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_MENU_MODEL, GMenuModelClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_MENU_MODEL, GMenuModelClass);
}
pub const G_TYPE_MENU_ATTRIBUTE_ITER = g_menu_attribute_iter_get_type();
pub inline fn G_MENU_ATTRIBUTE_ITER(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIter);
}
pub inline fn G_MENU_ATTRIBUTE_ITER_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass);
}
pub inline fn G_IS_MENU_ATTRIBUTE_ITER(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_ATTRIBUTE_ITER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_ATTRIBUTE_ITER);
}
pub inline fn G_IS_MENU_ATTRIBUTE_ITER_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_MENU_ATTRIBUTE_ITER)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_MENU_ATTRIBUTE_ITER);
}
pub inline fn G_MENU_ATTRIBUTE_ITER_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_MENU_ATTRIBUTE_ITER, GMenuAttributeIterClass);
}
pub const G_TYPE_MENU_LINK_ITER = g_menu_link_iter_get_type();
pub inline fn G_MENU_LINK_ITER(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_LINK_ITER, GMenuLinkIter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_LINK_ITER, GMenuLinkIter);
}
pub inline fn G_MENU_LINK_ITER_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass);
}
pub inline fn G_IS_MENU_LINK_ITER(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_LINK_ITER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_LINK_ITER);
}
pub inline fn G_IS_MENU_LINK_ITER_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_MENU_LINK_ITER)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_MENU_LINK_ITER);
}
pub inline fn G_MENU_LINK_ITER_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_MENU_LINK_ITER, GMenuLinkIterClass);
}
pub const G_TYPE_MENU = g_menu_get_type();
pub inline fn G_MENU(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU, GMenu)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU, GMenu);
}
pub inline fn G_IS_MENU(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU);
}
pub const G_TYPE_MENU_ITEM = g_menu_item_get_type();
pub inline fn G_MENU_ITEM(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_ITEM, GMenuItem)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_MENU_ITEM, GMenuItem);
}
pub inline fn G_IS_MENU_ITEM(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_ITEM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_MENU_ITEM);
}
pub const __G_MENU_EXPORTER_H__ = "";
pub const G_MENU_EXPORTER_MAX_SECTION_SIZE = @as(c_int, 1000) ++ GIO_AVAILABLE_MACRO_IN_2_76;
pub const __G_MOUNT_H__ = "";
pub const G_TYPE_MOUNT = g_mount_get_type();
pub inline fn G_MOUNT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_MOUNT, GMount)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_MOUNT, GMount);
}
pub inline fn G_IS_MOUNT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_MOUNT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_MOUNT);
}
pub inline fn G_MOUNT_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_MOUNT, GMountIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_MOUNT, GMountIface);
}
pub const __G_MOUNT_OPERATION_H__ = "";
pub const G_TYPE_MOUNT_OPERATION = g_mount_operation_get_type();
pub inline fn G_MOUNT_OPERATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MOUNT_OPERATION, GMountOperation)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_MOUNT_OPERATION, GMountOperation);
}
pub inline fn G_MOUNT_OPERATION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_MOUNT_OPERATION, GMountOperationClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_MOUNT_OPERATION, GMountOperationClass);
}
pub inline fn G_IS_MOUNT_OPERATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MOUNT_OPERATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_MOUNT_OPERATION);
}
pub inline fn G_IS_MOUNT_OPERATION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_MOUNT_OPERATION)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_MOUNT_OPERATION);
}
pub inline fn G_MOUNT_OPERATION_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_MOUNT_OPERATION, GMountOperationClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_MOUNT_OPERATION, GMountOperationClass);
}
pub const __G_NATIVE_SOCKET_ADDRESS_H__ = "";
pub const G_TYPE_NATIVE_SOCKET_ADDRESS = g_native_socket_address_get_type();
pub inline fn G_NATIVE_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddress);
}
pub inline fn G_NATIVE_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass);
}
pub inline fn G_IS_NATIVE_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NATIVE_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NATIVE_SOCKET_ADDRESS);
}
pub inline fn G_IS_NATIVE_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NATIVE_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NATIVE_SOCKET_ADDRESS);
}
pub inline fn G_NATIVE_SOCKET_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_NATIVE_SOCKET_ADDRESS, GNativeSocketAddressClass);
}
pub const __G_NATIVE_VOLUME_MONITOR_H__ = "";
pub const __G_VOLUME_MONITOR_H__ = "";
pub const G_TYPE_VOLUME_MONITOR = g_volume_monitor_get_type();
pub inline fn G_VOLUME_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_VOLUME_MONITOR, GVolumeMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_VOLUME_MONITOR, GVolumeMonitor);
}
pub inline fn G_VOLUME_MONITOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass);
}
pub inline fn G_VOLUME_MONITOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_VOLUME_MONITOR, GVolumeMonitorClass);
}
pub inline fn G_IS_VOLUME_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_VOLUME_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_VOLUME_MONITOR);
}
pub inline fn G_IS_VOLUME_MONITOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_VOLUME_MONITOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_VOLUME_MONITOR);
}
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-volume-monitor";
pub const G_TYPE_NATIVE_VOLUME_MONITOR = g_native_volume_monitor_get_type();
pub inline fn G_NATIVE_VOLUME_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitor);
}
pub inline fn G_NATIVE_VOLUME_MONITOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NATIVE_VOLUME_MONITOR, GNativeVolumeMonitorClass);
}
pub inline fn G_IS_NATIVE_VOLUME_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NATIVE_VOLUME_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NATIVE_VOLUME_MONITOR);
}
pub inline fn G_IS_NATIVE_VOLUME_MONITOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NATIVE_VOLUME_MONITOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NATIVE_VOLUME_MONITOR);
}
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME = "gio-native-volume-monitor";
pub const __G_NETWORK_ADDRESS_H__ = "";
pub const G_TYPE_NETWORK_ADDRESS = g_network_address_get_type();
pub inline fn G_NETWORK_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NETWORK_ADDRESS, GNetworkAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NETWORK_ADDRESS, GNetworkAddress);
}
pub inline fn G_NETWORK_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass);
}
pub inline fn G_IS_NETWORK_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NETWORK_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NETWORK_ADDRESS);
}
pub inline fn G_IS_NETWORK_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NETWORK_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NETWORK_ADDRESS);
}
pub inline fn G_NETWORK_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_NETWORK_ADDRESS, GNetworkAddressClass);
}
pub const __G_NETWORK_MONITOR_H__ = "";
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME = "gio-network-monitor";
pub const G_TYPE_NETWORK_MONITOR = g_network_monitor_get_type();
pub inline fn G_NETWORK_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NETWORK_MONITOR, GNetworkMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NETWORK_MONITOR, GNetworkMonitor);
}
pub inline fn G_IS_NETWORK_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NETWORK_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NETWORK_MONITOR);
}
pub inline fn G_NETWORK_MONITOR_GET_INTERFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_NETWORK_MONITOR, GNetworkMonitorInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_NETWORK_MONITOR, GNetworkMonitorInterface);
}
pub const __G_NETWORK_SERVICE_H__ = "";
pub const G_TYPE_NETWORK_SERVICE = g_network_service_get_type();
pub inline fn G_NETWORK_SERVICE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NETWORK_SERVICE, GNetworkService)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NETWORK_SERVICE, GNetworkService);
}
pub inline fn G_NETWORK_SERVICE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NETWORK_SERVICE, GNetworkServiceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_NETWORK_SERVICE, GNetworkServiceClass);
}
pub inline fn G_IS_NETWORK_SERVICE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NETWORK_SERVICE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NETWORK_SERVICE);
}
pub inline fn G_IS_NETWORK_SERVICE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NETWORK_SERVICE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_NETWORK_SERVICE);
}
pub inline fn G_NETWORK_SERVICE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_NETWORK_SERVICE, GNetworkServiceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_NETWORK_SERVICE, GNetworkServiceClass);
}
pub const __G_NOTIFICATION_H__ = "";
pub const G_TYPE_NOTIFICATION = g_notification_get_type();
pub inline fn G_NOTIFICATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NOTIFICATION, GNotification)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_NOTIFICATION, GNotification);
}
pub inline fn G_IS_NOTIFICATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NOTIFICATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_NOTIFICATION);
}
pub const __G_PERMISSION_H__ = "";
pub const G_TYPE_PERMISSION = g_permission_get_type();
pub inline fn G_PERMISSION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_PERMISSION, GPermission)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_PERMISSION, GPermission);
}
pub inline fn G_PERMISSION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_PERMISSION, GPermissionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_PERMISSION, GPermissionClass);
}
pub inline fn G_IS_PERMISSION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_PERMISSION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_PERMISSION);
}
pub inline fn G_IS_PERMISSION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_PERMISSION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_PERMISSION);
}
pub inline fn G_PERMISSION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_PERMISSION, GPermissionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_PERMISSION, GPermissionClass);
}
pub const __G_POLLABLE_INPUT_STREAM_H__ = "";
pub const G_TYPE_POLLABLE_INPUT_STREAM = g_pollable_input_stream_get_type();
pub inline fn G_POLLABLE_INPUT_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStream);
}
pub inline fn G_IS_POLLABLE_INPUT_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_POLLABLE_INPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_POLLABLE_INPUT_STREAM);
}
pub inline fn G_POLLABLE_INPUT_STREAM_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStreamInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_POLLABLE_INPUT_STREAM, GPollableInputStreamInterface);
}
pub const __G_POLLABLE_OUTPUT_STREAM_H__ = "";
pub const G_TYPE_POLLABLE_OUTPUT_STREAM = g_pollable_output_stream_get_type();
pub inline fn G_POLLABLE_OUTPUT_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStream);
}
pub inline fn G_IS_POLLABLE_OUTPUT_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_POLLABLE_OUTPUT_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_POLLABLE_OUTPUT_STREAM);
}
pub inline fn G_POLLABLE_OUTPUT_STREAM_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStreamInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_POLLABLE_OUTPUT_STREAM, GPollableOutputStreamInterface);
}
pub const __G_POLLABLE_UTILS_H__ = "";
pub const __G_POWER_PROFILE_MONITOR_H__ = "";
pub const G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME = "gio-power-profile-monitor";
pub const G_TYPE_POWER_PROFILE_MONITOR = g_power_profile_monitor_get_type();
pub inline fn G_POWER_PROFILE_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_POWER_PROFILE_MONITOR, GPowerProfileMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_POWER_PROFILE_MONITOR, GPowerProfileMonitor);
}
pub inline fn G_IS_POWER_PROFILE_MONITOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_POWER_PROFILE_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_POWER_PROFILE_MONITOR);
}
pub inline fn G_POWER_PROFILE_MONITOR_GET_INTERFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_POWER_PROFILE_MONITOR, GPowerProfileMonitorInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_POWER_PROFILE_MONITOR, GPowerProfileMonitorInterface);
}
pub const __G_PROPERTY_ACTION_H__ = "";
pub const G_TYPE_PROPERTY_ACTION = g_property_action_get_type();
pub inline fn G_PROPERTY_ACTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_PROPERTY_ACTION, GPropertyAction)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_PROPERTY_ACTION, GPropertyAction);
}
pub inline fn G_IS_PROPERTY_ACTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_PROPERTY_ACTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_PROPERTY_ACTION);
}
pub const __G_PROXY_H__ = "";
pub const G_TYPE_PROXY = g_proxy_get_type();
pub inline fn G_PROXY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY, GProxy)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY, GProxy);
}
pub inline fn G_IS_PROXY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY);
}
pub inline fn G_PROXY_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_PROXY, GProxyInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_PROXY, GProxyInterface);
}
pub const G_PROXY_EXTENSION_POINT_NAME = "gio-proxy";
pub const __G_PROXY_ADDRESS_H__ = "";
pub const G_TYPE_PROXY_ADDRESS = g_proxy_address_get_type();
pub inline fn G_PROXY_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY_ADDRESS, GProxyAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY_ADDRESS, GProxyAddress);
}
pub inline fn G_PROXY_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_PROXY_ADDRESS, GProxyAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_PROXY_ADDRESS, GProxyAddressClass);
}
pub inline fn G_IS_PROXY_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY_ADDRESS);
}
pub inline fn G_IS_PROXY_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_PROXY_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_PROXY_ADDRESS);
}
pub inline fn G_PROXY_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_PROXY_ADDRESS, GProxyAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_PROXY_ADDRESS, GProxyAddressClass);
}
pub const __G_PROXY_ADDRESS_ENUMERATOR_H__ = "";
pub const __G_SOCKET_ADDRESS_ENUMERATOR_H__ = "";
pub const G_TYPE_SOCKET_ADDRESS_ENUMERATOR = g_socket_address_enumerator_get_type();
pub inline fn G_SOCKET_ADDRESS_ENUMERATOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumerator)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumerator);
}
pub inline fn G_SOCKET_ADDRESS_ENUMERATOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass);
}
pub inline fn G_IS_SOCKET_ADDRESS_ENUMERATOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SOCKET_ADDRESS_ENUMERATOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SOCKET_ADDRESS_ENUMERATOR);
}
pub inline fn G_IS_SOCKET_ADDRESS_ENUMERATOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SOCKET_ADDRESS_ENUMERATOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SOCKET_ADDRESS_ENUMERATOR);
}
pub inline fn G_SOCKET_ADDRESS_ENUMERATOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SOCKET_ADDRESS_ENUMERATOR, GSocketAddressEnumeratorClass);
}
pub const G_TYPE_PROXY_ADDRESS_ENUMERATOR = g_proxy_address_enumerator_get_type();
pub inline fn G_PROXY_ADDRESS_ENUMERATOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumerator)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumerator);
}
pub inline fn G_PROXY_ADDRESS_ENUMERATOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass);
}
pub inline fn G_IS_PROXY_ADDRESS_ENUMERATOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY_ADDRESS_ENUMERATOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY_ADDRESS_ENUMERATOR);
}
pub inline fn G_IS_PROXY_ADDRESS_ENUMERATOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_PROXY_ADDRESS_ENUMERATOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_PROXY_ADDRESS_ENUMERATOR);
}
pub inline fn G_PROXY_ADDRESS_ENUMERATOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_PROXY_ADDRESS_ENUMERATOR, GProxyAddressEnumeratorClass);
}
pub const __G_PROXY_RESOLVER_H__ = "";
pub const G_TYPE_PROXY_RESOLVER = g_proxy_resolver_get_type();
pub inline fn G_PROXY_RESOLVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY_RESOLVER, GProxyResolver)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_PROXY_RESOLVER, GProxyResolver);
}
pub inline fn G_IS_PROXY_RESOLVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY_RESOLVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_PROXY_RESOLVER);
}
pub inline fn G_PROXY_RESOLVER_GET_IFACE(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_PROXY_RESOLVER, GProxyResolverInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(o, G_TYPE_PROXY_RESOLVER, GProxyResolverInterface);
}
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME = "gio-proxy-resolver";
pub const __G_REMOTE_ACTION_GROUP_H__ = "";
pub const G_TYPE_REMOTE_ACTION_GROUP = g_remote_action_group_get_type();
pub inline fn G_REMOTE_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroup);
}
pub inline fn G_IS_REMOTE_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_REMOTE_ACTION_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_REMOTE_ACTION_GROUP);
}
pub inline fn G_REMOTE_ACTION_GROUP_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroupInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_REMOTE_ACTION_GROUP, GRemoteActionGroupInterface);
}
pub const __G_RESOLVER_H__ = "";
pub const G_TYPE_RESOLVER = g_resolver_get_type();
pub inline fn G_RESOLVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_RESOLVER, GResolver)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_RESOLVER, GResolver);
}
pub inline fn G_RESOLVER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_RESOLVER, GResolverClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_RESOLVER, GResolverClass);
}
pub inline fn G_IS_RESOLVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_RESOLVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_RESOLVER);
}
pub inline fn G_IS_RESOLVER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_RESOLVER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_RESOLVER);
}
pub inline fn G_RESOLVER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_RESOLVER, GResolverClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_RESOLVER, GResolverClass);
}
pub const G_RESOLVER_ERROR = g_resolver_error_quark();
pub const __G_RESOURCE_H__ = "";
pub const G_TYPE_RESOURCE = g_resource_get_type();
pub const G_RESOURCE_ERROR = g_resource_error_quark();
pub const __G_SEEKABLE_H__ = "";
pub const G_TYPE_SEEKABLE = g_seekable_get_type();
pub inline fn G_SEEKABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SEEKABLE, GSeekable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SEEKABLE, GSeekable);
}
pub inline fn G_IS_SEEKABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SEEKABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SEEKABLE);
}
pub inline fn G_SEEKABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_SEEKABLE, GSeekableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_SEEKABLE, GSeekableIface);
}
pub const __G_SETTINGS_H__ = "";
pub const __G_SETTINGS_SCHEMA_H__ = "";
pub const G_TYPE_SETTINGS_SCHEMA_SOURCE = g_settings_schema_source_get_type();
pub const G_TYPE_SETTINGS_SCHEMA = g_settings_schema_get_type();
pub const G_TYPE_SETTINGS_SCHEMA_KEY = g_settings_schema_key_get_type();
pub const G_TYPE_SETTINGS = g_settings_get_type();
pub inline fn G_SETTINGS(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SETTINGS, GSettings)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SETTINGS, GSettings);
}
pub inline fn G_SETTINGS_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SETTINGS, GSettingsClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SETTINGS, GSettingsClass);
}
pub inline fn G_IS_SETTINGS(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SETTINGS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SETTINGS);
}
pub inline fn G_IS_SETTINGS_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SETTINGS)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SETTINGS);
}
pub inline fn G_SETTINGS_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SETTINGS, GSettingsClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SETTINGS, GSettingsClass);
}
pub const __G_SIMPLE_ACTION_H__ = "";
pub const G_TYPE_SIMPLE_ACTION = g_simple_action_get_type();
pub inline fn G_SIMPLE_ACTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SIMPLE_ACTION, GSimpleAction)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SIMPLE_ACTION, GSimpleAction);
}
pub inline fn G_IS_SIMPLE_ACTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SIMPLE_ACTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SIMPLE_ACTION);
}
pub const __G_SIMPLE_ACTION_GROUP_H__ = "";
pub const G_TYPE_SIMPLE_ACTION_GROUP = g_simple_action_group_get_type();
pub inline fn G_SIMPLE_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroup);
}
pub inline fn G_SIMPLE_ACTION_GROUP_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass);
}
pub inline fn G_IS_SIMPLE_ACTION_GROUP(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SIMPLE_ACTION_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SIMPLE_ACTION_GROUP);
}
pub inline fn G_IS_SIMPLE_ACTION_GROUP_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SIMPLE_ACTION_GROUP)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SIMPLE_ACTION_GROUP);
}
pub inline fn G_SIMPLE_ACTION_GROUP_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SIMPLE_ACTION_GROUP, GSimpleActionGroupClass);
}
pub const __G_SIMPLE_ASYNC_RESULT_H__ = "";
pub const G_TYPE_SIMPLE_ASYNC_RESULT = g_simple_async_result_get_type();
pub inline fn G_SIMPLE_ASYNC_RESULT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResult)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResult);
}
pub inline fn G_SIMPLE_ASYNC_RESULT_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass);
}
pub inline fn G_IS_SIMPLE_ASYNC_RESULT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SIMPLE_ASYNC_RESULT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SIMPLE_ASYNC_RESULT);
}
pub inline fn G_IS_SIMPLE_ASYNC_RESULT_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SIMPLE_ASYNC_RESULT)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SIMPLE_ASYNC_RESULT);
}
pub inline fn G_SIMPLE_ASYNC_RESULT_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SIMPLE_ASYNC_RESULT, GSimpleAsyncResultClass);
}
pub const __G_SIMPLE_IO_STREAM_H__ = "";
pub const G_TYPE_SIMPLE_IO_STREAM = g_simple_io_stream_get_type();
pub inline fn G_SIMPLE_IO_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SIMPLE_IO_STREAM, GSimpleIOStream)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SIMPLE_IO_STREAM, GSimpleIOStream);
}
pub inline fn G_IS_SIMPLE_IO_STREAM(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SIMPLE_IO_STREAM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SIMPLE_IO_STREAM);
}
pub const __G_SIMPLE_PERMISSION_H__ = "";
pub const G_TYPE_SIMPLE_PERMISSION = g_simple_permission_get_type();
pub inline fn G_SIMPLE_PERMISSION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SIMPLE_PERMISSION, GSimplePermission)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SIMPLE_PERMISSION, GSimplePermission);
}
pub inline fn G_IS_SIMPLE_PERMISSION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SIMPLE_PERMISSION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SIMPLE_PERMISSION);
}
pub const __G_SIMPLE_PROXY_RESOLVER_H__ = "";
pub const G_TYPE_SIMPLE_PROXY_RESOLVER = g_simple_proxy_resolver_get_type();
pub inline fn G_SIMPLE_PROXY_RESOLVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolver)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolver);
}
pub inline fn G_SIMPLE_PROXY_RESOLVER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass);
}
pub inline fn G_IS_SIMPLE_PROXY_RESOLVER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SIMPLE_PROXY_RESOLVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SIMPLE_PROXY_RESOLVER);
}
pub inline fn G_IS_SIMPLE_PROXY_RESOLVER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SIMPLE_PROXY_RESOLVER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_SIMPLE_PROXY_RESOLVER);
}
pub inline fn G_SIMPLE_PROXY_RESOLVER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_SIMPLE_PROXY_RESOLVER, GSimpleProxyResolverClass);
}
pub const __G_SOCKET_H__ = "";
pub const G_TYPE_SOCKET = g_socket_get_type();
pub inline fn G_SOCKET(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET, GSocket)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET, GSocket);
}
pub inline fn G_SOCKET_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET, GSocketClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET, GSocketClass);
}
pub inline fn G_IS_SOCKET(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET);
}
pub inline fn G_IS_SOCKET_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET);
}
pub inline fn G_SOCKET_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET, GSocketClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET, GSocketClass);
}
pub const __G_SOCKET_CLIENT_H__ = "";
pub const G_TYPE_SOCKET_CLIENT = g_socket_client_get_type();
pub inline fn G_SOCKET_CLIENT(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_CLIENT, GSocketClient)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_CLIENT, GSocketClient);
}
pub inline fn G_SOCKET_CLIENT_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_CLIENT, GSocketClientClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_CLIENT, GSocketClientClass);
}
pub inline fn G_IS_SOCKET_CLIENT(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_CLIENT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_CLIENT);
}
pub inline fn G_IS_SOCKET_CLIENT_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_CLIENT)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_CLIENT);
}
pub inline fn G_SOCKET_CLIENT_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_CLIENT, GSocketClientClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_CLIENT, GSocketClientClass);
}
pub const __G_SOCKET_CONNECTABLE_H__ = "";
pub const G_TYPE_SOCKET_CONNECTABLE = g_socket_connectable_get_type();
pub inline fn G_SOCKET_CONNECTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_SOCKET_CONNECTABLE, GSocketConnectable);
}
pub inline fn G_IS_SOCKET_CONNECTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SOCKET_CONNECTABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_SOCKET_CONNECTABLE);
}
pub inline fn G_SOCKET_CONNECTABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_SOCKET_CONNECTABLE, GSocketConnectableIface);
}
pub const __G_SOCKET_CONNECTION_H__ = "";
pub const G_TYPE_SOCKET_CONNECTION = g_socket_connection_get_type();
pub inline fn G_SOCKET_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_CONNECTION, GSocketConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_CONNECTION, GSocketConnection);
}
pub inline fn G_SOCKET_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass);
}
pub inline fn G_IS_SOCKET_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_CONNECTION);
}
pub inline fn G_IS_SOCKET_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_CONNECTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_CONNECTION);
}
pub inline fn G_SOCKET_CONNECTION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_CONNECTION, GSocketConnectionClass);
}
pub const __G_SOCKET_CONTROL_MESSAGE_H__ = "";
pub const G_TYPE_SOCKET_CONTROL_MESSAGE = g_socket_control_message_get_type();
pub inline fn G_SOCKET_CONTROL_MESSAGE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessage);
}
pub inline fn G_SOCKET_CONTROL_MESSAGE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessageClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessageClass);
}
pub inline fn G_IS_SOCKET_CONTROL_MESSAGE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_CONTROL_MESSAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_CONTROL_MESSAGE);
}
pub inline fn G_IS_SOCKET_CONTROL_MESSAGE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_CONTROL_MESSAGE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_CONTROL_MESSAGE);
}
pub inline fn G_SOCKET_CONTROL_MESSAGE_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessageClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_CONTROL_MESSAGE, GSocketControlMessageClass);
}
pub const __G_SOCKET_LISTENER_H__ = "";
pub const G_TYPE_SOCKET_LISTENER = g_socket_listener_get_type();
pub inline fn G_SOCKET_LISTENER(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_LISTENER, GSocketListener)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_LISTENER, GSocketListener);
}
pub inline fn G_SOCKET_LISTENER_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_LISTENER, GSocketListenerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_LISTENER, GSocketListenerClass);
}
pub inline fn G_IS_SOCKET_LISTENER(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_LISTENER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_LISTENER);
}
pub inline fn G_IS_SOCKET_LISTENER_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_LISTENER)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_LISTENER);
}
pub inline fn G_SOCKET_LISTENER_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_LISTENER, GSocketListenerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_LISTENER, GSocketListenerClass);
}
pub const __G_SOCKET_SERVICE_H__ = "";
pub const G_TYPE_SOCKET_SERVICE = g_socket_service_get_type();
pub inline fn G_SOCKET_SERVICE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_SERVICE, GSocketService)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_SOCKET_SERVICE, GSocketService);
}
pub inline fn G_SOCKET_SERVICE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_SERVICE, GSocketServiceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_SOCKET_SERVICE, GSocketServiceClass);
}
pub inline fn G_IS_SOCKET_SERVICE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_SERVICE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_SOCKET_SERVICE);
}
pub inline fn G_IS_SOCKET_SERVICE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_SERVICE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_SOCKET_SERVICE);
}
pub inline fn G_SOCKET_SERVICE_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_SERVICE, GSocketServiceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_SOCKET_SERVICE, GSocketServiceClass);
}
pub const __G_SRV_TARGET_H__ = "";
pub const G_TYPE_SRV_TARGET = g_srv_target_get_type();
pub const __G_SUBPROCESS_H__ = "";
pub const G_TYPE_SUBPROCESS = g_subprocess_get_type();
pub inline fn G_SUBPROCESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SUBPROCESS, GSubprocess)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SUBPROCESS, GSubprocess);
}
pub inline fn G_IS_SUBPROCESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SUBPROCESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SUBPROCESS);
}
pub const __G_SUBPROCESS_LAUNCHER_H__ = "";
pub const G_TYPE_SUBPROCESS_LAUNCHER = g_subprocess_launcher_get_type();
pub inline fn G_SUBPROCESS_LAUNCHER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SUBPROCESS_LAUNCHER, GSubprocessLauncher)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_SUBPROCESS_LAUNCHER, GSubprocessLauncher);
}
pub inline fn G_IS_SUBPROCESS_LAUNCHER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SUBPROCESS_LAUNCHER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_SUBPROCESS_LAUNCHER);
}
pub const __G_TASK_H__ = "";
pub const G_TYPE_TASK = g_task_get_type();
pub inline fn G_TASK(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_TASK, GTask)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_TASK, GTask);
}
pub inline fn G_TASK_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_TASK, GTaskClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_TASK, GTaskClass);
}
pub inline fn G_IS_TASK(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_TASK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_TASK);
}
pub inline fn G_IS_TASK_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_TASK)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_TASK);
}
pub inline fn G_TASK_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_TASK, GTaskClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_TASK, GTaskClass);
}
pub const __G_TCP_CONNECTION_H__ = "";
pub const G_TYPE_TCP_CONNECTION = g_tcp_connection_get_type();
pub inline fn G_TCP_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TCP_CONNECTION, GTcpConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TCP_CONNECTION, GTcpConnection);
}
pub inline fn G_TCP_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TCP_CONNECTION, GTcpConnectionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TCP_CONNECTION, GTcpConnectionClass);
}
pub inline fn G_IS_TCP_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TCP_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TCP_CONNECTION);
}
pub inline fn G_IS_TCP_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TCP_CONNECTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TCP_CONNECTION);
}
pub inline fn G_TCP_CONNECTION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TCP_CONNECTION, GTcpConnectionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TCP_CONNECTION, GTcpConnectionClass);
}
pub const __G_TCP_WRAPPER_CONNECTION_H__ = "";
pub const G_TYPE_TCP_WRAPPER_CONNECTION = g_tcp_wrapper_connection_get_type();
pub inline fn G_TCP_WRAPPER_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnection);
}
pub inline fn G_TCP_WRAPPER_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass);
}
pub inline fn G_IS_TCP_WRAPPER_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TCP_WRAPPER_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TCP_WRAPPER_CONNECTION);
}
pub inline fn G_IS_TCP_WRAPPER_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TCP_WRAPPER_CONNECTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TCP_WRAPPER_CONNECTION);
}
pub inline fn G_TCP_WRAPPER_CONNECTION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TCP_WRAPPER_CONNECTION, GTcpWrapperConnectionClass);
}
pub const __G_TEST_DBUS_H__ = "";
pub const G_TYPE_TEST_DBUS = g_test_dbus_get_type();
pub inline fn G_TEST_DBUS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_TEST_DBUS, GTestDBus)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_TEST_DBUS, GTestDBus);
}
pub inline fn G_IS_TEST_DBUS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_TEST_DBUS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_TEST_DBUS);
}
pub const __G_THEMED_ICON_H__ = "";
pub const G_TYPE_THEMED_ICON = g_themed_icon_get_type();
pub inline fn G_THEMED_ICON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_THEMED_ICON, GThemedIcon)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_THEMED_ICON, GThemedIcon);
}
pub inline fn G_THEMED_ICON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_THEMED_ICON, GThemedIconClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_THEMED_ICON, GThemedIconClass);
}
pub inline fn G_IS_THEMED_ICON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_THEMED_ICON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_THEMED_ICON);
}
pub inline fn G_IS_THEMED_ICON_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_THEMED_ICON)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_THEMED_ICON);
}
pub inline fn G_THEMED_ICON_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_THEMED_ICON, GThemedIconClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_THEMED_ICON, GThemedIconClass);
}
pub const __G_THREADED_SOCKET_SERVICE_H__ = "";
pub const G_TYPE_THREADED_SOCKET_SERVICE = g_threaded_socket_service_get_type();
pub inline fn G_THREADED_SOCKET_SERVICE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketService)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketService);
}
pub inline fn G_THREADED_SOCKET_SERVICE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketServiceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketServiceClass);
}
pub inline fn G_IS_THREADED_SOCKET_SERVICE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_THREADED_SOCKET_SERVICE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_THREADED_SOCKET_SERVICE);
}
pub inline fn G_IS_THREADED_SOCKET_SERVICE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_THREADED_SOCKET_SERVICE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_THREADED_SOCKET_SERVICE);
}
pub inline fn G_THREADED_SOCKET_SERVICE_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketServiceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_THREADED_SOCKET_SERVICE, GThreadedSocketServiceClass);
}
pub const __G_TLS_BACKEND_H__ = "";
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME = "gio-tls-backend";
pub const G_TYPE_TLS_BACKEND = g_tls_backend_get_type();
pub inline fn G_TLS_BACKEND(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_TLS_BACKEND, GTlsBackend)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_TLS_BACKEND, GTlsBackend);
}
pub inline fn G_IS_TLS_BACKEND(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_TLS_BACKEND)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_TLS_BACKEND);
}
pub inline fn G_TLS_BACKEND_GET_INTERFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_TLS_BACKEND, GTlsBackendInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_TLS_BACKEND, GTlsBackendInterface);
}
pub const __G_TLS_CERTIFICATE_H__ = "";
pub const G_TYPE_TLS_CERTIFICATE = g_tls_certificate_get_type();
pub inline fn G_TLS_CERTIFICATE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_CERTIFICATE, GTlsCertificate)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_CERTIFICATE, GTlsCertificate);
}
pub inline fn G_TLS_CERTIFICATE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass);
}
pub inline fn G_IS_TLS_CERTIFICATE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_CERTIFICATE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_CERTIFICATE);
}
pub inline fn G_IS_TLS_CERTIFICATE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TLS_CERTIFICATE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TLS_CERTIFICATE);
}
pub inline fn G_TLS_CERTIFICATE_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TLS_CERTIFICATE, GTlsCertificateClass);
}
pub const __G_TLS_CLIENT_CONNECTION_H__ = "";
pub const __G_TLS_CONNECTION_H__ = "";
pub const G_TYPE_TLS_CONNECTION = g_tls_connection_get_type();
pub inline fn G_TLS_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_CONNECTION, GTlsConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_CONNECTION, GTlsConnection);
}
pub inline fn G_TLS_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TLS_CONNECTION, GTlsConnectionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TLS_CONNECTION, GTlsConnectionClass);
}
pub inline fn G_IS_TLS_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_CONNECTION);
}
pub inline fn G_IS_TLS_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TLS_CONNECTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TLS_CONNECTION);
}
pub inline fn G_TLS_CONNECTION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TLS_CONNECTION, GTlsConnectionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TLS_CONNECTION, GTlsConnectionClass);
}
pub const G_TLS_ERROR = g_tls_error_quark();
pub const G_TLS_CHANNEL_BINDING_ERROR = g_tls_channel_binding_error_quark();
pub const G_TYPE_TLS_CLIENT_CONNECTION = g_tls_client_connection_get_type();
pub inline fn G_TLS_CLIENT_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnection);
}
pub inline fn G_IS_TLS_CLIENT_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_CLIENT_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_CLIENT_CONNECTION);
}
pub inline fn G_TLS_CLIENT_CONNECTION_GET_INTERFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnectionInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TLS_CLIENT_CONNECTION, GTlsClientConnectionInterface);
}
pub const __G_TLS_DATABASE_H__ = "";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = "1.3.6.1.5.5.7.3.1";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = "1.3.6.1.5.5.7.3.2";
pub const G_TYPE_TLS_DATABASE = g_tls_database_get_type();
pub inline fn G_TLS_DATABASE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_DATABASE, GTlsDatabase)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_DATABASE, GTlsDatabase);
}
pub inline fn G_TLS_DATABASE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TLS_DATABASE, GTlsDatabaseClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_TLS_DATABASE, GTlsDatabaseClass);
}
pub inline fn G_IS_TLS_DATABASE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_DATABASE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_DATABASE);
}
pub inline fn G_IS_TLS_DATABASE_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TLS_DATABASE)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_TLS_DATABASE);
}
pub inline fn G_TLS_DATABASE_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TLS_DATABASE, GTlsDatabaseClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_TLS_DATABASE, GTlsDatabaseClass);
}
pub const __G_TLS_FILE_DATABASE_H__ = "";
pub const G_TYPE_TLS_FILE_DATABASE = g_tls_file_database_get_type();
pub inline fn G_TLS_FILE_DATABASE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabase)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabase);
}
pub inline fn G_IS_TLS_FILE_DATABASE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_FILE_DATABASE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_FILE_DATABASE);
}
pub inline fn G_TLS_FILE_DATABASE_GET_INTERFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabaseInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TLS_FILE_DATABASE, GTlsFileDatabaseInterface);
}
pub const __G_TLS_INTERACTION_H__ = "";
pub const G_TYPE_TLS_INTERACTION = g_tls_interaction_get_type();
pub inline fn G_TLS_INTERACTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_TLS_INTERACTION, GTlsInteraction)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_TLS_INTERACTION, GTlsInteraction);
}
pub inline fn G_TLS_INTERACTION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_TLS_INTERACTION, GTlsInteractionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_TLS_INTERACTION, GTlsInteractionClass);
}
pub inline fn G_IS_TLS_INTERACTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_TLS_INTERACTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_TLS_INTERACTION);
}
pub inline fn G_IS_TLS_INTERACTION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_TLS_INTERACTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_TLS_INTERACTION);
}
pub inline fn G_TLS_INTERACTION_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_TLS_INTERACTION, GTlsInteractionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_TLS_INTERACTION, GTlsInteractionClass);
}
pub const __G_TLS_PASSWORD_H__ = "";
pub const G_TYPE_TLS_PASSWORD = g_tls_password_get_type();
pub inline fn G_TLS_PASSWORD(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_TLS_PASSWORD, GTlsPassword)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_TLS_PASSWORD, GTlsPassword);
}
pub inline fn G_TLS_PASSWORD_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_TLS_PASSWORD, GTlsPasswordClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_TLS_PASSWORD, GTlsPasswordClass);
}
pub inline fn G_IS_TLS_PASSWORD(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_TLS_PASSWORD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_TLS_PASSWORD);
}
pub inline fn G_IS_TLS_PASSWORD_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_TLS_PASSWORD)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_TLS_PASSWORD);
}
pub inline fn G_TLS_PASSWORD_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_TLS_PASSWORD, GTlsPasswordClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_TLS_PASSWORD, GTlsPasswordClass);
}
pub const __G_TLS_SERVER_CONNECTION_H__ = "";
pub const G_TYPE_TLS_SERVER_CONNECTION = g_tls_server_connection_get_type();
pub inline fn G_TLS_SERVER_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnection);
}
pub inline fn G_IS_TLS_SERVER_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_SERVER_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_TLS_SERVER_CONNECTION);
}
pub inline fn G_TLS_SERVER_CONNECTION_GET_INTERFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnectionInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, G_TYPE_TLS_SERVER_CONNECTION, GTlsServerConnectionInterface);
}
pub const __G_UNIX_CONNECTION_H__ = "";
pub const G_TYPE_UNIX_CONNECTION = g_unix_connection_get_type();
pub inline fn G_UNIX_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_UNIX_CONNECTION, GUnixConnection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_UNIX_CONNECTION, GUnixConnection);
}
pub inline fn G_UNIX_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_UNIX_CONNECTION, GUnixConnectionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_UNIX_CONNECTION, GUnixConnectionClass);
}
pub inline fn G_IS_UNIX_CONNECTION(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_UNIX_CONNECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_UNIX_CONNECTION);
}
pub inline fn G_IS_UNIX_CONNECTION_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_UNIX_CONNECTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_UNIX_CONNECTION);
}
pub inline fn G_UNIX_CONNECTION_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_UNIX_CONNECTION, GUnixConnectionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_UNIX_CONNECTION, GUnixConnectionClass);
}
pub const __G_UNIX_CREDENTIALS_MESSAGE_H__ = "";
pub const G_TYPE_UNIX_CREDENTIALS_MESSAGE = g_unix_credentials_message_get_type();
pub inline fn G_UNIX_CREDENTIALS_MESSAGE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessage);
}
pub inline fn G_UNIX_CREDENTIALS_MESSAGE_CLASS(c: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(c, G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass)) {
    return G_TYPE_CHECK_CLASS_CAST(c, G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass);
}
pub inline fn G_IS_UNIX_CREDENTIALS_MESSAGE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_UNIX_CREDENTIALS_MESSAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_UNIX_CREDENTIALS_MESSAGE);
}
pub inline fn G_IS_UNIX_CREDENTIALS_MESSAGE_CLASS(c: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(c, G_TYPE_UNIX_CREDENTIALS_MESSAGE)) {
    return G_TYPE_CHECK_CLASS_TYPE(c, G_TYPE_UNIX_CREDENTIALS_MESSAGE);
}
pub inline fn G_UNIX_CREDENTIALS_MESSAGE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_UNIX_CREDENTIALS_MESSAGE, GUnixCredentialsMessageClass);
}
pub const __G_UNIX_FD_LIST_H__ = "";
pub const G_TYPE_UNIX_FD_LIST = g_unix_fd_list_get_type();
pub inline fn G_UNIX_FD_LIST(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_UNIX_FD_LIST, GUnixFDList)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, G_TYPE_UNIX_FD_LIST, GUnixFDList);
}
pub inline fn G_UNIX_FD_LIST_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_UNIX_FD_LIST, GUnixFDListClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, G_TYPE_UNIX_FD_LIST, GUnixFDListClass);
}
pub inline fn G_IS_UNIX_FD_LIST(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_UNIX_FD_LIST)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, G_TYPE_UNIX_FD_LIST);
}
pub inline fn G_IS_UNIX_FD_LIST_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_UNIX_FD_LIST)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, G_TYPE_UNIX_FD_LIST);
}
pub inline fn G_UNIX_FD_LIST_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_UNIX_FD_LIST, GUnixFDListClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, G_TYPE_UNIX_FD_LIST, GUnixFDListClass);
}
pub const __G_UNIX_SOCKET_ADDRESS_H__ = "";
pub const G_TYPE_UNIX_SOCKET_ADDRESS = g_unix_socket_address_get_type();
pub inline fn G_UNIX_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddress);
}
pub inline fn G_UNIX_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass);
}
pub inline fn G_IS_UNIX_SOCKET_ADDRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_UNIX_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_UNIX_SOCKET_ADDRESS);
}
pub inline fn G_IS_UNIX_SOCKET_ADDRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_UNIX_SOCKET_ADDRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_UNIX_SOCKET_ADDRESS);
}
pub inline fn G_UNIX_SOCKET_ADDRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_UNIX_SOCKET_ADDRESS, GUnixSocketAddressClass);
}
pub const __G_VFS_H__ = "";
pub const G_TYPE_VFS = g_vfs_get_type();
pub inline fn G_VFS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_VFS, GVfs)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_VFS, GVfs);
}
pub inline fn G_VFS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_VFS, GVfsClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_VFS, GVfsClass);
}
pub inline fn G_VFS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_VFS, GVfsClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_VFS, GVfsClass);
}
pub inline fn G_IS_VFS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_VFS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_VFS);
}
pub inline fn G_IS_VFS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_VFS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_VFS);
}
pub const G_VFS_EXTENSION_POINT_NAME = "gio-vfs";
pub const __G_VOLUME_H__ = "";
pub const G_VOLUME_IDENTIFIER_KIND_HAL_UDI = "hal-udi" ++ GIO_DEPRECATED_MACRO_IN_2_58;
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = "unix-device";
pub const G_VOLUME_IDENTIFIER_KIND_LABEL = "label";
pub const G_VOLUME_IDENTIFIER_KIND_UUID = "uuid";
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT = "nfs-mount";
pub const G_VOLUME_IDENTIFIER_KIND_CLASS = "class";
pub const G_TYPE_VOLUME = g_volume_get_type();
pub inline fn G_VOLUME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_VOLUME, GVolume)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, G_TYPE_VOLUME, GVolume);
}
pub inline fn G_IS_VOLUME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_VOLUME)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, G_TYPE_VOLUME);
}
pub inline fn G_VOLUME_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_VOLUME, GVolumeIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, G_TYPE_VOLUME, GVolumeIface);
}
pub const __G_ZLIB_COMPRESSOR_H__ = "";
pub const G_TYPE_ZLIB_COMPRESSOR = g_zlib_compressor_get_type();
pub inline fn G_ZLIB_COMPRESSOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_ZLIB_COMPRESSOR, GZlibCompressor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_ZLIB_COMPRESSOR, GZlibCompressor);
}
pub inline fn G_ZLIB_COMPRESSOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass);
}
pub inline fn G_IS_ZLIB_COMPRESSOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_ZLIB_COMPRESSOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_ZLIB_COMPRESSOR);
}
pub inline fn G_IS_ZLIB_COMPRESSOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_ZLIB_COMPRESSOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_ZLIB_COMPRESSOR);
}
pub inline fn G_ZLIB_COMPRESSOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_ZLIB_COMPRESSOR, GZlibCompressorClass);
}
pub const __G_ZLIB_DECOMPRESSOR_H__ = "";
pub const G_TYPE_ZLIB_DECOMPRESSOR = g_zlib_decompressor_get_type();
pub inline fn G_ZLIB_DECOMPRESSOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressor);
}
pub inline fn G_ZLIB_DECOMPRESSOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass);
}
pub inline fn G_IS_ZLIB_DECOMPRESSOR(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_ZLIB_DECOMPRESSOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, G_TYPE_ZLIB_DECOMPRESSOR);
}
pub inline fn G_IS_ZLIB_DECOMPRESSOR_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_ZLIB_DECOMPRESSOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, G_TYPE_ZLIB_DECOMPRESSOR);
}
pub inline fn G_ZLIB_DECOMPRESSOR_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, G_TYPE_ZLIB_DECOMPRESSOR, GZlibDecompressorClass);
}
pub const GTK_TYPE_CSS_SECTION = gtk_css_section_get_type();
pub const __GDK_H_INSIDE__ = "";
pub const CAIRO_H = "";
pub const CAIRO_VERSION_H = "";
pub const CAIRO_VERSION_MAJOR = @as(c_int, 1);
pub const CAIRO_VERSION_MINOR = @as(c_int, 18);
pub const CAIRO_VERSION_MICRO = @as(c_int, 0);
pub const CAIRO_FEATURES_H = "";
pub const CAIRO_HAS_FC_FONT = @as(c_int, 1);
pub const CAIRO_HAS_FT_FONT = @as(c_int, 1);
pub const CAIRO_HAS_GOBJECT_FUNCTIONS = @as(c_int, 1);
pub const CAIRO_HAS_IMAGE_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_MIME_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_OBSERVER_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_PDF_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_PNG_FUNCTIONS = @as(c_int, 1);
pub const CAIRO_HAS_PS_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_RECORDING_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_SCRIPT_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_SVG_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_TEE_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_USER_FONT = @as(c_int, 1);
pub const CAIRO_HAS_XCB_SHM_FUNCTIONS = @as(c_int, 1);
pub const CAIRO_HAS_XCB_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_XLIB_SURFACE = @as(c_int, 1);
pub const CAIRO_HAS_XLIB_XRENDER_SURFACE = @as(c_int, 1);
pub const CAIRO_DEPRECATED_H = "";
pub const CAIRO_FONT_TYPE_ATSUI = CAIRO_FONT_TYPE_QUARTZ;
pub const CAIRO_BEGIN_DECLS = "";
pub const CAIRO_END_DECLS = "";
pub const _cairo_import = "";
pub const _cairo_api = _cairo_import;
pub inline fn CAIRO_VERSION_ENCODE(major: anytype, minor: anytype, micro: anytype) @TypeOf(((major * @as(c_int, 10000)) + (minor * @as(c_int, 100))) + (micro * @as(c_int, 1))) {
    return ((major * @as(c_int, 10000)) + (minor * @as(c_int, 100))) + (micro * @as(c_int, 1));
}
pub const CAIRO_VERSION = CAIRO_VERSION_ENCODE(CAIRO_VERSION_MAJOR, CAIRO_VERSION_MINOR, CAIRO_VERSION_MICRO);
pub inline fn CAIRO_VERSION_STRINGIZE(major: anytype, minor: anytype, micro: anytype) @TypeOf(CAIRO_VERSION_STRINGIZE_(major, minor, micro)) {
    return CAIRO_VERSION_STRINGIZE_(major, minor, micro);
}
pub const CAIRO_VERSION_STRING = CAIRO_VERSION_STRINGIZE(CAIRO_VERSION_MAJOR, CAIRO_VERSION_MINOR, CAIRO_VERSION_MICRO);
pub const CAIRO_TAG_DEST = "cairo.dest";
pub const CAIRO_TAG_LINK = "Link";
pub const CAIRO_TAG_CONTENT = "cairo.content";
pub const CAIRO_TAG_CONTENT_REF = "cairo.content_ref";
pub const CAIRO_COLOR_PALETTE_DEFAULT = @as(c_int, 0);
pub const CAIRO_MIME_TYPE_JPEG = "image/jpeg";
pub const CAIRO_MIME_TYPE_PNG = "image/png";
pub const CAIRO_MIME_TYPE_JP2 = "image/jp2";
pub const CAIRO_MIME_TYPE_URI = "text/x-uri";
pub const CAIRO_MIME_TYPE_UNIQUE_ID = "application/x-cairo.uuid";
pub const CAIRO_MIME_TYPE_JBIG2 = "application/x-cairo.jbig2";
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL = "application/x-cairo.jbig2-global";
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID = "application/x-cairo.jbig2-global-id";
pub const CAIRO_MIME_TYPE_CCITT_FAX = "image/g3fax";
pub const CAIRO_MIME_TYPE_CCITT_FAX_PARAMS = "application/x-cairo.ccitt.params";
pub const CAIRO_MIME_TYPE_EPS = "application/postscript";
pub const CAIRO_MIME_TYPE_EPS_PARAMS = "application/x-cairo.eps.params";
pub const __PANGO_H__ = "";
pub const __PANGO_ATTRIBUTES_H__ = "";
pub const __PANGO_FONT_H__ = "";
pub const __PANGO_COVERAGE_H__ = "";
pub const __PANGO_VERSION_H__ = "";
pub const PANGO_FEATURES_H = "";
pub const PANGO_VERSION_MAJOR = @as(c_int, 1);
pub const PANGO_VERSION_MINOR = @as(c_int, 51);
pub const PANGO_VERSION_MICRO = @as(c_int, 0);
pub const PANGO_VERSION_STRING = "1.51.0";
pub const PANGO_AVAILABLE_IN_ALL = _PANGO_EXTERN;
pub const PANGO_VERSION_1_2 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 2));
pub const PANGO_VERSION_1_4 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 4));
pub const PANGO_VERSION_1_6 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 6));
pub const PANGO_VERSION_1_8 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 8));
pub const PANGO_VERSION_1_10 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 10));
pub const PANGO_VERSION_1_12 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 12));
pub const PANGO_VERSION_1_14 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 14));
pub const PANGO_VERSION_1_16 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 16));
pub const PANGO_VERSION_1_18 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 18));
pub const PANGO_VERSION_1_20 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 20));
pub const PANGO_VERSION_1_22 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 22));
pub const PANGO_VERSION_1_24 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 24));
pub const PANGO_VERSION_1_26 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 26));
pub const PANGO_VERSION_1_28 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 28));
pub const PANGO_VERSION_1_30 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 30));
pub const PANGO_VERSION_1_32 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 32));
pub const PANGO_VERSION_1_34 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 34));
pub const PANGO_VERSION_1_36 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 36));
pub const PANGO_VERSION_1_38 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 38));
pub const PANGO_VERSION_1_40 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 40));
pub const PANGO_VERSION_1_42 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 42));
pub const PANGO_VERSION_1_44 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 44));
pub const PANGO_VERSION_1_46 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 46));
pub const PANGO_VERSION_1_48 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 48));
pub const PANGO_VERSION_1_50 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 50));
pub const PANGO_VERSION_1_52 = G_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 52));
pub const PANGO_VERSION_CUR_STABLE = G_ENCODE_VERSION(PANGO_VERSION_MAJOR, PANGO_VERSION_MINOR + @as(c_int, 1));
pub const PANGO_VERSION_PREV_STABLE = G_ENCODE_VERSION(PANGO_VERSION_MAJOR, PANGO_VERSION_MINOR - @as(c_int, 1));
pub const PANGO_VERSION_MIN_REQUIRED = PANGO_VERSION_CUR_STABLE;
pub const PANGO_VERSION_MAX_ALLOWED = PANGO_VERSION_CUR_STABLE;
pub const PANGO_DEPRECATED = G_DEPRECATED ++ _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_2 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_2_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_2 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_4 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_4_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_4 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_6 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_6_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_6 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_8 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_8_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_8 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_10 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_10_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_10 = _PANGO_EXTERN;
pub const PANGO_AVAILABLE_IN_1_12 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_12 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_12_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_14 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_14 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_14_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_16 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_16 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_16_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_DEPRECATED_IN_1_18 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_18_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_18 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_20 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_20_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_20 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_22 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_22_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_22 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_24 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_24_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_24 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_26 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_26_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_26 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_28 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_28_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_28 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_30 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_30_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_30 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_32 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_32_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_32 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_34 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_34_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_34 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_36 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_36_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_36 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_38 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_38_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_38 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_40 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_40_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_40 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_42 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_42_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_42 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_44 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_44_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_44 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_46 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_46_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_46 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_48 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_48_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_48 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_50 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_50_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_50 = _PANGO_EXTERN;
pub const PANGO_DEPRECATED_IN_1_52 = PANGO_DEPRECATED;
pub inline fn PANGO_DEPRECATED_IN_1_52_FOR(f: anytype) @TypeOf(PANGO_DEPRECATED_FOR(f)) {
    return PANGO_DEPRECATED_FOR(f);
}
pub const PANGO_AVAILABLE_IN_1_52 = _PANGO_EXTERN;
pub const HB_H = "";
pub const HB_H_IN = "";
pub const HB_BLOB_H = "";
pub const HB_COMMON_H = "";
pub const HB_BEGIN_DECLS = "";
pub const HB_END_DECLS = "";
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H = @as(c_int, 1);
pub const _BITS_WCHAR_H = @as(c_int, 1);
pub const __WCHAR_MAX = __WCHAR_MAX__;
pub const __WCHAR_MIN = -__WCHAR_MAX - @as(c_int, 1);
pub const _BITS_STDINT_UINTN_H = @as(c_int, 1);
pub const __INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_LEAST8_MIN = -@as(c_int, 128);
pub const INT_LEAST16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT_LEAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT_LEAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_LEAST8_MAX = @as(c_int, 127);
pub const INT_LEAST16_MAX = @as(c_int, 32767);
pub const INT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT_LEAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_LEAST8_MAX = @as(c_int, 255);
pub const UINT_LEAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT_LEAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_FAST8_MIN = -@as(c_int, 128);
pub const INT_FAST16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_FAST8_MAX = @as(c_int, 127);
pub const INT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_FAST8_MAX = @as(c_int, 255);
pub const UINT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INTPTR_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const UINTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const INTMAX_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INTMAX_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINTMAX_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const PTRDIFF_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const PTRDIFF_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const SIG_ATOMIC_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const SIG_ATOMIC_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const WCHAR_MIN = __WCHAR_MIN;
pub const WCHAR_MAX = __WCHAR_MAX;
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub inline fn INT8_C(c: anytype) @TypeOf(c) {
    return c;
}
pub inline fn INT16_C(c: anytype) @TypeOf(c) {
    return c;
}
pub inline fn INT32_C(c: anytype) @TypeOf(c) {
    return c;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn UINT8_C(c: anytype) @TypeOf(c) {
    return c;
}
pub inline fn UINT16_C(c: anytype) @TypeOf(c) {
    return c;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub inline fn HB_DEPRECATED_FOR(f: anytype) @TypeOf(HB_DEPRECATED) {
    _ = @TypeOf(f);
    return HB_DEPRECATED;
}
pub const HB_CODEPOINT_INVALID = @import("std").zig.c_translation.cast(hb_codepoint_t, -@as(c_int, 1));
pub inline fn HB_TAG(c1: anytype, c2: anytype, c3: anytype, c4: anytype) hb_tag_t {
    return @import("std").zig.c_translation.cast(hb_tag_t, ((((@import("std").zig.c_translation.cast(u32, c1) & @as(c_int, 0xFF)) << @as(c_int, 24)) | ((@import("std").zig.c_translation.cast(u32, c2) & @as(c_int, 0xFF)) << @as(c_int, 16))) | ((@import("std").zig.c_translation.cast(u32, c3) & @as(c_int, 0xFF)) << @as(c_int, 8))) | (@import("std").zig.c_translation.cast(u32, c4) & @as(c_int, 0xFF)));
}
pub inline fn HB_UNTAG(tag: anytype) u8 {
    return blk: {
        _ = @import("std").zig.c_translation.cast(u8, (tag >> @as(c_int, 24)) & @as(c_int, 0xFF));
        _ = @import("std").zig.c_translation.cast(u8, (tag >> @as(c_int, 16)) & @as(c_int, 0xFF));
        _ = @import("std").zig.c_translation.cast(u8, (tag >> @as(c_int, 8)) & @as(c_int, 0xFF));
        break :blk @import("std").zig.c_translation.cast(u8, tag & @as(c_int, 0xFF));
    };
}
pub const HB_TAG_NONE = HB_TAG(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
pub const HB_TAG_MAX = HB_TAG(@as(c_int, 0xff), @as(c_int, 0xff), @as(c_int, 0xff), @as(c_int, 0xff));
pub const HB_TAG_MAX_SIGNED = HB_TAG(@as(c_int, 0x7f), @as(c_int, 0xff), @as(c_int, 0xff), @as(c_int, 0xff));
pub inline fn HB_DIRECTION_IS_VALID(dir: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 3)) == @as(c_int, 4)) {
    return (@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 3)) == @as(c_int, 4);
}
pub inline fn HB_DIRECTION_IS_HORIZONTAL(dir: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 1)) == @as(c_int, 4)) {
    return (@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 1)) == @as(c_int, 4);
}
pub inline fn HB_DIRECTION_IS_VERTICAL(dir: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 1)) == @as(c_int, 6)) {
    return (@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 1)) == @as(c_int, 6);
}
pub inline fn HB_DIRECTION_IS_FORWARD(dir: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 2)) == @as(c_int, 4)) {
    return (@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 2)) == @as(c_int, 4);
}
pub inline fn HB_DIRECTION_IS_BACKWARD(dir: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 2)) == @as(c_int, 5)) {
    return (@import("std").zig.c_translation.cast(c_uint, dir) & ~@as(c_uint, 2)) == @as(c_int, 5);
}
pub inline fn HB_DIRECTION_REVERSE(dir: anytype) hb_direction_t {
    return @import("std").zig.c_translation.cast(hb_direction_t, @import("std").zig.c_translation.cast(c_uint, dir) ^ @as(c_int, 1));
}
pub const HB_LANGUAGE_INVALID = @import("std").zig.c_translation.cast(hb_language_t, @as(c_int, 0));
pub const HB_FEATURE_GLOBAL_START = @as(c_int, 0);
pub const HB_FEATURE_GLOBAL_END = @import("std").zig.c_translation.cast(c_uint, -@as(c_int, 1));
pub inline fn HB_COLOR(b: anytype, g: anytype, r: anytype, a: anytype) hb_color_t {
    return @import("std").zig.c_translation.cast(hb_color_t, HB_TAG(b, g, r, a));
}
pub const HB_BUFFER_H = "";
pub const HB_UNICODE_H = "";
pub const HB_UNICODE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x10FFFF, .hexadecimal);
pub const HB_FONT_H = "";
pub const HB_FACE_H = "";
pub const HB_MAP_H = "";
pub const HB_SET_H = "";
pub const HB_SET_VALUE_INVALID = HB_CODEPOINT_INVALID;
pub const HB_MAP_VALUE_INVALID = HB_CODEPOINT_INVALID;
pub const HB_DRAW_H = "";
pub const HB_PAINT_H = "";
pub const HB_PAINT_IMAGE_FORMAT_PNG = HB_TAG('p', 'n', 'g', ' ');
pub const HB_PAINT_IMAGE_FORMAT_SVG = HB_TAG('s', 'v', 'g', ' ');
pub const HB_PAINT_IMAGE_FORMAT_BGRA = HB_TAG('B', 'G', 'R', 'A');
pub const HB_FONT_NO_VAR_NAMED_INSTANCE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hexadecimal);
pub const HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT = @as(c_uint, 0xFFFD);
pub const HB_DEPRECATED_H = "";
pub const HB_SCRIPT_CANADIAN_ABORIGINAL = HB_SCRIPT_CANADIAN_SYLLABICS;
pub const HB_BUFFER_FLAGS_DEFAULT = HB_BUFFER_FLAG_DEFAULT;
pub const HB_BUFFER_SERIALIZE_FLAGS_DEFAULT = HB_BUFFER_SERIALIZE_FLAG_DEFAULT;
pub const HB_UNICODE_COMBINING_CLASS_CCC133 = @as(c_int, 133);
pub const HB_UNICODE_MAX_DECOMPOSITION_LEN = @as(c_int, 18) + @as(c_int, 1);
pub const HB_SHAPE_H = "";
pub const HB_SHAPE_PLAN_H = "";
pub const HB_STYLE_H = "";
pub const HB_VERSION_H = "";
pub const HB_VERSION_MAJOR = @as(c_int, 8);
pub const HB_VERSION_MINOR = @as(c_int, 3);
pub const HB_VERSION_MICRO = @as(c_int, 0);
pub const HB_VERSION_STRING = "8.3.0";
pub inline fn HB_VERSION_ATLEAST(major: anytype, minor: anytype, micro: anytype) @TypeOf((((major * @as(c_int, 10000)) + (minor * @as(c_int, 100))) + micro) <= (((HB_VERSION_MAJOR * @as(c_int, 10000)) + (HB_VERSION_MINOR * @as(c_int, 100))) + HB_VERSION_MICRO)) {
    return (((major * @as(c_int, 10000)) + (minor * @as(c_int, 100))) + micro) <= (((HB_VERSION_MAJOR * @as(c_int, 10000)) + (HB_VERSION_MINOR * @as(c_int, 100))) + HB_VERSION_MICRO);
}
pub const __PANGO_TYPES_H__ = "";
pub const PANGO_SCALE = @as(c_int, 1024);
pub inline fn PANGO_PIXELS(d: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_int, d) + @as(c_int, 512)) >> @as(c_int, 10)) {
    return (@import("std").zig.c_translation.cast(c_int, d) + @as(c_int, 512)) >> @as(c_int, 10);
}
pub inline fn PANGO_PIXELS_FLOOR(d: anytype) @TypeOf(@import("std").zig.c_translation.cast(c_int, d) >> @as(c_int, 10)) {
    return @import("std").zig.c_translation.cast(c_int, d) >> @as(c_int, 10);
}
pub inline fn PANGO_PIXELS_CEIL(d: anytype) @TypeOf((@import("std").zig.c_translation.cast(c_int, d) + @as(c_int, 1023)) >> @as(c_int, 10)) {
    return (@import("std").zig.c_translation.cast(c_int, d) + @as(c_int, 1023)) >> @as(c_int, 10);
}
pub inline fn PANGO_UNITS_FLOOR(d: anytype) @TypeOf(d & ~(PANGO_SCALE - @as(c_int, 1))) {
    return d & ~(PANGO_SCALE - @as(c_int, 1));
}
pub inline fn PANGO_UNITS_CEIL(d: anytype) @TypeOf((d + (PANGO_SCALE - @as(c_int, 1))) & ~(PANGO_SCALE - @as(c_int, 1))) {
    return (d + (PANGO_SCALE - @as(c_int, 1))) & ~(PANGO_SCALE - @as(c_int, 1));
}
pub inline fn PANGO_UNITS_ROUND(d: anytype) @TypeOf((d + (PANGO_SCALE >> @as(c_int, 1))) & ~(PANGO_SCALE - @as(c_int, 1))) {
    return (d + (PANGO_SCALE >> @as(c_int, 1))) & ~(PANGO_SCALE - @as(c_int, 1));
}
pub inline fn PANGO_ASCENT(rect: anytype) @TypeOf(-rect.y) {
    return -rect.y;
}
pub inline fn PANGO_DESCENT(rect: anytype) @TypeOf(rect.y + rect.height) {
    return rect.y + rect.height;
}
pub inline fn PANGO_LBEARING(rect: anytype) @TypeOf(rect.x) {
    return rect.x;
}
pub inline fn PANGO_RBEARING(rect: anytype) @TypeOf(rect.x + rect.width) {
    return rect.x + rect.width;
}
pub const __PANGO_GRAVITY_H__ = "";
pub inline fn PANGO_GRAVITY_IS_VERTICAL(gravity: anytype) @TypeOf((gravity == PANGO_GRAVITY_EAST) or (gravity == PANGO_GRAVITY_WEST)) {
    return (gravity == PANGO_GRAVITY_EAST) or (gravity == PANGO_GRAVITY_WEST);
}
pub inline fn PANGO_GRAVITY_IS_IMPROPER(gravity: anytype) @TypeOf((gravity == PANGO_GRAVITY_WEST) or (gravity == PANGO_GRAVITY_NORTH)) {
    return (gravity == PANGO_GRAVITY_WEST) or (gravity == PANGO_GRAVITY_NORTH);
}
pub const __PANGO_MATRIX_H__ = "";
pub const PANGO_TYPE_MATRIX = pango_matrix_get_type();
pub const __PANGO_SCRIPT_H__ = "";
pub const __PANGO_LANGUAGE_H__ = "";
pub const PANGO_TYPE_LANGUAGE = pango_language_get_type();
pub const __PANGO_BIDI_TYPE_H__ = "";
pub const __PANGO_DIRECTION_H__ = "";
pub const PANGO_SCALE_XX_SMALL = @import("std").zig.c_translation.cast(f64, @as(f64, 0.5787037037037));
pub const PANGO_SCALE_X_SMALL = @import("std").zig.c_translation.cast(f64, @as(f64, 0.6944444444444));
pub const PANGO_SCALE_SMALL = @import("std").zig.c_translation.cast(f64, @as(f64, 0.8333333333333));
pub const PANGO_SCALE_MEDIUM = @import("std").zig.c_translation.cast(f64, @as(f64, 1.0));
pub const PANGO_SCALE_LARGE = @import("std").zig.c_translation.cast(f64, @as(f64, 1.2));
pub const PANGO_SCALE_X_LARGE = @import("std").zig.c_translation.cast(f64, @as(f64, 1.44));
pub const PANGO_SCALE_XX_LARGE = @import("std").zig.c_translation.cast(f64, @as(f64, 1.728));
pub const PANGO_TYPE_FONT_DESCRIPTION = pango_font_description_get_type();
pub const PANGO_TYPE_FONT_METRICS = pango_font_metrics_get_type();
pub const PANGO_TYPE_FONT_FAMILY = pango_font_family_get_type();
pub inline fn PANGO_FONT_FAMILY(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT_FAMILY, PangoFontFamily)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT_FAMILY, PangoFontFamily);
}
pub inline fn PANGO_IS_FONT_FAMILY(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT_FAMILY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT_FAMILY);
}
pub inline fn PANGO_FONT_FAMILY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT_FAMILY, PangoFontFamilyClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT_FAMILY, PangoFontFamilyClass);
}
pub inline fn PANGO_IS_FONT_FAMILY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT_FAMILY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT_FAMILY);
}
pub inline fn PANGO_FONT_FAMILY_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT_FAMILY, PangoFontFamilyClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT_FAMILY, PangoFontFamilyClass);
}
pub const PANGO_TYPE_FONT_FACE = pango_font_face_get_type();
pub inline fn PANGO_FONT_FACE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT_FACE, PangoFontFace)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT_FACE, PangoFontFace);
}
pub inline fn PANGO_IS_FONT_FACE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT_FACE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT_FACE);
}
pub inline fn PANGO_FONT_FACE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT_FACE, PangoFontFaceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT_FACE, PangoFontFaceClass);
}
pub inline fn PANGO_IS_FONT_FACE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT_FACE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT_FACE);
}
pub inline fn PANGO_FONT_FACE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT_FACE, PangoFontFaceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT_FACE, PangoFontFaceClass);
}
pub const PANGO_TYPE_FONT = pango_font_get_type();
pub inline fn PANGO_FONT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT, PangoFont)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT, PangoFont);
}
pub inline fn PANGO_IS_FONT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT);
}
pub inline fn PANGO_FONT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT, PangoFontClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT, PangoFontClass);
}
pub inline fn PANGO_IS_FONT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT);
}
pub inline fn PANGO_FONT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT, PangoFontClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT, PangoFontClass);
}
pub const PANGO_GLYPH_EMPTY = @import("std").zig.c_translation.cast(PangoGlyph, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0FFFFFFF, .hexadecimal));
pub const PANGO_GLYPH_INVALID_INPUT = @import("std").zig.c_translation.cast(PangoGlyph, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hexadecimal));
pub const PANGO_GLYPH_UNKNOWN_FLAG = @import("std").zig.c_translation.cast(PangoGlyph, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hexadecimal));
pub inline fn PANGO_GET_UNKNOWN_GLYPH(wc: anytype) @TypeOf(@import("std").zig.c_translation.cast(PangoGlyph, wc) | PANGO_GLYPH_UNKNOWN_FLAG) {
    return @import("std").zig.c_translation.cast(PangoGlyph, wc) | PANGO_GLYPH_UNKNOWN_FLAG;
}
pub const PANGO_UNKNOWN_GLYPH_WIDTH = @as(c_int, 10);
pub const PANGO_UNKNOWN_GLYPH_HEIGHT = @as(c_int, 14);
pub const __PANGO_COLOR_H__ = "";
pub const PANGO_TYPE_COLOR = pango_color_get_type();
pub const PANGO_ATTR_INDEX_FROM_TEXT_BEGINNING = @import("std").zig.c_translation.cast(guint, @as(c_int, 0));
pub const PANGO_ATTR_INDEX_TO_TEXT_END = @import("std").zig.c_translation.cast(guint, G_MAXUINT + @as(c_int, 0));
pub const PANGO_TYPE_ATTR_LIST = pango_attr_list_get_type();
pub const __PANGO_BREAK_H__ = "";
pub const __PANGO_ITEM_H__ = "";
pub const PANGO_ANALYSIS_FLAG_CENTERED_BASELINE = @as(c_int, 1) << @as(c_int, 0);
pub const PANGO_ANALYSIS_FLAG_IS_ELLIPSIS = @as(c_int, 1) << @as(c_int, 1);
pub const PANGO_ANALYSIS_FLAG_NEED_HYPHEN = @as(c_int, 1) << @as(c_int, 2);
pub const PANGO_TYPE_ITEM = pango_item_get_type();
pub const __PANGO_CONTEXT_H__ = "";
pub const __PANGO_FONTMAP_H__ = "";
pub const __PANGO_FONTSET_H__ = "";
pub const PANGO_TYPE_FONTSET = pango_fontset_get_type();
pub inline fn PANGO_FONTSET(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONTSET, PangoFontset)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONTSET, PangoFontset);
}
pub inline fn PANGO_IS_FONTSET(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONTSET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONTSET);
}
pub inline fn PANGO_FONTSET_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONTSET, PangoFontsetClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONTSET, PangoFontsetClass);
}
pub inline fn PANGO_IS_FONTSET_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONTSET)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONTSET);
}
pub inline fn PANGO_FONTSET_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONTSET, PangoFontsetClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONTSET, PangoFontsetClass);
}
pub const PANGO_TYPE_FONT_MAP = pango_font_map_get_type();
pub inline fn PANGO_FONT_MAP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT_MAP, PangoFontMap)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONT_MAP, PangoFontMap);
}
pub inline fn PANGO_IS_FONT_MAP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT_MAP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONT_MAP);
}
pub inline fn PANGO_FONT_MAP_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT_MAP, PangoFontMapClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_FONT_MAP, PangoFontMapClass);
}
pub inline fn PANGO_IS_FONT_MAP_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT_MAP)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_FONT_MAP);
}
pub inline fn PANGO_FONT_MAP_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT_MAP, PangoFontMapClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_FONT_MAP, PangoFontMapClass);
}
pub const PANGO_TYPE_CONTEXT = pango_context_get_type();
pub inline fn PANGO_CONTEXT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_CONTEXT, PangoContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_CONTEXT, PangoContext);
}
pub inline fn PANGO_CONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_CONTEXT, PangoContextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_CONTEXT, PangoContextClass);
}
pub inline fn PANGO_IS_CONTEXT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_CONTEXT);
}
pub inline fn PANGO_IS_CONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_CONTEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_CONTEXT);
}
pub inline fn PANGO_CONTEXT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_CONTEXT, PangoContextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_CONTEXT, PangoContextClass);
}
pub const __PANGO_ENGINE_H__ = "";
pub const __PANGO_GLYPH_H__ = "";
pub const PANGO_TYPE_GLYPH_STRING = pango_glyph_string_get_type();
pub const PANGO_RENDER_TYPE_NONE = "PangoRenderNone";
pub const PANGO_TYPE_ENGINE = pango_engine_get_type();
pub inline fn PANGO_ENGINE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_ENGINE, PangoEngine)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_ENGINE, PangoEngine);
}
pub inline fn PANGO_IS_ENGINE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_ENGINE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_ENGINE);
}
pub inline fn PANGO_ENGINE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_ENGINE, PangoEngineClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_ENGINE, PangoEngineClass);
}
pub inline fn PANGO_IS_ENGINE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_ENGINE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_ENGINE);
}
pub inline fn PANGO_ENGINE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_ENGINE, PangoEngineClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_ENGINE, PangoEngineClass);
}
pub const PANGO_ENGINE_TYPE_LANG = "PangoEngineLang";
pub const PANGO_TYPE_ENGINE_LANG = pango_engine_lang_get_type();
pub inline fn PANGO_ENGINE_LANG(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_ENGINE_LANG, PangoEngineLang)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_ENGINE_LANG, PangoEngineLang);
}
pub inline fn PANGO_IS_ENGINE_LANG(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_ENGINE_LANG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_ENGINE_LANG);
}
pub inline fn PANGO_ENGINE_LANG_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_ENGINE_LANG, PangoEngineLangClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_ENGINE_LANG, PangoEngineLangClass);
}
pub inline fn PANGO_IS_ENGINE_LANG_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_ENGINE_LANG)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_ENGINE_LANG);
}
pub inline fn PANGO_ENGINE_LANG_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_ENGINE_LANG, PangoEngineLangClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_ENGINE_LANG, PangoEngineLangClass);
}
pub const PANGO_ENGINE_TYPE_SHAPE = "PangoEngineShape";
pub const PANGO_TYPE_ENGINE_SHAPE = pango_engine_shape_get_type();
pub inline fn PANGO_ENGINE_SHAPE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_ENGINE_SHAPE, PangoEngineShape)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_ENGINE_SHAPE, PangoEngineShape);
}
pub inline fn PANGO_IS_ENGINE_SHAPE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_ENGINE_SHAPE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_ENGINE_SHAPE);
}
pub inline fn PANGO_ENGINE_SHAPE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_ENGINE_SHAPE, PangoEngineShapeClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_ENGINE_SHAPE, PangoEngineShapeClass);
}
pub inline fn PANGO_IS_ENGINE_SHAPE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_ENGINE_SHAPE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_ENGINE_SHAPE);
}
pub inline fn PANGO_ENGINE_SHAPE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_ENGINE_SHAPE, PangoEngineShapeClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_ENGINE_SHAPE, PangoEngineShapeClass);
}
pub inline fn PANGO_ENGINE_LANG_DEFINE_TYPE(name: anytype, prefix: anytype, class_init: anytype, instance_init: anytype) @TypeOf(PANGO_ENGINE_DEFINE_TYPE(name, prefix, class_init, instance_init, PANGO_TYPE_ENGINE_LANG)) {
    return PANGO_ENGINE_DEFINE_TYPE(name, prefix, class_init, instance_init, PANGO_TYPE_ENGINE_LANG);
}
pub inline fn PANGO_ENGINE_SHAPE_DEFINE_TYPE(name: anytype, prefix: anytype, class_init: anytype, instance_init: anytype) @TypeOf(PANGO_ENGINE_DEFINE_TYPE(name, prefix, class_init, instance_init, PANGO_TYPE_ENGINE_SHAPE)) {
    return PANGO_ENGINE_DEFINE_TYPE(name, prefix, class_init, instance_init, PANGO_TYPE_ENGINE_SHAPE);
}
pub const __PANGO_ENUM_TYPES_H__ = "";
pub const PANGO_TYPE_ATTR_TYPE = pango_attr_type_get_type();
pub const PANGO_TYPE_UNDERLINE = pango_underline_get_type();
pub const PANGO_TYPE_OVERLINE = pango_overline_get_type();
pub const PANGO_TYPE_SHOW_FLAGS = pango_show_flags_get_type();
pub const PANGO_TYPE_TEXT_TRANSFORM = pango_text_transform_get_type();
pub const PANGO_TYPE_BASELINE_SHIFT = pango_baseline_shift_get_type();
pub const PANGO_TYPE_FONT_SCALE = pango_font_scale_get_type();
pub const PANGO_TYPE_BIDI_TYPE = pango_bidi_type_get_type();
pub const PANGO_TYPE_COVERAGE_LEVEL = pango_coverage_level_get_type();
pub const PANGO_TYPE_DIRECTION = pango_direction_get_type();
pub const PANGO_TYPE_STYLE = pango_style_get_type();
pub const PANGO_TYPE_VARIANT = pango_variant_get_type();
pub const PANGO_TYPE_WEIGHT = pango_weight_get_type();
pub const PANGO_TYPE_STRETCH = pango_stretch_get_type();
pub const PANGO_TYPE_FONT_MASK = pango_font_mask_get_type();
pub const PANGO_TYPE_SHAPE_FLAGS = pango_shape_flags_get_type();
pub const PANGO_TYPE_GRAVITY = pango_gravity_get_type();
pub const PANGO_TYPE_GRAVITY_HINT = pango_gravity_hint_get_type();
pub const PANGO_TYPE_ALIGNMENT = pango_alignment_get_type();
pub const PANGO_TYPE_WRAP_MODE = pango_wrap_mode_get_type();
pub const PANGO_TYPE_ELLIPSIZE_MODE = pango_ellipsize_mode_get_type();
pub const PANGO_TYPE_LAYOUT_SERIALIZE_FLAGS = pango_layout_serialize_flags_get_type();
pub const PANGO_TYPE_LAYOUT_DESERIALIZE_ERROR = pango_layout_deserialize_error_get_type();
pub const PANGO_TYPE_LAYOUT_DESERIALIZE_FLAGS = pango_layout_deserialize_flags_get_type();
pub const PANGO_TYPE_RENDER_PART = pango_render_part_get_type();
pub const PANGO_TYPE_SCRIPT = pango_script_get_type();
pub const PANGO_TYPE_TAB_ALIGN = pango_tab_align_get_type();
pub const __PANGO_FONTSET_SIMPLE_H__ = "";
pub const PANGO_TYPE_FONTSET_SIMPLE = pango_fontset_simple_get_type();
pub inline fn PANGO_FONTSET_SIMPLE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONTSET_SIMPLE, PangoFontsetSimple)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_FONTSET_SIMPLE, PangoFontsetSimple);
}
pub inline fn PANGO_IS_FONTSET_SIMPLE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONTSET_SIMPLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_FONTSET_SIMPLE);
}
pub const __PANGO_GLYPH_ITEM_H__ = "";
pub const PANGO_TYPE_GLYPH_ITEM = pango_glyph_item_get_type();
pub const PANGO_TYPE_GLYPH_ITEM_ITER = pango_glyph_item_iter_get_type();
pub const __PANGO_LAYOUT_H__ = "";
pub const __PANGO_TABS_H__ = "";
pub const PANGO_TYPE_TAB_ARRAY = pango_tab_array_get_type();
pub const PANGO_TYPE_LAYOUT = pango_layout_get_type();
pub inline fn PANGO_LAYOUT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_LAYOUT, PangoLayout)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_LAYOUT, PangoLayout);
}
pub inline fn PANGO_LAYOUT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_LAYOUT, PangoLayoutClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_LAYOUT, PangoLayoutClass);
}
pub inline fn PANGO_IS_LAYOUT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_LAYOUT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_LAYOUT);
}
pub inline fn PANGO_IS_LAYOUT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_LAYOUT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_LAYOUT);
}
pub inline fn PANGO_LAYOUT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_LAYOUT, PangoLayoutClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_LAYOUT, PangoLayoutClass);
}
pub const PANGO_LAYOUT_DESERIALIZE_ERROR = pango_layout_deserialize_error_quark();
pub const PANGO_TYPE_LAYOUT_LINE = pango_layout_line_get_type();
pub const PANGO_TYPE_LAYOUT_ITER = pango_layout_iter_get_type();
pub const __PANGO_MARKUP_H__ = "";
pub const __PANGO_RENDERER_H_ = "";
pub const PANGO_TYPE_RENDERER = pango_renderer_get_type();
pub inline fn PANGO_RENDERER(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_RENDERER, PangoRenderer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_RENDERER, PangoRenderer);
}
pub inline fn PANGO_IS_RENDERER(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_RENDERER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_RENDERER);
}
pub inline fn PANGO_RENDERER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_RENDERER, PangoRendererClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, PANGO_TYPE_RENDERER, PangoRendererClass);
}
pub inline fn PANGO_IS_RENDERER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_RENDERER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, PANGO_TYPE_RENDERER);
}
pub inline fn PANGO_RENDERER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_RENDERER, PangoRendererClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, PANGO_TYPE_RENDERER, PangoRendererClass);
}
pub const __PANGO_UTILS_H__ = "";
pub const _STDIO_H = @as(c_int, 1);
pub const __need___va_list = "";
pub const _____fpos_t_defined = @as(c_int, 1);
pub const ____mbstate_t_defined = @as(c_int, 1);
pub const _____fpos64_t_defined = @as(c_int, 1);
pub const ____FILE_defined = @as(c_int, 1);
pub const __FILE_defined = @as(c_int, 1);
pub const __struct_FILE_defined = @as(c_int, 1);
pub const _IO_EOF_SEEN = @as(c_int, 0x0010);
pub inline fn __feof_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0)) {
    return (_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0);
}
pub const _IO_ERR_SEEN = @as(c_int, 0x0020);
pub inline fn __ferror_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0)) {
    return (_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0);
}
pub const _IO_USER_LOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hexadecimal);
pub const __cookie_io_functions_t_defined = @as(c_int, 1);
pub const _VA_LIST_DEFINED = "";
pub const _IOFBF = @as(c_int, 0);
pub const _IOLBF = @as(c_int, 1);
pub const _IONBF = @as(c_int, 2);
pub const BUFSIZ = @as(c_int, 8192);
pub const EOF = -@as(c_int, 1);
pub const P_tmpdir = "/tmp";
pub const L_tmpnam = @as(c_int, 20);
pub const TMP_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 238328, .decimal);
pub const _BITS_STDIO_LIM_H = @as(c_int, 1);
pub const FILENAME_MAX = @as(c_int, 4096);
pub const L_ctermid = @as(c_int, 9);
pub const FOPEN_MAX = @as(c_int, 16);
pub const __attr_dealloc_fclose = __attr_dealloc(fclose, @as(c_int, 1));
pub inline fn PANGO_VERSION_ENCODE(major: anytype, minor: anytype, micro: anytype) @TypeOf(((major * @as(c_int, 10000)) + (minor * @as(c_int, 100))) + (micro * @as(c_int, 1))) {
    return ((major * @as(c_int, 10000)) + (minor * @as(c_int, 100))) + (micro * @as(c_int, 1));
}
pub const PANGO_VERSION = PANGO_VERSION_ENCODE(PANGO_VERSION_MAJOR, PANGO_VERSION_MINOR, PANGO_VERSION_MICRO);
pub inline fn PANGO_VERSION_CHECK(major: anytype, minor: anytype, micro: anytype) @TypeOf(PANGO_VERSION >= PANGO_VERSION_ENCODE(major, minor, micro)) {
    return PANGO_VERSION >= PANGO_VERSION_ENCODE(major, minor, micro);
}
pub const __GDKCONFIG_H__ = "";
pub const GDK_WINDOWING_X11 = "";
pub const GDK_WINDOWING_BROADWAY = "";
pub const GDK_WINDOWING_WAYLAND = "";
pub const GDK_RENDERING_CAIRO = "";
pub const GDK_RENDERING_GL = "";
pub const GDK_MODIFIER_MASK = ((((((((((GDK_SHIFT_MASK | GDK_LOCK_MASK) | GDK_CONTROL_MASK) | GDK_ALT_MASK) | GDK_SUPER_MASK) | GDK_HYPER_MASK) | GDK_META_MASK) | GDK_BUTTON1_MASK) | GDK_BUTTON2_MASK) | GDK_BUTTON3_MASK) | GDK_BUTTON4_MASK) | GDK_BUTTON5_MASK;
pub const GDK_ACTION_ALL = (GDK_ACTION_COPY | GDK_ACTION_MOVE) | GDK_ACTION_LINK;
pub const GDK_CURRENT_TIME = @as(c_long, 0);
pub const GDK_TYPE_APP_LAUNCH_CONTEXT = gdk_app_launch_context_get_type();
pub inline fn GDK_APP_LAUNCH_CONTEXT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_APP_LAUNCH_CONTEXT, GdkAppLaunchContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_APP_LAUNCH_CONTEXT, GdkAppLaunchContext);
}
pub inline fn GDK_IS_APP_LAUNCH_CONTEXT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_APP_LAUNCH_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_APP_LAUNCH_CONTEXT);
}
pub const GDK_PIXBUF_H = "";
pub const GDK_PIXBUF_H_INSIDE = "";
pub const GDK_PIXBUF_MACROS_H = "";
pub const __GDK_PIXBUF_FEATURES_H__ = "";
pub const GDK_PIXBUF_MAJOR = @as(c_int, 2);
pub const GDK_PIXBUF_MINOR = @as(c_int, 42);
pub const GDK_PIXBUF_MICRO = @as(c_int, 10);
pub const GDK_PIXBUF_VERSION = "2.42.10";
pub const GDK_PIXBUF_VAR = _GDK_PIXBUF_EXTERN;
pub inline fn GDK_PIXBUF_CHECK_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf(((GDK_PIXBUF_MAJOR > major) or ((GDK_PIXBUF_MAJOR == major) and (GDK_PIXBUF_MINOR > minor))) or (((GDK_PIXBUF_MAJOR == major) and (GDK_PIXBUF_MINOR == minor)) and (GDK_PIXBUF_MICRO >= micro))) {
    return ((GDK_PIXBUF_MAJOR > major) or ((GDK_PIXBUF_MAJOR == major) and (GDK_PIXBUF_MINOR > minor))) or (((GDK_PIXBUF_MAJOR == major) and (GDK_PIXBUF_MINOR == minor)) and (GDK_PIXBUF_MICRO >= micro));
}
pub const GDK_PIXBUF_VERSION_2_0 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 0));
pub const GDK_PIXBUF_VERSION_2_2 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 2));
pub const GDK_PIXBUF_VERSION_2_4 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 4));
pub const GDK_PIXBUF_VERSION_2_6 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 6));
pub const GDK_PIXBUF_VERSION_2_8 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 8));
pub const GDK_PIXBUF_VERSION_2_10 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 10));
pub const GDK_PIXBUF_VERSION_2_12 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 12));
pub const GDK_PIXBUF_VERSION_2_14 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 14));
pub const GDK_PIXBUF_VERSION_2_16 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 16));
pub const GDK_PIXBUF_VERSION_2_18 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 18));
pub const GDK_PIXBUF_VERSION_2_20 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 20));
pub const GDK_PIXBUF_VERSION_2_22 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 22));
pub const GDK_PIXBUF_VERSION_2_24 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 24));
pub const GDK_PIXBUF_VERSION_2_26 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 26));
pub const GDK_PIXBUF_VERSION_2_28 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 28));
pub const GDK_PIXBUF_VERSION_2_30 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 30));
pub const GDK_PIXBUF_VERSION_2_32 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 32));
pub const GDK_PIXBUF_VERSION_2_34 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 34));
pub const GDK_PIXBUF_VERSION_2_36 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 36));
pub const GDK_PIXBUF_VERSION_2_38 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 38));
pub const GDK_PIXBUF_VERSION_2_40 = G_ENCODE_VERSION(@as(c_int, 2), @as(c_int, 40));
pub const GDK_PIXBUF_VERSION_CUR_STABLE = G_ENCODE_VERSION(GDK_PIXBUF_MAJOR, GDK_PIXBUF_MINOR);
pub const GDK_PIXBUF_VERSION_PREV_STABLE = G_ENCODE_VERSION(GDK_PIXBUF_MAJOR, GDK_PIXBUF_MINOR - @as(c_int, 2));
pub const GDK_PIXBUF_VERSION_MIN_REQUIRED = GDK_PIXBUF_VERSION_CUR_STABLE;
pub const GDK_PIXBUF_VERSION_MAX_ALLOWED = GDK_PIXBUF_VERSION_MIN_REQUIRED;
pub const GDK_PIXBUF_AVAILABLE_IN_ALL = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_0 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_0 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_2 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_2 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_4 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_4 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_6 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_6 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_8 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_8 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_10 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_10 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_12 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_12 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_14 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_14 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_16 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_16 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_18 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_18 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_20 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_20 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_22 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_22 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_24 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_24 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_26 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_26 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_28 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_28 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_30 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_30 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_32 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_32 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_34 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_34 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_36 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_36 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_38 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_38 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_DEPRECATED_IN_2_40 = G_DEPRECATED ++ _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_AVAILABLE_IN_2_40 = _GDK_PIXBUF_EXTERN;
pub const GDK_PIXBUF_CORE_H = "";
pub const GDK_TYPE_PIXBUF = gdk_pixbuf_get_type();
pub inline fn GDK_PIXBUF(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF, GdkPixbuf)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF, GdkPixbuf);
}
pub inline fn GDK_IS_PIXBUF(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF);
}
pub const GDK_PIXBUF_ERROR = gdk_pixbuf_error_quark();
pub const GDK_PIXBUF_TRANSFORM_H = "";
pub const GDK_PIXBUF_ANIMATION_H = "";
pub const GDK_TYPE_PIXBUF_ANIMATION = gdk_pixbuf_animation_get_type();
pub inline fn GDK_PIXBUF_ANIMATION(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF_ANIMATION, GdkPixbufAnimation)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF_ANIMATION, GdkPixbufAnimation);
}
pub inline fn GDK_IS_PIXBUF_ANIMATION(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF_ANIMATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF_ANIMATION);
}
pub const GDK_TYPE_PIXBUF_ANIMATION_ITER = gdk_pixbuf_animation_iter_get_type();
pub inline fn GDK_PIXBUF_ANIMATION_ITER(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF_ANIMATION_ITER, GdkPixbufAnimationIter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF_ANIMATION_ITER, GdkPixbufAnimationIter);
}
pub inline fn GDK_IS_PIXBUF_ANIMATION_ITER(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF_ANIMATION_ITER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF_ANIMATION_ITER);
}
pub const GDK_PIXBUF_SIMPLE_ANIM_H = "";
pub const GDK_TYPE_PIXBUF_SIMPLE_ANIM = gdk_pixbuf_simple_anim_get_type();
pub inline fn GDK_PIXBUF_SIMPLE_ANIM(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF_SIMPLE_ANIM, GdkPixbufSimpleAnim)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_PIXBUF_SIMPLE_ANIM, GdkPixbufSimpleAnim);
}
pub inline fn GDK_IS_PIXBUF_SIMPLE_ANIM(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF_SIMPLE_ANIM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_PIXBUF_SIMPLE_ANIM);
}
pub inline fn GDK_PIXBUF_SIMPLE_ANIM_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_PIXBUF_SIMPLE_ANIM, GdkPixbufSimpleAnimClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_PIXBUF_SIMPLE_ANIM, GdkPixbufSimpleAnimClass);
}
pub inline fn GDK_IS_PIXBUF_SIMPLE_ANIM_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_PIXBUF_SIMPLE_ANIM)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_PIXBUF_SIMPLE_ANIM);
}
pub inline fn GDK_PIXBUF_SIMPLE_ANIM_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_PIXBUF_SIMPLE_ANIM, GdkPixbufSimpleAnimClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_PIXBUF_SIMPLE_ANIM, GdkPixbufSimpleAnimClass);
}
pub const GDK_PIXBUF_IO_H = "";
pub const GDK_PIXBUF_LOADER_H = "";
pub const GDK_TYPE_PIXBUF_LOADER = gdk_pixbuf_loader_get_type();
pub inline fn GDK_PIXBUF_LOADER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoader)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoader);
}
pub inline fn GDK_PIXBUF_LOADER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoaderClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoaderClass);
}
pub inline fn GDK_IS_PIXBUF_LOADER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_PIXBUF_LOADER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_PIXBUF_LOADER);
}
pub inline fn GDK_IS_PIXBUF_LOADER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_PIXBUF_LOADER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_PIXBUF_LOADER);
}
pub inline fn GDK_PIXBUF_LOADER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoaderClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_PIXBUF_LOADER, GdkPixbufLoaderClass);
}
pub const __GDK_PIXBUF_ENUM_TYPES_H__ = "";
pub const GDK_TYPE_PIXBUF_ALPHA_MODE = gdk_pixbuf_alpha_mode_get_type();
pub const GDK_TYPE_COLORSPACE = gdk_colorspace_get_type();
pub const GDK_TYPE_PIXBUF_ERROR = gdk_pixbuf_error_get_type();
pub const GDK_TYPE_INTERP_TYPE = gdk_interp_type_get_type();
pub const GDK_TYPE_PIXBUF_ROTATION = gdk_pixbuf_rotation_get_type();
pub const GDK_PIXBUF_AUTOCLEANUPS_H = "";
pub const __PANGOCAIRO_H__ = "";
pub const PANGO_TYPE_CAIRO_FONT = pango_cairo_font_get_type();
pub inline fn PANGO_CAIRO_FONT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_CAIRO_FONT, PangoCairoFont)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_CAIRO_FONT, PangoCairoFont);
}
pub inline fn PANGO_IS_CAIRO_FONT(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_CAIRO_FONT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_CAIRO_FONT);
}
pub const PANGO_TYPE_CAIRO_FONT_MAP = pango_cairo_font_map_get_type();
pub inline fn PANGO_CAIRO_FONT_MAP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_CAIRO_FONT_MAP, PangoCairoFontMap)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, PANGO_TYPE_CAIRO_FONT_MAP, PangoCairoFontMap);
}
pub inline fn PANGO_IS_CAIRO_FONT_MAP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_CAIRO_FONT_MAP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, PANGO_TYPE_CAIRO_FONT_MAP);
}
pub const GDK_TYPE_CAIRO_CONTEXT = gdk_cairo_context_get_type();
pub inline fn GDK_CAIRO_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_CAIRO_CONTEXT, GdkCairoContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_CAIRO_CONTEXT, GdkCairoContext);
}
pub inline fn GDK_IS_CAIRO_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_CAIRO_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_CAIRO_CONTEXT);
}
pub const GDK_TYPE_CLIPBOARD = gdk_clipboard_get_type();
pub inline fn GDK_CLIPBOARD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_CLIPBOARD, GdkClipboard)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_CLIPBOARD, GdkClipboard);
}
pub inline fn GDK_IS_CLIPBOARD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_CLIPBOARD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_CLIPBOARD);
}
pub const GDK_TYPE_CONTENT_DESERIALIZER = gdk_content_deserializer_get_type();
pub inline fn GDK_CONTENT_DESERIALIZER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_CONTENT_DESERIALIZER, GdkContentDeserializer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_CONTENT_DESERIALIZER, GdkContentDeserializer);
}
pub inline fn GDK_IS_CONTENT_DESERIALIZER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_CONTENT_DESERIALIZER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_CONTENT_DESERIALIZER);
}
pub const GDK_TYPE_CONTENT_FORMATS = gdk_content_formats_get_type();
pub const GDK_TYPE_CONTENT_FORMATS_BUILDER = gdk_content_formats_builder_get_type();
pub const GDK_TYPE_FILE_LIST = gdk_file_list_get_type();
pub const GDK_TYPE_CONTENT_PROVIDER = gdk_content_provider_get_type();
pub inline fn GDK_CONTENT_PROVIDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_CONTENT_PROVIDER, GdkContentProvider)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_CONTENT_PROVIDER, GdkContentProvider);
}
pub inline fn GDK_IS_CONTENT_PROVIDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_CONTENT_PROVIDER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_CONTENT_PROVIDER);
}
pub inline fn GDK_CONTENT_PROVIDER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_CONTENT_PROVIDER, GdkContentProviderClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_CONTENT_PROVIDER, GdkContentProviderClass);
}
pub inline fn GDK_IS_CONTENT_PROVIDER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_CONTENT_PROVIDER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_CONTENT_PROVIDER);
}
pub inline fn GDK_CONTENT_PROVIDER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_CONTENT_PROVIDER, GdkContentProviderClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_CONTENT_PROVIDER, GdkContentProviderClass);
}
pub const GDK_TYPE_CONTENT_SERIALIZER = gdk_content_serializer_get_type();
pub inline fn GDK_CONTENT_SERIALIZER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_CONTENT_SERIALIZER, GdkContentSerializer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_CONTENT_SERIALIZER, GdkContentSerializer);
}
pub inline fn GDK_IS_CONTENT_SERIALIZER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_CONTENT_SERIALIZER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_CONTENT_SERIALIZER);
}
pub const GDK_TYPE_CURSOR = gdk_cursor_get_type();
pub inline fn GDK_CURSOR(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_CURSOR, GdkCursor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_CURSOR, GdkCursor);
}
pub inline fn GDK_IS_CURSOR(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_CURSOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_CURSOR);
}
pub const GDK_TYPE_DEVICE_TOOL = gdk_device_tool_get_type();
pub inline fn GDK_DEVICE_TOOL(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_DEVICE_TOOL, GdkDeviceTool)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_DEVICE_TOOL, GdkDeviceTool);
}
pub inline fn GDK_IS_DEVICE_TOOL(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_DEVICE_TOOL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_DEVICE_TOOL);
}
pub const GDK_TYPE_DEVICE = gdk_device_get_type();
pub inline fn GDK_DEVICE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_DEVICE, GdkDevice)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_DEVICE, GdkDevice);
}
pub inline fn GDK_IS_DEVICE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_DEVICE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_DEVICE);
}
pub const GDK_TYPE_DEVICE_PAD = gdk_device_pad_get_type();
pub inline fn GDK_DEVICE_PAD(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_DEVICE_PAD, GdkDevicePad)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_DEVICE_PAD, GdkDevicePad);
}
pub inline fn GDK_IS_DEVICE_PAD(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_DEVICE_PAD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_DEVICE_PAD);
}
pub const GDK_TYPE_DRAG = gdk_drag_get_type();
pub inline fn GDK_DRAG(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DRAG, GdkDrag)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DRAG, GdkDrag);
}
pub inline fn GDK_IS_DRAG(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DRAG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DRAG);
}
pub const GDK_TYPE_EVENT = gdk_event_get_type();
pub const GDK_TYPE_EVENT_SEQUENCE = gdk_event_sequence_get_type();
pub inline fn GDK_IS_EVENT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_EVENT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_EVENT);
}
pub inline fn GDK_EVENT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_EVENT, GdkEvent)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_EVENT, GdkEvent);
}
pub inline fn GDK_IS_EVENT_TYPE(event: anytype, @"type": anytype) @TypeOf(gdk_event_get_event_type(event) == @"type") {
    return gdk_event_get_event_type(event) == @"type";
}
pub const GDK_PRIORITY_EVENTS = G_PRIORITY_DEFAULT;
pub const GDK_PRIORITY_REDRAW = G_PRIORITY_HIGH_IDLE + @as(c_int, 20);
pub const GDK_EVENT_PROPAGATE = FALSE;
pub const GDK_EVENT_STOP = TRUE;
pub const GDK_BUTTON_PRIMARY = @as(c_int, 1);
pub const GDK_BUTTON_MIDDLE = @as(c_int, 2);
pub const GDK_BUTTON_SECONDARY = @as(c_int, 3);
pub const GDK_TYPE_BUTTON_EVENT = gdk_button_event_get_type();
pub const GDK_TYPE_CROSSING_EVENT = gdk_crossing_event_get_type();
pub const GDK_TYPE_DELETE_EVENT = gdk_delete_event_get_type();
pub const GDK_TYPE_DND_EVENT = gdk_dnd_event_get_type();
pub const GDK_TYPE_FOCUS_EVENT = gdk_focus_event_get_type();
pub const GDK_TYPE_GRAB_BROKEN_EVENT = gdk_grab_broken_event_get_type();
pub const GDK_TYPE_KEY_EVENT = gdk_key_event_get_type();
pub const GDK_TYPE_MOTION_EVENT = gdk_motion_event_get_type();
pub const GDK_TYPE_PAD_EVENT = gdk_pad_event_get_type();
pub const GDK_TYPE_PROXIMITY_EVENT = gdk_proximity_event_get_type();
pub const GDK_TYPE_SCROLL_EVENT = gdk_scroll_event_get_type();
pub const GDK_TYPE_TOUCH_EVENT = gdk_touch_event_get_type();
pub const GDK_TYPE_TOUCHPAD_EVENT = gdk_touchpad_event_get_type();
pub const GDK_TYPE_FRAME_CLOCK = gdk_frame_clock_get_type();
pub inline fn GDK_FRAME_CLOCK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_FRAME_CLOCK, GdkFrameClock)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_FRAME_CLOCK, GdkFrameClock);
}
pub inline fn GDK_FRAME_CLOCK_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_FRAME_CLOCK, GdkFrameClockClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_FRAME_CLOCK, GdkFrameClockClass);
}
pub inline fn GDK_IS_FRAME_CLOCK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_FRAME_CLOCK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_FRAME_CLOCK);
}
pub inline fn GDK_IS_FRAME_CLOCK_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_FRAME_CLOCK)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_FRAME_CLOCK);
}
pub inline fn GDK_FRAME_CLOCK_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_FRAME_CLOCK, GdkFrameClockClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_FRAME_CLOCK, GdkFrameClockClass);
}
pub const GDK_TYPE_MONITOR = gdk_monitor_get_type();
pub inline fn GDK_MONITOR(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_MONITOR, GdkMonitor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_MONITOR, GdkMonitor);
}
pub inline fn GDK_IS_MONITOR(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_MONITOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_MONITOR);
}
pub const GDK_TYPE_POPUP_LAYOUT = gdk_popup_layout_get_type();
pub const GDK_TYPE_SURFACE = gdk_surface_get_type();
pub inline fn GDK_SURFACE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_SURFACE, GdkSurface)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_SURFACE, GdkSurface);
}
pub inline fn GDK_SURFACE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_SURFACE, GdkSurfaceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GDK_TYPE_SURFACE, GdkSurfaceClass);
}
pub inline fn GDK_IS_SURFACE(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_SURFACE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_SURFACE);
}
pub inline fn GDK_IS_SURFACE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_SURFACE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GDK_TYPE_SURFACE);
}
pub inline fn GDK_SURFACE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_SURFACE, GdkSurfaceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GDK_TYPE_SURFACE, GdkSurfaceClass);
}
pub const GDK_TYPE_SEAT = gdk_seat_get_type();
pub inline fn GDK_SEAT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_SEAT, GdkSeat)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GDK_TYPE_SEAT, GdkSeat);
}
pub inline fn GDK_IS_SEAT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_SEAT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GDK_TYPE_SEAT);
}
pub const GDK_TYPE_DISPLAY = gdk_display_get_type();
pub inline fn GDK_DISPLAY(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DISPLAY, GdkDisplay)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DISPLAY, GdkDisplay);
}
pub inline fn GDK_IS_DISPLAY(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DISPLAY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DISPLAY);
}
pub const GDK_TYPE_DISPLAY_MANAGER = gdk_display_manager_get_type();
pub inline fn GDK_DISPLAY_MANAGER(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DISPLAY_MANAGER, GdkDisplayManager)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DISPLAY_MANAGER, GdkDisplayManager);
}
pub inline fn GDK_IS_DISPLAY_MANAGER(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DISPLAY_MANAGER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DISPLAY_MANAGER);
}
pub const GDK_TYPE_DRAG_SURFACE = gdk_drag_surface_get_type();
pub const GDK_TYPE_DRAG_SURFACE_SIZE = gdk_drag_surface_size_get_type();
pub const GDK_TYPE_DRAW_CONTEXT = gdk_draw_context_get_type();
pub inline fn GDK_DRAW_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_DRAW_CONTEXT, GdkDrawContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_DRAW_CONTEXT, GdkDrawContext);
}
pub inline fn GDK_IS_DRAW_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_DRAW_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_DRAW_CONTEXT);
}
pub const GDK_TYPE_DROP = gdk_drop_get_type();
pub inline fn GDK_DROP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DROP, GdkDrop)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GDK_TYPE_DROP, GdkDrop);
}
pub inline fn GDK_IS_DROP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DROP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GDK_TYPE_DROP);
}
pub const GDK_TYPE_INPUT_SOURCE = gdk_input_source_get_type();
pub const GDK_TYPE_DEVICE_PAD_FEATURE = gdk_device_pad_feature_get_type();
pub const GDK_TYPE_DEVICE_TOOL_TYPE = gdk_device_tool_type_get_type();
pub const GDK_TYPE_DRAG_CANCEL_REASON = gdk_drag_cancel_reason_get_type();
pub const GDK_TYPE_GL_API = gdk_gl_api_get_type();
pub const GDK_TYPE_GRAVITY = gdk_gravity_get_type();
pub const GDK_TYPE_MODIFIER_TYPE = gdk_modifier_type_get_type();
pub const GDK_TYPE_GL_ERROR = gdk_gl_error_get_type();
pub const GDK_TYPE_VULKAN_ERROR = gdk_vulkan_error_get_type();
pub const GDK_TYPE_AXIS_USE = gdk_axis_use_get_type();
pub const GDK_TYPE_AXIS_FLAGS = gdk_axis_flags_get_type();
pub const GDK_TYPE_DRAG_ACTION = gdk_drag_action_get_type();
pub const GDK_TYPE_MEMORY_FORMAT = gdk_memory_format_get_type();
pub const GDK_TYPE_EVENT_TYPE = gdk_event_type_get_type();
pub const GDK_TYPE_TOUCHPAD_GESTURE_PHASE = gdk_touchpad_gesture_phase_get_type();
pub const GDK_TYPE_SCROLL_DIRECTION = gdk_scroll_direction_get_type();
pub const GDK_TYPE_SCROLL_UNIT = gdk_scroll_unit_get_type();
pub const GDK_TYPE_NOTIFY_TYPE = gdk_notify_type_get_type();
pub const GDK_TYPE_CROSSING_MODE = gdk_crossing_mode_get_type();
pub const GDK_TYPE_KEY_MATCH = gdk_key_match_get_type();
pub const GDK_TYPE_FRAME_CLOCK_PHASE = gdk_frame_clock_phase_get_type();
pub const GDK_TYPE_SUBPIXEL_LAYOUT = gdk_subpixel_layout_get_type();
pub const GDK_TYPE_PAINTABLE_FLAGS = gdk_paintable_flags_get_type();
pub const GDK_TYPE_ANCHOR_HINTS = gdk_anchor_hints_get_type();
pub const GDK_TYPE_SEAT_CAPABILITIES = gdk_seat_capabilities_get_type();
pub const GDK_TYPE_TEXTURE_ERROR = gdk_texture_error_get_type();
pub const GDK_TYPE_SURFACE_EDGE = gdk_surface_edge_get_type();
pub const GDK_TYPE_FULLSCREEN_MODE = gdk_fullscreen_mode_get_type();
pub const GDK_TYPE_TOPLEVEL_STATE = gdk_toplevel_state_get_type();
pub const GDK_TYPE_TITLEBAR_GESTURE = gdk_titlebar_gesture_get_type();
pub const GDK_TYPE_GL_CONTEXT = gdk_gl_context_get_type();
pub inline fn GDK_GL_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_GL_CONTEXT, GdkGLContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_GL_CONTEXT, GdkGLContext);
}
pub inline fn GDK_IS_GL_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_GL_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_GL_CONTEXT);
}
pub const GDK_GL_ERROR = gdk_gl_error_quark();
pub const GDK_TYPE_TEXTURE = gdk_texture_get_type();
pub inline fn GDK_TEXTURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_TEXTURE, GdkTexture)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_TEXTURE, GdkTexture);
}
pub inline fn GDK_IS_TEXTURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_TEXTURE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_TEXTURE);
}
pub const GDK_TEXTURE_ERROR = gdk_texture_error_quark();
pub const GDK_TYPE_GL_TEXTURE = gdk_gl_texture_get_type();
pub inline fn GDK_GL_TEXTURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_GL_TEXTURE, GdkGLTexture)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_GL_TEXTURE, GdkGLTexture);
}
pub inline fn GDK_IS_GL_TEXTURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_GL_TEXTURE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_GL_TEXTURE);
}
pub const GDK_TYPE_GL_TEXTURE_BUILDER = gdk_gl_texture_builder_get_type();
pub const GDK_KEY_VoidSymbol = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffff, .hexadecimal);
pub const GDK_KEY_BackSpace = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff08, .hexadecimal);
pub const GDK_KEY_Tab = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff09, .hexadecimal);
pub const GDK_KEY_Linefeed = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff0a, .hexadecimal);
pub const GDK_KEY_Clear = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff0b, .hexadecimal);
pub const GDK_KEY_Return = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff0d, .hexadecimal);
pub const GDK_KEY_Pause = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff13, .hexadecimal);
pub const GDK_KEY_Scroll_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff14, .hexadecimal);
pub const GDK_KEY_Sys_Req = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff15, .hexadecimal);
pub const GDK_KEY_Escape = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff1b, .hexadecimal);
pub const GDK_KEY_Delete = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hexadecimal);
pub const GDK_KEY_Multi_key = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff20, .hexadecimal);
pub const GDK_KEY_Codeinput = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff37, .hexadecimal);
pub const GDK_KEY_SingleCandidate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3c, .hexadecimal);
pub const GDK_KEY_MultipleCandidate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3d, .hexadecimal);
pub const GDK_KEY_PreviousCandidate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3e, .hexadecimal);
pub const GDK_KEY_Kanji = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff21, .hexadecimal);
pub const GDK_KEY_Muhenkan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff22, .hexadecimal);
pub const GDK_KEY_Henkan_Mode = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff23, .hexadecimal);
pub const GDK_KEY_Henkan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff23, .hexadecimal);
pub const GDK_KEY_Romaji = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff24, .hexadecimal);
pub const GDK_KEY_Hiragana = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff25, .hexadecimal);
pub const GDK_KEY_Katakana = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff26, .hexadecimal);
pub const GDK_KEY_Hiragana_Katakana = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff27, .hexadecimal);
pub const GDK_KEY_Zenkaku = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff28, .hexadecimal);
pub const GDK_KEY_Hankaku = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff29, .hexadecimal);
pub const GDK_KEY_Zenkaku_Hankaku = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff2a, .hexadecimal);
pub const GDK_KEY_Touroku = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff2b, .hexadecimal);
pub const GDK_KEY_Massyo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff2c, .hexadecimal);
pub const GDK_KEY_Kana_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff2d, .hexadecimal);
pub const GDK_KEY_Kana_Shift = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff2e, .hexadecimal);
pub const GDK_KEY_Eisu_Shift = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff2f, .hexadecimal);
pub const GDK_KEY_Eisu_toggle = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff30, .hexadecimal);
pub const GDK_KEY_Kanji_Bangou = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff37, .hexadecimal);
pub const GDK_KEY_Zen_Koho = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3d, .hexadecimal);
pub const GDK_KEY_Mae_Koho = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3e, .hexadecimal);
pub const GDK_KEY_Home = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff50, .hexadecimal);
pub const GDK_KEY_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff51, .hexadecimal);
pub const GDK_KEY_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff52, .hexadecimal);
pub const GDK_KEY_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff53, .hexadecimal);
pub const GDK_KEY_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff54, .hexadecimal);
pub const GDK_KEY_Prior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff55, .hexadecimal);
pub const GDK_KEY_Page_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff55, .hexadecimal);
pub const GDK_KEY_Next = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff56, .hexadecimal);
pub const GDK_KEY_Page_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff56, .hexadecimal);
pub const GDK_KEY_End = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff57, .hexadecimal);
pub const GDK_KEY_Begin = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff58, .hexadecimal);
pub const GDK_KEY_Select = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff60, .hexadecimal);
pub const GDK_KEY_Print = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff61, .hexadecimal);
pub const GDK_KEY_Execute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff62, .hexadecimal);
pub const GDK_KEY_Insert = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff63, .hexadecimal);
pub const GDK_KEY_Undo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff65, .hexadecimal);
pub const GDK_KEY_Redo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff66, .hexadecimal);
pub const GDK_KEY_Menu = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff67, .hexadecimal);
pub const GDK_KEY_Find = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff68, .hexadecimal);
pub const GDK_KEY_Cancel = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff69, .hexadecimal);
pub const GDK_KEY_Help = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff6a, .hexadecimal);
pub const GDK_KEY_Break = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff6b, .hexadecimal);
pub const GDK_KEY_Mode_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_script_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_Num_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7f, .hexadecimal);
pub const GDK_KEY_KP_Space = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff80, .hexadecimal);
pub const GDK_KEY_KP_Tab = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff89, .hexadecimal);
pub const GDK_KEY_KP_Enter = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff8d, .hexadecimal);
pub const GDK_KEY_KP_F1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff91, .hexadecimal);
pub const GDK_KEY_KP_F2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff92, .hexadecimal);
pub const GDK_KEY_KP_F3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff93, .hexadecimal);
pub const GDK_KEY_KP_F4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff94, .hexadecimal);
pub const GDK_KEY_KP_Home = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff95, .hexadecimal);
pub const GDK_KEY_KP_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff96, .hexadecimal);
pub const GDK_KEY_KP_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff97, .hexadecimal);
pub const GDK_KEY_KP_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff98, .hexadecimal);
pub const GDK_KEY_KP_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff99, .hexadecimal);
pub const GDK_KEY_KP_Prior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9a, .hexadecimal);
pub const GDK_KEY_KP_Page_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9a, .hexadecimal);
pub const GDK_KEY_KP_Next = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9b, .hexadecimal);
pub const GDK_KEY_KP_Page_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9b, .hexadecimal);
pub const GDK_KEY_KP_End = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9c, .hexadecimal);
pub const GDK_KEY_KP_Begin = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9d, .hexadecimal);
pub const GDK_KEY_KP_Insert = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9e, .hexadecimal);
pub const GDK_KEY_KP_Delete = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff9f, .hexadecimal);
pub const GDK_KEY_KP_Equal = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffbd, .hexadecimal);
pub const GDK_KEY_KP_Multiply = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffaa, .hexadecimal);
pub const GDK_KEY_KP_Add = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffab, .hexadecimal);
pub const GDK_KEY_KP_Separator = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffac, .hexadecimal);
pub const GDK_KEY_KP_Subtract = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffad, .hexadecimal);
pub const GDK_KEY_KP_Decimal = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffae, .hexadecimal);
pub const GDK_KEY_KP_Divide = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffaf, .hexadecimal);
pub const GDK_KEY_KP_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb0, .hexadecimal);
pub const GDK_KEY_KP_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb1, .hexadecimal);
pub const GDK_KEY_KP_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb2, .hexadecimal);
pub const GDK_KEY_KP_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb3, .hexadecimal);
pub const GDK_KEY_KP_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb4, .hexadecimal);
pub const GDK_KEY_KP_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb5, .hexadecimal);
pub const GDK_KEY_KP_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb6, .hexadecimal);
pub const GDK_KEY_KP_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb7, .hexadecimal);
pub const GDK_KEY_KP_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb8, .hexadecimal);
pub const GDK_KEY_KP_9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffb9, .hexadecimal);
pub const GDK_KEY_F1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffbe, .hexadecimal);
pub const GDK_KEY_F2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffbf, .hexadecimal);
pub const GDK_KEY_F3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc0, .hexadecimal);
pub const GDK_KEY_F4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc1, .hexadecimal);
pub const GDK_KEY_F5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc2, .hexadecimal);
pub const GDK_KEY_F6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc3, .hexadecimal);
pub const GDK_KEY_F7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc4, .hexadecimal);
pub const GDK_KEY_F8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc5, .hexadecimal);
pub const GDK_KEY_F9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc6, .hexadecimal);
pub const GDK_KEY_F10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc7, .hexadecimal);
pub const GDK_KEY_F11 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc8, .hexadecimal);
pub const GDK_KEY_L1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc8, .hexadecimal);
pub const GDK_KEY_F12 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc9, .hexadecimal);
pub const GDK_KEY_L2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffc9, .hexadecimal);
pub const GDK_KEY_F13 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffca, .hexadecimal);
pub const GDK_KEY_L3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffca, .hexadecimal);
pub const GDK_KEY_F14 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcb, .hexadecimal);
pub const GDK_KEY_L4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcb, .hexadecimal);
pub const GDK_KEY_F15 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcc, .hexadecimal);
pub const GDK_KEY_L5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcc, .hexadecimal);
pub const GDK_KEY_F16 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcd, .hexadecimal);
pub const GDK_KEY_L6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcd, .hexadecimal);
pub const GDK_KEY_F17 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffce, .hexadecimal);
pub const GDK_KEY_L7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffce, .hexadecimal);
pub const GDK_KEY_F18 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcf, .hexadecimal);
pub const GDK_KEY_L8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffcf, .hexadecimal);
pub const GDK_KEY_F19 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd0, .hexadecimal);
pub const GDK_KEY_L9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd0, .hexadecimal);
pub const GDK_KEY_F20 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd1, .hexadecimal);
pub const GDK_KEY_L10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd1, .hexadecimal);
pub const GDK_KEY_F21 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd2, .hexadecimal);
pub const GDK_KEY_R1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd2, .hexadecimal);
pub const GDK_KEY_F22 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd3, .hexadecimal);
pub const GDK_KEY_R2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd3, .hexadecimal);
pub const GDK_KEY_F23 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd4, .hexadecimal);
pub const GDK_KEY_R3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd4, .hexadecimal);
pub const GDK_KEY_F24 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd5, .hexadecimal);
pub const GDK_KEY_R4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd5, .hexadecimal);
pub const GDK_KEY_F25 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd6, .hexadecimal);
pub const GDK_KEY_R5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd6, .hexadecimal);
pub const GDK_KEY_F26 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd7, .hexadecimal);
pub const GDK_KEY_R6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd7, .hexadecimal);
pub const GDK_KEY_F27 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd8, .hexadecimal);
pub const GDK_KEY_R7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd8, .hexadecimal);
pub const GDK_KEY_F28 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd9, .hexadecimal);
pub const GDK_KEY_R8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffd9, .hexadecimal);
pub const GDK_KEY_F29 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffda, .hexadecimal);
pub const GDK_KEY_R9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffda, .hexadecimal);
pub const GDK_KEY_F30 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdb, .hexadecimal);
pub const GDK_KEY_R10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdb, .hexadecimal);
pub const GDK_KEY_F31 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdc, .hexadecimal);
pub const GDK_KEY_R11 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdc, .hexadecimal);
pub const GDK_KEY_F32 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdd, .hexadecimal);
pub const GDK_KEY_R12 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdd, .hexadecimal);
pub const GDK_KEY_F33 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffde, .hexadecimal);
pub const GDK_KEY_R13 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffde, .hexadecimal);
pub const GDK_KEY_F34 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdf, .hexadecimal);
pub const GDK_KEY_R14 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffdf, .hexadecimal);
pub const GDK_KEY_F35 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe0, .hexadecimal);
pub const GDK_KEY_R15 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe0, .hexadecimal);
pub const GDK_KEY_Shift_L = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe1, .hexadecimal);
pub const GDK_KEY_Shift_R = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe2, .hexadecimal);
pub const GDK_KEY_Control_L = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe3, .hexadecimal);
pub const GDK_KEY_Control_R = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe4, .hexadecimal);
pub const GDK_KEY_Caps_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe5, .hexadecimal);
pub const GDK_KEY_Shift_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe6, .hexadecimal);
pub const GDK_KEY_Meta_L = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe7, .hexadecimal);
pub const GDK_KEY_Meta_R = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe8, .hexadecimal);
pub const GDK_KEY_Alt_L = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffe9, .hexadecimal);
pub const GDK_KEY_Alt_R = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffea, .hexadecimal);
pub const GDK_KEY_Super_L = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffeb, .hexadecimal);
pub const GDK_KEY_Super_R = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffec, .hexadecimal);
pub const GDK_KEY_Hyper_L = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffed, .hexadecimal);
pub const GDK_KEY_Hyper_R = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffee, .hexadecimal);
pub const GDK_KEY_ISO_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe01, .hexadecimal);
pub const GDK_KEY_ISO_Level2_Latch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe02, .hexadecimal);
pub const GDK_KEY_ISO_Level3_Shift = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe03, .hexadecimal);
pub const GDK_KEY_ISO_Level3_Latch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe04, .hexadecimal);
pub const GDK_KEY_ISO_Level3_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe05, .hexadecimal);
pub const GDK_KEY_ISO_Level5_Shift = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe11, .hexadecimal);
pub const GDK_KEY_ISO_Level5_Latch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe12, .hexadecimal);
pub const GDK_KEY_ISO_Level5_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe13, .hexadecimal);
pub const GDK_KEY_ISO_Group_Shift = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_ISO_Group_Latch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe06, .hexadecimal);
pub const GDK_KEY_ISO_Group_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe07, .hexadecimal);
pub const GDK_KEY_ISO_Next_Group = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe08, .hexadecimal);
pub const GDK_KEY_ISO_Next_Group_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe09, .hexadecimal);
pub const GDK_KEY_ISO_Prev_Group = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe0a, .hexadecimal);
pub const GDK_KEY_ISO_Prev_Group_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe0b, .hexadecimal);
pub const GDK_KEY_ISO_First_Group = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe0c, .hexadecimal);
pub const GDK_KEY_ISO_First_Group_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe0d, .hexadecimal);
pub const GDK_KEY_ISO_Last_Group = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe0e, .hexadecimal);
pub const GDK_KEY_ISO_Last_Group_Lock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe0f, .hexadecimal);
pub const GDK_KEY_ISO_Left_Tab = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe20, .hexadecimal);
pub const GDK_KEY_ISO_Move_Line_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe21, .hexadecimal);
pub const GDK_KEY_ISO_Move_Line_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe22, .hexadecimal);
pub const GDK_KEY_ISO_Partial_Line_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe23, .hexadecimal);
pub const GDK_KEY_ISO_Partial_Line_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe24, .hexadecimal);
pub const GDK_KEY_ISO_Partial_Space_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe25, .hexadecimal);
pub const GDK_KEY_ISO_Partial_Space_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe26, .hexadecimal);
pub const GDK_KEY_ISO_Set_Margin_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe27, .hexadecimal);
pub const GDK_KEY_ISO_Set_Margin_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe28, .hexadecimal);
pub const GDK_KEY_ISO_Release_Margin_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe29, .hexadecimal);
pub const GDK_KEY_ISO_Release_Margin_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe2a, .hexadecimal);
pub const GDK_KEY_ISO_Release_Both_Margins = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe2b, .hexadecimal);
pub const GDK_KEY_ISO_Fast_Cursor_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe2c, .hexadecimal);
pub const GDK_KEY_ISO_Fast_Cursor_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe2d, .hexadecimal);
pub const GDK_KEY_ISO_Fast_Cursor_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe2e, .hexadecimal);
pub const GDK_KEY_ISO_Fast_Cursor_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe2f, .hexadecimal);
pub const GDK_KEY_ISO_Continuous_Underline = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe30, .hexadecimal);
pub const GDK_KEY_ISO_Discontinuous_Underline = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe31, .hexadecimal);
pub const GDK_KEY_ISO_Emphasize = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe32, .hexadecimal);
pub const GDK_KEY_ISO_Center_Object = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe33, .hexadecimal);
pub const GDK_KEY_ISO_Enter = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe34, .hexadecimal);
pub const GDK_KEY_dead_grave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe50, .hexadecimal);
pub const GDK_KEY_dead_acute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe51, .hexadecimal);
pub const GDK_KEY_dead_circumflex = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe52, .hexadecimal);
pub const GDK_KEY_dead_tilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe53, .hexadecimal);
pub const GDK_KEY_dead_perispomeni = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe53, .hexadecimal);
pub const GDK_KEY_dead_macron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe54, .hexadecimal);
pub const GDK_KEY_dead_breve = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe55, .hexadecimal);
pub const GDK_KEY_dead_abovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe56, .hexadecimal);
pub const GDK_KEY_dead_diaeresis = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe57, .hexadecimal);
pub const GDK_KEY_dead_abovering = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe58, .hexadecimal);
pub const GDK_KEY_dead_doubleacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe59, .hexadecimal);
pub const GDK_KEY_dead_caron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe5a, .hexadecimal);
pub const GDK_KEY_dead_cedilla = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe5b, .hexadecimal);
pub const GDK_KEY_dead_ogonek = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe5c, .hexadecimal);
pub const GDK_KEY_dead_iota = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe5d, .hexadecimal);
pub const GDK_KEY_dead_voiced_sound = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe5e, .hexadecimal);
pub const GDK_KEY_dead_semivoiced_sound = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe5f, .hexadecimal);
pub const GDK_KEY_dead_belowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe60, .hexadecimal);
pub const GDK_KEY_dead_hook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe61, .hexadecimal);
pub const GDK_KEY_dead_horn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe62, .hexadecimal);
pub const GDK_KEY_dead_stroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe63, .hexadecimal);
pub const GDK_KEY_dead_abovecomma = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe64, .hexadecimal);
pub const GDK_KEY_dead_psili = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe64, .hexadecimal);
pub const GDK_KEY_dead_abovereversedcomma = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe65, .hexadecimal);
pub const GDK_KEY_dead_dasia = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe65, .hexadecimal);
pub const GDK_KEY_dead_doublegrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe66, .hexadecimal);
pub const GDK_KEY_dead_belowring = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe67, .hexadecimal);
pub const GDK_KEY_dead_belowmacron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe68, .hexadecimal);
pub const GDK_KEY_dead_belowcircumflex = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe69, .hexadecimal);
pub const GDK_KEY_dead_belowtilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe6a, .hexadecimal);
pub const GDK_KEY_dead_belowbreve = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe6b, .hexadecimal);
pub const GDK_KEY_dead_belowdiaeresis = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe6c, .hexadecimal);
pub const GDK_KEY_dead_invertedbreve = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe6d, .hexadecimal);
pub const GDK_KEY_dead_belowcomma = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe6e, .hexadecimal);
pub const GDK_KEY_dead_currency = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe6f, .hexadecimal);
pub const GDK_KEY_dead_lowline = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe90, .hexadecimal);
pub const GDK_KEY_dead_aboveverticalline = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe91, .hexadecimal);
pub const GDK_KEY_dead_belowverticalline = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe92, .hexadecimal);
pub const GDK_KEY_dead_longsolidusoverlay = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe93, .hexadecimal);
pub const GDK_KEY_dead_a = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe80, .hexadecimal);
pub const GDK_KEY_dead_A = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe81, .hexadecimal);
pub const GDK_KEY_dead_e = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe82, .hexadecimal);
pub const GDK_KEY_dead_E = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe83, .hexadecimal);
pub const GDK_KEY_dead_i = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe84, .hexadecimal);
pub const GDK_KEY_dead_I = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe85, .hexadecimal);
pub const GDK_KEY_dead_o = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe86, .hexadecimal);
pub const GDK_KEY_dead_O = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe87, .hexadecimal);
pub const GDK_KEY_dead_u = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe88, .hexadecimal);
pub const GDK_KEY_dead_U = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe89, .hexadecimal);
pub const GDK_KEY_dead_small_schwa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe8a, .hexadecimal);
pub const GDK_KEY_dead_capital_schwa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe8b, .hexadecimal);
pub const GDK_KEY_dead_greek = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe8c, .hexadecimal);
pub const GDK_KEY_First_Virtual_Screen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfed0, .hexadecimal);
pub const GDK_KEY_Prev_Virtual_Screen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfed1, .hexadecimal);
pub const GDK_KEY_Next_Virtual_Screen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfed2, .hexadecimal);
pub const GDK_KEY_Last_Virtual_Screen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfed4, .hexadecimal);
pub const GDK_KEY_Terminate_Server = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfed5, .hexadecimal);
pub const GDK_KEY_AccessX_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe70, .hexadecimal);
pub const GDK_KEY_AccessX_Feedback_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe71, .hexadecimal);
pub const GDK_KEY_RepeatKeys_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe72, .hexadecimal);
pub const GDK_KEY_SlowKeys_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe73, .hexadecimal);
pub const GDK_KEY_BounceKeys_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe74, .hexadecimal);
pub const GDK_KEY_StickyKeys_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe75, .hexadecimal);
pub const GDK_KEY_MouseKeys_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe76, .hexadecimal);
pub const GDK_KEY_MouseKeys_Accel_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe77, .hexadecimal);
pub const GDK_KEY_Overlay1_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe78, .hexadecimal);
pub const GDK_KEY_Overlay2_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe79, .hexadecimal);
pub const GDK_KEY_AudibleBell_Enable = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfe7a, .hexadecimal);
pub const GDK_KEY_Pointer_Left = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee0, .hexadecimal);
pub const GDK_KEY_Pointer_Right = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee1, .hexadecimal);
pub const GDK_KEY_Pointer_Up = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee2, .hexadecimal);
pub const GDK_KEY_Pointer_Down = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee3, .hexadecimal);
pub const GDK_KEY_Pointer_UpLeft = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee4, .hexadecimal);
pub const GDK_KEY_Pointer_UpRight = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee5, .hexadecimal);
pub const GDK_KEY_Pointer_DownLeft = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee6, .hexadecimal);
pub const GDK_KEY_Pointer_DownRight = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee7, .hexadecimal);
pub const GDK_KEY_Pointer_Button_Dflt = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee8, .hexadecimal);
pub const GDK_KEY_Pointer_Button1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfee9, .hexadecimal);
pub const GDK_KEY_Pointer_Button2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfeea, .hexadecimal);
pub const GDK_KEY_Pointer_Button3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfeeb, .hexadecimal);
pub const GDK_KEY_Pointer_Button4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfeec, .hexadecimal);
pub const GDK_KEY_Pointer_Button5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfeed, .hexadecimal);
pub const GDK_KEY_Pointer_DblClick_Dflt = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfeee, .hexadecimal);
pub const GDK_KEY_Pointer_DblClick1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfeef, .hexadecimal);
pub const GDK_KEY_Pointer_DblClick2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef0, .hexadecimal);
pub const GDK_KEY_Pointer_DblClick3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef1, .hexadecimal);
pub const GDK_KEY_Pointer_DblClick4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef2, .hexadecimal);
pub const GDK_KEY_Pointer_DblClick5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef3, .hexadecimal);
pub const GDK_KEY_Pointer_Drag_Dflt = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef4, .hexadecimal);
pub const GDK_KEY_Pointer_Drag1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef5, .hexadecimal);
pub const GDK_KEY_Pointer_Drag2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef6, .hexadecimal);
pub const GDK_KEY_Pointer_Drag3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef7, .hexadecimal);
pub const GDK_KEY_Pointer_Drag4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef8, .hexadecimal);
pub const GDK_KEY_Pointer_Drag5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfefd, .hexadecimal);
pub const GDK_KEY_Pointer_EnableKeys = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfef9, .hexadecimal);
pub const GDK_KEY_Pointer_Accelerate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfefa, .hexadecimal);
pub const GDK_KEY_Pointer_DfltBtnNext = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfefb, .hexadecimal);
pub const GDK_KEY_Pointer_DfltBtnPrev = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfefc, .hexadecimal);
pub const GDK_KEY_ch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfea0, .hexadecimal);
pub const GDK_KEY_Ch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfea1, .hexadecimal);
pub const GDK_KEY_CH = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfea2, .hexadecimal);
pub const GDK_KEY_c_h = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfea3, .hexadecimal);
pub const GDK_KEY_C_h = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfea4, .hexadecimal);
pub const GDK_KEY_C_H = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfea5, .hexadecimal);
pub const GDK_KEY_3270_Duplicate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd01, .hexadecimal);
pub const GDK_KEY_3270_FieldMark = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd02, .hexadecimal);
pub const GDK_KEY_3270_Right2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd03, .hexadecimal);
pub const GDK_KEY_3270_Left2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd04, .hexadecimal);
pub const GDK_KEY_3270_BackTab = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd05, .hexadecimal);
pub const GDK_KEY_3270_EraseEOF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd06, .hexadecimal);
pub const GDK_KEY_3270_EraseInput = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd07, .hexadecimal);
pub const GDK_KEY_3270_Reset = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd08, .hexadecimal);
pub const GDK_KEY_3270_Quit = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd09, .hexadecimal);
pub const GDK_KEY_3270_PA1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd0a, .hexadecimal);
pub const GDK_KEY_3270_PA2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd0b, .hexadecimal);
pub const GDK_KEY_3270_PA3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd0c, .hexadecimal);
pub const GDK_KEY_3270_Test = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd0d, .hexadecimal);
pub const GDK_KEY_3270_Attn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd0e, .hexadecimal);
pub const GDK_KEY_3270_CursorBlink = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd0f, .hexadecimal);
pub const GDK_KEY_3270_AltCursor = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd10, .hexadecimal);
pub const GDK_KEY_3270_KeyClick = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd11, .hexadecimal);
pub const GDK_KEY_3270_Jump = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd12, .hexadecimal);
pub const GDK_KEY_3270_Ident = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd13, .hexadecimal);
pub const GDK_KEY_3270_Rule = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd14, .hexadecimal);
pub const GDK_KEY_3270_Copy = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd15, .hexadecimal);
pub const GDK_KEY_3270_Play = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd16, .hexadecimal);
pub const GDK_KEY_3270_Setup = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd17, .hexadecimal);
pub const GDK_KEY_3270_Record = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd18, .hexadecimal);
pub const GDK_KEY_3270_ChangeScreen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd19, .hexadecimal);
pub const GDK_KEY_3270_DeleteWord = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd1a, .hexadecimal);
pub const GDK_KEY_3270_ExSelect = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd1b, .hexadecimal);
pub const GDK_KEY_3270_CursorSelect = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd1c, .hexadecimal);
pub const GDK_KEY_3270_PrintScreen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd1d, .hexadecimal);
pub const GDK_KEY_3270_Enter = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfd1e, .hexadecimal);
pub const GDK_KEY_space = @as(c_int, 0x020);
pub const GDK_KEY_exclam = @as(c_int, 0x021);
pub const GDK_KEY_quotedbl = @as(c_int, 0x022);
pub const GDK_KEY_numbersign = @as(c_int, 0x023);
pub const GDK_KEY_dollar = @as(c_int, 0x024);
pub const GDK_KEY_percent = @as(c_int, 0x025);
pub const GDK_KEY_ampersand = @as(c_int, 0x026);
pub const GDK_KEY_apostrophe = @as(c_int, 0x027);
pub const GDK_KEY_quoteright = @as(c_int, 0x027);
pub const GDK_KEY_parenleft = @as(c_int, 0x028);
pub const GDK_KEY_parenright = @as(c_int, 0x029);
pub const GDK_KEY_asterisk = @as(c_int, 0x02a);
pub const GDK_KEY_plus = @as(c_int, 0x02b);
pub const GDK_KEY_comma = @as(c_int, 0x02c);
pub const GDK_KEY_minus = @as(c_int, 0x02d);
pub const GDK_KEY_period = @as(c_int, 0x02e);
pub const GDK_KEY_slash = @as(c_int, 0x02f);
pub const GDK_KEY_0 = @as(c_int, 0x030);
pub const GDK_KEY_1 = @as(c_int, 0x031);
pub const GDK_KEY_2 = @as(c_int, 0x032);
pub const GDK_KEY_3 = @as(c_int, 0x033);
pub const GDK_KEY_4 = @as(c_int, 0x034);
pub const GDK_KEY_5 = @as(c_int, 0x035);
pub const GDK_KEY_6 = @as(c_int, 0x036);
pub const GDK_KEY_7 = @as(c_int, 0x037);
pub const GDK_KEY_8 = @as(c_int, 0x038);
pub const GDK_KEY_9 = @as(c_int, 0x039);
pub const GDK_KEY_colon = @as(c_int, 0x03a);
pub const GDK_KEY_semicolon = @as(c_int, 0x03b);
pub const GDK_KEY_less = @as(c_int, 0x03c);
pub const GDK_KEY_equal = @as(c_int, 0x03d);
pub const GDK_KEY_greater = @as(c_int, 0x03e);
pub const GDK_KEY_question = @as(c_int, 0x03f);
pub const GDK_KEY_at = @as(c_int, 0x040);
pub const GDK_KEY_A = @as(c_int, 0x041);
pub const GDK_KEY_B = @as(c_int, 0x042);
pub const GDK_KEY_C = @as(c_int, 0x043);
pub const GDK_KEY_D = @as(c_int, 0x044);
pub const GDK_KEY_E = @as(c_int, 0x045);
pub const GDK_KEY_F = @as(c_int, 0x046);
pub const GDK_KEY_G = @as(c_int, 0x047);
pub const GDK_KEY_H = @as(c_int, 0x048);
pub const GDK_KEY_I = @as(c_int, 0x049);
pub const GDK_KEY_J = @as(c_int, 0x04a);
pub const GDK_KEY_K = @as(c_int, 0x04b);
pub const GDK_KEY_L = @as(c_int, 0x04c);
pub const GDK_KEY_M = @as(c_int, 0x04d);
pub const GDK_KEY_N = @as(c_int, 0x04e);
pub const GDK_KEY_O = @as(c_int, 0x04f);
pub const GDK_KEY_P = @as(c_int, 0x050);
pub const GDK_KEY_Q = @as(c_int, 0x051);
pub const GDK_KEY_R = @as(c_int, 0x052);
pub const GDK_KEY_S = @as(c_int, 0x053);
pub const GDK_KEY_T = @as(c_int, 0x054);
pub const GDK_KEY_U = @as(c_int, 0x055);
pub const GDK_KEY_V = @as(c_int, 0x056);
pub const GDK_KEY_W = @as(c_int, 0x057);
pub const GDK_KEY_X = @as(c_int, 0x058);
pub const GDK_KEY_Y = @as(c_int, 0x059);
pub const GDK_KEY_Z = @as(c_int, 0x05a);
pub const GDK_KEY_bracketleft = @as(c_int, 0x05b);
pub const GDK_KEY_backslash = @as(c_int, 0x05c);
pub const GDK_KEY_bracketright = @as(c_int, 0x05d);
pub const GDK_KEY_asciicircum = @as(c_int, 0x05e);
pub const GDK_KEY_underscore = @as(c_int, 0x05f);
pub const GDK_KEY_grave = @as(c_int, 0x060);
pub const GDK_KEY_quoteleft = @as(c_int, 0x060);
pub const GDK_KEY_a = @as(c_int, 0x061);
pub const GDK_KEY_b = @as(c_int, 0x062);
pub const GDK_KEY_c = @as(c_int, 0x063);
pub const GDK_KEY_d = @as(c_int, 0x064);
pub const GDK_KEY_e = @as(c_int, 0x065);
pub const GDK_KEY_f = @as(c_int, 0x066);
pub const GDK_KEY_g = @as(c_int, 0x067);
pub const GDK_KEY_h = @as(c_int, 0x068);
pub const GDK_KEY_i = @as(c_int, 0x069);
pub const GDK_KEY_j = @as(c_int, 0x06a);
pub const GDK_KEY_k = @as(c_int, 0x06b);
pub const GDK_KEY_l = @as(c_int, 0x06c);
pub const GDK_KEY_m = @as(c_int, 0x06d);
pub const GDK_KEY_n = @as(c_int, 0x06e);
pub const GDK_KEY_o = @as(c_int, 0x06f);
pub const GDK_KEY_p = @as(c_int, 0x070);
pub const GDK_KEY_q = @as(c_int, 0x071);
pub const GDK_KEY_r = @as(c_int, 0x072);
pub const GDK_KEY_s = @as(c_int, 0x073);
pub const GDK_KEY_t = @as(c_int, 0x074);
pub const GDK_KEY_u = @as(c_int, 0x075);
pub const GDK_KEY_v = @as(c_int, 0x076);
pub const GDK_KEY_w = @as(c_int, 0x077);
pub const GDK_KEY_x = @as(c_int, 0x078);
pub const GDK_KEY_y = @as(c_int, 0x079);
pub const GDK_KEY_z = @as(c_int, 0x07a);
pub const GDK_KEY_braceleft = @as(c_int, 0x07b);
pub const GDK_KEY_bar = @as(c_int, 0x07c);
pub const GDK_KEY_braceright = @as(c_int, 0x07d);
pub const GDK_KEY_asciitilde = @as(c_int, 0x07e);
pub const GDK_KEY_nobreakspace = @as(c_int, 0x0a0);
pub const GDK_KEY_exclamdown = @as(c_int, 0x0a1);
pub const GDK_KEY_cent = @as(c_int, 0x0a2);
pub const GDK_KEY_sterling = @as(c_int, 0x0a3);
pub const GDK_KEY_currency = @as(c_int, 0x0a4);
pub const GDK_KEY_yen = @as(c_int, 0x0a5);
pub const GDK_KEY_brokenbar = @as(c_int, 0x0a6);
pub const GDK_KEY_section = @as(c_int, 0x0a7);
pub const GDK_KEY_diaeresis = @as(c_int, 0x0a8);
pub const GDK_KEY_copyright = @as(c_int, 0x0a9);
pub const GDK_KEY_ordfeminine = @as(c_int, 0x0aa);
pub const GDK_KEY_guillemotleft = @as(c_int, 0x0ab);
pub const GDK_KEY_notsign = @as(c_int, 0x0ac);
pub const GDK_KEY_hyphen = @as(c_int, 0x0ad);
pub const GDK_KEY_registered = @as(c_int, 0x0ae);
pub const GDK_KEY_macron = @as(c_int, 0x0af);
pub const GDK_KEY_degree = @as(c_int, 0x0b0);
pub const GDK_KEY_plusminus = @as(c_int, 0x0b1);
pub const GDK_KEY_twosuperior = @as(c_int, 0x0b2);
pub const GDK_KEY_threesuperior = @as(c_int, 0x0b3);
pub const GDK_KEY_acute = @as(c_int, 0x0b4);
pub const GDK_KEY_mu = @as(c_int, 0x0b5);
pub const GDK_KEY_paragraph = @as(c_int, 0x0b6);
pub const GDK_KEY_periodcentered = @as(c_int, 0x0b7);
pub const GDK_KEY_cedilla = @as(c_int, 0x0b8);
pub const GDK_KEY_onesuperior = @as(c_int, 0x0b9);
pub const GDK_KEY_masculine = @as(c_int, 0x0ba);
pub const GDK_KEY_guillemotright = @as(c_int, 0x0bb);
pub const GDK_KEY_onequarter = @as(c_int, 0x0bc);
pub const GDK_KEY_onehalf = @as(c_int, 0x0bd);
pub const GDK_KEY_threequarters = @as(c_int, 0x0be);
pub const GDK_KEY_questiondown = @as(c_int, 0x0bf);
pub const GDK_KEY_Agrave = @as(c_int, 0x0c0);
pub const GDK_KEY_Aacute = @as(c_int, 0x0c1);
pub const GDK_KEY_Acircumflex = @as(c_int, 0x0c2);
pub const GDK_KEY_Atilde = @as(c_int, 0x0c3);
pub const GDK_KEY_Adiaeresis = @as(c_int, 0x0c4);
pub const GDK_KEY_Aring = @as(c_int, 0x0c5);
pub const GDK_KEY_AE = @as(c_int, 0x0c6);
pub const GDK_KEY_Ccedilla = @as(c_int, 0x0c7);
pub const GDK_KEY_Egrave = @as(c_int, 0x0c8);
pub const GDK_KEY_Eacute = @as(c_int, 0x0c9);
pub const GDK_KEY_Ecircumflex = @as(c_int, 0x0ca);
pub const GDK_KEY_Ediaeresis = @as(c_int, 0x0cb);
pub const GDK_KEY_Igrave = @as(c_int, 0x0cc);
pub const GDK_KEY_Iacute = @as(c_int, 0x0cd);
pub const GDK_KEY_Icircumflex = @as(c_int, 0x0ce);
pub const GDK_KEY_Idiaeresis = @as(c_int, 0x0cf);
pub const GDK_KEY_ETH = @as(c_int, 0x0d0);
pub const GDK_KEY_Eth = @as(c_int, 0x0d0);
pub const GDK_KEY_Ntilde = @as(c_int, 0x0d1);
pub const GDK_KEY_Ograve = @as(c_int, 0x0d2);
pub const GDK_KEY_Oacute = @as(c_int, 0x0d3);
pub const GDK_KEY_Ocircumflex = @as(c_int, 0x0d4);
pub const GDK_KEY_Otilde = @as(c_int, 0x0d5);
pub const GDK_KEY_Odiaeresis = @as(c_int, 0x0d6);
pub const GDK_KEY_multiply = @as(c_int, 0x0d7);
pub const GDK_KEY_Oslash = @as(c_int, 0x0d8);
pub const GDK_KEY_Ooblique = @as(c_int, 0x0d8);
pub const GDK_KEY_Ugrave = @as(c_int, 0x0d9);
pub const GDK_KEY_Uacute = @as(c_int, 0x0da);
pub const GDK_KEY_Ucircumflex = @as(c_int, 0x0db);
pub const GDK_KEY_Udiaeresis = @as(c_int, 0x0dc);
pub const GDK_KEY_Yacute = @as(c_int, 0x0dd);
pub const GDK_KEY_THORN = @as(c_int, 0x0de);
pub const GDK_KEY_Thorn = @as(c_int, 0x0de);
pub const GDK_KEY_ssharp = @as(c_int, 0x0df);
pub const GDK_KEY_agrave = @as(c_int, 0x0e0);
pub const GDK_KEY_aacute = @as(c_int, 0x0e1);
pub const GDK_KEY_acircumflex = @as(c_int, 0x0e2);
pub const GDK_KEY_atilde = @as(c_int, 0x0e3);
pub const GDK_KEY_adiaeresis = @as(c_int, 0x0e4);
pub const GDK_KEY_aring = @as(c_int, 0x0e5);
pub const GDK_KEY_ae = @as(c_int, 0x0e6);
pub const GDK_KEY_ccedilla = @as(c_int, 0x0e7);
pub const GDK_KEY_egrave = @as(c_int, 0x0e8);
pub const GDK_KEY_eacute = @as(c_int, 0x0e9);
pub const GDK_KEY_ecircumflex = @as(c_int, 0x0ea);
pub const GDK_KEY_ediaeresis = @as(c_int, 0x0eb);
pub const GDK_KEY_igrave = @as(c_int, 0x0ec);
pub const GDK_KEY_iacute = @as(c_int, 0x0ed);
pub const GDK_KEY_icircumflex = @as(c_int, 0x0ee);
pub const GDK_KEY_idiaeresis = @as(c_int, 0x0ef);
pub const GDK_KEY_eth = @as(c_int, 0x0f0);
pub const GDK_KEY_ntilde = @as(c_int, 0x0f1);
pub const GDK_KEY_ograve = @as(c_int, 0x0f2);
pub const GDK_KEY_oacute = @as(c_int, 0x0f3);
pub const GDK_KEY_ocircumflex = @as(c_int, 0x0f4);
pub const GDK_KEY_otilde = @as(c_int, 0x0f5);
pub const GDK_KEY_odiaeresis = @as(c_int, 0x0f6);
pub const GDK_KEY_division = @as(c_int, 0x0f7);
pub const GDK_KEY_oslash = @as(c_int, 0x0f8);
pub const GDK_KEY_ooblique = @as(c_int, 0x0f8);
pub const GDK_KEY_ugrave = @as(c_int, 0x0f9);
pub const GDK_KEY_uacute = @as(c_int, 0x0fa);
pub const GDK_KEY_ucircumflex = @as(c_int, 0x0fb);
pub const GDK_KEY_udiaeresis = @as(c_int, 0x0fc);
pub const GDK_KEY_yacute = @as(c_int, 0x0fd);
pub const GDK_KEY_thorn = @as(c_int, 0x0fe);
pub const GDK_KEY_ydiaeresis = @as(c_int, 0x0ff);
pub const GDK_KEY_Aogonek = @as(c_int, 0x1a1);
pub const GDK_KEY_breve = @as(c_int, 0x1a2);
pub const GDK_KEY_Lstroke = @as(c_int, 0x1a3);
pub const GDK_KEY_Lcaron = @as(c_int, 0x1a5);
pub const GDK_KEY_Sacute = @as(c_int, 0x1a6);
pub const GDK_KEY_Scaron = @as(c_int, 0x1a9);
pub const GDK_KEY_Scedilla = @as(c_int, 0x1aa);
pub const GDK_KEY_Tcaron = @as(c_int, 0x1ab);
pub const GDK_KEY_Zacute = @as(c_int, 0x1ac);
pub const GDK_KEY_Zcaron = @as(c_int, 0x1ae);
pub const GDK_KEY_Zabovedot = @as(c_int, 0x1af);
pub const GDK_KEY_aogonek = @as(c_int, 0x1b1);
pub const GDK_KEY_ogonek = @as(c_int, 0x1b2);
pub const GDK_KEY_lstroke = @as(c_int, 0x1b3);
pub const GDK_KEY_lcaron = @as(c_int, 0x1b5);
pub const GDK_KEY_sacute = @as(c_int, 0x1b6);
pub const GDK_KEY_caron = @as(c_int, 0x1b7);
pub const GDK_KEY_scaron = @as(c_int, 0x1b9);
pub const GDK_KEY_scedilla = @as(c_int, 0x1ba);
pub const GDK_KEY_tcaron = @as(c_int, 0x1bb);
pub const GDK_KEY_zacute = @as(c_int, 0x1bc);
pub const GDK_KEY_doubleacute = @as(c_int, 0x1bd);
pub const GDK_KEY_zcaron = @as(c_int, 0x1be);
pub const GDK_KEY_zabovedot = @as(c_int, 0x1bf);
pub const GDK_KEY_Racute = @as(c_int, 0x1c0);
pub const GDK_KEY_Abreve = @as(c_int, 0x1c3);
pub const GDK_KEY_Lacute = @as(c_int, 0x1c5);
pub const GDK_KEY_Cacute = @as(c_int, 0x1c6);
pub const GDK_KEY_Ccaron = @as(c_int, 0x1c8);
pub const GDK_KEY_Eogonek = @as(c_int, 0x1ca);
pub const GDK_KEY_Ecaron = @as(c_int, 0x1cc);
pub const GDK_KEY_Dcaron = @as(c_int, 0x1cf);
pub const GDK_KEY_Dstroke = @as(c_int, 0x1d0);
pub const GDK_KEY_Nacute = @as(c_int, 0x1d1);
pub const GDK_KEY_Ncaron = @as(c_int, 0x1d2);
pub const GDK_KEY_Odoubleacute = @as(c_int, 0x1d5);
pub const GDK_KEY_Rcaron = @as(c_int, 0x1d8);
pub const GDK_KEY_Uring = @as(c_int, 0x1d9);
pub const GDK_KEY_Udoubleacute = @as(c_int, 0x1db);
pub const GDK_KEY_Tcedilla = @as(c_int, 0x1de);
pub const GDK_KEY_racute = @as(c_int, 0x1e0);
pub const GDK_KEY_abreve = @as(c_int, 0x1e3);
pub const GDK_KEY_lacute = @as(c_int, 0x1e5);
pub const GDK_KEY_cacute = @as(c_int, 0x1e6);
pub const GDK_KEY_ccaron = @as(c_int, 0x1e8);
pub const GDK_KEY_eogonek = @as(c_int, 0x1ea);
pub const GDK_KEY_ecaron = @as(c_int, 0x1ec);
pub const GDK_KEY_dcaron = @as(c_int, 0x1ef);
pub const GDK_KEY_dstroke = @as(c_int, 0x1f0);
pub const GDK_KEY_nacute = @as(c_int, 0x1f1);
pub const GDK_KEY_ncaron = @as(c_int, 0x1f2);
pub const GDK_KEY_odoubleacute = @as(c_int, 0x1f5);
pub const GDK_KEY_rcaron = @as(c_int, 0x1f8);
pub const GDK_KEY_uring = @as(c_int, 0x1f9);
pub const GDK_KEY_udoubleacute = @as(c_int, 0x1fb);
pub const GDK_KEY_tcedilla = @as(c_int, 0x1fe);
pub const GDK_KEY_abovedot = @as(c_int, 0x1ff);
pub const GDK_KEY_Hstroke = @as(c_int, 0x2a1);
pub const GDK_KEY_Hcircumflex = @as(c_int, 0x2a6);
pub const GDK_KEY_Iabovedot = @as(c_int, 0x2a9);
pub const GDK_KEY_Gbreve = @as(c_int, 0x2ab);
pub const GDK_KEY_Jcircumflex = @as(c_int, 0x2ac);
pub const GDK_KEY_hstroke = @as(c_int, 0x2b1);
pub const GDK_KEY_hcircumflex = @as(c_int, 0x2b6);
pub const GDK_KEY_idotless = @as(c_int, 0x2b9);
pub const GDK_KEY_gbreve = @as(c_int, 0x2bb);
pub const GDK_KEY_jcircumflex = @as(c_int, 0x2bc);
pub const GDK_KEY_Cabovedot = @as(c_int, 0x2c5);
pub const GDK_KEY_Ccircumflex = @as(c_int, 0x2c6);
pub const GDK_KEY_Gabovedot = @as(c_int, 0x2d5);
pub const GDK_KEY_Gcircumflex = @as(c_int, 0x2d8);
pub const GDK_KEY_Ubreve = @as(c_int, 0x2dd);
pub const GDK_KEY_Scircumflex = @as(c_int, 0x2de);
pub const GDK_KEY_cabovedot = @as(c_int, 0x2e5);
pub const GDK_KEY_ccircumflex = @as(c_int, 0x2e6);
pub const GDK_KEY_gabovedot = @as(c_int, 0x2f5);
pub const GDK_KEY_gcircumflex = @as(c_int, 0x2f8);
pub const GDK_KEY_ubreve = @as(c_int, 0x2fd);
pub const GDK_KEY_scircumflex = @as(c_int, 0x2fe);
pub const GDK_KEY_kra = @as(c_int, 0x3a2);
pub const GDK_KEY_kappa = @as(c_int, 0x3a2);
pub const GDK_KEY_Rcedilla = @as(c_int, 0x3a3);
pub const GDK_KEY_Itilde = @as(c_int, 0x3a5);
pub const GDK_KEY_Lcedilla = @as(c_int, 0x3a6);
pub const GDK_KEY_Emacron = @as(c_int, 0x3aa);
pub const GDK_KEY_Gcedilla = @as(c_int, 0x3ab);
pub const GDK_KEY_Tslash = @as(c_int, 0x3ac);
pub const GDK_KEY_rcedilla = @as(c_int, 0x3b3);
pub const GDK_KEY_itilde = @as(c_int, 0x3b5);
pub const GDK_KEY_lcedilla = @as(c_int, 0x3b6);
pub const GDK_KEY_emacron = @as(c_int, 0x3ba);
pub const GDK_KEY_gcedilla = @as(c_int, 0x3bb);
pub const GDK_KEY_tslash = @as(c_int, 0x3bc);
pub const GDK_KEY_ENG = @as(c_int, 0x3bd);
pub const GDK_KEY_eng = @as(c_int, 0x3bf);
pub const GDK_KEY_Amacron = @as(c_int, 0x3c0);
pub const GDK_KEY_Iogonek = @as(c_int, 0x3c7);
pub const GDK_KEY_Eabovedot = @as(c_int, 0x3cc);
pub const GDK_KEY_Imacron = @as(c_int, 0x3cf);
pub const GDK_KEY_Ncedilla = @as(c_int, 0x3d1);
pub const GDK_KEY_Omacron = @as(c_int, 0x3d2);
pub const GDK_KEY_Kcedilla = @as(c_int, 0x3d3);
pub const GDK_KEY_Uogonek = @as(c_int, 0x3d9);
pub const GDK_KEY_Utilde = @as(c_int, 0x3dd);
pub const GDK_KEY_Umacron = @as(c_int, 0x3de);
pub const GDK_KEY_amacron = @as(c_int, 0x3e0);
pub const GDK_KEY_iogonek = @as(c_int, 0x3e7);
pub const GDK_KEY_eabovedot = @as(c_int, 0x3ec);
pub const GDK_KEY_imacron = @as(c_int, 0x3ef);
pub const GDK_KEY_ncedilla = @as(c_int, 0x3f1);
pub const GDK_KEY_omacron = @as(c_int, 0x3f2);
pub const GDK_KEY_kcedilla = @as(c_int, 0x3f3);
pub const GDK_KEY_uogonek = @as(c_int, 0x3f9);
pub const GDK_KEY_utilde = @as(c_int, 0x3fd);
pub const GDK_KEY_umacron = @as(c_int, 0x3fe);
pub const GDK_KEY_Wcircumflex = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000174, .hexadecimal);
pub const GDK_KEY_wcircumflex = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000175, .hexadecimal);
pub const GDK_KEY_Ycircumflex = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000176, .hexadecimal);
pub const GDK_KEY_ycircumflex = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000177, .hexadecimal);
pub const GDK_KEY_Babovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e02, .hexadecimal);
pub const GDK_KEY_babovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e03, .hexadecimal);
pub const GDK_KEY_Dabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e0a, .hexadecimal);
pub const GDK_KEY_dabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e0b, .hexadecimal);
pub const GDK_KEY_Fabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e1e, .hexadecimal);
pub const GDK_KEY_fabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e1f, .hexadecimal);
pub const GDK_KEY_Mabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e40, .hexadecimal);
pub const GDK_KEY_mabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e41, .hexadecimal);
pub const GDK_KEY_Pabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e56, .hexadecimal);
pub const GDK_KEY_pabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e57, .hexadecimal);
pub const GDK_KEY_Sabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e60, .hexadecimal);
pub const GDK_KEY_sabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e61, .hexadecimal);
pub const GDK_KEY_Tabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e6a, .hexadecimal);
pub const GDK_KEY_tabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e6b, .hexadecimal);
pub const GDK_KEY_Wgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e80, .hexadecimal);
pub const GDK_KEY_wgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e81, .hexadecimal);
pub const GDK_KEY_Wacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e82, .hexadecimal);
pub const GDK_KEY_wacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e83, .hexadecimal);
pub const GDK_KEY_Wdiaeresis = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e84, .hexadecimal);
pub const GDK_KEY_wdiaeresis = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e85, .hexadecimal);
pub const GDK_KEY_Ygrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef2, .hexadecimal);
pub const GDK_KEY_ygrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef3, .hexadecimal);
pub const GDK_KEY_OE = @as(c_int, 0x13bc);
pub const GDK_KEY_oe = @as(c_int, 0x13bd);
pub const GDK_KEY_Ydiaeresis = @as(c_int, 0x13be);
pub const GDK_KEY_overline = @as(c_int, 0x47e);
pub const GDK_KEY_kana_fullstop = @as(c_int, 0x4a1);
pub const GDK_KEY_kana_openingbracket = @as(c_int, 0x4a2);
pub const GDK_KEY_kana_closingbracket = @as(c_int, 0x4a3);
pub const GDK_KEY_kana_comma = @as(c_int, 0x4a4);
pub const GDK_KEY_kana_conjunctive = @as(c_int, 0x4a5);
pub const GDK_KEY_kana_middledot = @as(c_int, 0x4a5);
pub const GDK_KEY_kana_WO = @as(c_int, 0x4a6);
pub const GDK_KEY_kana_a = @as(c_int, 0x4a7);
pub const GDK_KEY_kana_i = @as(c_int, 0x4a8);
pub const GDK_KEY_kana_u = @as(c_int, 0x4a9);
pub const GDK_KEY_kana_e = @as(c_int, 0x4aa);
pub const GDK_KEY_kana_o = @as(c_int, 0x4ab);
pub const GDK_KEY_kana_ya = @as(c_int, 0x4ac);
pub const GDK_KEY_kana_yu = @as(c_int, 0x4ad);
pub const GDK_KEY_kana_yo = @as(c_int, 0x4ae);
pub const GDK_KEY_kana_tsu = @as(c_int, 0x4af);
pub const GDK_KEY_kana_tu = @as(c_int, 0x4af);
pub const GDK_KEY_prolongedsound = @as(c_int, 0x4b0);
pub const GDK_KEY_kana_A = @as(c_int, 0x4b1);
pub const GDK_KEY_kana_I = @as(c_int, 0x4b2);
pub const GDK_KEY_kana_U = @as(c_int, 0x4b3);
pub const GDK_KEY_kana_E = @as(c_int, 0x4b4);
pub const GDK_KEY_kana_O = @as(c_int, 0x4b5);
pub const GDK_KEY_kana_KA = @as(c_int, 0x4b6);
pub const GDK_KEY_kana_KI = @as(c_int, 0x4b7);
pub const GDK_KEY_kana_KU = @as(c_int, 0x4b8);
pub const GDK_KEY_kana_KE = @as(c_int, 0x4b9);
pub const GDK_KEY_kana_KO = @as(c_int, 0x4ba);
pub const GDK_KEY_kana_SA = @as(c_int, 0x4bb);
pub const GDK_KEY_kana_SHI = @as(c_int, 0x4bc);
pub const GDK_KEY_kana_SU = @as(c_int, 0x4bd);
pub const GDK_KEY_kana_SE = @as(c_int, 0x4be);
pub const GDK_KEY_kana_SO = @as(c_int, 0x4bf);
pub const GDK_KEY_kana_TA = @as(c_int, 0x4c0);
pub const GDK_KEY_kana_CHI = @as(c_int, 0x4c1);
pub const GDK_KEY_kana_TI = @as(c_int, 0x4c1);
pub const GDK_KEY_kana_TSU = @as(c_int, 0x4c2);
pub const GDK_KEY_kana_TU = @as(c_int, 0x4c2);
pub const GDK_KEY_kana_TE = @as(c_int, 0x4c3);
pub const GDK_KEY_kana_TO = @as(c_int, 0x4c4);
pub const GDK_KEY_kana_NA = @as(c_int, 0x4c5);
pub const GDK_KEY_kana_NI = @as(c_int, 0x4c6);
pub const GDK_KEY_kana_NU = @as(c_int, 0x4c7);
pub const GDK_KEY_kana_NE = @as(c_int, 0x4c8);
pub const GDK_KEY_kana_NO = @as(c_int, 0x4c9);
pub const GDK_KEY_kana_HA = @as(c_int, 0x4ca);
pub const GDK_KEY_kana_HI = @as(c_int, 0x4cb);
pub const GDK_KEY_kana_FU = @as(c_int, 0x4cc);
pub const GDK_KEY_kana_HU = @as(c_int, 0x4cc);
pub const GDK_KEY_kana_HE = @as(c_int, 0x4cd);
pub const GDK_KEY_kana_HO = @as(c_int, 0x4ce);
pub const GDK_KEY_kana_MA = @as(c_int, 0x4cf);
pub const GDK_KEY_kana_MI = @as(c_int, 0x4d0);
pub const GDK_KEY_kana_MU = @as(c_int, 0x4d1);
pub const GDK_KEY_kana_ME = @as(c_int, 0x4d2);
pub const GDK_KEY_kana_MO = @as(c_int, 0x4d3);
pub const GDK_KEY_kana_YA = @as(c_int, 0x4d4);
pub const GDK_KEY_kana_YU = @as(c_int, 0x4d5);
pub const GDK_KEY_kana_YO = @as(c_int, 0x4d6);
pub const GDK_KEY_kana_RA = @as(c_int, 0x4d7);
pub const GDK_KEY_kana_RI = @as(c_int, 0x4d8);
pub const GDK_KEY_kana_RU = @as(c_int, 0x4d9);
pub const GDK_KEY_kana_RE = @as(c_int, 0x4da);
pub const GDK_KEY_kana_RO = @as(c_int, 0x4db);
pub const GDK_KEY_kana_WA = @as(c_int, 0x4dc);
pub const GDK_KEY_kana_N = @as(c_int, 0x4dd);
pub const GDK_KEY_voicedsound = @as(c_int, 0x4de);
pub const GDK_KEY_semivoicedsound = @as(c_int, 0x4df);
pub const GDK_KEY_kana_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_Farsi_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f0, .hexadecimal);
pub const GDK_KEY_Farsi_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f1, .hexadecimal);
pub const GDK_KEY_Farsi_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f2, .hexadecimal);
pub const GDK_KEY_Farsi_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f3, .hexadecimal);
pub const GDK_KEY_Farsi_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f4, .hexadecimal);
pub const GDK_KEY_Farsi_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f5, .hexadecimal);
pub const GDK_KEY_Farsi_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f6, .hexadecimal);
pub const GDK_KEY_Farsi_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f7, .hexadecimal);
pub const GDK_KEY_Farsi_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f8, .hexadecimal);
pub const GDK_KEY_Farsi_9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006f9, .hexadecimal);
pub const GDK_KEY_Arabic_percent = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100066a, .hexadecimal);
pub const GDK_KEY_Arabic_superscript_alef = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000670, .hexadecimal);
pub const GDK_KEY_Arabic_tteh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000679, .hexadecimal);
pub const GDK_KEY_Arabic_peh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100067e, .hexadecimal);
pub const GDK_KEY_Arabic_tcheh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000686, .hexadecimal);
pub const GDK_KEY_Arabic_ddal = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000688, .hexadecimal);
pub const GDK_KEY_Arabic_rreh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000691, .hexadecimal);
pub const GDK_KEY_Arabic_comma = @as(c_int, 0x5ac);
pub const GDK_KEY_Arabic_fullstop = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006d4, .hexadecimal);
pub const GDK_KEY_Arabic_0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000660, .hexadecimal);
pub const GDK_KEY_Arabic_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000661, .hexadecimal);
pub const GDK_KEY_Arabic_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000662, .hexadecimal);
pub const GDK_KEY_Arabic_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000663, .hexadecimal);
pub const GDK_KEY_Arabic_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000664, .hexadecimal);
pub const GDK_KEY_Arabic_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000665, .hexadecimal);
pub const GDK_KEY_Arabic_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000666, .hexadecimal);
pub const GDK_KEY_Arabic_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000667, .hexadecimal);
pub const GDK_KEY_Arabic_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000668, .hexadecimal);
pub const GDK_KEY_Arabic_9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000669, .hexadecimal);
pub const GDK_KEY_Arabic_semicolon = @as(c_int, 0x5bb);
pub const GDK_KEY_Arabic_question_mark = @as(c_int, 0x5bf);
pub const GDK_KEY_Arabic_hamza = @as(c_int, 0x5c1);
pub const GDK_KEY_Arabic_maddaonalef = @as(c_int, 0x5c2);
pub const GDK_KEY_Arabic_hamzaonalef = @as(c_int, 0x5c3);
pub const GDK_KEY_Arabic_hamzaonwaw = @as(c_int, 0x5c4);
pub const GDK_KEY_Arabic_hamzaunderalef = @as(c_int, 0x5c5);
pub const GDK_KEY_Arabic_hamzaonyeh = @as(c_int, 0x5c6);
pub const GDK_KEY_Arabic_alef = @as(c_int, 0x5c7);
pub const GDK_KEY_Arabic_beh = @as(c_int, 0x5c8);
pub const GDK_KEY_Arabic_tehmarbuta = @as(c_int, 0x5c9);
pub const GDK_KEY_Arabic_teh = @as(c_int, 0x5ca);
pub const GDK_KEY_Arabic_theh = @as(c_int, 0x5cb);
pub const GDK_KEY_Arabic_jeem = @as(c_int, 0x5cc);
pub const GDK_KEY_Arabic_hah = @as(c_int, 0x5cd);
pub const GDK_KEY_Arabic_khah = @as(c_int, 0x5ce);
pub const GDK_KEY_Arabic_dal = @as(c_int, 0x5cf);
pub const GDK_KEY_Arabic_thal = @as(c_int, 0x5d0);
pub const GDK_KEY_Arabic_ra = @as(c_int, 0x5d1);
pub const GDK_KEY_Arabic_zain = @as(c_int, 0x5d2);
pub const GDK_KEY_Arabic_seen = @as(c_int, 0x5d3);
pub const GDK_KEY_Arabic_sheen = @as(c_int, 0x5d4);
pub const GDK_KEY_Arabic_sad = @as(c_int, 0x5d5);
pub const GDK_KEY_Arabic_dad = @as(c_int, 0x5d6);
pub const GDK_KEY_Arabic_tah = @as(c_int, 0x5d7);
pub const GDK_KEY_Arabic_zah = @as(c_int, 0x5d8);
pub const GDK_KEY_Arabic_ain = @as(c_int, 0x5d9);
pub const GDK_KEY_Arabic_ghain = @as(c_int, 0x5da);
pub const GDK_KEY_Arabic_tatweel = @as(c_int, 0x5e0);
pub const GDK_KEY_Arabic_feh = @as(c_int, 0x5e1);
pub const GDK_KEY_Arabic_qaf = @as(c_int, 0x5e2);
pub const GDK_KEY_Arabic_kaf = @as(c_int, 0x5e3);
pub const GDK_KEY_Arabic_lam = @as(c_int, 0x5e4);
pub const GDK_KEY_Arabic_meem = @as(c_int, 0x5e5);
pub const GDK_KEY_Arabic_noon = @as(c_int, 0x5e6);
pub const GDK_KEY_Arabic_ha = @as(c_int, 0x5e7);
pub const GDK_KEY_Arabic_heh = @as(c_int, 0x5e7);
pub const GDK_KEY_Arabic_waw = @as(c_int, 0x5e8);
pub const GDK_KEY_Arabic_alefmaksura = @as(c_int, 0x5e9);
pub const GDK_KEY_Arabic_yeh = @as(c_int, 0x5ea);
pub const GDK_KEY_Arabic_fathatan = @as(c_int, 0x5eb);
pub const GDK_KEY_Arabic_dammatan = @as(c_int, 0x5ec);
pub const GDK_KEY_Arabic_kasratan = @as(c_int, 0x5ed);
pub const GDK_KEY_Arabic_fatha = @as(c_int, 0x5ee);
pub const GDK_KEY_Arabic_damma = @as(c_int, 0x5ef);
pub const GDK_KEY_Arabic_kasra = @as(c_int, 0x5f0);
pub const GDK_KEY_Arabic_shadda = @as(c_int, 0x5f1);
pub const GDK_KEY_Arabic_sukun = @as(c_int, 0x5f2);
pub const GDK_KEY_Arabic_madda_above = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000653, .hexadecimal);
pub const GDK_KEY_Arabic_hamza_above = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000654, .hexadecimal);
pub const GDK_KEY_Arabic_hamza_below = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000655, .hexadecimal);
pub const GDK_KEY_Arabic_jeh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000698, .hexadecimal);
pub const GDK_KEY_Arabic_veh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006a4, .hexadecimal);
pub const GDK_KEY_Arabic_keheh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006a9, .hexadecimal);
pub const GDK_KEY_Arabic_gaf = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006af, .hexadecimal);
pub const GDK_KEY_Arabic_noon_ghunna = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006ba, .hexadecimal);
pub const GDK_KEY_Arabic_heh_doachashmee = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006be, .hexadecimal);
pub const GDK_KEY_Farsi_yeh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006cc, .hexadecimal);
pub const GDK_KEY_Arabic_farsi_yeh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006cc, .hexadecimal);
pub const GDK_KEY_Arabic_yeh_baree = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006d2, .hexadecimal);
pub const GDK_KEY_Arabic_heh_goal = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10006c1, .hexadecimal);
pub const GDK_KEY_Arabic_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_Cyrillic_GHE_bar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000492, .hexadecimal);
pub const GDK_KEY_Cyrillic_ghe_bar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000493, .hexadecimal);
pub const GDK_KEY_Cyrillic_ZHE_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000496, .hexadecimal);
pub const GDK_KEY_Cyrillic_zhe_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000497, .hexadecimal);
pub const GDK_KEY_Cyrillic_KA_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100049a, .hexadecimal);
pub const GDK_KEY_Cyrillic_ka_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100049b, .hexadecimal);
pub const GDK_KEY_Cyrillic_KA_vertstroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100049c, .hexadecimal);
pub const GDK_KEY_Cyrillic_ka_vertstroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100049d, .hexadecimal);
pub const GDK_KEY_Cyrillic_EN_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004a2, .hexadecimal);
pub const GDK_KEY_Cyrillic_en_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004a3, .hexadecimal);
pub const GDK_KEY_Cyrillic_U_straight = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004ae, .hexadecimal);
pub const GDK_KEY_Cyrillic_u_straight = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004af, .hexadecimal);
pub const GDK_KEY_Cyrillic_U_straight_bar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b0, .hexadecimal);
pub const GDK_KEY_Cyrillic_u_straight_bar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b1, .hexadecimal);
pub const GDK_KEY_Cyrillic_HA_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b2, .hexadecimal);
pub const GDK_KEY_Cyrillic_ha_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b3, .hexadecimal);
pub const GDK_KEY_Cyrillic_CHE_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b6, .hexadecimal);
pub const GDK_KEY_Cyrillic_che_descender = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b7, .hexadecimal);
pub const GDK_KEY_Cyrillic_CHE_vertstroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b8, .hexadecimal);
pub const GDK_KEY_Cyrillic_che_vertstroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004b9, .hexadecimal);
pub const GDK_KEY_Cyrillic_SHHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004ba, .hexadecimal);
pub const GDK_KEY_Cyrillic_shha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004bb, .hexadecimal);
pub const GDK_KEY_Cyrillic_SCHWA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004d8, .hexadecimal);
pub const GDK_KEY_Cyrillic_schwa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004d9, .hexadecimal);
pub const GDK_KEY_Cyrillic_I_macron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004e2, .hexadecimal);
pub const GDK_KEY_Cyrillic_i_macron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004e3, .hexadecimal);
pub const GDK_KEY_Cyrillic_O_bar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004e8, .hexadecimal);
pub const GDK_KEY_Cyrillic_o_bar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004e9, .hexadecimal);
pub const GDK_KEY_Cyrillic_U_macron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004ee, .hexadecimal);
pub const GDK_KEY_Cyrillic_u_macron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004ef, .hexadecimal);
pub const GDK_KEY_Serbian_dje = @as(c_int, 0x6a1);
pub const GDK_KEY_Macedonia_gje = @as(c_int, 0x6a2);
pub const GDK_KEY_Cyrillic_io = @as(c_int, 0x6a3);
pub const GDK_KEY_Ukrainian_ie = @as(c_int, 0x6a4);
pub const GDK_KEY_Ukranian_je = @as(c_int, 0x6a4);
pub const GDK_KEY_Macedonia_dse = @as(c_int, 0x6a5);
pub const GDK_KEY_Ukrainian_i = @as(c_int, 0x6a6);
pub const GDK_KEY_Ukranian_i = @as(c_int, 0x6a6);
pub const GDK_KEY_Ukrainian_yi = @as(c_int, 0x6a7);
pub const GDK_KEY_Ukranian_yi = @as(c_int, 0x6a7);
pub const GDK_KEY_Cyrillic_je = @as(c_int, 0x6a8);
pub const GDK_KEY_Serbian_je = @as(c_int, 0x6a8);
pub const GDK_KEY_Cyrillic_lje = @as(c_int, 0x6a9);
pub const GDK_KEY_Serbian_lje = @as(c_int, 0x6a9);
pub const GDK_KEY_Cyrillic_nje = @as(c_int, 0x6aa);
pub const GDK_KEY_Serbian_nje = @as(c_int, 0x6aa);
pub const GDK_KEY_Serbian_tshe = @as(c_int, 0x6ab);
pub const GDK_KEY_Macedonia_kje = @as(c_int, 0x6ac);
pub const GDK_KEY_Ukrainian_ghe_with_upturn = @as(c_int, 0x6ad);
pub const GDK_KEY_Byelorussian_shortu = @as(c_int, 0x6ae);
pub const GDK_KEY_Cyrillic_dzhe = @as(c_int, 0x6af);
pub const GDK_KEY_Serbian_dze = @as(c_int, 0x6af);
pub const GDK_KEY_numerosign = @as(c_int, 0x6b0);
pub const GDK_KEY_Serbian_DJE = @as(c_int, 0x6b1);
pub const GDK_KEY_Macedonia_GJE = @as(c_int, 0x6b2);
pub const GDK_KEY_Cyrillic_IO = @as(c_int, 0x6b3);
pub const GDK_KEY_Ukrainian_IE = @as(c_int, 0x6b4);
pub const GDK_KEY_Ukranian_JE = @as(c_int, 0x6b4);
pub const GDK_KEY_Macedonia_DSE = @as(c_int, 0x6b5);
pub const GDK_KEY_Ukrainian_I = @as(c_int, 0x6b6);
pub const GDK_KEY_Ukranian_I = @as(c_int, 0x6b6);
pub const GDK_KEY_Ukrainian_YI = @as(c_int, 0x6b7);
pub const GDK_KEY_Ukranian_YI = @as(c_int, 0x6b7);
pub const GDK_KEY_Cyrillic_JE = @as(c_int, 0x6b8);
pub const GDK_KEY_Serbian_JE = @as(c_int, 0x6b8);
pub const GDK_KEY_Cyrillic_LJE = @as(c_int, 0x6b9);
pub const GDK_KEY_Serbian_LJE = @as(c_int, 0x6b9);
pub const GDK_KEY_Cyrillic_NJE = @as(c_int, 0x6ba);
pub const GDK_KEY_Serbian_NJE = @as(c_int, 0x6ba);
pub const GDK_KEY_Serbian_TSHE = @as(c_int, 0x6bb);
pub const GDK_KEY_Macedonia_KJE = @as(c_int, 0x6bc);
pub const GDK_KEY_Ukrainian_GHE_WITH_UPTURN = @as(c_int, 0x6bd);
pub const GDK_KEY_Byelorussian_SHORTU = @as(c_int, 0x6be);
pub const GDK_KEY_Cyrillic_DZHE = @as(c_int, 0x6bf);
pub const GDK_KEY_Serbian_DZE = @as(c_int, 0x6bf);
pub const GDK_KEY_Cyrillic_yu = @as(c_int, 0x6c0);
pub const GDK_KEY_Cyrillic_a = @as(c_int, 0x6c1);
pub const GDK_KEY_Cyrillic_be = @as(c_int, 0x6c2);
pub const GDK_KEY_Cyrillic_tse = @as(c_int, 0x6c3);
pub const GDK_KEY_Cyrillic_de = @as(c_int, 0x6c4);
pub const GDK_KEY_Cyrillic_ie = @as(c_int, 0x6c5);
pub const GDK_KEY_Cyrillic_ef = @as(c_int, 0x6c6);
pub const GDK_KEY_Cyrillic_ghe = @as(c_int, 0x6c7);
pub const GDK_KEY_Cyrillic_ha = @as(c_int, 0x6c8);
pub const GDK_KEY_Cyrillic_i = @as(c_int, 0x6c9);
pub const GDK_KEY_Cyrillic_shorti = @as(c_int, 0x6ca);
pub const GDK_KEY_Cyrillic_ka = @as(c_int, 0x6cb);
pub const GDK_KEY_Cyrillic_el = @as(c_int, 0x6cc);
pub const GDK_KEY_Cyrillic_em = @as(c_int, 0x6cd);
pub const GDK_KEY_Cyrillic_en = @as(c_int, 0x6ce);
pub const GDK_KEY_Cyrillic_o = @as(c_int, 0x6cf);
pub const GDK_KEY_Cyrillic_pe = @as(c_int, 0x6d0);
pub const GDK_KEY_Cyrillic_ya = @as(c_int, 0x6d1);
pub const GDK_KEY_Cyrillic_er = @as(c_int, 0x6d2);
pub const GDK_KEY_Cyrillic_es = @as(c_int, 0x6d3);
pub const GDK_KEY_Cyrillic_te = @as(c_int, 0x6d4);
pub const GDK_KEY_Cyrillic_u = @as(c_int, 0x6d5);
pub const GDK_KEY_Cyrillic_zhe = @as(c_int, 0x6d6);
pub const GDK_KEY_Cyrillic_ve = @as(c_int, 0x6d7);
pub const GDK_KEY_Cyrillic_softsign = @as(c_int, 0x6d8);
pub const GDK_KEY_Cyrillic_yeru = @as(c_int, 0x6d9);
pub const GDK_KEY_Cyrillic_ze = @as(c_int, 0x6da);
pub const GDK_KEY_Cyrillic_sha = @as(c_int, 0x6db);
pub const GDK_KEY_Cyrillic_e = @as(c_int, 0x6dc);
pub const GDK_KEY_Cyrillic_shcha = @as(c_int, 0x6dd);
pub const GDK_KEY_Cyrillic_che = @as(c_int, 0x6de);
pub const GDK_KEY_Cyrillic_hardsign = @as(c_int, 0x6df);
pub const GDK_KEY_Cyrillic_YU = @as(c_int, 0x6e0);
pub const GDK_KEY_Cyrillic_A = @as(c_int, 0x6e1);
pub const GDK_KEY_Cyrillic_BE = @as(c_int, 0x6e2);
pub const GDK_KEY_Cyrillic_TSE = @as(c_int, 0x6e3);
pub const GDK_KEY_Cyrillic_DE = @as(c_int, 0x6e4);
pub const GDK_KEY_Cyrillic_IE = @as(c_int, 0x6e5);
pub const GDK_KEY_Cyrillic_EF = @as(c_int, 0x6e6);
pub const GDK_KEY_Cyrillic_GHE = @as(c_int, 0x6e7);
pub const GDK_KEY_Cyrillic_HA = @as(c_int, 0x6e8);
pub const GDK_KEY_Cyrillic_I = @as(c_int, 0x6e9);
pub const GDK_KEY_Cyrillic_SHORTI = @as(c_int, 0x6ea);
pub const GDK_KEY_Cyrillic_KA = @as(c_int, 0x6eb);
pub const GDK_KEY_Cyrillic_EL = @as(c_int, 0x6ec);
pub const GDK_KEY_Cyrillic_EM = @as(c_int, 0x6ed);
pub const GDK_KEY_Cyrillic_EN = @as(c_int, 0x6ee);
pub const GDK_KEY_Cyrillic_O = @as(c_int, 0x6ef);
pub const GDK_KEY_Cyrillic_PE = @as(c_int, 0x6f0);
pub const GDK_KEY_Cyrillic_YA = @as(c_int, 0x6f1);
pub const GDK_KEY_Cyrillic_ER = @as(c_int, 0x6f2);
pub const GDK_KEY_Cyrillic_ES = @as(c_int, 0x6f3);
pub const GDK_KEY_Cyrillic_TE = @as(c_int, 0x6f4);
pub const GDK_KEY_Cyrillic_U = @as(c_int, 0x6f5);
pub const GDK_KEY_Cyrillic_ZHE = @as(c_int, 0x6f6);
pub const GDK_KEY_Cyrillic_VE = @as(c_int, 0x6f7);
pub const GDK_KEY_Cyrillic_SOFTSIGN = @as(c_int, 0x6f8);
pub const GDK_KEY_Cyrillic_YERU = @as(c_int, 0x6f9);
pub const GDK_KEY_Cyrillic_ZE = @as(c_int, 0x6fa);
pub const GDK_KEY_Cyrillic_SHA = @as(c_int, 0x6fb);
pub const GDK_KEY_Cyrillic_E = @as(c_int, 0x6fc);
pub const GDK_KEY_Cyrillic_SHCHA = @as(c_int, 0x6fd);
pub const GDK_KEY_Cyrillic_CHE = @as(c_int, 0x6fe);
pub const GDK_KEY_Cyrillic_HARDSIGN = @as(c_int, 0x6ff);
pub const GDK_KEY_Greek_ALPHAaccent = @as(c_int, 0x7a1);
pub const GDK_KEY_Greek_EPSILONaccent = @as(c_int, 0x7a2);
pub const GDK_KEY_Greek_ETAaccent = @as(c_int, 0x7a3);
pub const GDK_KEY_Greek_IOTAaccent = @as(c_int, 0x7a4);
pub const GDK_KEY_Greek_IOTAdieresis = @as(c_int, 0x7a5);
pub const GDK_KEY_Greek_IOTAdiaeresis = @as(c_int, 0x7a5);
pub const GDK_KEY_Greek_OMICRONaccent = @as(c_int, 0x7a7);
pub const GDK_KEY_Greek_UPSILONaccent = @as(c_int, 0x7a8);
pub const GDK_KEY_Greek_UPSILONdieresis = @as(c_int, 0x7a9);
pub const GDK_KEY_Greek_OMEGAaccent = @as(c_int, 0x7ab);
pub const GDK_KEY_Greek_accentdieresis = @as(c_int, 0x7ae);
pub const GDK_KEY_Greek_horizbar = @as(c_int, 0x7af);
pub const GDK_KEY_Greek_alphaaccent = @as(c_int, 0x7b1);
pub const GDK_KEY_Greek_epsilonaccent = @as(c_int, 0x7b2);
pub const GDK_KEY_Greek_etaaccent = @as(c_int, 0x7b3);
pub const GDK_KEY_Greek_iotaaccent = @as(c_int, 0x7b4);
pub const GDK_KEY_Greek_iotadieresis = @as(c_int, 0x7b5);
pub const GDK_KEY_Greek_iotaaccentdieresis = @as(c_int, 0x7b6);
pub const GDK_KEY_Greek_omicronaccent = @as(c_int, 0x7b7);
pub const GDK_KEY_Greek_upsilonaccent = @as(c_int, 0x7b8);
pub const GDK_KEY_Greek_upsilondieresis = @as(c_int, 0x7b9);
pub const GDK_KEY_Greek_upsilonaccentdieresis = @as(c_int, 0x7ba);
pub const GDK_KEY_Greek_omegaaccent = @as(c_int, 0x7bb);
pub const GDK_KEY_Greek_ALPHA = @as(c_int, 0x7c1);
pub const GDK_KEY_Greek_BETA = @as(c_int, 0x7c2);
pub const GDK_KEY_Greek_GAMMA = @as(c_int, 0x7c3);
pub const GDK_KEY_Greek_DELTA = @as(c_int, 0x7c4);
pub const GDK_KEY_Greek_EPSILON = @as(c_int, 0x7c5);
pub const GDK_KEY_Greek_ZETA = @as(c_int, 0x7c6);
pub const GDK_KEY_Greek_ETA = @as(c_int, 0x7c7);
pub const GDK_KEY_Greek_THETA = @as(c_int, 0x7c8);
pub const GDK_KEY_Greek_IOTA = @as(c_int, 0x7c9);
pub const GDK_KEY_Greek_KAPPA = @as(c_int, 0x7ca);
pub const GDK_KEY_Greek_LAMDA = @as(c_int, 0x7cb);
pub const GDK_KEY_Greek_LAMBDA = @as(c_int, 0x7cb);
pub const GDK_KEY_Greek_MU = @as(c_int, 0x7cc);
pub const GDK_KEY_Greek_NU = @as(c_int, 0x7cd);
pub const GDK_KEY_Greek_XI = @as(c_int, 0x7ce);
pub const GDK_KEY_Greek_OMICRON = @as(c_int, 0x7cf);
pub const GDK_KEY_Greek_PI = @as(c_int, 0x7d0);
pub const GDK_KEY_Greek_RHO = @as(c_int, 0x7d1);
pub const GDK_KEY_Greek_SIGMA = @as(c_int, 0x7d2);
pub const GDK_KEY_Greek_TAU = @as(c_int, 0x7d4);
pub const GDK_KEY_Greek_UPSILON = @as(c_int, 0x7d5);
pub const GDK_KEY_Greek_PHI = @as(c_int, 0x7d6);
pub const GDK_KEY_Greek_CHI = @as(c_int, 0x7d7);
pub const GDK_KEY_Greek_PSI = @as(c_int, 0x7d8);
pub const GDK_KEY_Greek_OMEGA = @as(c_int, 0x7d9);
pub const GDK_KEY_Greek_alpha = @as(c_int, 0x7e1);
pub const GDK_KEY_Greek_beta = @as(c_int, 0x7e2);
pub const GDK_KEY_Greek_gamma = @as(c_int, 0x7e3);
pub const GDK_KEY_Greek_delta = @as(c_int, 0x7e4);
pub const GDK_KEY_Greek_epsilon = @as(c_int, 0x7e5);
pub const GDK_KEY_Greek_zeta = @as(c_int, 0x7e6);
pub const GDK_KEY_Greek_eta = @as(c_int, 0x7e7);
pub const GDK_KEY_Greek_theta = @as(c_int, 0x7e8);
pub const GDK_KEY_Greek_iota = @as(c_int, 0x7e9);
pub const GDK_KEY_Greek_kappa = @as(c_int, 0x7ea);
pub const GDK_KEY_Greek_lamda = @as(c_int, 0x7eb);
pub const GDK_KEY_Greek_lambda = @as(c_int, 0x7eb);
pub const GDK_KEY_Greek_mu = @as(c_int, 0x7ec);
pub const GDK_KEY_Greek_nu = @as(c_int, 0x7ed);
pub const GDK_KEY_Greek_xi = @as(c_int, 0x7ee);
pub const GDK_KEY_Greek_omicron = @as(c_int, 0x7ef);
pub const GDK_KEY_Greek_pi = @as(c_int, 0x7f0);
pub const GDK_KEY_Greek_rho = @as(c_int, 0x7f1);
pub const GDK_KEY_Greek_sigma = @as(c_int, 0x7f2);
pub const GDK_KEY_Greek_finalsmallsigma = @as(c_int, 0x7f3);
pub const GDK_KEY_Greek_tau = @as(c_int, 0x7f4);
pub const GDK_KEY_Greek_upsilon = @as(c_int, 0x7f5);
pub const GDK_KEY_Greek_phi = @as(c_int, 0x7f6);
pub const GDK_KEY_Greek_chi = @as(c_int, 0x7f7);
pub const GDK_KEY_Greek_psi = @as(c_int, 0x7f8);
pub const GDK_KEY_Greek_omega = @as(c_int, 0x7f9);
pub const GDK_KEY_Greek_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_leftradical = @as(c_int, 0x8a1);
pub const GDK_KEY_topleftradical = @as(c_int, 0x8a2);
pub const GDK_KEY_horizconnector = @as(c_int, 0x8a3);
pub const GDK_KEY_topintegral = @as(c_int, 0x8a4);
pub const GDK_KEY_botintegral = @as(c_int, 0x8a5);
pub const GDK_KEY_vertconnector = @as(c_int, 0x8a6);
pub const GDK_KEY_topleftsqbracket = @as(c_int, 0x8a7);
pub const GDK_KEY_botleftsqbracket = @as(c_int, 0x8a8);
pub const GDK_KEY_toprightsqbracket = @as(c_int, 0x8a9);
pub const GDK_KEY_botrightsqbracket = @as(c_int, 0x8aa);
pub const GDK_KEY_topleftparens = @as(c_int, 0x8ab);
pub const GDK_KEY_botleftparens = @as(c_int, 0x8ac);
pub const GDK_KEY_toprightparens = @as(c_int, 0x8ad);
pub const GDK_KEY_botrightparens = @as(c_int, 0x8ae);
pub const GDK_KEY_leftmiddlecurlybrace = @as(c_int, 0x8af);
pub const GDK_KEY_rightmiddlecurlybrace = @as(c_int, 0x8b0);
pub const GDK_KEY_topleftsummation = @as(c_int, 0x8b1);
pub const GDK_KEY_botleftsummation = @as(c_int, 0x8b2);
pub const GDK_KEY_topvertsummationconnector = @as(c_int, 0x8b3);
pub const GDK_KEY_botvertsummationconnector = @as(c_int, 0x8b4);
pub const GDK_KEY_toprightsummation = @as(c_int, 0x8b5);
pub const GDK_KEY_botrightsummation = @as(c_int, 0x8b6);
pub const GDK_KEY_rightmiddlesummation = @as(c_int, 0x8b7);
pub const GDK_KEY_lessthanequal = @as(c_int, 0x8bc);
pub const GDK_KEY_notequal = @as(c_int, 0x8bd);
pub const GDK_KEY_greaterthanequal = @as(c_int, 0x8be);
pub const GDK_KEY_integral = @as(c_int, 0x8bf);
pub const GDK_KEY_therefore = @as(c_int, 0x8c0);
pub const GDK_KEY_variation = @as(c_int, 0x8c1);
pub const GDK_KEY_infinity = @as(c_int, 0x8c2);
pub const GDK_KEY_nabla = @as(c_int, 0x8c5);
pub const GDK_KEY_approximate = @as(c_int, 0x8c8);
pub const GDK_KEY_similarequal = @as(c_int, 0x8c9);
pub const GDK_KEY_ifonlyif = @as(c_int, 0x8cd);
pub const GDK_KEY_implies = @as(c_int, 0x8ce);
pub const GDK_KEY_identical = @as(c_int, 0x8cf);
pub const GDK_KEY_radical = @as(c_int, 0x8d6);
pub const GDK_KEY_includedin = @as(c_int, 0x8da);
pub const GDK_KEY_includes = @as(c_int, 0x8db);
pub const GDK_KEY_intersection = @as(c_int, 0x8dc);
pub const GDK_KEY_union = @as(c_int, 0x8dd);
pub const GDK_KEY_logicaland = @as(c_int, 0x8de);
pub const GDK_KEY_logicalor = @as(c_int, 0x8df);
pub const GDK_KEY_partialderivative = @as(c_int, 0x8ef);
pub const GDK_KEY_function = @as(c_int, 0x8f6);
pub const GDK_KEY_leftarrow = @as(c_int, 0x8fb);
pub const GDK_KEY_uparrow = @as(c_int, 0x8fc);
pub const GDK_KEY_rightarrow = @as(c_int, 0x8fd);
pub const GDK_KEY_downarrow = @as(c_int, 0x8fe);
pub const GDK_KEY_blank = @as(c_int, 0x9df);
pub const GDK_KEY_soliddiamond = @as(c_int, 0x9e0);
pub const GDK_KEY_checkerboard = @as(c_int, 0x9e1);
pub const GDK_KEY_ht = @as(c_int, 0x9e2);
pub const GDK_KEY_ff = @as(c_int, 0x9e3);
pub const GDK_KEY_cr = @as(c_int, 0x9e4);
pub const GDK_KEY_lf = @as(c_int, 0x9e5);
pub const GDK_KEY_nl = @as(c_int, 0x9e8);
pub const GDK_KEY_vt = @as(c_int, 0x9e9);
pub const GDK_KEY_lowrightcorner = @as(c_int, 0x9ea);
pub const GDK_KEY_uprightcorner = @as(c_int, 0x9eb);
pub const GDK_KEY_upleftcorner = @as(c_int, 0x9ec);
pub const GDK_KEY_lowleftcorner = @as(c_int, 0x9ed);
pub const GDK_KEY_crossinglines = @as(c_int, 0x9ee);
pub const GDK_KEY_horizlinescan1 = @as(c_int, 0x9ef);
pub const GDK_KEY_horizlinescan3 = @as(c_int, 0x9f0);
pub const GDK_KEY_horizlinescan5 = @as(c_int, 0x9f1);
pub const GDK_KEY_horizlinescan7 = @as(c_int, 0x9f2);
pub const GDK_KEY_horizlinescan9 = @as(c_int, 0x9f3);
pub const GDK_KEY_leftt = @as(c_int, 0x9f4);
pub const GDK_KEY_rightt = @as(c_int, 0x9f5);
pub const GDK_KEY_bott = @as(c_int, 0x9f6);
pub const GDK_KEY_topt = @as(c_int, 0x9f7);
pub const GDK_KEY_vertbar = @as(c_int, 0x9f8);
pub const GDK_KEY_emspace = @as(c_int, 0xaa1);
pub const GDK_KEY_enspace = @as(c_int, 0xaa2);
pub const GDK_KEY_em3space = @as(c_int, 0xaa3);
pub const GDK_KEY_em4space = @as(c_int, 0xaa4);
pub const GDK_KEY_digitspace = @as(c_int, 0xaa5);
pub const GDK_KEY_punctspace = @as(c_int, 0xaa6);
pub const GDK_KEY_thinspace = @as(c_int, 0xaa7);
pub const GDK_KEY_hairspace = @as(c_int, 0xaa8);
pub const GDK_KEY_emdash = @as(c_int, 0xaa9);
pub const GDK_KEY_endash = @as(c_int, 0xaaa);
pub const GDK_KEY_signifblank = @as(c_int, 0xaac);
pub const GDK_KEY_ellipsis = @as(c_int, 0xaae);
pub const GDK_KEY_doubbaselinedot = @as(c_int, 0xaaf);
pub const GDK_KEY_onethird = @as(c_int, 0xab0);
pub const GDK_KEY_twothirds = @as(c_int, 0xab1);
pub const GDK_KEY_onefifth = @as(c_int, 0xab2);
pub const GDK_KEY_twofifths = @as(c_int, 0xab3);
pub const GDK_KEY_threefifths = @as(c_int, 0xab4);
pub const GDK_KEY_fourfifths = @as(c_int, 0xab5);
pub const GDK_KEY_onesixth = @as(c_int, 0xab6);
pub const GDK_KEY_fivesixths = @as(c_int, 0xab7);
pub const GDK_KEY_careof = @as(c_int, 0xab8);
pub const GDK_KEY_figdash = @as(c_int, 0xabb);
pub const GDK_KEY_leftanglebracket = @as(c_int, 0xabc);
pub const GDK_KEY_decimalpoint = @as(c_int, 0xabd);
pub const GDK_KEY_rightanglebracket = @as(c_int, 0xabe);
pub const GDK_KEY_marker = @as(c_int, 0xabf);
pub const GDK_KEY_oneeighth = @as(c_int, 0xac3);
pub const GDK_KEY_threeeighths = @as(c_int, 0xac4);
pub const GDK_KEY_fiveeighths = @as(c_int, 0xac5);
pub const GDK_KEY_seveneighths = @as(c_int, 0xac6);
pub const GDK_KEY_trademark = @as(c_int, 0xac9);
pub const GDK_KEY_signaturemark = @as(c_int, 0xaca);
pub const GDK_KEY_trademarkincircle = @as(c_int, 0xacb);
pub const GDK_KEY_leftopentriangle = @as(c_int, 0xacc);
pub const GDK_KEY_rightopentriangle = @as(c_int, 0xacd);
pub const GDK_KEY_emopencircle = @as(c_int, 0xace);
pub const GDK_KEY_emopenrectangle = @as(c_int, 0xacf);
pub const GDK_KEY_leftsinglequotemark = @as(c_int, 0xad0);
pub const GDK_KEY_rightsinglequotemark = @as(c_int, 0xad1);
pub const GDK_KEY_leftdoublequotemark = @as(c_int, 0xad2);
pub const GDK_KEY_rightdoublequotemark = @as(c_int, 0xad3);
pub const GDK_KEY_prescription = @as(c_int, 0xad4);
pub const GDK_KEY_permille = @as(c_int, 0xad5);
pub const GDK_KEY_minutes = @as(c_int, 0xad6);
pub const GDK_KEY_seconds = @as(c_int, 0xad7);
pub const GDK_KEY_latincross = @as(c_int, 0xad9);
pub const GDK_KEY_hexagram = @as(c_int, 0xada);
pub const GDK_KEY_filledrectbullet = @as(c_int, 0xadb);
pub const GDK_KEY_filledlefttribullet = @as(c_int, 0xadc);
pub const GDK_KEY_filledrighttribullet = @as(c_int, 0xadd);
pub const GDK_KEY_emfilledcircle = @as(c_int, 0xade);
pub const GDK_KEY_emfilledrect = @as(c_int, 0xadf);
pub const GDK_KEY_enopencircbullet = @as(c_int, 0xae0);
pub const GDK_KEY_enopensquarebullet = @as(c_int, 0xae1);
pub const GDK_KEY_openrectbullet = @as(c_int, 0xae2);
pub const GDK_KEY_opentribulletup = @as(c_int, 0xae3);
pub const GDK_KEY_opentribulletdown = @as(c_int, 0xae4);
pub const GDK_KEY_openstar = @as(c_int, 0xae5);
pub const GDK_KEY_enfilledcircbullet = @as(c_int, 0xae6);
pub const GDK_KEY_enfilledsqbullet = @as(c_int, 0xae7);
pub const GDK_KEY_filledtribulletup = @as(c_int, 0xae8);
pub const GDK_KEY_filledtribulletdown = @as(c_int, 0xae9);
pub const GDK_KEY_leftpointer = @as(c_int, 0xaea);
pub const GDK_KEY_rightpointer = @as(c_int, 0xaeb);
pub const GDK_KEY_club = @as(c_int, 0xaec);
pub const GDK_KEY_diamond = @as(c_int, 0xaed);
pub const GDK_KEY_heart = @as(c_int, 0xaee);
pub const GDK_KEY_maltesecross = @as(c_int, 0xaf0);
pub const GDK_KEY_dagger = @as(c_int, 0xaf1);
pub const GDK_KEY_doubledagger = @as(c_int, 0xaf2);
pub const GDK_KEY_checkmark = @as(c_int, 0xaf3);
pub const GDK_KEY_ballotcross = @as(c_int, 0xaf4);
pub const GDK_KEY_musicalsharp = @as(c_int, 0xaf5);
pub const GDK_KEY_musicalflat = @as(c_int, 0xaf6);
pub const GDK_KEY_malesymbol = @as(c_int, 0xaf7);
pub const GDK_KEY_femalesymbol = @as(c_int, 0xaf8);
pub const GDK_KEY_telephone = @as(c_int, 0xaf9);
pub const GDK_KEY_telephonerecorder = @as(c_int, 0xafa);
pub const GDK_KEY_phonographcopyright = @as(c_int, 0xafb);
pub const GDK_KEY_caret = @as(c_int, 0xafc);
pub const GDK_KEY_singlelowquotemark = @as(c_int, 0xafd);
pub const GDK_KEY_doublelowquotemark = @as(c_int, 0xafe);
pub const GDK_KEY_cursor = @as(c_int, 0xaff);
pub const GDK_KEY_leftcaret = @as(c_int, 0xba3);
pub const GDK_KEY_rightcaret = @as(c_int, 0xba6);
pub const GDK_KEY_downcaret = @as(c_int, 0xba8);
pub const GDK_KEY_upcaret = @as(c_int, 0xba9);
pub const GDK_KEY_overbar = @as(c_int, 0xbc0);
pub const GDK_KEY_downtack = @as(c_int, 0xbc2);
pub const GDK_KEY_upshoe = @as(c_int, 0xbc3);
pub const GDK_KEY_downstile = @as(c_int, 0xbc4);
pub const GDK_KEY_underbar = @as(c_int, 0xbc6);
pub const GDK_KEY_jot = @as(c_int, 0xbca);
pub const GDK_KEY_quad = @as(c_int, 0xbcc);
pub const GDK_KEY_uptack = @as(c_int, 0xbce);
pub const GDK_KEY_circle = @as(c_int, 0xbcf);
pub const GDK_KEY_upstile = @as(c_int, 0xbd3);
pub const GDK_KEY_downshoe = @as(c_int, 0xbd6);
pub const GDK_KEY_rightshoe = @as(c_int, 0xbd8);
pub const GDK_KEY_leftshoe = @as(c_int, 0xbda);
pub const GDK_KEY_lefttack = @as(c_int, 0xbdc);
pub const GDK_KEY_righttack = @as(c_int, 0xbfc);
pub const GDK_KEY_hebrew_doublelowline = @as(c_int, 0xcdf);
pub const GDK_KEY_hebrew_aleph = @as(c_int, 0xce0);
pub const GDK_KEY_hebrew_bet = @as(c_int, 0xce1);
pub const GDK_KEY_hebrew_beth = @as(c_int, 0xce1);
pub const GDK_KEY_hebrew_gimel = @as(c_int, 0xce2);
pub const GDK_KEY_hebrew_gimmel = @as(c_int, 0xce2);
pub const GDK_KEY_hebrew_dalet = @as(c_int, 0xce3);
pub const GDK_KEY_hebrew_daleth = @as(c_int, 0xce3);
pub const GDK_KEY_hebrew_he = @as(c_int, 0xce4);
pub const GDK_KEY_hebrew_waw = @as(c_int, 0xce5);
pub const GDK_KEY_hebrew_zain = @as(c_int, 0xce6);
pub const GDK_KEY_hebrew_zayin = @as(c_int, 0xce6);
pub const GDK_KEY_hebrew_chet = @as(c_int, 0xce7);
pub const GDK_KEY_hebrew_het = @as(c_int, 0xce7);
pub const GDK_KEY_hebrew_tet = @as(c_int, 0xce8);
pub const GDK_KEY_hebrew_teth = @as(c_int, 0xce8);
pub const GDK_KEY_hebrew_yod = @as(c_int, 0xce9);
pub const GDK_KEY_hebrew_finalkaph = @as(c_int, 0xcea);
pub const GDK_KEY_hebrew_kaph = @as(c_int, 0xceb);
pub const GDK_KEY_hebrew_lamed = @as(c_int, 0xcec);
pub const GDK_KEY_hebrew_finalmem = @as(c_int, 0xced);
pub const GDK_KEY_hebrew_mem = @as(c_int, 0xcee);
pub const GDK_KEY_hebrew_finalnun = @as(c_int, 0xcef);
pub const GDK_KEY_hebrew_nun = @as(c_int, 0xcf0);
pub const GDK_KEY_hebrew_samech = @as(c_int, 0xcf1);
pub const GDK_KEY_hebrew_samekh = @as(c_int, 0xcf1);
pub const GDK_KEY_hebrew_ayin = @as(c_int, 0xcf2);
pub const GDK_KEY_hebrew_finalpe = @as(c_int, 0xcf3);
pub const GDK_KEY_hebrew_pe = @as(c_int, 0xcf4);
pub const GDK_KEY_hebrew_finalzade = @as(c_int, 0xcf5);
pub const GDK_KEY_hebrew_finalzadi = @as(c_int, 0xcf5);
pub const GDK_KEY_hebrew_zade = @as(c_int, 0xcf6);
pub const GDK_KEY_hebrew_zadi = @as(c_int, 0xcf6);
pub const GDK_KEY_hebrew_qoph = @as(c_int, 0xcf7);
pub const GDK_KEY_hebrew_kuf = @as(c_int, 0xcf7);
pub const GDK_KEY_hebrew_resh = @as(c_int, 0xcf8);
pub const GDK_KEY_hebrew_shin = @as(c_int, 0xcf9);
pub const GDK_KEY_hebrew_taw = @as(c_int, 0xcfa);
pub const GDK_KEY_hebrew_taf = @as(c_int, 0xcfa);
pub const GDK_KEY_Hebrew_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_Thai_kokai = @as(c_int, 0xda1);
pub const GDK_KEY_Thai_khokhai = @as(c_int, 0xda2);
pub const GDK_KEY_Thai_khokhuat = @as(c_int, 0xda3);
pub const GDK_KEY_Thai_khokhwai = @as(c_int, 0xda4);
pub const GDK_KEY_Thai_khokhon = @as(c_int, 0xda5);
pub const GDK_KEY_Thai_khorakhang = @as(c_int, 0xda6);
pub const GDK_KEY_Thai_ngongu = @as(c_int, 0xda7);
pub const GDK_KEY_Thai_chochan = @as(c_int, 0xda8);
pub const GDK_KEY_Thai_choching = @as(c_int, 0xda9);
pub const GDK_KEY_Thai_chochang = @as(c_int, 0xdaa);
pub const GDK_KEY_Thai_soso = @as(c_int, 0xdab);
pub const GDK_KEY_Thai_chochoe = @as(c_int, 0xdac);
pub const GDK_KEY_Thai_yoying = @as(c_int, 0xdad);
pub const GDK_KEY_Thai_dochada = @as(c_int, 0xdae);
pub const GDK_KEY_Thai_topatak = @as(c_int, 0xdaf);
pub const GDK_KEY_Thai_thothan = @as(c_int, 0xdb0);
pub const GDK_KEY_Thai_thonangmontho = @as(c_int, 0xdb1);
pub const GDK_KEY_Thai_thophuthao = @as(c_int, 0xdb2);
pub const GDK_KEY_Thai_nonen = @as(c_int, 0xdb3);
pub const GDK_KEY_Thai_dodek = @as(c_int, 0xdb4);
pub const GDK_KEY_Thai_totao = @as(c_int, 0xdb5);
pub const GDK_KEY_Thai_thothung = @as(c_int, 0xdb6);
pub const GDK_KEY_Thai_thothahan = @as(c_int, 0xdb7);
pub const GDK_KEY_Thai_thothong = @as(c_int, 0xdb8);
pub const GDK_KEY_Thai_nonu = @as(c_int, 0xdb9);
pub const GDK_KEY_Thai_bobaimai = @as(c_int, 0xdba);
pub const GDK_KEY_Thai_popla = @as(c_int, 0xdbb);
pub const GDK_KEY_Thai_phophung = @as(c_int, 0xdbc);
pub const GDK_KEY_Thai_fofa = @as(c_int, 0xdbd);
pub const GDK_KEY_Thai_phophan = @as(c_int, 0xdbe);
pub const GDK_KEY_Thai_fofan = @as(c_int, 0xdbf);
pub const GDK_KEY_Thai_phosamphao = @as(c_int, 0xdc0);
pub const GDK_KEY_Thai_moma = @as(c_int, 0xdc1);
pub const GDK_KEY_Thai_yoyak = @as(c_int, 0xdc2);
pub const GDK_KEY_Thai_rorua = @as(c_int, 0xdc3);
pub const GDK_KEY_Thai_ru = @as(c_int, 0xdc4);
pub const GDK_KEY_Thai_loling = @as(c_int, 0xdc5);
pub const GDK_KEY_Thai_lu = @as(c_int, 0xdc6);
pub const GDK_KEY_Thai_wowaen = @as(c_int, 0xdc7);
pub const GDK_KEY_Thai_sosala = @as(c_int, 0xdc8);
pub const GDK_KEY_Thai_sorusi = @as(c_int, 0xdc9);
pub const GDK_KEY_Thai_sosua = @as(c_int, 0xdca);
pub const GDK_KEY_Thai_hohip = @as(c_int, 0xdcb);
pub const GDK_KEY_Thai_lochula = @as(c_int, 0xdcc);
pub const GDK_KEY_Thai_oang = @as(c_int, 0xdcd);
pub const GDK_KEY_Thai_honokhuk = @as(c_int, 0xdce);
pub const GDK_KEY_Thai_paiyannoi = @as(c_int, 0xdcf);
pub const GDK_KEY_Thai_saraa = @as(c_int, 0xdd0);
pub const GDK_KEY_Thai_maihanakat = @as(c_int, 0xdd1);
pub const GDK_KEY_Thai_saraaa = @as(c_int, 0xdd2);
pub const GDK_KEY_Thai_saraam = @as(c_int, 0xdd3);
pub const GDK_KEY_Thai_sarai = @as(c_int, 0xdd4);
pub const GDK_KEY_Thai_saraii = @as(c_int, 0xdd5);
pub const GDK_KEY_Thai_saraue = @as(c_int, 0xdd6);
pub const GDK_KEY_Thai_sarauee = @as(c_int, 0xdd7);
pub const GDK_KEY_Thai_sarau = @as(c_int, 0xdd8);
pub const GDK_KEY_Thai_sarauu = @as(c_int, 0xdd9);
pub const GDK_KEY_Thai_phinthu = @as(c_int, 0xdda);
pub const GDK_KEY_Thai_maihanakat_maitho = @as(c_int, 0xdde);
pub const GDK_KEY_Thai_baht = @as(c_int, 0xddf);
pub const GDK_KEY_Thai_sarae = @as(c_int, 0xde0);
pub const GDK_KEY_Thai_saraae = @as(c_int, 0xde1);
pub const GDK_KEY_Thai_sarao = @as(c_int, 0xde2);
pub const GDK_KEY_Thai_saraaimaimuan = @as(c_int, 0xde3);
pub const GDK_KEY_Thai_saraaimaimalai = @as(c_int, 0xde4);
pub const GDK_KEY_Thai_lakkhangyao = @as(c_int, 0xde5);
pub const GDK_KEY_Thai_maiyamok = @as(c_int, 0xde6);
pub const GDK_KEY_Thai_maitaikhu = @as(c_int, 0xde7);
pub const GDK_KEY_Thai_maiek = @as(c_int, 0xde8);
pub const GDK_KEY_Thai_maitho = @as(c_int, 0xde9);
pub const GDK_KEY_Thai_maitri = @as(c_int, 0xdea);
pub const GDK_KEY_Thai_maichattawa = @as(c_int, 0xdeb);
pub const GDK_KEY_Thai_thanthakhat = @as(c_int, 0xdec);
pub const GDK_KEY_Thai_nikhahit = @as(c_int, 0xded);
pub const GDK_KEY_Thai_leksun = @as(c_int, 0xdf0);
pub const GDK_KEY_Thai_leknung = @as(c_int, 0xdf1);
pub const GDK_KEY_Thai_leksong = @as(c_int, 0xdf2);
pub const GDK_KEY_Thai_leksam = @as(c_int, 0xdf3);
pub const GDK_KEY_Thai_leksi = @as(c_int, 0xdf4);
pub const GDK_KEY_Thai_lekha = @as(c_int, 0xdf5);
pub const GDK_KEY_Thai_lekhok = @as(c_int, 0xdf6);
pub const GDK_KEY_Thai_lekchet = @as(c_int, 0xdf7);
pub const GDK_KEY_Thai_lekpaet = @as(c_int, 0xdf8);
pub const GDK_KEY_Thai_lekkao = @as(c_int, 0xdf9);
pub const GDK_KEY_Hangul = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff31, .hexadecimal);
pub const GDK_KEY_Hangul_Start = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff32, .hexadecimal);
pub const GDK_KEY_Hangul_End = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff33, .hexadecimal);
pub const GDK_KEY_Hangul_Hanja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff34, .hexadecimal);
pub const GDK_KEY_Hangul_Jamo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff35, .hexadecimal);
pub const GDK_KEY_Hangul_Romaja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff36, .hexadecimal);
pub const GDK_KEY_Hangul_Codeinput = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff37, .hexadecimal);
pub const GDK_KEY_Hangul_Jeonja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff38, .hexadecimal);
pub const GDK_KEY_Hangul_Banja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff39, .hexadecimal);
pub const GDK_KEY_Hangul_PreHanja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3a, .hexadecimal);
pub const GDK_KEY_Hangul_PostHanja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3b, .hexadecimal);
pub const GDK_KEY_Hangul_SingleCandidate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3c, .hexadecimal);
pub const GDK_KEY_Hangul_MultipleCandidate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3d, .hexadecimal);
pub const GDK_KEY_Hangul_PreviousCandidate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3e, .hexadecimal);
pub const GDK_KEY_Hangul_Special = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff3f, .hexadecimal);
pub const GDK_KEY_Hangul_switch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff7e, .hexadecimal);
pub const GDK_KEY_Hangul_Kiyeog = @as(c_int, 0xea1);
pub const GDK_KEY_Hangul_SsangKiyeog = @as(c_int, 0xea2);
pub const GDK_KEY_Hangul_KiyeogSios = @as(c_int, 0xea3);
pub const GDK_KEY_Hangul_Nieun = @as(c_int, 0xea4);
pub const GDK_KEY_Hangul_NieunJieuj = @as(c_int, 0xea5);
pub const GDK_KEY_Hangul_NieunHieuh = @as(c_int, 0xea6);
pub const GDK_KEY_Hangul_Dikeud = @as(c_int, 0xea7);
pub const GDK_KEY_Hangul_SsangDikeud = @as(c_int, 0xea8);
pub const GDK_KEY_Hangul_Rieul = @as(c_int, 0xea9);
pub const GDK_KEY_Hangul_RieulKiyeog = @as(c_int, 0xeaa);
pub const GDK_KEY_Hangul_RieulMieum = @as(c_int, 0xeab);
pub const GDK_KEY_Hangul_RieulPieub = @as(c_int, 0xeac);
pub const GDK_KEY_Hangul_RieulSios = @as(c_int, 0xead);
pub const GDK_KEY_Hangul_RieulTieut = @as(c_int, 0xeae);
pub const GDK_KEY_Hangul_RieulPhieuf = @as(c_int, 0xeaf);
pub const GDK_KEY_Hangul_RieulHieuh = @as(c_int, 0xeb0);
pub const GDK_KEY_Hangul_Mieum = @as(c_int, 0xeb1);
pub const GDK_KEY_Hangul_Pieub = @as(c_int, 0xeb2);
pub const GDK_KEY_Hangul_SsangPieub = @as(c_int, 0xeb3);
pub const GDK_KEY_Hangul_PieubSios = @as(c_int, 0xeb4);
pub const GDK_KEY_Hangul_Sios = @as(c_int, 0xeb5);
pub const GDK_KEY_Hangul_SsangSios = @as(c_int, 0xeb6);
pub const GDK_KEY_Hangul_Ieung = @as(c_int, 0xeb7);
pub const GDK_KEY_Hangul_Jieuj = @as(c_int, 0xeb8);
pub const GDK_KEY_Hangul_SsangJieuj = @as(c_int, 0xeb9);
pub const GDK_KEY_Hangul_Cieuc = @as(c_int, 0xeba);
pub const GDK_KEY_Hangul_Khieuq = @as(c_int, 0xebb);
pub const GDK_KEY_Hangul_Tieut = @as(c_int, 0xebc);
pub const GDK_KEY_Hangul_Phieuf = @as(c_int, 0xebd);
pub const GDK_KEY_Hangul_Hieuh = @as(c_int, 0xebe);
pub const GDK_KEY_Hangul_A = @as(c_int, 0xebf);
pub const GDK_KEY_Hangul_AE = @as(c_int, 0xec0);
pub const GDK_KEY_Hangul_YA = @as(c_int, 0xec1);
pub const GDK_KEY_Hangul_YAE = @as(c_int, 0xec2);
pub const GDK_KEY_Hangul_EO = @as(c_int, 0xec3);
pub const GDK_KEY_Hangul_E = @as(c_int, 0xec4);
pub const GDK_KEY_Hangul_YEO = @as(c_int, 0xec5);
pub const GDK_KEY_Hangul_YE = @as(c_int, 0xec6);
pub const GDK_KEY_Hangul_O = @as(c_int, 0xec7);
pub const GDK_KEY_Hangul_WA = @as(c_int, 0xec8);
pub const GDK_KEY_Hangul_WAE = @as(c_int, 0xec9);
pub const GDK_KEY_Hangul_OE = @as(c_int, 0xeca);
pub const GDK_KEY_Hangul_YO = @as(c_int, 0xecb);
pub const GDK_KEY_Hangul_U = @as(c_int, 0xecc);
pub const GDK_KEY_Hangul_WEO = @as(c_int, 0xecd);
pub const GDK_KEY_Hangul_WE = @as(c_int, 0xece);
pub const GDK_KEY_Hangul_WI = @as(c_int, 0xecf);
pub const GDK_KEY_Hangul_YU = @as(c_int, 0xed0);
pub const GDK_KEY_Hangul_EU = @as(c_int, 0xed1);
pub const GDK_KEY_Hangul_YI = @as(c_int, 0xed2);
pub const GDK_KEY_Hangul_I = @as(c_int, 0xed3);
pub const GDK_KEY_Hangul_J_Kiyeog = @as(c_int, 0xed4);
pub const GDK_KEY_Hangul_J_SsangKiyeog = @as(c_int, 0xed5);
pub const GDK_KEY_Hangul_J_KiyeogSios = @as(c_int, 0xed6);
pub const GDK_KEY_Hangul_J_Nieun = @as(c_int, 0xed7);
pub const GDK_KEY_Hangul_J_NieunJieuj = @as(c_int, 0xed8);
pub const GDK_KEY_Hangul_J_NieunHieuh = @as(c_int, 0xed9);
pub const GDK_KEY_Hangul_J_Dikeud = @as(c_int, 0xeda);
pub const GDK_KEY_Hangul_J_Rieul = @as(c_int, 0xedb);
pub const GDK_KEY_Hangul_J_RieulKiyeog = @as(c_int, 0xedc);
pub const GDK_KEY_Hangul_J_RieulMieum = @as(c_int, 0xedd);
pub const GDK_KEY_Hangul_J_RieulPieub = @as(c_int, 0xede);
pub const GDK_KEY_Hangul_J_RieulSios = @as(c_int, 0xedf);
pub const GDK_KEY_Hangul_J_RieulTieut = @as(c_int, 0xee0);
pub const GDK_KEY_Hangul_J_RieulPhieuf = @as(c_int, 0xee1);
pub const GDK_KEY_Hangul_J_RieulHieuh = @as(c_int, 0xee2);
pub const GDK_KEY_Hangul_J_Mieum = @as(c_int, 0xee3);
pub const GDK_KEY_Hangul_J_Pieub = @as(c_int, 0xee4);
pub const GDK_KEY_Hangul_J_PieubSios = @as(c_int, 0xee5);
pub const GDK_KEY_Hangul_J_Sios = @as(c_int, 0xee6);
pub const GDK_KEY_Hangul_J_SsangSios = @as(c_int, 0xee7);
pub const GDK_KEY_Hangul_J_Ieung = @as(c_int, 0xee8);
pub const GDK_KEY_Hangul_J_Jieuj = @as(c_int, 0xee9);
pub const GDK_KEY_Hangul_J_Cieuc = @as(c_int, 0xeea);
pub const GDK_KEY_Hangul_J_Khieuq = @as(c_int, 0xeeb);
pub const GDK_KEY_Hangul_J_Tieut = @as(c_int, 0xeec);
pub const GDK_KEY_Hangul_J_Phieuf = @as(c_int, 0xeed);
pub const GDK_KEY_Hangul_J_Hieuh = @as(c_int, 0xeee);
pub const GDK_KEY_Hangul_RieulYeorinHieuh = @as(c_int, 0xeef);
pub const GDK_KEY_Hangul_SunkyeongeumMieum = @as(c_int, 0xef0);
pub const GDK_KEY_Hangul_SunkyeongeumPieub = @as(c_int, 0xef1);
pub const GDK_KEY_Hangul_PanSios = @as(c_int, 0xef2);
pub const GDK_KEY_Hangul_KkogjiDalrinIeung = @as(c_int, 0xef3);
pub const GDK_KEY_Hangul_SunkyeongeumPhieuf = @as(c_int, 0xef4);
pub const GDK_KEY_Hangul_YeorinHieuh = @as(c_int, 0xef5);
pub const GDK_KEY_Hangul_AraeA = @as(c_int, 0xef6);
pub const GDK_KEY_Hangul_AraeAE = @as(c_int, 0xef7);
pub const GDK_KEY_Hangul_J_PanSios = @as(c_int, 0xef8);
pub const GDK_KEY_Hangul_J_KkogjiDalrinIeung = @as(c_int, 0xef9);
pub const GDK_KEY_Hangul_J_YeorinHieuh = @as(c_int, 0xefa);
pub const GDK_KEY_Korean_Won = @as(c_int, 0xeff);
pub const GDK_KEY_Armenian_ligature_ew = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000587, .hexadecimal);
pub const GDK_KEY_Armenian_full_stop = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000589, .hexadecimal);
pub const GDK_KEY_Armenian_verjaket = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000589, .hexadecimal);
pub const GDK_KEY_Armenian_separation_mark = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055d, .hexadecimal);
pub const GDK_KEY_Armenian_but = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055d, .hexadecimal);
pub const GDK_KEY_Armenian_hyphen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100058a, .hexadecimal);
pub const GDK_KEY_Armenian_yentamna = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100058a, .hexadecimal);
pub const GDK_KEY_Armenian_exclam = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055c, .hexadecimal);
pub const GDK_KEY_Armenian_amanak = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055c, .hexadecimal);
pub const GDK_KEY_Armenian_accent = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055b, .hexadecimal);
pub const GDK_KEY_Armenian_shesht = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055b, .hexadecimal);
pub const GDK_KEY_Armenian_question = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055e, .hexadecimal);
pub const GDK_KEY_Armenian_paruyk = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055e, .hexadecimal);
pub const GDK_KEY_Armenian_AYB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000531, .hexadecimal);
pub const GDK_KEY_Armenian_ayb = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000561, .hexadecimal);
pub const GDK_KEY_Armenian_BEN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000532, .hexadecimal);
pub const GDK_KEY_Armenian_ben = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000562, .hexadecimal);
pub const GDK_KEY_Armenian_GIM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000533, .hexadecimal);
pub const GDK_KEY_Armenian_gim = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000563, .hexadecimal);
pub const GDK_KEY_Armenian_DA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000534, .hexadecimal);
pub const GDK_KEY_Armenian_da = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000564, .hexadecimal);
pub const GDK_KEY_Armenian_YECH = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000535, .hexadecimal);
pub const GDK_KEY_Armenian_yech = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000565, .hexadecimal);
pub const GDK_KEY_Armenian_ZA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000536, .hexadecimal);
pub const GDK_KEY_Armenian_za = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000566, .hexadecimal);
pub const GDK_KEY_Armenian_E = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000537, .hexadecimal);
pub const GDK_KEY_Armenian_e = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000567, .hexadecimal);
pub const GDK_KEY_Armenian_AT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000538, .hexadecimal);
pub const GDK_KEY_Armenian_at = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000568, .hexadecimal);
pub const GDK_KEY_Armenian_TO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000539, .hexadecimal);
pub const GDK_KEY_Armenian_to = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000569, .hexadecimal);
pub const GDK_KEY_Armenian_ZHE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100053a, .hexadecimal);
pub const GDK_KEY_Armenian_zhe = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100056a, .hexadecimal);
pub const GDK_KEY_Armenian_INI = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100053b, .hexadecimal);
pub const GDK_KEY_Armenian_ini = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100056b, .hexadecimal);
pub const GDK_KEY_Armenian_LYUN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100053c, .hexadecimal);
pub const GDK_KEY_Armenian_lyun = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100056c, .hexadecimal);
pub const GDK_KEY_Armenian_KHE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100053d, .hexadecimal);
pub const GDK_KEY_Armenian_khe = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100056d, .hexadecimal);
pub const GDK_KEY_Armenian_TSA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100053e, .hexadecimal);
pub const GDK_KEY_Armenian_tsa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100056e, .hexadecimal);
pub const GDK_KEY_Armenian_KEN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100053f, .hexadecimal);
pub const GDK_KEY_Armenian_ken = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100056f, .hexadecimal);
pub const GDK_KEY_Armenian_HO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000540, .hexadecimal);
pub const GDK_KEY_Armenian_ho = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000570, .hexadecimal);
pub const GDK_KEY_Armenian_DZA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000541, .hexadecimal);
pub const GDK_KEY_Armenian_dza = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000571, .hexadecimal);
pub const GDK_KEY_Armenian_GHAT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000542, .hexadecimal);
pub const GDK_KEY_Armenian_ghat = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000572, .hexadecimal);
pub const GDK_KEY_Armenian_TCHE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000543, .hexadecimal);
pub const GDK_KEY_Armenian_tche = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000573, .hexadecimal);
pub const GDK_KEY_Armenian_MEN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000544, .hexadecimal);
pub const GDK_KEY_Armenian_men = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000574, .hexadecimal);
pub const GDK_KEY_Armenian_HI = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000545, .hexadecimal);
pub const GDK_KEY_Armenian_hi = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000575, .hexadecimal);
pub const GDK_KEY_Armenian_NU = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000546, .hexadecimal);
pub const GDK_KEY_Armenian_nu = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000576, .hexadecimal);
pub const GDK_KEY_Armenian_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000547, .hexadecimal);
pub const GDK_KEY_Armenian_sha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000577, .hexadecimal);
pub const GDK_KEY_Armenian_VO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000548, .hexadecimal);
pub const GDK_KEY_Armenian_vo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000578, .hexadecimal);
pub const GDK_KEY_Armenian_CHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000549, .hexadecimal);
pub const GDK_KEY_Armenian_cha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000579, .hexadecimal);
pub const GDK_KEY_Armenian_PE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100054a, .hexadecimal);
pub const GDK_KEY_Armenian_pe = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100057a, .hexadecimal);
pub const GDK_KEY_Armenian_JE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100054b, .hexadecimal);
pub const GDK_KEY_Armenian_je = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100057b, .hexadecimal);
pub const GDK_KEY_Armenian_RA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100054c, .hexadecimal);
pub const GDK_KEY_Armenian_ra = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100057c, .hexadecimal);
pub const GDK_KEY_Armenian_SE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100054d, .hexadecimal);
pub const GDK_KEY_Armenian_se = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100057d, .hexadecimal);
pub const GDK_KEY_Armenian_VEV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100054e, .hexadecimal);
pub const GDK_KEY_Armenian_vev = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100057e, .hexadecimal);
pub const GDK_KEY_Armenian_TYUN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100054f, .hexadecimal);
pub const GDK_KEY_Armenian_tyun = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100057f, .hexadecimal);
pub const GDK_KEY_Armenian_RE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000550, .hexadecimal);
pub const GDK_KEY_Armenian_re = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000580, .hexadecimal);
pub const GDK_KEY_Armenian_TSO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000551, .hexadecimal);
pub const GDK_KEY_Armenian_tso = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000581, .hexadecimal);
pub const GDK_KEY_Armenian_VYUN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000552, .hexadecimal);
pub const GDK_KEY_Armenian_vyun = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000582, .hexadecimal);
pub const GDK_KEY_Armenian_PYUR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000553, .hexadecimal);
pub const GDK_KEY_Armenian_pyur = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000583, .hexadecimal);
pub const GDK_KEY_Armenian_KE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000554, .hexadecimal);
pub const GDK_KEY_Armenian_ke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000584, .hexadecimal);
pub const GDK_KEY_Armenian_O = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000555, .hexadecimal);
pub const GDK_KEY_Armenian_o = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000585, .hexadecimal);
pub const GDK_KEY_Armenian_FE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000556, .hexadecimal);
pub const GDK_KEY_Armenian_fe = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000586, .hexadecimal);
pub const GDK_KEY_Armenian_apostrophe = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100055a, .hexadecimal);
pub const GDK_KEY_Georgian_an = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d0, .hexadecimal);
pub const GDK_KEY_Georgian_ban = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d1, .hexadecimal);
pub const GDK_KEY_Georgian_gan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d2, .hexadecimal);
pub const GDK_KEY_Georgian_don = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d3, .hexadecimal);
pub const GDK_KEY_Georgian_en = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d4, .hexadecimal);
pub const GDK_KEY_Georgian_vin = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d5, .hexadecimal);
pub const GDK_KEY_Georgian_zen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d6, .hexadecimal);
pub const GDK_KEY_Georgian_tan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d7, .hexadecimal);
pub const GDK_KEY_Georgian_in = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d8, .hexadecimal);
pub const GDK_KEY_Georgian_kan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010d9, .hexadecimal);
pub const GDK_KEY_Georgian_las = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010da, .hexadecimal);
pub const GDK_KEY_Georgian_man = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010db, .hexadecimal);
pub const GDK_KEY_Georgian_nar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010dc, .hexadecimal);
pub const GDK_KEY_Georgian_on = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010dd, .hexadecimal);
pub const GDK_KEY_Georgian_par = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010de, .hexadecimal);
pub const GDK_KEY_Georgian_zhar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010df, .hexadecimal);
pub const GDK_KEY_Georgian_rae = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e0, .hexadecimal);
pub const GDK_KEY_Georgian_san = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e1, .hexadecimal);
pub const GDK_KEY_Georgian_tar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e2, .hexadecimal);
pub const GDK_KEY_Georgian_un = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e3, .hexadecimal);
pub const GDK_KEY_Georgian_phar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e4, .hexadecimal);
pub const GDK_KEY_Georgian_khar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e5, .hexadecimal);
pub const GDK_KEY_Georgian_ghan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e6, .hexadecimal);
pub const GDK_KEY_Georgian_qar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e7, .hexadecimal);
pub const GDK_KEY_Georgian_shin = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e8, .hexadecimal);
pub const GDK_KEY_Georgian_chin = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010e9, .hexadecimal);
pub const GDK_KEY_Georgian_can = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010ea, .hexadecimal);
pub const GDK_KEY_Georgian_jil = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010eb, .hexadecimal);
pub const GDK_KEY_Georgian_cil = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010ec, .hexadecimal);
pub const GDK_KEY_Georgian_char = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010ed, .hexadecimal);
pub const GDK_KEY_Georgian_xan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010ee, .hexadecimal);
pub const GDK_KEY_Georgian_jhan = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010ef, .hexadecimal);
pub const GDK_KEY_Georgian_hae = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f0, .hexadecimal);
pub const GDK_KEY_Georgian_he = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f1, .hexadecimal);
pub const GDK_KEY_Georgian_hie = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f2, .hexadecimal);
pub const GDK_KEY_Georgian_we = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f3, .hexadecimal);
pub const GDK_KEY_Georgian_har = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f4, .hexadecimal);
pub const GDK_KEY_Georgian_hoe = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f5, .hexadecimal);
pub const GDK_KEY_Georgian_fi = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10010f6, .hexadecimal);
pub const GDK_KEY_Xabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e8a, .hexadecimal);
pub const GDK_KEY_Ibreve = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100012c, .hexadecimal);
pub const GDK_KEY_Zstroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001b5, .hexadecimal);
pub const GDK_KEY_Gcaron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001e6, .hexadecimal);
pub const GDK_KEY_Ocaron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001d1, .hexadecimal);
pub const GDK_KEY_Obarred = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100019f, .hexadecimal);
pub const GDK_KEY_xabovedot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e8b, .hexadecimal);
pub const GDK_KEY_ibreve = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100012d, .hexadecimal);
pub const GDK_KEY_zstroke = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001b6, .hexadecimal);
pub const GDK_KEY_gcaron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001e7, .hexadecimal);
pub const GDK_KEY_ocaron = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001d2, .hexadecimal);
pub const GDK_KEY_obarred = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000275, .hexadecimal);
pub const GDK_KEY_SCHWA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100018f, .hexadecimal);
pub const GDK_KEY_schwa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000259, .hexadecimal);
pub const GDK_KEY_EZH = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001b7, .hexadecimal);
pub const GDK_KEY_ezh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000292, .hexadecimal);
pub const GDK_KEY_Lbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e36, .hexadecimal);
pub const GDK_KEY_lbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001e37, .hexadecimal);
pub const GDK_KEY_Abelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea0, .hexadecimal);
pub const GDK_KEY_abelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea1, .hexadecimal);
pub const GDK_KEY_Ahook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea2, .hexadecimal);
pub const GDK_KEY_ahook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea3, .hexadecimal);
pub const GDK_KEY_Acircumflexacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea4, .hexadecimal);
pub const GDK_KEY_acircumflexacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea5, .hexadecimal);
pub const GDK_KEY_Acircumflexgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea6, .hexadecimal);
pub const GDK_KEY_acircumflexgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea7, .hexadecimal);
pub const GDK_KEY_Acircumflexhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea8, .hexadecimal);
pub const GDK_KEY_acircumflexhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ea9, .hexadecimal);
pub const GDK_KEY_Acircumflextilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eaa, .hexadecimal);
pub const GDK_KEY_acircumflextilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eab, .hexadecimal);
pub const GDK_KEY_Acircumflexbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eac, .hexadecimal);
pub const GDK_KEY_acircumflexbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ead, .hexadecimal);
pub const GDK_KEY_Abreveacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eae, .hexadecimal);
pub const GDK_KEY_abreveacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eaf, .hexadecimal);
pub const GDK_KEY_Abrevegrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb0, .hexadecimal);
pub const GDK_KEY_abrevegrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb1, .hexadecimal);
pub const GDK_KEY_Abrevehook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb2, .hexadecimal);
pub const GDK_KEY_abrevehook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb3, .hexadecimal);
pub const GDK_KEY_Abrevetilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb4, .hexadecimal);
pub const GDK_KEY_abrevetilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb5, .hexadecimal);
pub const GDK_KEY_Abrevebelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb6, .hexadecimal);
pub const GDK_KEY_abrevebelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb7, .hexadecimal);
pub const GDK_KEY_Ebelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb8, .hexadecimal);
pub const GDK_KEY_ebelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eb9, .hexadecimal);
pub const GDK_KEY_Ehook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eba, .hexadecimal);
pub const GDK_KEY_ehook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ebb, .hexadecimal);
pub const GDK_KEY_Etilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ebc, .hexadecimal);
pub const GDK_KEY_etilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ebd, .hexadecimal);
pub const GDK_KEY_Ecircumflexacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ebe, .hexadecimal);
pub const GDK_KEY_ecircumflexacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ebf, .hexadecimal);
pub const GDK_KEY_Ecircumflexgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec0, .hexadecimal);
pub const GDK_KEY_ecircumflexgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec1, .hexadecimal);
pub const GDK_KEY_Ecircumflexhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec2, .hexadecimal);
pub const GDK_KEY_ecircumflexhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec3, .hexadecimal);
pub const GDK_KEY_Ecircumflextilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec4, .hexadecimal);
pub const GDK_KEY_ecircumflextilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec5, .hexadecimal);
pub const GDK_KEY_Ecircumflexbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec6, .hexadecimal);
pub const GDK_KEY_ecircumflexbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec7, .hexadecimal);
pub const GDK_KEY_Ihook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec8, .hexadecimal);
pub const GDK_KEY_ihook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ec9, .hexadecimal);
pub const GDK_KEY_Ibelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eca, .hexadecimal);
pub const GDK_KEY_ibelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ecb, .hexadecimal);
pub const GDK_KEY_Obelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ecc, .hexadecimal);
pub const GDK_KEY_obelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ecd, .hexadecimal);
pub const GDK_KEY_Ohook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ece, .hexadecimal);
pub const GDK_KEY_ohook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ecf, .hexadecimal);
pub const GDK_KEY_Ocircumflexacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed0, .hexadecimal);
pub const GDK_KEY_ocircumflexacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed1, .hexadecimal);
pub const GDK_KEY_Ocircumflexgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed2, .hexadecimal);
pub const GDK_KEY_ocircumflexgrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed3, .hexadecimal);
pub const GDK_KEY_Ocircumflexhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed4, .hexadecimal);
pub const GDK_KEY_ocircumflexhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed5, .hexadecimal);
pub const GDK_KEY_Ocircumflextilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed6, .hexadecimal);
pub const GDK_KEY_ocircumflextilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed7, .hexadecimal);
pub const GDK_KEY_Ocircumflexbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed8, .hexadecimal);
pub const GDK_KEY_ocircumflexbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ed9, .hexadecimal);
pub const GDK_KEY_Ohornacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eda, .hexadecimal);
pub const GDK_KEY_ohornacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001edb, .hexadecimal);
pub const GDK_KEY_Ohorngrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001edc, .hexadecimal);
pub const GDK_KEY_ohorngrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001edd, .hexadecimal);
pub const GDK_KEY_Ohornhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ede, .hexadecimal);
pub const GDK_KEY_ohornhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001edf, .hexadecimal);
pub const GDK_KEY_Ohorntilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee0, .hexadecimal);
pub const GDK_KEY_ohorntilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee1, .hexadecimal);
pub const GDK_KEY_Ohornbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee2, .hexadecimal);
pub const GDK_KEY_ohornbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee3, .hexadecimal);
pub const GDK_KEY_Ubelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee4, .hexadecimal);
pub const GDK_KEY_ubelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee5, .hexadecimal);
pub const GDK_KEY_Uhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee6, .hexadecimal);
pub const GDK_KEY_uhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee7, .hexadecimal);
pub const GDK_KEY_Uhornacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee8, .hexadecimal);
pub const GDK_KEY_uhornacute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ee9, .hexadecimal);
pub const GDK_KEY_Uhorngrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eea, .hexadecimal);
pub const GDK_KEY_uhorngrave = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eeb, .hexadecimal);
pub const GDK_KEY_Uhornhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eec, .hexadecimal);
pub const GDK_KEY_uhornhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eed, .hexadecimal);
pub const GDK_KEY_Uhorntilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eee, .hexadecimal);
pub const GDK_KEY_uhorntilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001eef, .hexadecimal);
pub const GDK_KEY_Uhornbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef0, .hexadecimal);
pub const GDK_KEY_uhornbelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef1, .hexadecimal);
pub const GDK_KEY_Ybelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef4, .hexadecimal);
pub const GDK_KEY_ybelowdot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef5, .hexadecimal);
pub const GDK_KEY_Yhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef6, .hexadecimal);
pub const GDK_KEY_yhook = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef7, .hexadecimal);
pub const GDK_KEY_Ytilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef8, .hexadecimal);
pub const GDK_KEY_ytilde = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1001ef9, .hexadecimal);
pub const GDK_KEY_Ohorn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001a0, .hexadecimal);
pub const GDK_KEY_ohorn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001a1, .hexadecimal);
pub const GDK_KEY_Uhorn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001af, .hexadecimal);
pub const GDK_KEY_uhorn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001b0, .hexadecimal);
pub const GDK_KEY_EcuSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a0, .hexadecimal);
pub const GDK_KEY_ColonSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a1, .hexadecimal);
pub const GDK_KEY_CruzeiroSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a2, .hexadecimal);
pub const GDK_KEY_FFrancSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a3, .hexadecimal);
pub const GDK_KEY_LiraSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a4, .hexadecimal);
pub const GDK_KEY_MillSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a5, .hexadecimal);
pub const GDK_KEY_NairaSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a6, .hexadecimal);
pub const GDK_KEY_PesetaSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a7, .hexadecimal);
pub const GDK_KEY_RupeeSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a8, .hexadecimal);
pub const GDK_KEY_WonSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020a9, .hexadecimal);
pub const GDK_KEY_NewSheqelSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020aa, .hexadecimal);
pub const GDK_KEY_DongSign = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10020ab, .hexadecimal);
pub const GDK_KEY_EuroSign = @as(c_int, 0x20ac);
pub const GDK_KEY_zerosuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002070, .hexadecimal);
pub const GDK_KEY_foursuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002074, .hexadecimal);
pub const GDK_KEY_fivesuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002075, .hexadecimal);
pub const GDK_KEY_sixsuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002076, .hexadecimal);
pub const GDK_KEY_sevensuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002077, .hexadecimal);
pub const GDK_KEY_eightsuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002078, .hexadecimal);
pub const GDK_KEY_ninesuperior = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002079, .hexadecimal);
pub const GDK_KEY_zerosubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002080, .hexadecimal);
pub const GDK_KEY_onesubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002081, .hexadecimal);
pub const GDK_KEY_twosubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002082, .hexadecimal);
pub const GDK_KEY_threesubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002083, .hexadecimal);
pub const GDK_KEY_foursubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002084, .hexadecimal);
pub const GDK_KEY_fivesubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002085, .hexadecimal);
pub const GDK_KEY_sixsubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002086, .hexadecimal);
pub const GDK_KEY_sevensubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002087, .hexadecimal);
pub const GDK_KEY_eightsubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002088, .hexadecimal);
pub const GDK_KEY_ninesubscript = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002089, .hexadecimal);
pub const GDK_KEY_partdifferential = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002202, .hexadecimal);
pub const GDK_KEY_emptyset = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002205, .hexadecimal);
pub const GDK_KEY_elementof = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002208, .hexadecimal);
pub const GDK_KEY_notelementof = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002209, .hexadecimal);
pub const GDK_KEY_containsas = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100220b, .hexadecimal);
pub const GDK_KEY_squareroot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100221a, .hexadecimal);
pub const GDK_KEY_cuberoot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100221b, .hexadecimal);
pub const GDK_KEY_fourthroot = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100221c, .hexadecimal);
pub const GDK_KEY_dintegral = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100222c, .hexadecimal);
pub const GDK_KEY_tintegral = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100222d, .hexadecimal);
pub const GDK_KEY_because = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002235, .hexadecimal);
pub const GDK_KEY_approxeq = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002248, .hexadecimal);
pub const GDK_KEY_notapproxeq = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002247, .hexadecimal);
pub const GDK_KEY_notidentical = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002262, .hexadecimal);
pub const GDK_KEY_stricteq = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002263, .hexadecimal);
pub const GDK_KEY_braille_dot_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff1, .hexadecimal);
pub const GDK_KEY_braille_dot_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff2, .hexadecimal);
pub const GDK_KEY_braille_dot_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff3, .hexadecimal);
pub const GDK_KEY_braille_dot_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff4, .hexadecimal);
pub const GDK_KEY_braille_dot_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff5, .hexadecimal);
pub const GDK_KEY_braille_dot_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff6, .hexadecimal);
pub const GDK_KEY_braille_dot_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff7, .hexadecimal);
pub const GDK_KEY_braille_dot_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff8, .hexadecimal);
pub const GDK_KEY_braille_dot_9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfff9, .hexadecimal);
pub const GDK_KEY_braille_dot_10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfffa, .hexadecimal);
pub const GDK_KEY_braille_blank = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002800, .hexadecimal);
pub const GDK_KEY_braille_dots_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002801, .hexadecimal);
pub const GDK_KEY_braille_dots_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002802, .hexadecimal);
pub const GDK_KEY_braille_dots_12 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002803, .hexadecimal);
pub const GDK_KEY_braille_dots_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002804, .hexadecimal);
pub const GDK_KEY_braille_dots_13 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002805, .hexadecimal);
pub const GDK_KEY_braille_dots_23 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002806, .hexadecimal);
pub const GDK_KEY_braille_dots_123 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002807, .hexadecimal);
pub const GDK_KEY_braille_dots_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002808, .hexadecimal);
pub const GDK_KEY_braille_dots_14 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002809, .hexadecimal);
pub const GDK_KEY_braille_dots_24 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100280a, .hexadecimal);
pub const GDK_KEY_braille_dots_124 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100280b, .hexadecimal);
pub const GDK_KEY_braille_dots_34 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100280c, .hexadecimal);
pub const GDK_KEY_braille_dots_134 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100280d, .hexadecimal);
pub const GDK_KEY_braille_dots_234 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100280e, .hexadecimal);
pub const GDK_KEY_braille_dots_1234 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100280f, .hexadecimal);
pub const GDK_KEY_braille_dots_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002810, .hexadecimal);
pub const GDK_KEY_braille_dots_15 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002811, .hexadecimal);
pub const GDK_KEY_braille_dots_25 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002812, .hexadecimal);
pub const GDK_KEY_braille_dots_125 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002813, .hexadecimal);
pub const GDK_KEY_braille_dots_35 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002814, .hexadecimal);
pub const GDK_KEY_braille_dots_135 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002815, .hexadecimal);
pub const GDK_KEY_braille_dots_235 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002816, .hexadecimal);
pub const GDK_KEY_braille_dots_1235 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002817, .hexadecimal);
pub const GDK_KEY_braille_dots_45 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002818, .hexadecimal);
pub const GDK_KEY_braille_dots_145 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002819, .hexadecimal);
pub const GDK_KEY_braille_dots_245 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100281a, .hexadecimal);
pub const GDK_KEY_braille_dots_1245 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100281b, .hexadecimal);
pub const GDK_KEY_braille_dots_345 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100281c, .hexadecimal);
pub const GDK_KEY_braille_dots_1345 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100281d, .hexadecimal);
pub const GDK_KEY_braille_dots_2345 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100281e, .hexadecimal);
pub const GDK_KEY_braille_dots_12345 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100281f, .hexadecimal);
pub const GDK_KEY_braille_dots_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002820, .hexadecimal);
pub const GDK_KEY_braille_dots_16 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002821, .hexadecimal);
pub const GDK_KEY_braille_dots_26 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002822, .hexadecimal);
pub const GDK_KEY_braille_dots_126 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002823, .hexadecimal);
pub const GDK_KEY_braille_dots_36 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002824, .hexadecimal);
pub const GDK_KEY_braille_dots_136 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002825, .hexadecimal);
pub const GDK_KEY_braille_dots_236 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002826, .hexadecimal);
pub const GDK_KEY_braille_dots_1236 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002827, .hexadecimal);
pub const GDK_KEY_braille_dots_46 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002828, .hexadecimal);
pub const GDK_KEY_braille_dots_146 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002829, .hexadecimal);
pub const GDK_KEY_braille_dots_246 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100282a, .hexadecimal);
pub const GDK_KEY_braille_dots_1246 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100282b, .hexadecimal);
pub const GDK_KEY_braille_dots_346 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100282c, .hexadecimal);
pub const GDK_KEY_braille_dots_1346 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100282d, .hexadecimal);
pub const GDK_KEY_braille_dots_2346 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100282e, .hexadecimal);
pub const GDK_KEY_braille_dots_12346 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100282f, .hexadecimal);
pub const GDK_KEY_braille_dots_56 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002830, .hexadecimal);
pub const GDK_KEY_braille_dots_156 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002831, .hexadecimal);
pub const GDK_KEY_braille_dots_256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002832, .hexadecimal);
pub const GDK_KEY_braille_dots_1256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002833, .hexadecimal);
pub const GDK_KEY_braille_dots_356 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002834, .hexadecimal);
pub const GDK_KEY_braille_dots_1356 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002835, .hexadecimal);
pub const GDK_KEY_braille_dots_2356 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002836, .hexadecimal);
pub const GDK_KEY_braille_dots_12356 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002837, .hexadecimal);
pub const GDK_KEY_braille_dots_456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002838, .hexadecimal);
pub const GDK_KEY_braille_dots_1456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002839, .hexadecimal);
pub const GDK_KEY_braille_dots_2456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100283a, .hexadecimal);
pub const GDK_KEY_braille_dots_12456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100283b, .hexadecimal);
pub const GDK_KEY_braille_dots_3456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100283c, .hexadecimal);
pub const GDK_KEY_braille_dots_13456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100283d, .hexadecimal);
pub const GDK_KEY_braille_dots_23456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100283e, .hexadecimal);
pub const GDK_KEY_braille_dots_123456 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100283f, .hexadecimal);
pub const GDK_KEY_braille_dots_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002840, .hexadecimal);
pub const GDK_KEY_braille_dots_17 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002841, .hexadecimal);
pub const GDK_KEY_braille_dots_27 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002842, .hexadecimal);
pub const GDK_KEY_braille_dots_127 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002843, .hexadecimal);
pub const GDK_KEY_braille_dots_37 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002844, .hexadecimal);
pub const GDK_KEY_braille_dots_137 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002845, .hexadecimal);
pub const GDK_KEY_braille_dots_237 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002846, .hexadecimal);
pub const GDK_KEY_braille_dots_1237 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002847, .hexadecimal);
pub const GDK_KEY_braille_dots_47 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002848, .hexadecimal);
pub const GDK_KEY_braille_dots_147 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002849, .hexadecimal);
pub const GDK_KEY_braille_dots_247 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100284a, .hexadecimal);
pub const GDK_KEY_braille_dots_1247 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100284b, .hexadecimal);
pub const GDK_KEY_braille_dots_347 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100284c, .hexadecimal);
pub const GDK_KEY_braille_dots_1347 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100284d, .hexadecimal);
pub const GDK_KEY_braille_dots_2347 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100284e, .hexadecimal);
pub const GDK_KEY_braille_dots_12347 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100284f, .hexadecimal);
pub const GDK_KEY_braille_dots_57 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002850, .hexadecimal);
pub const GDK_KEY_braille_dots_157 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002851, .hexadecimal);
pub const GDK_KEY_braille_dots_257 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002852, .hexadecimal);
pub const GDK_KEY_braille_dots_1257 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002853, .hexadecimal);
pub const GDK_KEY_braille_dots_357 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002854, .hexadecimal);
pub const GDK_KEY_braille_dots_1357 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002855, .hexadecimal);
pub const GDK_KEY_braille_dots_2357 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002856, .hexadecimal);
pub const GDK_KEY_braille_dots_12357 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002857, .hexadecimal);
pub const GDK_KEY_braille_dots_457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002858, .hexadecimal);
pub const GDK_KEY_braille_dots_1457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002859, .hexadecimal);
pub const GDK_KEY_braille_dots_2457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100285a, .hexadecimal);
pub const GDK_KEY_braille_dots_12457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100285b, .hexadecimal);
pub const GDK_KEY_braille_dots_3457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100285c, .hexadecimal);
pub const GDK_KEY_braille_dots_13457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100285d, .hexadecimal);
pub const GDK_KEY_braille_dots_23457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100285e, .hexadecimal);
pub const GDK_KEY_braille_dots_123457 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100285f, .hexadecimal);
pub const GDK_KEY_braille_dots_67 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002860, .hexadecimal);
pub const GDK_KEY_braille_dots_167 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002861, .hexadecimal);
pub const GDK_KEY_braille_dots_267 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002862, .hexadecimal);
pub const GDK_KEY_braille_dots_1267 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002863, .hexadecimal);
pub const GDK_KEY_braille_dots_367 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002864, .hexadecimal);
pub const GDK_KEY_braille_dots_1367 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002865, .hexadecimal);
pub const GDK_KEY_braille_dots_2367 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002866, .hexadecimal);
pub const GDK_KEY_braille_dots_12367 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002867, .hexadecimal);
pub const GDK_KEY_braille_dots_467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002868, .hexadecimal);
pub const GDK_KEY_braille_dots_1467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002869, .hexadecimal);
pub const GDK_KEY_braille_dots_2467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100286a, .hexadecimal);
pub const GDK_KEY_braille_dots_12467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100286b, .hexadecimal);
pub const GDK_KEY_braille_dots_3467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100286c, .hexadecimal);
pub const GDK_KEY_braille_dots_13467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100286d, .hexadecimal);
pub const GDK_KEY_braille_dots_23467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100286e, .hexadecimal);
pub const GDK_KEY_braille_dots_123467 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100286f, .hexadecimal);
pub const GDK_KEY_braille_dots_567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002870, .hexadecimal);
pub const GDK_KEY_braille_dots_1567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002871, .hexadecimal);
pub const GDK_KEY_braille_dots_2567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002872, .hexadecimal);
pub const GDK_KEY_braille_dots_12567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002873, .hexadecimal);
pub const GDK_KEY_braille_dots_3567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002874, .hexadecimal);
pub const GDK_KEY_braille_dots_13567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002875, .hexadecimal);
pub const GDK_KEY_braille_dots_23567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002876, .hexadecimal);
pub const GDK_KEY_braille_dots_123567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002877, .hexadecimal);
pub const GDK_KEY_braille_dots_4567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002878, .hexadecimal);
pub const GDK_KEY_braille_dots_14567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002879, .hexadecimal);
pub const GDK_KEY_braille_dots_24567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100287a, .hexadecimal);
pub const GDK_KEY_braille_dots_124567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100287b, .hexadecimal);
pub const GDK_KEY_braille_dots_34567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100287c, .hexadecimal);
pub const GDK_KEY_braille_dots_134567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100287d, .hexadecimal);
pub const GDK_KEY_braille_dots_234567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100287e, .hexadecimal);
pub const GDK_KEY_braille_dots_1234567 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100287f, .hexadecimal);
pub const GDK_KEY_braille_dots_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002880, .hexadecimal);
pub const GDK_KEY_braille_dots_18 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002881, .hexadecimal);
pub const GDK_KEY_braille_dots_28 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002882, .hexadecimal);
pub const GDK_KEY_braille_dots_128 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002883, .hexadecimal);
pub const GDK_KEY_braille_dots_38 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002884, .hexadecimal);
pub const GDK_KEY_braille_dots_138 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002885, .hexadecimal);
pub const GDK_KEY_braille_dots_238 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002886, .hexadecimal);
pub const GDK_KEY_braille_dots_1238 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002887, .hexadecimal);
pub const GDK_KEY_braille_dots_48 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002888, .hexadecimal);
pub const GDK_KEY_braille_dots_148 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002889, .hexadecimal);
pub const GDK_KEY_braille_dots_248 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100288a, .hexadecimal);
pub const GDK_KEY_braille_dots_1248 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100288b, .hexadecimal);
pub const GDK_KEY_braille_dots_348 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100288c, .hexadecimal);
pub const GDK_KEY_braille_dots_1348 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100288d, .hexadecimal);
pub const GDK_KEY_braille_dots_2348 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100288e, .hexadecimal);
pub const GDK_KEY_braille_dots_12348 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100288f, .hexadecimal);
pub const GDK_KEY_braille_dots_58 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002890, .hexadecimal);
pub const GDK_KEY_braille_dots_158 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002891, .hexadecimal);
pub const GDK_KEY_braille_dots_258 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002892, .hexadecimal);
pub const GDK_KEY_braille_dots_1258 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002893, .hexadecimal);
pub const GDK_KEY_braille_dots_358 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002894, .hexadecimal);
pub const GDK_KEY_braille_dots_1358 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002895, .hexadecimal);
pub const GDK_KEY_braille_dots_2358 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002896, .hexadecimal);
pub const GDK_KEY_braille_dots_12358 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002897, .hexadecimal);
pub const GDK_KEY_braille_dots_458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002898, .hexadecimal);
pub const GDK_KEY_braille_dots_1458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1002899, .hexadecimal);
pub const GDK_KEY_braille_dots_2458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100289a, .hexadecimal);
pub const GDK_KEY_braille_dots_12458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100289b, .hexadecimal);
pub const GDK_KEY_braille_dots_3458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100289c, .hexadecimal);
pub const GDK_KEY_braille_dots_13458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100289d, .hexadecimal);
pub const GDK_KEY_braille_dots_23458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100289e, .hexadecimal);
pub const GDK_KEY_braille_dots_123458 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100289f, .hexadecimal);
pub const GDK_KEY_braille_dots_68 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a0, .hexadecimal);
pub const GDK_KEY_braille_dots_168 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a1, .hexadecimal);
pub const GDK_KEY_braille_dots_268 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a2, .hexadecimal);
pub const GDK_KEY_braille_dots_1268 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a3, .hexadecimal);
pub const GDK_KEY_braille_dots_368 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a4, .hexadecimal);
pub const GDK_KEY_braille_dots_1368 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a5, .hexadecimal);
pub const GDK_KEY_braille_dots_2368 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a6, .hexadecimal);
pub const GDK_KEY_braille_dots_12368 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a7, .hexadecimal);
pub const GDK_KEY_braille_dots_468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a8, .hexadecimal);
pub const GDK_KEY_braille_dots_1468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028a9, .hexadecimal);
pub const GDK_KEY_braille_dots_2468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028aa, .hexadecimal);
pub const GDK_KEY_braille_dots_12468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ab, .hexadecimal);
pub const GDK_KEY_braille_dots_3468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ac, .hexadecimal);
pub const GDK_KEY_braille_dots_13468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ad, .hexadecimal);
pub const GDK_KEY_braille_dots_23468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ae, .hexadecimal);
pub const GDK_KEY_braille_dots_123468 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028af, .hexadecimal);
pub const GDK_KEY_braille_dots_568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b0, .hexadecimal);
pub const GDK_KEY_braille_dots_1568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b1, .hexadecimal);
pub const GDK_KEY_braille_dots_2568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b2, .hexadecimal);
pub const GDK_KEY_braille_dots_12568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b3, .hexadecimal);
pub const GDK_KEY_braille_dots_3568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b4, .hexadecimal);
pub const GDK_KEY_braille_dots_13568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b5, .hexadecimal);
pub const GDK_KEY_braille_dots_23568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b6, .hexadecimal);
pub const GDK_KEY_braille_dots_123568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b7, .hexadecimal);
pub const GDK_KEY_braille_dots_4568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b8, .hexadecimal);
pub const GDK_KEY_braille_dots_14568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028b9, .hexadecimal);
pub const GDK_KEY_braille_dots_24568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ba, .hexadecimal);
pub const GDK_KEY_braille_dots_124568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028bb, .hexadecimal);
pub const GDK_KEY_braille_dots_34568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028bc, .hexadecimal);
pub const GDK_KEY_braille_dots_134568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028bd, .hexadecimal);
pub const GDK_KEY_braille_dots_234568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028be, .hexadecimal);
pub const GDK_KEY_braille_dots_1234568 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028bf, .hexadecimal);
pub const GDK_KEY_braille_dots_78 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c0, .hexadecimal);
pub const GDK_KEY_braille_dots_178 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c1, .hexadecimal);
pub const GDK_KEY_braille_dots_278 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c2, .hexadecimal);
pub const GDK_KEY_braille_dots_1278 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c3, .hexadecimal);
pub const GDK_KEY_braille_dots_378 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c4, .hexadecimal);
pub const GDK_KEY_braille_dots_1378 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c5, .hexadecimal);
pub const GDK_KEY_braille_dots_2378 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c6, .hexadecimal);
pub const GDK_KEY_braille_dots_12378 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c7, .hexadecimal);
pub const GDK_KEY_braille_dots_478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c8, .hexadecimal);
pub const GDK_KEY_braille_dots_1478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028c9, .hexadecimal);
pub const GDK_KEY_braille_dots_2478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ca, .hexadecimal);
pub const GDK_KEY_braille_dots_12478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028cb, .hexadecimal);
pub const GDK_KEY_braille_dots_3478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028cc, .hexadecimal);
pub const GDK_KEY_braille_dots_13478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028cd, .hexadecimal);
pub const GDK_KEY_braille_dots_23478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ce, .hexadecimal);
pub const GDK_KEY_braille_dots_123478 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028cf, .hexadecimal);
pub const GDK_KEY_braille_dots_578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d0, .hexadecimal);
pub const GDK_KEY_braille_dots_1578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d1, .hexadecimal);
pub const GDK_KEY_braille_dots_2578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d2, .hexadecimal);
pub const GDK_KEY_braille_dots_12578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d3, .hexadecimal);
pub const GDK_KEY_braille_dots_3578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d4, .hexadecimal);
pub const GDK_KEY_braille_dots_13578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d5, .hexadecimal);
pub const GDK_KEY_braille_dots_23578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d6, .hexadecimal);
pub const GDK_KEY_braille_dots_123578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d7, .hexadecimal);
pub const GDK_KEY_braille_dots_4578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d8, .hexadecimal);
pub const GDK_KEY_braille_dots_14578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028d9, .hexadecimal);
pub const GDK_KEY_braille_dots_24578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028da, .hexadecimal);
pub const GDK_KEY_braille_dots_124578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028db, .hexadecimal);
pub const GDK_KEY_braille_dots_34578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028dc, .hexadecimal);
pub const GDK_KEY_braille_dots_134578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028dd, .hexadecimal);
pub const GDK_KEY_braille_dots_234578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028de, .hexadecimal);
pub const GDK_KEY_braille_dots_1234578 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028df, .hexadecimal);
pub const GDK_KEY_braille_dots_678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e0, .hexadecimal);
pub const GDK_KEY_braille_dots_1678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e1, .hexadecimal);
pub const GDK_KEY_braille_dots_2678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e2, .hexadecimal);
pub const GDK_KEY_braille_dots_12678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e3, .hexadecimal);
pub const GDK_KEY_braille_dots_3678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e4, .hexadecimal);
pub const GDK_KEY_braille_dots_13678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e5, .hexadecimal);
pub const GDK_KEY_braille_dots_23678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e6, .hexadecimal);
pub const GDK_KEY_braille_dots_123678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e7, .hexadecimal);
pub const GDK_KEY_braille_dots_4678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e8, .hexadecimal);
pub const GDK_KEY_braille_dots_14678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028e9, .hexadecimal);
pub const GDK_KEY_braille_dots_24678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ea, .hexadecimal);
pub const GDK_KEY_braille_dots_124678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028eb, .hexadecimal);
pub const GDK_KEY_braille_dots_34678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ec, .hexadecimal);
pub const GDK_KEY_braille_dots_134678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ed, .hexadecimal);
pub const GDK_KEY_braille_dots_234678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ee, .hexadecimal);
pub const GDK_KEY_braille_dots_1234678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ef, .hexadecimal);
pub const GDK_KEY_braille_dots_5678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f0, .hexadecimal);
pub const GDK_KEY_braille_dots_15678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f1, .hexadecimal);
pub const GDK_KEY_braille_dots_25678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f2, .hexadecimal);
pub const GDK_KEY_braille_dots_125678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f3, .hexadecimal);
pub const GDK_KEY_braille_dots_35678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f4, .hexadecimal);
pub const GDK_KEY_braille_dots_135678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f5, .hexadecimal);
pub const GDK_KEY_braille_dots_235678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f6, .hexadecimal);
pub const GDK_KEY_braille_dots_1235678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f7, .hexadecimal);
pub const GDK_KEY_braille_dots_45678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f8, .hexadecimal);
pub const GDK_KEY_braille_dots_145678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028f9, .hexadecimal);
pub const GDK_KEY_braille_dots_245678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028fa, .hexadecimal);
pub const GDK_KEY_braille_dots_1245678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028fb, .hexadecimal);
pub const GDK_KEY_braille_dots_345678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028fc, .hexadecimal);
pub const GDK_KEY_braille_dots_1345678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028fd, .hexadecimal);
pub const GDK_KEY_braille_dots_2345678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028fe, .hexadecimal);
pub const GDK_KEY_braille_dots_12345678 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10028ff, .hexadecimal);
pub const GDK_KEY_Sinh_ng = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d82, .hexadecimal);
pub const GDK_KEY_Sinh_h2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d83, .hexadecimal);
pub const GDK_KEY_Sinh_a = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d85, .hexadecimal);
pub const GDK_KEY_Sinh_aa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d86, .hexadecimal);
pub const GDK_KEY_Sinh_ae = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d87, .hexadecimal);
pub const GDK_KEY_Sinh_aee = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d88, .hexadecimal);
pub const GDK_KEY_Sinh_i = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d89, .hexadecimal);
pub const GDK_KEY_Sinh_ii = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d8a, .hexadecimal);
pub const GDK_KEY_Sinh_u = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d8b, .hexadecimal);
pub const GDK_KEY_Sinh_uu = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d8c, .hexadecimal);
pub const GDK_KEY_Sinh_ri = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d8d, .hexadecimal);
pub const GDK_KEY_Sinh_rii = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d8e, .hexadecimal);
pub const GDK_KEY_Sinh_lu = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d8f, .hexadecimal);
pub const GDK_KEY_Sinh_luu = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d90, .hexadecimal);
pub const GDK_KEY_Sinh_e = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d91, .hexadecimal);
pub const GDK_KEY_Sinh_ee = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d92, .hexadecimal);
pub const GDK_KEY_Sinh_ai = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d93, .hexadecimal);
pub const GDK_KEY_Sinh_o = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d94, .hexadecimal);
pub const GDK_KEY_Sinh_oo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d95, .hexadecimal);
pub const GDK_KEY_Sinh_au = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d96, .hexadecimal);
pub const GDK_KEY_Sinh_ka = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d9a, .hexadecimal);
pub const GDK_KEY_Sinh_kha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d9b, .hexadecimal);
pub const GDK_KEY_Sinh_ga = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d9c, .hexadecimal);
pub const GDK_KEY_Sinh_gha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d9d, .hexadecimal);
pub const GDK_KEY_Sinh_ng2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d9e, .hexadecimal);
pub const GDK_KEY_Sinh_nga = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000d9f, .hexadecimal);
pub const GDK_KEY_Sinh_ca = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da0, .hexadecimal);
pub const GDK_KEY_Sinh_cha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da1, .hexadecimal);
pub const GDK_KEY_Sinh_ja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da2, .hexadecimal);
pub const GDK_KEY_Sinh_jha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da3, .hexadecimal);
pub const GDK_KEY_Sinh_nya = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da4, .hexadecimal);
pub const GDK_KEY_Sinh_jnya = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da5, .hexadecimal);
pub const GDK_KEY_Sinh_nja = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da6, .hexadecimal);
pub const GDK_KEY_Sinh_tta = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da7, .hexadecimal);
pub const GDK_KEY_Sinh_ttha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da8, .hexadecimal);
pub const GDK_KEY_Sinh_dda = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000da9, .hexadecimal);
pub const GDK_KEY_Sinh_ddha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000daa, .hexadecimal);
pub const GDK_KEY_Sinh_nna = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dab, .hexadecimal);
pub const GDK_KEY_Sinh_ndda = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dac, .hexadecimal);
pub const GDK_KEY_Sinh_tha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dad, .hexadecimal);
pub const GDK_KEY_Sinh_thha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dae, .hexadecimal);
pub const GDK_KEY_Sinh_dha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000daf, .hexadecimal);
pub const GDK_KEY_Sinh_dhha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db0, .hexadecimal);
pub const GDK_KEY_Sinh_na = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db1, .hexadecimal);
pub const GDK_KEY_Sinh_ndha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db3, .hexadecimal);
pub const GDK_KEY_Sinh_pa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db4, .hexadecimal);
pub const GDK_KEY_Sinh_pha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db5, .hexadecimal);
pub const GDK_KEY_Sinh_ba = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db6, .hexadecimal);
pub const GDK_KEY_Sinh_bha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db7, .hexadecimal);
pub const GDK_KEY_Sinh_ma = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db8, .hexadecimal);
pub const GDK_KEY_Sinh_mba = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000db9, .hexadecimal);
pub const GDK_KEY_Sinh_ya = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dba, .hexadecimal);
pub const GDK_KEY_Sinh_ra = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dbb, .hexadecimal);
pub const GDK_KEY_Sinh_la = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dbd, .hexadecimal);
pub const GDK_KEY_Sinh_va = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc0, .hexadecimal);
pub const GDK_KEY_Sinh_sha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc1, .hexadecimal);
pub const GDK_KEY_Sinh_ssha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc2, .hexadecimal);
pub const GDK_KEY_Sinh_sa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc3, .hexadecimal);
pub const GDK_KEY_Sinh_ha = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc4, .hexadecimal);
pub const GDK_KEY_Sinh_lla = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc5, .hexadecimal);
pub const GDK_KEY_Sinh_fa = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dc6, .hexadecimal);
pub const GDK_KEY_Sinh_al = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dca, .hexadecimal);
pub const GDK_KEY_Sinh_aa2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dcf, .hexadecimal);
pub const GDK_KEY_Sinh_ae2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd0, .hexadecimal);
pub const GDK_KEY_Sinh_aee2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd1, .hexadecimal);
pub const GDK_KEY_Sinh_i2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd2, .hexadecimal);
pub const GDK_KEY_Sinh_ii2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd3, .hexadecimal);
pub const GDK_KEY_Sinh_u2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd4, .hexadecimal);
pub const GDK_KEY_Sinh_uu2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd6, .hexadecimal);
pub const GDK_KEY_Sinh_ru2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd8, .hexadecimal);
pub const GDK_KEY_Sinh_e2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dd9, .hexadecimal);
pub const GDK_KEY_Sinh_ee2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dda, .hexadecimal);
pub const GDK_KEY_Sinh_ai2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000ddb, .hexadecimal);
pub const GDK_KEY_Sinh_o2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000ddc, .hexadecimal);
pub const GDK_KEY_Sinh_oo2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000ddd, .hexadecimal);
pub const GDK_KEY_Sinh_au2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000dde, .hexadecimal);
pub const GDK_KEY_Sinh_lu2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000ddf, .hexadecimal);
pub const GDK_KEY_Sinh_ruu2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000df2, .hexadecimal);
pub const GDK_KEY_Sinh_luu2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000df3, .hexadecimal);
pub const GDK_KEY_Sinh_kunddaliya = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000df4, .hexadecimal);
pub const GDK_KEY_ModeLock = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff01, .hexadecimal);
pub const GDK_KEY_MonBrightnessUp = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff02, .hexadecimal);
pub const GDK_KEY_MonBrightnessDown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff03, .hexadecimal);
pub const GDK_KEY_KbdLightOnOff = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff04, .hexadecimal);
pub const GDK_KEY_KbdBrightnessUp = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff05, .hexadecimal);
pub const GDK_KEY_KbdBrightnessDown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff06, .hexadecimal);
pub const GDK_KEY_Standby = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff10, .hexadecimal);
pub const GDK_KEY_AudioLowerVolume = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff11, .hexadecimal);
pub const GDK_KEY_AudioMute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff12, .hexadecimal);
pub const GDK_KEY_AudioRaiseVolume = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff13, .hexadecimal);
pub const GDK_KEY_AudioPlay = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff14, .hexadecimal);
pub const GDK_KEY_AudioStop = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff15, .hexadecimal);
pub const GDK_KEY_AudioPrev = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff16, .hexadecimal);
pub const GDK_KEY_AudioNext = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff17, .hexadecimal);
pub const GDK_KEY_HomePage = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff18, .hexadecimal);
pub const GDK_KEY_Mail = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff19, .hexadecimal);
pub const GDK_KEY_Start = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff1a, .hexadecimal);
pub const GDK_KEY_Search = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff1b, .hexadecimal);
pub const GDK_KEY_AudioRecord = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff1c, .hexadecimal);
pub const GDK_KEY_Calculator = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff1d, .hexadecimal);
pub const GDK_KEY_Memo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff1e, .hexadecimal);
pub const GDK_KEY_ToDoList = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff1f, .hexadecimal);
pub const GDK_KEY_Calendar = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff20, .hexadecimal);
pub const GDK_KEY_PowerDown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff21, .hexadecimal);
pub const GDK_KEY_ContrastAdjust = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff22, .hexadecimal);
pub const GDK_KEY_RockerUp = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff23, .hexadecimal);
pub const GDK_KEY_RockerDown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff24, .hexadecimal);
pub const GDK_KEY_RockerEnter = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff25, .hexadecimal);
pub const GDK_KEY_Back = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff26, .hexadecimal);
pub const GDK_KEY_Forward = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff27, .hexadecimal);
pub const GDK_KEY_Stop = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff28, .hexadecimal);
pub const GDK_KEY_Refresh = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff29, .hexadecimal);
pub const GDK_KEY_PowerOff = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff2a, .hexadecimal);
pub const GDK_KEY_WakeUp = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff2b, .hexadecimal);
pub const GDK_KEY_Eject = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff2c, .hexadecimal);
pub const GDK_KEY_ScreenSaver = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff2d, .hexadecimal);
pub const GDK_KEY_WWW = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff2e, .hexadecimal);
pub const GDK_KEY_Sleep = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff2f, .hexadecimal);
pub const GDK_KEY_Favorites = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff30, .hexadecimal);
pub const GDK_KEY_AudioPause = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff31, .hexadecimal);
pub const GDK_KEY_AudioMedia = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff32, .hexadecimal);
pub const GDK_KEY_MyComputer = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff33, .hexadecimal);
pub const GDK_KEY_VendorHome = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff34, .hexadecimal);
pub const GDK_KEY_LightBulb = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff35, .hexadecimal);
pub const GDK_KEY_Shop = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff36, .hexadecimal);
pub const GDK_KEY_History = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff37, .hexadecimal);
pub const GDK_KEY_OpenURL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff38, .hexadecimal);
pub const GDK_KEY_AddFavorite = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff39, .hexadecimal);
pub const GDK_KEY_HotLinks = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff3a, .hexadecimal);
pub const GDK_KEY_BrightnessAdjust = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff3b, .hexadecimal);
pub const GDK_KEY_Finance = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff3c, .hexadecimal);
pub const GDK_KEY_Community = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff3d, .hexadecimal);
pub const GDK_KEY_AudioRewind = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff3e, .hexadecimal);
pub const GDK_KEY_BackForward = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff3f, .hexadecimal);
pub const GDK_KEY_Launch0 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff40, .hexadecimal);
pub const GDK_KEY_Launch1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff41, .hexadecimal);
pub const GDK_KEY_Launch2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff42, .hexadecimal);
pub const GDK_KEY_Launch3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff43, .hexadecimal);
pub const GDK_KEY_Launch4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff44, .hexadecimal);
pub const GDK_KEY_Launch5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff45, .hexadecimal);
pub const GDK_KEY_Launch6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff46, .hexadecimal);
pub const GDK_KEY_Launch7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff47, .hexadecimal);
pub const GDK_KEY_Launch8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff48, .hexadecimal);
pub const GDK_KEY_Launch9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff49, .hexadecimal);
pub const GDK_KEY_LaunchA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff4a, .hexadecimal);
pub const GDK_KEY_LaunchB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff4b, .hexadecimal);
pub const GDK_KEY_LaunchC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff4c, .hexadecimal);
pub const GDK_KEY_LaunchD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff4d, .hexadecimal);
pub const GDK_KEY_LaunchE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff4e, .hexadecimal);
pub const GDK_KEY_LaunchF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff4f, .hexadecimal);
pub const GDK_KEY_ApplicationLeft = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff50, .hexadecimal);
pub const GDK_KEY_ApplicationRight = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff51, .hexadecimal);
pub const GDK_KEY_Book = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff52, .hexadecimal);
pub const GDK_KEY_CD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff53, .hexadecimal);
pub const GDK_KEY_WindowClear = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff55, .hexadecimal);
pub const GDK_KEY_Close = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff56, .hexadecimal);
pub const GDK_KEY_Copy = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff57, .hexadecimal);
pub const GDK_KEY_Cut = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff58, .hexadecimal);
pub const GDK_KEY_Display = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff59, .hexadecimal);
pub const GDK_KEY_DOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff5a, .hexadecimal);
pub const GDK_KEY_Documents = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff5b, .hexadecimal);
pub const GDK_KEY_Excel = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff5c, .hexadecimal);
pub const GDK_KEY_Explorer = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff5d, .hexadecimal);
pub const GDK_KEY_Game = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff5e, .hexadecimal);
pub const GDK_KEY_Go = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff5f, .hexadecimal);
pub const GDK_KEY_iTouch = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff60, .hexadecimal);
pub const GDK_KEY_LogOff = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff61, .hexadecimal);
pub const GDK_KEY_Market = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff62, .hexadecimal);
pub const GDK_KEY_Meeting = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff63, .hexadecimal);
pub const GDK_KEY_MenuKB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff65, .hexadecimal);
pub const GDK_KEY_MenuPB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff66, .hexadecimal);
pub const GDK_KEY_MySites = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff67, .hexadecimal);
pub const GDK_KEY_New = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff68, .hexadecimal);
pub const GDK_KEY_News = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff69, .hexadecimal);
pub const GDK_KEY_OfficeHome = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff6a, .hexadecimal);
pub const GDK_KEY_Open = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff6b, .hexadecimal);
pub const GDK_KEY_Option = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff6c, .hexadecimal);
pub const GDK_KEY_Paste = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff6d, .hexadecimal);
pub const GDK_KEY_Phone = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff6e, .hexadecimal);
pub const GDK_KEY_Reply = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff72, .hexadecimal);
pub const GDK_KEY_Reload = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff73, .hexadecimal);
pub const GDK_KEY_RotateWindows = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff74, .hexadecimal);
pub const GDK_KEY_RotationPB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff75, .hexadecimal);
pub const GDK_KEY_RotationKB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff76, .hexadecimal);
pub const GDK_KEY_Save = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff77, .hexadecimal);
pub const GDK_KEY_ScrollUp = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff78, .hexadecimal);
pub const GDK_KEY_ScrollDown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff79, .hexadecimal);
pub const GDK_KEY_ScrollClick = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff7a, .hexadecimal);
pub const GDK_KEY_Send = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff7b, .hexadecimal);
pub const GDK_KEY_Spell = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff7c, .hexadecimal);
pub const GDK_KEY_SplitScreen = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff7d, .hexadecimal);
pub const GDK_KEY_Support = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff7e, .hexadecimal);
pub const GDK_KEY_TaskPane = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff7f, .hexadecimal);
pub const GDK_KEY_Terminal = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff80, .hexadecimal);
pub const GDK_KEY_Tools = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff81, .hexadecimal);
pub const GDK_KEY_Travel = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff82, .hexadecimal);
pub const GDK_KEY_UserPB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff84, .hexadecimal);
pub const GDK_KEY_User1KB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff85, .hexadecimal);
pub const GDK_KEY_User2KB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff86, .hexadecimal);
pub const GDK_KEY_Video = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff87, .hexadecimal);
pub const GDK_KEY_WheelButton = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff88, .hexadecimal);
pub const GDK_KEY_Word = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff89, .hexadecimal);
pub const GDK_KEY_Xfer = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff8a, .hexadecimal);
pub const GDK_KEY_ZoomIn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff8b, .hexadecimal);
pub const GDK_KEY_ZoomOut = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff8c, .hexadecimal);
pub const GDK_KEY_Away = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff8d, .hexadecimal);
pub const GDK_KEY_Messenger = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff8e, .hexadecimal);
pub const GDK_KEY_WebCam = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff8f, .hexadecimal);
pub const GDK_KEY_MailForward = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff90, .hexadecimal);
pub const GDK_KEY_Pictures = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff91, .hexadecimal);
pub const GDK_KEY_Music = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff92, .hexadecimal);
pub const GDK_KEY_Battery = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff93, .hexadecimal);
pub const GDK_KEY_Bluetooth = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff94, .hexadecimal);
pub const GDK_KEY_WLAN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff95, .hexadecimal);
pub const GDK_KEY_UWB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff96, .hexadecimal);
pub const GDK_KEY_AudioForward = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff97, .hexadecimal);
pub const GDK_KEY_AudioRepeat = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff98, .hexadecimal);
pub const GDK_KEY_AudioRandomPlay = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff99, .hexadecimal);
pub const GDK_KEY_Subtitle = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff9a, .hexadecimal);
pub const GDK_KEY_AudioCycleTrack = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff9b, .hexadecimal);
pub const GDK_KEY_CycleAngle = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff9c, .hexadecimal);
pub const GDK_KEY_FrameBack = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff9d, .hexadecimal);
pub const GDK_KEY_FrameForward = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff9e, .hexadecimal);
pub const GDK_KEY_Time = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ff9f, .hexadecimal);
pub const GDK_KEY_SelectButton = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa0, .hexadecimal);
pub const GDK_KEY_View = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa1, .hexadecimal);
pub const GDK_KEY_TopMenu = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa2, .hexadecimal);
pub const GDK_KEY_Red = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa3, .hexadecimal);
pub const GDK_KEY_Green = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa4, .hexadecimal);
pub const GDK_KEY_Yellow = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa5, .hexadecimal);
pub const GDK_KEY_Blue = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa6, .hexadecimal);
pub const GDK_KEY_Suspend = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa7, .hexadecimal);
pub const GDK_KEY_Hibernate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa8, .hexadecimal);
pub const GDK_KEY_TouchpadToggle = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffa9, .hexadecimal);
pub const GDK_KEY_TouchpadOn = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb0, .hexadecimal);
pub const GDK_KEY_TouchpadOff = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb1, .hexadecimal);
pub const GDK_KEY_AudioMicMute = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb2, .hexadecimal);
pub const GDK_KEY_Keyboard = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb3, .hexadecimal);
pub const GDK_KEY_WWAN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb4, .hexadecimal);
pub const GDK_KEY_RFKill = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb5, .hexadecimal);
pub const GDK_KEY_AudioPreset = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008ffb6, .hexadecimal);
pub const GDK_KEY_Switch_VT_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe01, .hexadecimal);
pub const GDK_KEY_Switch_VT_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe02, .hexadecimal);
pub const GDK_KEY_Switch_VT_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe03, .hexadecimal);
pub const GDK_KEY_Switch_VT_4 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe04, .hexadecimal);
pub const GDK_KEY_Switch_VT_5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe05, .hexadecimal);
pub const GDK_KEY_Switch_VT_6 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe06, .hexadecimal);
pub const GDK_KEY_Switch_VT_7 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe07, .hexadecimal);
pub const GDK_KEY_Switch_VT_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe08, .hexadecimal);
pub const GDK_KEY_Switch_VT_9 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe09, .hexadecimal);
pub const GDK_KEY_Switch_VT_10 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe0a, .hexadecimal);
pub const GDK_KEY_Switch_VT_11 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe0b, .hexadecimal);
pub const GDK_KEY_Switch_VT_12 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe0c, .hexadecimal);
pub const GDK_KEY_Ungrab = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe20, .hexadecimal);
pub const GDK_KEY_ClearGrab = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe21, .hexadecimal);
pub const GDK_KEY_Next_VMode = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe22, .hexadecimal);
pub const GDK_KEY_Prev_VMode = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe23, .hexadecimal);
pub const GDK_KEY_LogWindowTree = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe24, .hexadecimal);
pub const GDK_KEY_LogGrabInfo = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1008fe25, .hexadecimal);
pub const GDK_MEMORY_DEFAULT = GDK_MEMORY_B8G8R8A8_PREMULTIPLIED;
pub const GDK_TYPE_MEMORY_TEXTURE = gdk_memory_texture_get_type();
pub inline fn GDK_MEMORY_TEXTURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_MEMORY_TEXTURE, GdkMemoryTexture)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_MEMORY_TEXTURE, GdkMemoryTexture);
}
pub inline fn GDK_IS_MEMORY_TEXTURE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_MEMORY_TEXTURE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_MEMORY_TEXTURE);
}
pub const GDK_TYPE_PAINTABLE = gdk_paintable_get_type();
pub const GDK_TYPE_POPUP = gdk_popup_get_type();
pub const GDK_TYPE_RECTANGLE = gdk_rectangle_get_type();
pub const GDK_TYPE_RGBA = gdk_rgba_get_type();
pub const GDK_TYPE_SNAPSHOT = gdk_snapshot_get_type();
pub inline fn GDK_SNAPSHOT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_SNAPSHOT, GdkSnapshot)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_SNAPSHOT, GdkSnapshot);
}
pub inline fn GDK_IS_SNAPSHOT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_SNAPSHOT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_SNAPSHOT);
}
pub const GDK_TYPE_TEXTURE_DOWNLOADER = gdk_texture_downloader_get_type();
pub const GDK_TYPE_TOPLEVEL_LAYOUT = gdk_toplevel_layout_get_type();
pub const GDK_TYPE_TOPLEVEL = gdk_toplevel_get_type();
pub const GDK_TYPE_TOPLEVEL_SIZE = gdk_toplevel_size_get_type();
pub const GDK_TYPE_VULKAN_CONTEXT = gdk_vulkan_context_get_type();
pub inline fn GDK_VULKAN_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_VULKAN_CONTEXT, GdkVulkanContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GDK_TYPE_VULKAN_CONTEXT, GdkVulkanContext);
}
pub inline fn GDK_IS_VULKAN_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_VULKAN_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GDK_TYPE_VULKAN_CONTEXT);
}
pub const GDK_VULKAN_ERROR = gdk_vulkan_error_quark();
pub const __GSK_H_INSIDE__ = "";
pub const __GRAPHENE_H__ = "";
pub const GRAPHENE_H_INSIDE = "";
pub const GRAPHENE_HAS_SSE = @as(c_int, 1);
pub const GRAPHENE_HAS_SCALAR = @as(c_int, 1);
pub const GRAPHENE_USE_SSE = "";
pub const GRAPHENE_SIMD_S = "sse";
pub const __XMMINTRIN_H = "";
pub const __MMINTRIN_H = "";
pub const _m_empty = _mm_empty;
pub const _m_from_int = _mm_cvtsi32_si64;
pub const _m_from_int64 = _mm_cvtsi64_m64;
pub const _m_to_int = _mm_cvtsi64_si32;
pub const _m_to_int64 = _mm_cvtm64_si64;
pub const _m_packsswb = _mm_packs_pi16;
pub const _m_packssdw = _mm_packs_pi32;
pub const _m_packuswb = _mm_packs_pu16;
pub const _m_punpckhbw = _mm_unpackhi_pi8;
pub const _m_punpckhwd = _mm_unpackhi_pi16;
pub const _m_punpckhdq = _mm_unpackhi_pi32;
pub const _m_punpcklbw = _mm_unpacklo_pi8;
pub const _m_punpcklwd = _mm_unpacklo_pi16;
pub const _m_punpckldq = _mm_unpacklo_pi32;
pub const _m_paddb = _mm_add_pi8;
pub const _m_paddw = _mm_add_pi16;
pub const _m_paddd = _mm_add_pi32;
pub const _m_paddsb = _mm_adds_pi8;
pub const _m_paddsw = _mm_adds_pi16;
pub const _m_paddusb = _mm_adds_pu8;
pub const _m_paddusw = _mm_adds_pu16;
pub const _m_psubb = _mm_sub_pi8;
pub const _m_psubw = _mm_sub_pi16;
pub const _m_psubd = _mm_sub_pi32;
pub const _m_psubsb = _mm_subs_pi8;
pub const _m_psubsw = _mm_subs_pi16;
pub const _m_psubusb = _mm_subs_pu8;
pub const _m_psubusw = _mm_subs_pu16;
pub const _m_pmaddwd = _mm_madd_pi16;
pub const _m_pmulhw = _mm_mulhi_pi16;
pub const _m_pmullw = _mm_mullo_pi16;
pub const _m_psllw = _mm_sll_pi16;
pub const _m_psllwi = _mm_slli_pi16;
pub const _m_pslld = _mm_sll_pi32;
pub const _m_pslldi = _mm_slli_pi32;
pub const _m_psllq = _mm_sll_si64;
pub const _m_psllqi = _mm_slli_si64;
pub const _m_psraw = _mm_sra_pi16;
pub const _m_psrawi = _mm_srai_pi16;
pub const _m_psrad = _mm_sra_pi32;
pub const _m_psradi = _mm_srai_pi32;
pub const _m_psrlw = _mm_srl_pi16;
pub const _m_psrlwi = _mm_srli_pi16;
pub const _m_psrld = _mm_srl_pi32;
pub const _m_psrldi = _mm_srli_pi32;
pub const _m_psrlq = _mm_srl_si64;
pub const _m_psrlqi = _mm_srli_si64;
pub const _m_pand = _mm_and_si64;
pub const _m_pandn = _mm_andnot_si64;
pub const _m_por = _mm_or_si64;
pub const _m_pxor = _mm_xor_si64;
pub const _m_pcmpeqb = _mm_cmpeq_pi8;
pub const _m_pcmpeqw = _mm_cmpeq_pi16;
pub const _m_pcmpeqd = _mm_cmpeq_pi32;
pub const _m_pcmpgtb = _mm_cmpgt_pi8;
pub const _m_pcmpgtw = _mm_cmpgt_pi16;
pub const _m_pcmpgtd = _mm_cmpgt_pi32;
pub const __MM_MALLOC_H = "";
pub inline fn _mm_load_ps1(p: anytype) @TypeOf(_mm_load1_ps(p)) {
    return _mm_load1_ps(p);
}
pub const _MM_HINT_ET0 = @as(c_int, 7);
pub const _MM_HINT_ET1 = @as(c_int, 6);
pub const _MM_HINT_T0 = @as(c_int, 3);
pub const _MM_HINT_T1 = @as(c_int, 2);
pub const _MM_HINT_T2 = @as(c_int, 1);
pub const _MM_HINT_NTA = @as(c_int, 0);
pub inline fn _MM_SHUFFLE(z: anytype, y: anytype, x: anytype, w: anytype) @TypeOf((((z << @as(c_int, 6)) | (y << @as(c_int, 4))) | (x << @as(c_int, 2))) | w) {
    return (((z << @as(c_int, 6)) | (y << @as(c_int, 4))) | (x << @as(c_int, 2))) | w;
}
pub const _MM_EXCEPT_INVALID = @as(c_uint, 0x0001);
pub const _MM_EXCEPT_DENORM = @as(c_uint, 0x0002);
pub const _MM_EXCEPT_DIV_ZERO = @as(c_uint, 0x0004);
pub const _MM_EXCEPT_OVERFLOW = @as(c_uint, 0x0008);
pub const _MM_EXCEPT_UNDERFLOW = @as(c_uint, 0x0010);
pub const _MM_EXCEPT_INEXACT = @as(c_uint, 0x0020);
pub const _MM_EXCEPT_MASK = @as(c_uint, 0x003f);
pub const _MM_MASK_INVALID = @as(c_uint, 0x0080);
pub const _MM_MASK_DENORM = @as(c_uint, 0x0100);
pub const _MM_MASK_DIV_ZERO = @as(c_uint, 0x0200);
pub const _MM_MASK_OVERFLOW = @as(c_uint, 0x0400);
pub const _MM_MASK_UNDERFLOW = @as(c_uint, 0x0800);
pub const _MM_MASK_INEXACT = @as(c_uint, 0x1000);
pub const _MM_MASK_MASK = @as(c_uint, 0x1f80);
pub const _MM_ROUND_NEAREST = @as(c_uint, 0x0000);
pub const _MM_ROUND_DOWN = @as(c_uint, 0x2000);
pub const _MM_ROUND_UP = @as(c_uint, 0x4000);
pub const _MM_ROUND_TOWARD_ZERO = @as(c_uint, 0x6000);
pub const _MM_ROUND_MASK = @as(c_uint, 0x6000);
pub const _MM_FLUSH_ZERO_MASK = @as(c_uint, 0x8000);
pub const _MM_FLUSH_ZERO_ON = @as(c_uint, 0x8000);
pub const _MM_FLUSH_ZERO_OFF = @as(c_uint, 0x0000);
pub inline fn _MM_GET_EXCEPTION_MASK() @TypeOf(_mm_getcsr() & _MM_MASK_MASK) {
    return _mm_getcsr() & _MM_MASK_MASK;
}
pub inline fn _MM_GET_EXCEPTION_STATE() @TypeOf(_mm_getcsr() & _MM_EXCEPT_MASK) {
    return _mm_getcsr() & _MM_EXCEPT_MASK;
}
pub inline fn _MM_GET_FLUSH_ZERO_MODE() @TypeOf(_mm_getcsr() & _MM_FLUSH_ZERO_MASK) {
    return _mm_getcsr() & _MM_FLUSH_ZERO_MASK;
}
pub inline fn _MM_GET_ROUNDING_MODE() @TypeOf(_mm_getcsr() & _MM_ROUND_MASK) {
    return _mm_getcsr() & _MM_ROUND_MASK;
}
pub inline fn _MM_SET_EXCEPTION_MASK(x: anytype) @TypeOf(_mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | x)) {
    return _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | x);
}
pub inline fn _MM_SET_EXCEPTION_STATE(x: anytype) @TypeOf(_mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | x)) {
    return _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | x);
}
pub inline fn _MM_SET_FLUSH_ZERO_MODE(x: anytype) @TypeOf(_mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | x)) {
    return _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | x);
}
pub inline fn _MM_SET_ROUNDING_MODE(x: anytype) @TypeOf(_mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | x)) {
    return _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | x);
}
pub const _m_pextrw = _mm_extract_pi16;
pub const _m_pinsrw = _mm_insert_pi16;
pub const _m_pmaxsw = _mm_max_pi16;
pub const _m_pmaxub = _mm_max_pu8;
pub const _m_pminsw = _mm_min_pi16;
pub const _m_pminub = _mm_min_pu8;
pub const _m_pmovmskb = _mm_movemask_pi8;
pub const _m_pmulhuw = _mm_mulhi_pu16;
pub const _m_pshufw = _mm_shuffle_pi16;
pub const _m_maskmovq = _mm_maskmove_si64;
pub const _m_pavgb = _mm_avg_pu8;
pub const _m_pavgw = _mm_avg_pu16;
pub const _m_psadbw = _mm_sad_pu8;
pub const __EMMINTRIN_H = "";
pub inline fn _mm_load_pd1(dp: anytype) @TypeOf(_mm_load1_pd(dp)) {
    return _mm_load1_pd(dp);
}
pub inline fn _MM_SHUFFLE2(x: anytype, y: anytype) @TypeOf((x << @as(c_int, 1)) | y) {
    return (x << @as(c_int, 1)) | y;
}
pub const _MM_DENORMALS_ZERO_ON = @as(c_uint, 0x0040);
pub const _MM_DENORMALS_ZERO_OFF = @as(c_uint, 0x0000);
pub const _MM_DENORMALS_ZERO_MASK = @as(c_uint, 0x0040);
pub inline fn _MM_GET_DENORMALS_ZERO_MODE() @TypeOf(_mm_getcsr() & _MM_DENORMALS_ZERO_MASK) {
    return _mm_getcsr() & _MM_DENORMALS_ZERO_MASK;
}
pub inline fn _MM_SET_DENORMALS_ZERO_MODE(x: anytype) @TypeOf(_mm_setcsr((_mm_getcsr() & ~_MM_DENORMALS_ZERO_MASK) | x)) {
    return _mm_setcsr((_mm_getcsr() & ~_MM_DENORMALS_ZERO_MASK) | x);
}
pub const GRAPHENE_USE_SSE4_1 = "";
pub const __SMMINTRIN_H = "";
pub const __TMMINTRIN_H = "";
pub const __PMMINTRIN_H = "";
pub inline fn _mm_loaddup_pd(dp: anytype) @TypeOf(_mm_load1_pd(dp)) {
    return _mm_load1_pd(dp);
}
pub const _MM_FROUND_TO_NEAREST_INT = @as(c_int, 0x00);
pub const _MM_FROUND_TO_NEG_INF = @as(c_int, 0x01);
pub const _MM_FROUND_TO_POS_INF = @as(c_int, 0x02);
pub const _MM_FROUND_TO_ZERO = @as(c_int, 0x03);
pub const _MM_FROUND_CUR_DIRECTION = @as(c_int, 0x04);
pub const _MM_FROUND_RAISE_EXC = @as(c_int, 0x00);
pub const _MM_FROUND_NO_EXC = @as(c_int, 0x08);
pub const _MM_FROUND_NINT = _MM_FROUND_RAISE_EXC | _MM_FROUND_TO_NEAREST_INT;
pub const _MM_FROUND_FLOOR = _MM_FROUND_RAISE_EXC | _MM_FROUND_TO_NEG_INF;
pub const _MM_FROUND_CEIL = _MM_FROUND_RAISE_EXC | _MM_FROUND_TO_POS_INF;
pub const _MM_FROUND_TRUNC = _MM_FROUND_RAISE_EXC | _MM_FROUND_TO_ZERO;
pub const _MM_FROUND_RINT = _MM_FROUND_RAISE_EXC | _MM_FROUND_CUR_DIRECTION;
pub const _MM_FROUND_NEARBYINT = _MM_FROUND_NO_EXC | _MM_FROUND_CUR_DIRECTION;
pub inline fn _mm_ceil_ps(X: anytype) @TypeOf(_mm_round_ps(X, _MM_FROUND_CEIL)) {
    return _mm_round_ps(X, _MM_FROUND_CEIL);
}
pub inline fn _mm_ceil_pd(X: anytype) @TypeOf(_mm_round_pd(X, _MM_FROUND_CEIL)) {
    return _mm_round_pd(X, _MM_FROUND_CEIL);
}
pub inline fn _mm_ceil_ss(X: anytype, Y: anytype) @TypeOf(_mm_round_ss(X, Y, _MM_FROUND_CEIL)) {
    return _mm_round_ss(X, Y, _MM_FROUND_CEIL);
}
pub inline fn _mm_ceil_sd(X: anytype, Y: anytype) @TypeOf(_mm_round_sd(X, Y, _MM_FROUND_CEIL)) {
    return _mm_round_sd(X, Y, _MM_FROUND_CEIL);
}
pub inline fn _mm_floor_ps(X: anytype) @TypeOf(_mm_round_ps(X, _MM_FROUND_FLOOR)) {
    return _mm_round_ps(X, _MM_FROUND_FLOOR);
}
pub inline fn _mm_floor_pd(X: anytype) @TypeOf(_mm_round_pd(X, _MM_FROUND_FLOOR)) {
    return _mm_round_pd(X, _MM_FROUND_FLOOR);
}
pub inline fn _mm_floor_ss(X: anytype, Y: anytype) @TypeOf(_mm_round_ss(X, Y, _MM_FROUND_FLOOR)) {
    return _mm_round_ss(X, Y, _MM_FROUND_FLOOR);
}
pub inline fn _mm_floor_sd(X: anytype, Y: anytype) @TypeOf(_mm_round_sd(X, Y, _MM_FROUND_FLOOR)) {
    return _mm_round_sd(X, Y, _MM_FROUND_FLOOR);
}
pub inline fn _MM_MK_INSERTPS_NDX(X: anytype, Y: anytype, Z: anytype) @TypeOf(((X << @as(c_int, 6)) | (Y << @as(c_int, 4))) | Z) {
    return ((X << @as(c_int, 6)) | (Y << @as(c_int, 4))) | Z;
}
pub inline fn _MM_PICK_OUT_PS(X: anytype, N: anytype) @TypeOf(_mm_insert_ps(_mm_setzero_ps(), X, _MM_MK_INSERTPS_NDX(N, @as(c_int, 0), @as(c_int, 0x0e)))) {
    return _mm_insert_ps(_mm_setzero_ps(), X, _MM_MK_INSERTPS_NDX(N, @as(c_int, 0), @as(c_int, 0x0e)));
}
pub inline fn _mm_test_all_ones(V: anytype) @TypeOf(_mm_testc_si128(V, _mm_set1_epi32(-@as(c_int, 1)))) {
    return _mm_testc_si128(V, _mm_set1_epi32(-@as(c_int, 1)));
}
pub inline fn _mm_test_mix_ones_zeros(M: anytype, V: anytype) @TypeOf(_mm_testnzc_si128(M, V)) {
    return _mm_testnzc_si128(M, V);
}
pub inline fn _mm_test_all_zeros(M: anytype, V: anytype) @TypeOf(_mm_testz_si128(M, V)) {
    return _mm_testz_si128(M, V);
}
pub const _SIDD_UBYTE_OPS = @as(c_int, 0x00);
pub const _SIDD_UWORD_OPS = @as(c_int, 0x01);
pub const _SIDD_SBYTE_OPS = @as(c_int, 0x02);
pub const _SIDD_SWORD_OPS = @as(c_int, 0x03);
pub const _SIDD_CMP_EQUAL_ANY = @as(c_int, 0x00);
pub const _SIDD_CMP_RANGES = @as(c_int, 0x04);
pub const _SIDD_CMP_EQUAL_EACH = @as(c_int, 0x08);
pub const _SIDD_CMP_EQUAL_ORDERED = @as(c_int, 0x0c);
pub const _SIDD_POSITIVE_POLARITY = @as(c_int, 0x00);
pub const _SIDD_NEGATIVE_POLARITY = @as(c_int, 0x10);
pub const _SIDD_MASKED_POSITIVE_POLARITY = @as(c_int, 0x20);
pub const _SIDD_MASKED_NEGATIVE_POLARITY = @as(c_int, 0x30);
pub const _SIDD_LEAST_SIGNIFICANT = @as(c_int, 0x00);
pub const _SIDD_MOST_SIGNIFICANT = @as(c_int, 0x40);
pub const _SIDD_BIT_MASK = @as(c_int, 0x00);
pub const _SIDD_UNIT_MASK = @as(c_int, 0x40);
pub const __POPCNTINTRIN_H = "";
pub const __DEFAULT_FN_ATTRS_CONSTEXPR = __DEFAULT_FN_ATTRS;
pub const __CRC32INTRIN_H = "";
pub const GRAPHENE_VECTORCALL = "";
pub const GRAPHENE_BEGIN_DECLS = "";
pub const GRAPHENE_END_DECLS = "";
pub const __STDBOOL_H = "";
pub const __bool_true_false_are_defined = @as(c_int, 1);
pub const @"bool" = bool;
pub const @"true" = @as(c_int, 1);
pub const @"false" = @as(c_int, 0);
pub inline fn _GRAPHENE_DEPRECATED_FOR(f: anytype) @TypeOf(_GRAPHENE_DEPRECATED) {
    _ = @TypeOf(f);
    return _GRAPHENE_DEPRECATED;
}
pub inline fn _GRAPHENE_UNAVAILABLE(maj: anytype, min: anytype) @TypeOf(_GRAPHENE_DEPRECATED) {
    _ = @TypeOf(maj);
    _ = @TypeOf(min);
    return _GRAPHENE_DEPRECATED;
}
pub const GRAPHENE_PI = @as(f32, 3.1415926535897932384626434);
pub const GRAPHENE_PI_2 = @as(f32, 1.5707963267948966192313217);
pub const GRAPHENE_MAJOR_VERSION = @as(c_int, 1);
pub const GRAPHENE_MINOR_VERSION = @as(c_int, 10);
pub const GRAPHENE_MICRO_VERSION = @as(c_int, 8);
pub inline fn GRAPHENE_ENCODE_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf(((major << @as(c_int, 24)) | (minor << @as(c_int, 16))) | (micro << @as(c_int, 8))) {
    return ((major << @as(c_int, 24)) | (minor << @as(c_int, 16))) | (micro << @as(c_int, 8));
}
pub inline fn _GRAPHENE_ENCODE_VERSION(maj: anytype, min: anytype) @TypeOf((maj << @as(c_int, 16)) | (min << @as(c_int, 8))) {
    return (maj << @as(c_int, 16)) | (min << @as(c_int, 8));
}
pub const GRAPHENE_DEPRECATED = _GRAPHENE_DEPRECATED ++ _GRAPHENE_PUBLIC;
pub const GRAPHENE_VERSION = GRAPHENE_ENCODE_VERSION(GRAPHENE_MAJOR_VERSION, GRAPHENE_MINOR_VERSION, GRAPHENE_MICRO_VERSION);
pub inline fn GRAPHENE_CHECK_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf(((major > GRAPHENE_MAJOR_VERSION) or ((major == GRAPHENE_MAJOR_VERSION) and (minor > GRAPHENE_MINOR_VERSION))) or (((major == GRAPHENE_MAJOR_VERSION) and (minor == GRAPHENE_MINOR_VERSION)) and (micro >= GRAPHENE_MICRO_VERSION))) {
    return ((major > GRAPHENE_MAJOR_VERSION) or ((major == GRAPHENE_MAJOR_VERSION) and (minor > GRAPHENE_MINOR_VERSION))) or (((major == GRAPHENE_MAJOR_VERSION) and (minor == GRAPHENE_MINOR_VERSION)) and (micro >= GRAPHENE_MICRO_VERSION));
}
pub const GRAPHENE_VERSION_CUR_STABLE = _GRAPHENE_ENCODE_VERSION(GRAPHENE_MAJOR_VERSION, GRAPHENE_MINOR_VERSION);
pub const GRAPHENE_VERSION_PREV_STABLE = _GRAPHENE_ENCODE_VERSION(GRAPHENE_MAJOR_VERSION, GRAPHENE_MINOR_VERSION - @as(c_int, 2));
pub const GRAPHENE_VERSION_1_0 = _GRAPHENE_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 0));
pub const GRAPHENE_VERSION_1_2 = _GRAPHENE_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 2));
pub const GRAPHENE_VERSION_1_4 = _GRAPHENE_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 4));
pub const GRAPHENE_VERSION_1_6 = _GRAPHENE_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 6));
pub const GRAPHENE_VERSION_1_8 = _GRAPHENE_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 8));
pub const GRAPHENE_VERSION_1_10 = _GRAPHENE_ENCODE_VERSION(@as(c_int, 1), @as(c_int, 10));
pub const GRAPHENE_VERSION_MIN_REQUIRED = GRAPHENE_VERSION_1_0;
pub const GRAPHENE_VERSION_MAX_ALLOWED = GRAPHENE_VERSION_CUR_STABLE;
pub const GRAPHENE_DEPRECATED_IN_1_0 = GRAPHENE_DEPRECATED;
pub inline fn GRAPHENE_DEPRECATED_IN_1_0_FOR(f: anytype) @TypeOf(GRAPHENE_DEPRECATED_FOR(f)) {
    return GRAPHENE_DEPRECATED_FOR(f);
}
pub const GRAPHENE_AVAILABLE_IN_1_0 = _GRAPHENE_PUBLIC;
pub const GRAPHENE_DEPRECATED_IN_1_2 = _GRAPHENE_PUBLIC;
pub inline fn GRAPHENE_DEPRECATED_IN_1_2_FOR(f: anytype) @TypeOf(_GRAPHENE_PUBLIC) {
    _ = @TypeOf(f);
    return _GRAPHENE_PUBLIC;
}
pub const GRAPHENE_AVAILABLE_IN_1_2 = _GRAPHENE_PUBLIC;
pub const GRAPHENE_DEPRECATED_IN_1_4 = _GRAPHENE_PUBLIC;
pub inline fn GRAPHENE_DEPRECATED_IN_1_4_FOR(f: anytype) @TypeOf(_GRAPHENE_PUBLIC) {
    _ = @TypeOf(f);
    return _GRAPHENE_PUBLIC;
}
pub const GRAPHENE_AVAILABLE_IN_1_4 = _GRAPHENE_PUBLIC;
pub const GRAPHENE_DEPRECATED_IN_1_6 = _GRAPHENE_PUBLIC;
pub inline fn GRAPHENE_DEPRECATED_IN_1_6_FOR(f: anytype) @TypeOf(_GRAPHENE_PUBLIC) {
    _ = @TypeOf(f);
    return _GRAPHENE_PUBLIC;
}
pub const GRAPHENE_AVAILABLE_IN_1_6 = _GRAPHENE_PUBLIC;
pub const GRAPHENE_DEPRECATED_IN_1_8 = _GRAPHENE_PUBLIC;
pub inline fn GRAPHENE_DEPRECATED_IN_1_8_FOR(f: anytype) @TypeOf(_GRAPHENE_PUBLIC) {
    _ = @TypeOf(f);
    return _GRAPHENE_PUBLIC;
}
pub const GRAPHENE_AVAILABLE_IN_1_8 = _GRAPHENE_PUBLIC;
pub const GRAPHENE_DEPRECATED_IN_1_10 = _GRAPHENE_PUBLIC;
pub inline fn GRAPHENE_DEPRECATED_IN_1_10_FOR(f: anytype) @TypeOf(_GRAPHENE_PUBLIC) {
    _ = @TypeOf(f);
    return _GRAPHENE_PUBLIC;
}
pub const GRAPHENE_AVAILABLE_IN_1_10 = _GRAPHENE_PUBLIC;
pub const GRAPHENE_VEC2_LEN = @as(c_int, 2);
pub const GRAPHENE_VEC3_LEN = @as(c_int, 3);
pub const GRAPHENE_VEC4_LEN = @as(c_int, 4);
pub const _MATH_H = @as(c_int, 1);
pub const _BITS_LIBM_SIMD_DECL_STUBS_H = @as(c_int, 1);
pub const __DECL_SIMD_cos = "";
pub const __DECL_SIMD_cosf = "";
pub const __DECL_SIMD_cosl = "";
pub const __DECL_SIMD_cosf16 = "";
pub const __DECL_SIMD_cosf32 = "";
pub const __DECL_SIMD_cosf64 = "";
pub const __DECL_SIMD_cosf128 = "";
pub const __DECL_SIMD_cosf32x = "";
pub const __DECL_SIMD_cosf64x = "";
pub const __DECL_SIMD_cosf128x = "";
pub const __DECL_SIMD_sin = "";
pub const __DECL_SIMD_sinf = "";
pub const __DECL_SIMD_sinl = "";
pub const __DECL_SIMD_sinf16 = "";
pub const __DECL_SIMD_sinf32 = "";
pub const __DECL_SIMD_sinf64 = "";
pub const __DECL_SIMD_sinf128 = "";
pub const __DECL_SIMD_sinf32x = "";
pub const __DECL_SIMD_sinf64x = "";
pub const __DECL_SIMD_sinf128x = "";
pub const __DECL_SIMD_sincos = "";
pub const __DECL_SIMD_sincosf = "";
pub const __DECL_SIMD_sincosl = "";
pub const __DECL_SIMD_sincosf16 = "";
pub const __DECL_SIMD_sincosf32 = "";
pub const __DECL_SIMD_sincosf64 = "";
pub const __DECL_SIMD_sincosf128 = "";
pub const __DECL_SIMD_sincosf32x = "";
pub const __DECL_SIMD_sincosf64x = "";
pub const __DECL_SIMD_sincosf128x = "";
pub const __DECL_SIMD_log = "";
pub const __DECL_SIMD_logf = "";
pub const __DECL_SIMD_logl = "";
pub const __DECL_SIMD_logf16 = "";
pub const __DECL_SIMD_logf32 = "";
pub const __DECL_SIMD_logf64 = "";
pub const __DECL_SIMD_logf128 = "";
pub const __DECL_SIMD_logf32x = "";
pub const __DECL_SIMD_logf64x = "";
pub const __DECL_SIMD_logf128x = "";
pub const __DECL_SIMD_exp = "";
pub const __DECL_SIMD_expf = "";
pub const __DECL_SIMD_expl = "";
pub const __DECL_SIMD_expf16 = "";
pub const __DECL_SIMD_expf32 = "";
pub const __DECL_SIMD_expf64 = "";
pub const __DECL_SIMD_expf128 = "";
pub const __DECL_SIMD_expf32x = "";
pub const __DECL_SIMD_expf64x = "";
pub const __DECL_SIMD_expf128x = "";
pub const __DECL_SIMD_pow = "";
pub const __DECL_SIMD_powf = "";
pub const __DECL_SIMD_powl = "";
pub const __DECL_SIMD_powf16 = "";
pub const __DECL_SIMD_powf32 = "";
pub const __DECL_SIMD_powf64 = "";
pub const __DECL_SIMD_powf128 = "";
pub const __DECL_SIMD_powf32x = "";
pub const __DECL_SIMD_powf64x = "";
pub const __DECL_SIMD_powf128x = "";
pub const __DECL_SIMD_acos = "";
pub const __DECL_SIMD_acosf = "";
pub const __DECL_SIMD_acosl = "";
pub const __DECL_SIMD_acosf16 = "";
pub const __DECL_SIMD_acosf32 = "";
pub const __DECL_SIMD_acosf64 = "";
pub const __DECL_SIMD_acosf128 = "";
pub const __DECL_SIMD_acosf32x = "";
pub const __DECL_SIMD_acosf64x = "";
pub const __DECL_SIMD_acosf128x = "";
pub const __DECL_SIMD_atan = "";
pub const __DECL_SIMD_atanf = "";
pub const __DECL_SIMD_atanl = "";
pub const __DECL_SIMD_atanf16 = "";
pub const __DECL_SIMD_atanf32 = "";
pub const __DECL_SIMD_atanf64 = "";
pub const __DECL_SIMD_atanf128 = "";
pub const __DECL_SIMD_atanf32x = "";
pub const __DECL_SIMD_atanf64x = "";
pub const __DECL_SIMD_atanf128x = "";
pub const __DECL_SIMD_asin = "";
pub const __DECL_SIMD_asinf = "";
pub const __DECL_SIMD_asinl = "";
pub const __DECL_SIMD_asinf16 = "";
pub const __DECL_SIMD_asinf32 = "";
pub const __DECL_SIMD_asinf64 = "";
pub const __DECL_SIMD_asinf128 = "";
pub const __DECL_SIMD_asinf32x = "";
pub const __DECL_SIMD_asinf64x = "";
pub const __DECL_SIMD_asinf128x = "";
pub const __DECL_SIMD_hypot = "";
pub const __DECL_SIMD_hypotf = "";
pub const __DECL_SIMD_hypotl = "";
pub const __DECL_SIMD_hypotf16 = "";
pub const __DECL_SIMD_hypotf32 = "";
pub const __DECL_SIMD_hypotf64 = "";
pub const __DECL_SIMD_hypotf128 = "";
pub const __DECL_SIMD_hypotf32x = "";
pub const __DECL_SIMD_hypotf64x = "";
pub const __DECL_SIMD_hypotf128x = "";
pub const __DECL_SIMD_exp2 = "";
pub const __DECL_SIMD_exp2f = "";
pub const __DECL_SIMD_exp2l = "";
pub const __DECL_SIMD_exp2f16 = "";
pub const __DECL_SIMD_exp2f32 = "";
pub const __DECL_SIMD_exp2f64 = "";
pub const __DECL_SIMD_exp2f128 = "";
pub const __DECL_SIMD_exp2f32x = "";
pub const __DECL_SIMD_exp2f64x = "";
pub const __DECL_SIMD_exp2f128x = "";
pub const __DECL_SIMD_exp10 = "";
pub const __DECL_SIMD_exp10f = "";
pub const __DECL_SIMD_exp10l = "";
pub const __DECL_SIMD_exp10f16 = "";
pub const __DECL_SIMD_exp10f32 = "";
pub const __DECL_SIMD_exp10f64 = "";
pub const __DECL_SIMD_exp10f128 = "";
pub const __DECL_SIMD_exp10f32x = "";
pub const __DECL_SIMD_exp10f64x = "";
pub const __DECL_SIMD_exp10f128x = "";
pub const __DECL_SIMD_cosh = "";
pub const __DECL_SIMD_coshf = "";
pub const __DECL_SIMD_coshl = "";
pub const __DECL_SIMD_coshf16 = "";
pub const __DECL_SIMD_coshf32 = "";
pub const __DECL_SIMD_coshf64 = "";
pub const __DECL_SIMD_coshf128 = "";
pub const __DECL_SIMD_coshf32x = "";
pub const __DECL_SIMD_coshf64x = "";
pub const __DECL_SIMD_coshf128x = "";
pub const __DECL_SIMD_expm1 = "";
pub const __DECL_SIMD_expm1f = "";
pub const __DECL_SIMD_expm1l = "";
pub const __DECL_SIMD_expm1f16 = "";
pub const __DECL_SIMD_expm1f32 = "";
pub const __DECL_SIMD_expm1f64 = "";
pub const __DECL_SIMD_expm1f128 = "";
pub const __DECL_SIMD_expm1f32x = "";
pub const __DECL_SIMD_expm1f64x = "";
pub const __DECL_SIMD_expm1f128x = "";
pub const __DECL_SIMD_sinh = "";
pub const __DECL_SIMD_sinhf = "";
pub const __DECL_SIMD_sinhl = "";
pub const __DECL_SIMD_sinhf16 = "";
pub const __DECL_SIMD_sinhf32 = "";
pub const __DECL_SIMD_sinhf64 = "";
pub const __DECL_SIMD_sinhf128 = "";
pub const __DECL_SIMD_sinhf32x = "";
pub const __DECL_SIMD_sinhf64x = "";
pub const __DECL_SIMD_sinhf128x = "";
pub const __DECL_SIMD_cbrt = "";
pub const __DECL_SIMD_cbrtf = "";
pub const __DECL_SIMD_cbrtl = "";
pub const __DECL_SIMD_cbrtf16 = "";
pub const __DECL_SIMD_cbrtf32 = "";
pub const __DECL_SIMD_cbrtf64 = "";
pub const __DECL_SIMD_cbrtf128 = "";
pub const __DECL_SIMD_cbrtf32x = "";
pub const __DECL_SIMD_cbrtf64x = "";
pub const __DECL_SIMD_cbrtf128x = "";
pub const __DECL_SIMD_atan2 = "";
pub const __DECL_SIMD_atan2f = "";
pub const __DECL_SIMD_atan2l = "";
pub const __DECL_SIMD_atan2f16 = "";
pub const __DECL_SIMD_atan2f32 = "";
pub const __DECL_SIMD_atan2f64 = "";
pub const __DECL_SIMD_atan2f128 = "";
pub const __DECL_SIMD_atan2f32x = "";
pub const __DECL_SIMD_atan2f64x = "";
pub const __DECL_SIMD_atan2f128x = "";
pub const __DECL_SIMD_log10 = "";
pub const __DECL_SIMD_log10f = "";
pub const __DECL_SIMD_log10l = "";
pub const __DECL_SIMD_log10f16 = "";
pub const __DECL_SIMD_log10f32 = "";
pub const __DECL_SIMD_log10f64 = "";
pub const __DECL_SIMD_log10f128 = "";
pub const __DECL_SIMD_log10f32x = "";
pub const __DECL_SIMD_log10f64x = "";
pub const __DECL_SIMD_log10f128x = "";
pub const __DECL_SIMD_log2 = "";
pub const __DECL_SIMD_log2f = "";
pub const __DECL_SIMD_log2l = "";
pub const __DECL_SIMD_log2f16 = "";
pub const __DECL_SIMD_log2f32 = "";
pub const __DECL_SIMD_log2f64 = "";
pub const __DECL_SIMD_log2f128 = "";
pub const __DECL_SIMD_log2f32x = "";
pub const __DECL_SIMD_log2f64x = "";
pub const __DECL_SIMD_log2f128x = "";
pub const __DECL_SIMD_log1p = "";
pub const __DECL_SIMD_log1pf = "";
pub const __DECL_SIMD_log1pl = "";
pub const __DECL_SIMD_log1pf16 = "";
pub const __DECL_SIMD_log1pf32 = "";
pub const __DECL_SIMD_log1pf64 = "";
pub const __DECL_SIMD_log1pf128 = "";
pub const __DECL_SIMD_log1pf32x = "";
pub const __DECL_SIMD_log1pf64x = "";
pub const __DECL_SIMD_log1pf128x = "";
pub const __DECL_SIMD_atanh = "";
pub const __DECL_SIMD_atanhf = "";
pub const __DECL_SIMD_atanhl = "";
pub const __DECL_SIMD_atanhf16 = "";
pub const __DECL_SIMD_atanhf32 = "";
pub const __DECL_SIMD_atanhf64 = "";
pub const __DECL_SIMD_atanhf128 = "";
pub const __DECL_SIMD_atanhf32x = "";
pub const __DECL_SIMD_atanhf64x = "";
pub const __DECL_SIMD_atanhf128x = "";
pub const __DECL_SIMD_acosh = "";
pub const __DECL_SIMD_acoshf = "";
pub const __DECL_SIMD_acoshl = "";
pub const __DECL_SIMD_acoshf16 = "";
pub const __DECL_SIMD_acoshf32 = "";
pub const __DECL_SIMD_acoshf64 = "";
pub const __DECL_SIMD_acoshf128 = "";
pub const __DECL_SIMD_acoshf32x = "";
pub const __DECL_SIMD_acoshf64x = "";
pub const __DECL_SIMD_acoshf128x = "";
pub const __DECL_SIMD_erf = "";
pub const __DECL_SIMD_erff = "";
pub const __DECL_SIMD_erfl = "";
pub const __DECL_SIMD_erff16 = "";
pub const __DECL_SIMD_erff32 = "";
pub const __DECL_SIMD_erff64 = "";
pub const __DECL_SIMD_erff128 = "";
pub const __DECL_SIMD_erff32x = "";
pub const __DECL_SIMD_erff64x = "";
pub const __DECL_SIMD_erff128x = "";
pub const __DECL_SIMD_tanh = "";
pub const __DECL_SIMD_tanhf = "";
pub const __DECL_SIMD_tanhl = "";
pub const __DECL_SIMD_tanhf16 = "";
pub const __DECL_SIMD_tanhf32 = "";
pub const __DECL_SIMD_tanhf64 = "";
pub const __DECL_SIMD_tanhf128 = "";
pub const __DECL_SIMD_tanhf32x = "";
pub const __DECL_SIMD_tanhf64x = "";
pub const __DECL_SIMD_tanhf128x = "";
pub const __DECL_SIMD_asinh = "";
pub const __DECL_SIMD_asinhf = "";
pub const __DECL_SIMD_asinhl = "";
pub const __DECL_SIMD_asinhf16 = "";
pub const __DECL_SIMD_asinhf32 = "";
pub const __DECL_SIMD_asinhf64 = "";
pub const __DECL_SIMD_asinhf128 = "";
pub const __DECL_SIMD_asinhf32x = "";
pub const __DECL_SIMD_asinhf64x = "";
pub const __DECL_SIMD_asinhf128x = "";
pub const __DECL_SIMD_erfc = "";
pub const __DECL_SIMD_erfcf = "";
pub const __DECL_SIMD_erfcl = "";
pub const __DECL_SIMD_erfcf16 = "";
pub const __DECL_SIMD_erfcf32 = "";
pub const __DECL_SIMD_erfcf64 = "";
pub const __DECL_SIMD_erfcf128 = "";
pub const __DECL_SIMD_erfcf32x = "";
pub const __DECL_SIMD_erfcf64x = "";
pub const __DECL_SIMD_erfcf128x = "";
pub const __DECL_SIMD_tan = "";
pub const __DECL_SIMD_tanf = "";
pub const __DECL_SIMD_tanl = "";
pub const __DECL_SIMD_tanf16 = "";
pub const __DECL_SIMD_tanf32 = "";
pub const __DECL_SIMD_tanf64 = "";
pub const __DECL_SIMD_tanf128 = "";
pub const __DECL_SIMD_tanf32x = "";
pub const __DECL_SIMD_tanf64x = "";
pub const __DECL_SIMD_tanf128x = "";
pub const HUGE_VALF = __builtin_huge_valf();
pub const INFINITY = __builtin_inff();
pub const NAN = __builtin_nanf("");
pub const __FP_LOGB0_IS_MIN = @as(c_int, 1);
pub const __FP_LOGBNAN_IS_MIN = @as(c_int, 1);
pub const FP_ILOGB0 = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const FP_ILOGBNAN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub inline fn __MATHCALL(function: anytype, suffix: anytype, args: anytype) @TypeOf(__MATHDECL(_Mdouble_, function, suffix, args)) {
    return __MATHDECL(_Mdouble_, function, suffix, args);
}
pub inline fn __MATHCALLX(function: anytype, suffix: anytype, args: anytype, attrib: anytype) @TypeOf(__MATHDECLX(_Mdouble_, function, suffix, args, attrib)) {
    return __MATHDECLX(_Mdouble_, function, suffix, args, attrib);
}
pub inline fn __MATHDECL_1(@"type": anytype, function: anytype, suffix: anytype, args: anytype) @TypeOf(__MATHDECL_1_IMPL(@"type", function, suffix, args)) {
    return __MATHDECL_1_IMPL(@"type", function, suffix, args);
}
pub inline fn __MATHDECL_ALIAS(@"type": anytype, function: anytype, suffix: anytype, args: anytype, alias: anytype) @TypeOf(__MATHDECL_1(@"type", function, suffix, args)) {
    _ = @TypeOf(alias);
    return __MATHDECL_1(@"type", function, suffix, args);
}
pub const _Mdouble_ = f64;
pub inline fn __MATH_PRECNAME(name: anytype, r: anytype) @TypeOf(__CONCAT(name, r)) {
    return __CONCAT(name, r);
}
pub const __MATH_DECLARING_DOUBLE = @as(c_int, 1);
pub const __MATH_DECLARING_FLOATN = @as(c_int, 0);
pub const __MATH_DECLARE_LDOUBLE = @as(c_int, 1);
pub inline fn __MATHCALL_NARROW(func: anytype, redir: anytype, nargs: anytype) @TypeOf(__MATHCALL_NARROW_NORMAL(func, nargs)) {
    _ = @TypeOf(redir);
    return __MATHCALL_NARROW_NORMAL(func, nargs);
}
pub inline fn signbit(x: anytype) @TypeOf(__builtin_signbit(x)) {
    return __builtin_signbit(x);
}
pub const MATH_ERRNO = @as(c_int, 1);
pub const MATH_ERREXCEPT = @as(c_int, 2);
pub const math_errhandling = MATH_ERRNO | MATH_ERREXCEPT;
pub const M_E = @as(f64, 2.7182818284590452354);
pub const M_LOG2E = @as(f64, 1.4426950408889634074);
pub const M_LOG10E = @as(f64, 0.43429448190325182765);
pub const M_LN2 = @as(f64, 0.69314718055994530942);
pub const M_LN10 = @as(f64, 2.30258509299404568402);
pub const M_PI = @as(f64, 3.14159265358979323846);
pub const M_PI_2 = @as(f64, 1.57079632679489661923);
pub const M_PI_4 = @as(f64, 0.78539816339744830962);
pub const M_1_PI = @as(f64, 0.31830988618379067154);
pub const M_2_PI = @as(f64, 0.63661977236758134308);
pub const M_2_SQRTPI = @as(f64, 1.12837916709551257390);
pub const M_SQRT2 = @as(f64, 1.41421356237309504880);
pub const M_SQRT1_2 = @as(f64, 0.70710678118654752440);
pub inline fn GRAPHENE_POINT_INIT(_x: anytype, _y: anytype) graphene_point_t {
    return @import("std").mem.zeroInit(graphene_point_t, .{
        .x = _x,
        .y = _y,
    });
}
pub const GRAPHENE_POINT_INIT_ZERO = GRAPHENE_POINT_INIT(@as(f32, 0.0), @as(f32, 0.0));
pub inline fn GRAPHENE_SIZE_INIT(_w: anytype, _h: anytype) graphene_size_t {
    return @import("std").mem.zeroInit(graphene_size_t, .{
        .width = _w,
        .height = _h,
    });
}
pub const GRAPHENE_SIZE_INIT_ZERO = GRAPHENE_SIZE_INIT(@as(f32, 0.0), @as(f32, 0.0));
pub const GRAPHENE_RECT_INIT_ZERO = GRAPHENE_RECT_INIT(@as(f32, 0.0), @as(f32, 0.0), @as(f32, 0.0), @as(f32, 0.0));
pub inline fn GRAPHENE_POINT3D_INIT(_x: anytype, _y: anytype, _z: anytype) graphene_point3d_t {
    return @import("std").mem.zeroInit(graphene_point3d_t, .{
        .x = _x,
        .y = _y,
        .z = _z,
    });
}
pub const GRAPHENE_POINT3D_INIT_ZERO = GRAPHENE_POINT3D_INIT(@as(f32, 0.0), @as(f32, 0.0), @as(f32, 0.0));
pub const GSK_TYPE_SHADER_ARGS_BUILDER = gsk_shader_args_builder_get_type();
pub const GSK_TYPE_GL_SHADER = gsk_gl_shader_get_type();
pub const GSK_TYPE_RENDER_NODE = gsk_render_node_get_type();
pub inline fn GSK_IS_RENDER_NODE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GSK_TYPE_RENDER_NODE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GSK_TYPE_RENDER_NODE);
}
pub const GSK_SERIALIZATION_ERROR = gsk_serialization_error_quark();
pub const GSK_TYPE_DEBUG_NODE = gsk_debug_node_get_type();
pub const GSK_TYPE_COLOR_NODE = gsk_color_node_get_type();
pub const GSK_TYPE_TEXTURE_NODE = gsk_texture_node_get_type();
pub const GSK_TYPE_TEXTURE_SCALE_NODE = gsk_texture_scale_node_get_type();
pub const GSK_TYPE_LINEAR_GRADIENT_NODE = gsk_linear_gradient_node_get_type();
pub const GSK_TYPE_REPEATING_LINEAR_GRADIENT_NODE = gsk_repeating_linear_gradient_node_get_type();
pub const GSK_TYPE_RADIAL_GRADIENT_NODE = gsk_radial_gradient_node_get_type();
pub const GSK_TYPE_REPEATING_RADIAL_GRADIENT_NODE = gsk_repeating_radial_gradient_node_get_type();
pub const GSK_TYPE_CONIC_GRADIENT_NODE = gsk_conic_gradient_node_get_type();
pub const GSK_TYPE_BORDER_NODE = gsk_border_node_get_type();
pub const GSK_TYPE_INSET_SHADOW_NODE = gsk_inset_shadow_node_get_type();
pub const GSK_TYPE_OUTSET_SHADOW_NODE = gsk_outset_shadow_node_get_type();
pub const GSK_TYPE_CAIRO_NODE = gsk_cairo_node_get_type();
pub const GSK_TYPE_CONTAINER_NODE = gsk_container_node_get_type();
pub const GSK_TYPE_TRANSFORM_NODE = gsk_transform_node_get_type();
pub const GSK_TYPE_OPACITY_NODE = gsk_opacity_node_get_type();
pub const GSK_TYPE_COLOR_MATRIX_NODE = gsk_color_matrix_node_get_type();
pub const GSK_TYPE_REPEAT_NODE = gsk_repeat_node_get_type();
pub const GSK_TYPE_CLIP_NODE = gsk_clip_node_get_type();
pub const GSK_TYPE_ROUNDED_CLIP_NODE = gsk_rounded_clip_node_get_type();
pub const GSK_TYPE_SHADOW_NODE = gsk_shadow_node_get_type();
pub const GSK_TYPE_BLEND_NODE = gsk_blend_node_get_type();
pub const GSK_TYPE_CROSS_FADE_NODE = gsk_cross_fade_node_get_type();
pub const GSK_TYPE_TEXT_NODE = gsk_text_node_get_type();
pub const GSK_TYPE_BLUR_NODE = gsk_blur_node_get_type();
pub const GSK_TYPE_MASK_NODE = gsk_mask_node_get_type();
pub const GSK_TYPE_GL_SHADER_NODE = gsk_gl_shader_node_get_type();
pub inline fn GSK_VALUE_HOLDS_RENDER_NODE(value: anytype) @TypeOf(G_VALUE_HOLDS(value, GSK_TYPE_RENDER_NODE)) {
    return G_VALUE_HOLDS(value, GSK_TYPE_RENDER_NODE);
}
pub const GSK_TYPE_RENDERER = gsk_renderer_get_type();
pub inline fn GSK_RENDERER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GSK_TYPE_RENDERER, GskRenderer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GSK_TYPE_RENDERER, GskRenderer);
}
pub inline fn GSK_IS_RENDERER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GSK_TYPE_RENDERER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GSK_TYPE_RENDERER);
}
pub const GSK_TYPE_TRANSFORM = gsk_transform_get_type();
pub const GSK_TYPE_CAIRO_RENDERER = gsk_cairo_renderer_get_type();
pub inline fn GSK_CAIRO_RENDERER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GSK_TYPE_CAIRO_RENDERER, GskCairoRenderer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GSK_TYPE_CAIRO_RENDERER, GskCairoRenderer);
}
pub inline fn GSK_IS_CAIRO_RENDERER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GSK_TYPE_CAIRO_RENDERER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GSK_TYPE_CAIRO_RENDERER);
}
pub inline fn GSK_CAIRO_RENDERER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GSK_TYPE_CAIRO_RENDERER, GskCairoRendererClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GSK_TYPE_CAIRO_RENDERER, GskCairoRendererClass);
}
pub inline fn GSK_IS_CAIRO_RENDERER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GSK_TYPE_CAIRO_RENDERER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GSK_TYPE_CAIRO_RENDERER);
}
pub inline fn GSK_CAIRO_RENDERER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GSK_TYPE_CAIRO_RENDERER, GskCairoRendererClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GSK_TYPE_CAIRO_RENDERER, GskCairoRendererClass);
}
pub const __GSK_ENUM_TYPES_H__ = "";
pub const GSK_TYPE_RENDER_NODE_TYPE = gsk_render_node_type_get_type();
pub const GSK_TYPE_SCALING_FILTER = gsk_scaling_filter_get_type();
pub const GSK_TYPE_BLEND_MODE = gsk_blend_mode_get_type();
pub const GSK_TYPE_CORNER = gsk_corner_get_type();
pub const GSK_TYPE_SERIALIZATION_ERROR = gsk_serialization_error_get_type();
pub const GSK_TYPE_TRANSFORM_CATEGORY = gsk_transform_category_get_type();
pub const GSK_TYPE_GL_UNIFORM_TYPE = gsk_gl_uniform_type_get_type();
pub const GSK_TYPE_MASK_MODE = gsk_mask_mode_get_type();
pub const GTK_UNIT_PIXEL = GTK_UNIT_NONE;
pub const GTK_ACCESSIBLE_VALUE_UNDEFINED = -@as(c_int, 1);
pub const GTK_INVALID_LIST_POSITION = @import("std").zig.c_translation.cast(guint, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal));
pub const GTK_TYPE_SHORTCUT = gtk_shortcut_get_type();
pub const GTK_TYPE_SHORTCUT_ACTION = gtk_shortcut_action_get_type();
pub const GTK_TYPE_NOTHING_ACTION = gtk_nothing_action_get_type();
pub const GTK_TYPE_CALLBACK_ACTION = gtk_callback_action_get_type();
pub const GTK_TYPE_MNEMONIC_ACTION = gtk_mnemonic_action_get_type();
pub const GTK_TYPE_ACTIVATE_ACTION = gtk_activate_action_get_type();
pub const GTK_TYPE_SIGNAL_ACTION = gtk_signal_action_get_type();
pub const GTK_TYPE_NAMED_ACTION = gtk_named_action_get_type();
pub const GTK_TYPE_WIDGET = gtk_widget_get_type();
pub inline fn GTK_WIDGET(widget: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(widget, GTK_TYPE_WIDGET, GtkWidget)) {
    return G_TYPE_CHECK_INSTANCE_CAST(widget, GTK_TYPE_WIDGET, GtkWidget);
}
pub inline fn GTK_WIDGET_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_WIDGET, GtkWidgetClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_WIDGET, GtkWidgetClass);
}
pub inline fn GTK_IS_WIDGET(widget: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(widget, GTK_TYPE_WIDGET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(widget, GTK_TYPE_WIDGET);
}
pub inline fn GTK_IS_WIDGET_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_WIDGET)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_WIDGET);
}
pub inline fn GTK_WIDGET_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_WIDGET, GtkWidgetClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_WIDGET, GtkWidgetClass);
}
pub const GTK_TYPE_REQUISITION = gtk_requisition_get_type();
pub const GTK_TYPE_APPLICATION = gtk_application_get_type();
pub inline fn GTK_APPLICATION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APPLICATION, GtkApplication)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APPLICATION, GtkApplication);
}
pub inline fn GTK_APPLICATION_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_APPLICATION, GtkApplicationClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_APPLICATION, GtkApplicationClass);
}
pub inline fn GTK_IS_APPLICATION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APPLICATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APPLICATION);
}
pub inline fn GTK_IS_APPLICATION_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_APPLICATION)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_APPLICATION);
}
pub inline fn GTK_APPLICATION_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_APPLICATION, GtkApplicationClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_APPLICATION, GtkApplicationClass);
}
pub const GTK_TYPE_WINDOW = gtk_window_get_type();
pub inline fn GTK_WINDOW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_WINDOW, GtkWindow)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_WINDOW, GtkWindow);
}
pub inline fn GTK_WINDOW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_WINDOW, GtkWindowClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_WINDOW, GtkWindowClass);
}
pub inline fn GTK_IS_WINDOW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_WINDOW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_WINDOW);
}
pub inline fn GTK_IS_WINDOW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_WINDOW)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_WINDOW);
}
pub inline fn GTK_WINDOW_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_WINDOW, GtkWindowClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_WINDOW, GtkWindowClass);
}
pub const GTK_TYPE_ABOUT_DIALOG = gtk_about_dialog_get_type();
pub inline fn GTK_ABOUT_DIALOG(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_ABOUT_DIALOG, GtkAboutDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_ABOUT_DIALOG, GtkAboutDialog);
}
pub inline fn GTK_IS_ABOUT_DIALOG(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_ABOUT_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_ABOUT_DIALOG);
}
pub const GTK_TYPE_ACCESSIBLE = gtk_accessible_get_type();
pub const GTK_TYPE_ACCESSIBLE_RANGE = gtk_accessible_range_get_type();
pub const GTK_TYPE_ACTIONABLE = gtk_actionable_get_type();
pub inline fn GTK_ACTIONABLE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, GTK_TYPE_ACTIONABLE, GtkActionable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, GTK_TYPE_ACTIONABLE, GtkActionable);
}
pub inline fn GTK_IS_ACTIONABLE(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, GTK_TYPE_ACTIONABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, GTK_TYPE_ACTIONABLE);
}
pub inline fn GTK_ACTIONABLE_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_ACTIONABLE, GtkActionableInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_ACTIONABLE, GtkActionableInterface);
}
pub const GTK_TYPE_ACTION_BAR = gtk_action_bar_get_type();
pub inline fn GTK_ACTION_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ACTION_BAR, GtkActionBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ACTION_BAR, GtkActionBar);
}
pub inline fn GTK_IS_ACTION_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ACTION_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ACTION_BAR);
}
pub const GTK_TYPE_ADJUSTMENT = gtk_adjustment_get_type();
pub inline fn GTK_ADJUSTMENT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ADJUSTMENT, GtkAdjustment)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ADJUSTMENT, GtkAdjustment);
}
pub inline fn GTK_ADJUSTMENT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_ADJUSTMENT, GtkAdjustmentClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_ADJUSTMENT, GtkAdjustmentClass);
}
pub inline fn GTK_IS_ADJUSTMENT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ADJUSTMENT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ADJUSTMENT);
}
pub inline fn GTK_IS_ADJUSTMENT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_ADJUSTMENT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_ADJUSTMENT);
}
pub inline fn GTK_ADJUSTMENT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_ADJUSTMENT, GtkAdjustmentClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_ADJUSTMENT, GtkAdjustmentClass);
}
pub const GTK_TYPE_ALERT_DIALOG = gtk_alert_dialog_get_type();
pub const GTK_TYPE_APP_CHOOSER = gtk_app_chooser_get_type();
pub inline fn GTK_APP_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER, GtkAppChooser)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER, GtkAppChooser);
}
pub inline fn GTK_IS_APP_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER);
}
pub const GTK_TYPE_DIALOG = gtk_dialog_get_type();
pub inline fn GTK_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_DIALOG, GtkDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_DIALOG, GtkDialog);
}
pub inline fn GTK_DIALOG_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_DIALOG, GtkDialogClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_DIALOG, GtkDialogClass);
}
pub inline fn GTK_IS_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_DIALOG);
}
pub inline fn GTK_IS_DIALOG_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_DIALOG)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_DIALOG);
}
pub inline fn GTK_DIALOG_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_DIALOG, GtkDialogClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_DIALOG, GtkDialogClass);
}
pub const GTK_TYPE_APP_CHOOSER_DIALOG = gtk_app_chooser_dialog_get_type();
pub inline fn GTK_APP_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER_DIALOG, GtkAppChooserDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER_DIALOG, GtkAppChooserDialog);
}
pub inline fn GTK_IS_APP_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER_DIALOG);
}
pub const GTK_TYPE_APP_CHOOSER_WIDGET = gtk_app_chooser_widget_get_type();
pub inline fn GTK_APP_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER_WIDGET, GtkAppChooserWidget)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER_WIDGET, GtkAppChooserWidget);
}
pub inline fn GTK_IS_APP_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER_WIDGET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER_WIDGET);
}
pub const GTK_TYPE_APP_CHOOSER_BUTTON = gtk_app_chooser_button_get_type();
pub inline fn GTK_APP_CHOOSER_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER_BUTTON, GtkAppChooserButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_APP_CHOOSER_BUTTON, GtkAppChooserButton);
}
pub inline fn GTK_IS_APP_CHOOSER_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_APP_CHOOSER_BUTTON);
}
pub const GTK_TYPE_SHORTCUTS_WINDOW = gtk_shortcuts_window_get_type();
pub inline fn GTK_SHORTCUTS_WINDOW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_WINDOW, GtkShortcutsWindow)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_WINDOW, GtkShortcutsWindow);
}
pub inline fn GTK_IS_SHORTCUTS_WINDOW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_WINDOW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_WINDOW);
}
pub const GTK_TYPE_APPLICATION_WINDOW = gtk_application_window_get_type();
pub inline fn GTK_APPLICATION_WINDOW(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(inst, GTK_TYPE_APPLICATION_WINDOW, GtkApplicationWindow)) {
    return G_TYPE_CHECK_INSTANCE_CAST(inst, GTK_TYPE_APPLICATION_WINDOW, GtkApplicationWindow);
}
pub inline fn GTK_APPLICATION_WINDOW_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(class, GTK_TYPE_APPLICATION_WINDOW, GtkApplicationWindowClass)) {
    return G_TYPE_CHECK_CLASS_CAST(class, GTK_TYPE_APPLICATION_WINDOW, GtkApplicationWindowClass);
}
pub inline fn GTK_IS_APPLICATION_WINDOW(inst: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(inst, GTK_TYPE_APPLICATION_WINDOW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(inst, GTK_TYPE_APPLICATION_WINDOW);
}
pub inline fn GTK_IS_APPLICATION_WINDOW_CLASS(class: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(class, GTK_TYPE_APPLICATION_WINDOW)) {
    return G_TYPE_CHECK_CLASS_TYPE(class, GTK_TYPE_APPLICATION_WINDOW);
}
pub inline fn GTK_APPLICATION_WINDOW_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, GTK_TYPE_APPLICATION_WINDOW, GtkApplicationWindowClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, GTK_TYPE_APPLICATION_WINDOW, GtkApplicationWindowClass);
}
pub const GTK_TYPE_ASPECT_FRAME = gtk_aspect_frame_get_type();
pub inline fn GTK_ASPECT_FRAME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ASPECT_FRAME, GtkAspectFrame)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ASPECT_FRAME, GtkAspectFrame);
}
pub inline fn GTK_IS_ASPECT_FRAME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ASPECT_FRAME)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ASPECT_FRAME);
}
pub const GTK_TYPE_ASSISTANT = gtk_assistant_get_type();
pub inline fn GTK_ASSISTANT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_ASSISTANT, GtkAssistant)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_ASSISTANT, GtkAssistant);
}
pub inline fn GTK_IS_ASSISTANT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_ASSISTANT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_ASSISTANT);
}
pub const GTK_TYPE_ASSISTANT_PAGE = gtk_assistant_page_get_type();
pub inline fn GTK_ASSISTANT_PAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ASSISTANT_PAGE, GtkAssistantPage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ASSISTANT_PAGE, GtkAssistantPage);
}
pub inline fn GTK_IS_ASSISTANT_PAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ASSISTANT_PAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ASSISTANT_PAGE);
}
pub const GTK_TYPE_AT_CONTEXT = gtk_at_context_get_type();
pub const GTK_TYPE_LAYOUT_CHILD = gtk_layout_child_get_type();
pub const GTK_TYPE_LAYOUT_MANAGER = gtk_layout_manager_get_type();
pub const GTK_TYPE_BIN_LAYOUT = gtk_bin_layout_get_type();
pub const GTK_TYPE_BITSET = gtk_bitset_get_type();
pub const GTK_TYPE_BOOKMARK_LIST = gtk_bookmark_list_get_type();
pub const GTK_TYPE_EXPRESSION = gtk_expression_get_type();
pub const GTK_TYPE_EXPRESSION_WATCH = gtk_expression_watch_get_type();
pub inline fn GTK_IS_EXPRESSION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EXPRESSION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EXPRESSION);
}
pub inline fn GTK_EXPRESSION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EXPRESSION, GtkExpression)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EXPRESSION, GtkExpression);
}
pub const GTK_TYPE_PROPERTY_EXPRESSION = gtk_property_expression_get_type();
pub const GTK_TYPE_CONSTANT_EXPRESSION = gtk_constant_expression_get_type();
pub const GTK_TYPE_OBJECT_EXPRESSION = gtk_object_expression_get_type();
pub const GTK_TYPE_CLOSURE_EXPRESSION = gtk_closure_expression_get_type();
pub const GTK_TYPE_CCLOSURE_EXPRESSION = gtk_cclosure_expression_get_type();
pub inline fn GTK_VALUE_HOLDS_EXPRESSION(value: anytype) @TypeOf(G_VALUE_HOLDS(value, GTK_TYPE_EXPRESSION)) {
    return G_VALUE_HOLDS(value, GTK_TYPE_EXPRESSION);
}
pub const GTK_TYPE_PARAM_SPEC_EXPRESSION = gtk_param_expression_get_type();
pub inline fn GTK_PARAM_SPEC_EXPRESSION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PARAM_SPEC_EXPRESSION, GtkParamSpecExpression)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PARAM_SPEC_EXPRESSION, GtkParamSpecExpression);
}
pub inline fn GTK_IS_PARAM_SPEC_EXPRESSION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PARAM_SPEC_EXPRESSION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PARAM_SPEC_EXPRESSION);
}
pub const GTK_TYPE_FILTER = gtk_filter_get_type();
pub const GTK_TYPE_BOOL_FILTER = gtk_bool_filter_get_type();
pub const GTK_TYPE_BORDER = gtk_border_get_type();
pub const GTK_TYPE_BOX_LAYOUT = gtk_box_layout_get_type();
pub const GTK_TYPE_BOX = gtk_box_get_type();
pub inline fn GTK_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BOX, GtkBox)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BOX, GtkBox);
}
pub inline fn GTK_BOX_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_BOX, GtkBoxClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_BOX, GtkBoxClass);
}
pub inline fn GTK_IS_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BOX)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BOX);
}
pub inline fn GTK_IS_BOX_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_BOX)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_BOX);
}
pub inline fn GTK_BOX_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_BOX, GtkBoxClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_BOX, GtkBoxClass);
}
pub const GTK_TYPE_BUILDER_SCOPE = gtk_builder_scope_get_type();
pub const GTK_TYPE_BUILDER_CSCOPE = gtk_builder_cscope_get_type();
pub const GTK_TYPE_BUILDER = gtk_builder_get_type();
pub inline fn GTK_BUILDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BUILDER, GtkBuilder)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BUILDER, GtkBuilder);
}
pub inline fn GTK_BUILDER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_BUILDER, GtkBuilderClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_BUILDER, GtkBuilderClass);
}
pub inline fn GTK_IS_BUILDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BUILDER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BUILDER);
}
pub inline fn GTK_IS_BUILDER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_BUILDER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_BUILDER);
}
pub inline fn GTK_BUILDER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_BUILDER, GtkBuilderClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_BUILDER, GtkBuilderClass);
}
pub const GTK_BUILDER_ERROR = gtk_builder_error_quark();
pub inline fn GTK_BUILDER_WARN_INVALID_CHILD_TYPE(object: anytype, @"type": anytype) @TypeOf(g_warning("'%s' is not a valid child type of '%s'", @"type", g_type_name(G_OBJECT_TYPE(object)))) {
    return g_warning("'%s' is not a valid child type of '%s'", @"type", g_type_name(G_OBJECT_TYPE(object)));
}
pub const GTK_TYPE_BUILDABLE = gtk_buildable_get_type();
pub inline fn GTK_BUILDABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BUILDABLE, GtkBuildable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BUILDABLE, GtkBuildable);
}
pub inline fn GTK_IS_BUILDABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BUILDABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BUILDABLE);
}
pub inline fn GTK_BUILDABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_BUILDABLE, GtkBuildableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_BUILDABLE, GtkBuildableIface);
}
pub const GTK_TYPE_LIST_ITEM_FACTORY = gtk_list_item_factory_get_type();
pub inline fn GTK_LIST_ITEM_FACTORY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LIST_ITEM_FACTORY, GtkListItemFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LIST_ITEM_FACTORY, GtkListItemFactory);
}
pub inline fn GTK_LIST_ITEM_FACTORY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_LIST_ITEM_FACTORY, GtkListItemFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_LIST_ITEM_FACTORY, GtkListItemFactoryClass);
}
pub inline fn GTK_IS_LIST_ITEM_FACTORY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LIST_ITEM_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LIST_ITEM_FACTORY);
}
pub inline fn GTK_IS_LIST_ITEM_FACTORY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_LIST_ITEM_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_LIST_ITEM_FACTORY);
}
pub inline fn GTK_LIST_ITEM_FACTORY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_LIST_ITEM_FACTORY, GtkListItemFactoryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_LIST_ITEM_FACTORY, GtkListItemFactoryClass);
}
pub const GTK_TYPE_BUILDER_LIST_ITEM_FACTORY = gtk_builder_list_item_factory_get_type();
pub inline fn GTK_BUILDER_LIST_ITEM_FACTORY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY, GtkBuilderListItemFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY, GtkBuilderListItemFactory);
}
pub inline fn GTK_BUILDER_LIST_ITEM_FACTORY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY, GtkBuilderListItemFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY, GtkBuilderListItemFactoryClass);
}
pub inline fn GTK_IS_BUILDER_LIST_ITEM_FACTORY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY);
}
pub inline fn GTK_IS_BUILDER_LIST_ITEM_FACTORY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY);
}
pub inline fn GTK_BUILDER_LIST_ITEM_FACTORY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY, GtkBuilderListItemFactoryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_BUILDER_LIST_ITEM_FACTORY, GtkBuilderListItemFactoryClass);
}
pub const GTK_TYPE_BUTTON = gtk_button_get_type();
pub inline fn GTK_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BUTTON, GtkButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_BUTTON, GtkButton);
}
pub inline fn GTK_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_BUTTON, GtkButtonClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_BUTTON, GtkButtonClass);
}
pub inline fn GTK_IS_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_BUTTON);
}
pub inline fn GTK_IS_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_BUTTON)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_BUTTON);
}
pub inline fn GTK_BUTTON_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_BUTTON, GtkButtonClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_BUTTON, GtkButtonClass);
}
pub const GTK_TYPE_CALENDAR = gtk_calendar_get_type();
pub inline fn GTK_CALENDAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CALENDAR, GtkCalendar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CALENDAR, GtkCalendar);
}
pub inline fn GTK_IS_CALENDAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CALENDAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CALENDAR);
}
pub const GTK_TYPE_CELL_EDITABLE = gtk_cell_editable_get_type();
pub inline fn GTK_CELL_EDITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_EDITABLE, GtkCellEditable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_EDITABLE, GtkCellEditable);
}
pub inline fn GTK_IS_CELL_EDITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_EDITABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_EDITABLE);
}
pub inline fn GTK_CELL_EDITABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_CELL_EDITABLE, GtkCellEditableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_CELL_EDITABLE, GtkCellEditableIface);
}
pub const GTK_TYPE_CELL_RENDERER = gtk_cell_renderer_get_type();
pub inline fn GTK_CELL_RENDERER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER, GtkCellRenderer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER, GtkCellRenderer);
}
pub inline fn GTK_CELL_RENDERER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_RENDERER, GtkCellRendererClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_RENDERER, GtkCellRendererClass);
}
pub inline fn GTK_IS_CELL_RENDERER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER);
}
pub inline fn GTK_IS_CELL_RENDERER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_RENDERER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_RENDERER);
}
pub inline fn GTK_CELL_RENDERER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_RENDERER, GtkCellRendererClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_RENDERER, GtkCellRendererClass);
}
pub const GTK_TYPE_TREE_MODEL = gtk_tree_model_get_type();
pub inline fn GTK_TREE_MODEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_MODEL, GtkTreeModel)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_MODEL, GtkTreeModel);
}
pub inline fn GTK_IS_TREE_MODEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_MODEL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_MODEL);
}
pub inline fn GTK_TREE_MODEL_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_MODEL, GtkTreeModelIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_MODEL, GtkTreeModelIface);
}
pub const GTK_TYPE_TREE_ITER = gtk_tree_iter_get_type();
pub const GTK_TYPE_TREE_PATH = gtk_tree_path_get_type();
pub const GTK_TYPE_TREE_ROW_REFERENCE = gtk_tree_row_reference_get_type();
pub const GTK_TYPE_CELL_AREA = gtk_cell_area_get_type();
pub inline fn GTK_CELL_AREA(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_AREA, GtkCellArea)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_AREA, GtkCellArea);
}
pub inline fn GTK_CELL_AREA_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_AREA, GtkCellAreaClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_AREA, GtkCellAreaClass);
}
pub inline fn GTK_IS_CELL_AREA(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_AREA)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_AREA);
}
pub inline fn GTK_IS_CELL_AREA_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_AREA)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_AREA);
}
pub inline fn GTK_CELL_AREA_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_AREA, GtkCellAreaClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_AREA, GtkCellAreaClass);
}
pub inline fn GTK_CELL_AREA_WARN_INVALID_CELL_PROPERTY_ID(object: anytype, property_id: anytype, pspec: anytype) @TypeOf(G_OBJECT_WARN_INVALID_PSPEC(object, "cell property id", property_id, pspec)) {
    return G_OBJECT_WARN_INVALID_PSPEC(object, "cell property id", property_id, pspec);
}
pub const GTK_TYPE_CELL_AREA_BOX = gtk_cell_area_box_get_type();
pub inline fn GTK_CELL_AREA_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_AREA_BOX, GtkCellAreaBox)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_AREA_BOX, GtkCellAreaBox);
}
pub inline fn GTK_IS_CELL_AREA_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_AREA_BOX)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_AREA_BOX);
}
pub const GTK_TYPE_CELL_AREA_CONTEXT = gtk_cell_area_context_get_type();
pub inline fn GTK_CELL_AREA_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_AREA_CONTEXT, GtkCellAreaContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_AREA_CONTEXT, GtkCellAreaContext);
}
pub inline fn GTK_CELL_AREA_CONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_AREA_CONTEXT, GtkCellAreaContextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_AREA_CONTEXT, GtkCellAreaContextClass);
}
pub inline fn GTK_IS_CELL_AREA_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_AREA_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_AREA_CONTEXT);
}
pub inline fn GTK_IS_CELL_AREA_CONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_AREA_CONTEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_AREA_CONTEXT);
}
pub inline fn GTK_CELL_AREA_CONTEXT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_AREA_CONTEXT, GtkCellAreaContextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_AREA_CONTEXT, GtkCellAreaContextClass);
}
pub const GTK_TYPE_CELL_LAYOUT = gtk_cell_layout_get_type();
pub inline fn GTK_CELL_LAYOUT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_LAYOUT, GtkCellLayout)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_LAYOUT, GtkCellLayout);
}
pub inline fn GTK_IS_CELL_LAYOUT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_LAYOUT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_LAYOUT);
}
pub inline fn GTK_CELL_LAYOUT_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_CELL_LAYOUT, GtkCellLayoutIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_CELL_LAYOUT, GtkCellLayoutIface);
}
pub const GTK_TYPE_CELL_RENDERER_TEXT = gtk_cell_renderer_text_get_type();
pub inline fn GTK_CELL_RENDERER_TEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_TEXT, GtkCellRendererText)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_TEXT, GtkCellRendererText);
}
pub inline fn GTK_CELL_RENDERER_TEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_RENDERER_TEXT, GtkCellRendererTextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CELL_RENDERER_TEXT, GtkCellRendererTextClass);
}
pub inline fn GTK_IS_CELL_RENDERER_TEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_TEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_TEXT);
}
pub inline fn GTK_IS_CELL_RENDERER_TEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_RENDERER_TEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CELL_RENDERER_TEXT);
}
pub inline fn GTK_CELL_RENDERER_TEXT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_RENDERER_TEXT, GtkCellRendererTextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CELL_RENDERER_TEXT, GtkCellRendererTextClass);
}
pub const GTK_TYPE_CELL_RENDERER_ACCEL = gtk_cell_renderer_accel_get_type();
pub inline fn GTK_CELL_RENDERER_ACCEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_ACCEL, GtkCellRendererAccel)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_ACCEL, GtkCellRendererAccel);
}
pub inline fn GTK_IS_CELL_RENDERER_ACCEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_ACCEL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_ACCEL);
}
pub const GTK_TYPE_CELL_RENDERER_COMBO = gtk_cell_renderer_combo_get_type();
pub inline fn GTK_CELL_RENDERER_COMBO(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_COMBO, GtkCellRendererCombo)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_COMBO, GtkCellRendererCombo);
}
pub inline fn GTK_IS_CELL_RENDERER_COMBO(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_COMBO)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_COMBO);
}
pub const GTK_TYPE_CELL_RENDERER_PIXBUF = gtk_cell_renderer_pixbuf_get_type();
pub inline fn GTK_CELL_RENDERER_PIXBUF(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_PIXBUF, GtkCellRendererPixbuf)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_PIXBUF, GtkCellRendererPixbuf);
}
pub inline fn GTK_IS_CELL_RENDERER_PIXBUF(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_PIXBUF)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_PIXBUF);
}
pub const GTK_TYPE_CELL_RENDERER_PROGRESS = gtk_cell_renderer_progress_get_type();
pub inline fn GTK_CELL_RENDERER_PROGRESS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_PROGRESS, GtkCellRendererProgress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_PROGRESS, GtkCellRendererProgress);
}
pub inline fn GTK_IS_CELL_RENDERER_PROGRESS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_PROGRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_PROGRESS);
}
pub const GTK_TYPE_CELL_RENDERER_SPIN = gtk_cell_renderer_spin_get_type();
pub inline fn GTK_CELL_RENDERER_SPIN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_SPIN, GtkCellRendererSpin)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_SPIN, GtkCellRendererSpin);
}
pub inline fn GTK_IS_CELL_RENDERER_SPIN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_SPIN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_SPIN);
}
pub const GTK_TYPE_CELL_RENDERER_SPINNER = gtk_cell_renderer_spinner_get_type();
pub inline fn GTK_CELL_RENDERER_SPINNER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_SPINNER, GtkCellRendererSpinner)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_SPINNER, GtkCellRendererSpinner);
}
pub inline fn GTK_IS_CELL_RENDERER_SPINNER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_SPINNER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_SPINNER);
}
pub const GTK_TYPE_CELL_RENDERER_TOGGLE = gtk_cell_renderer_toggle_get_type();
pub inline fn GTK_CELL_RENDERER_TOGGLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_TOGGLE, GtkCellRendererToggle)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_RENDERER_TOGGLE, GtkCellRendererToggle);
}
pub inline fn GTK_IS_CELL_RENDERER_TOGGLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_TOGGLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_RENDERER_TOGGLE);
}
pub const GTK_TYPE_CELL_VIEW = gtk_cell_view_get_type();
pub inline fn GTK_CELL_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_VIEW, GtkCellView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CELL_VIEW, GtkCellView);
}
pub inline fn GTK_IS_CELL_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CELL_VIEW);
}
pub const GTK_TYPE_CENTER_BOX = gtk_center_box_get_type();
pub inline fn GTK_CENTER_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CENTER_BOX, GtkCenterBox)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CENTER_BOX, GtkCenterBox);
}
pub inline fn GTK_CENTER_BOX_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CENTER_BOX, GtkCenterBoxClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CENTER_BOX, GtkCenterBoxClass);
}
pub inline fn GTK_IS_CENTER_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CENTER_BOX)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CENTER_BOX);
}
pub inline fn GTK_IS_CENTER_BOX_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CENTER_BOX)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CENTER_BOX);
}
pub inline fn GTK_CENTER_BOX_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CENTER_BOX, GtkCenterBoxClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CENTER_BOX, GtkCenterBoxClass);
}
pub const GTK_TYPE_CENTER_LAYOUT = gtk_center_layout_get_type();
pub const GTK_TYPE_TOGGLE_BUTTON = gtk_toggle_button_get_type();
pub inline fn GTK_TOGGLE_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TOGGLE_BUTTON, GtkToggleButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TOGGLE_BUTTON, GtkToggleButton);
}
pub inline fn GTK_TOGGLE_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TOGGLE_BUTTON, GtkToggleButtonClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TOGGLE_BUTTON, GtkToggleButtonClass);
}
pub inline fn GTK_IS_TOGGLE_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TOGGLE_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TOGGLE_BUTTON);
}
pub inline fn GTK_IS_TOGGLE_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TOGGLE_BUTTON)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TOGGLE_BUTTON);
}
pub inline fn GTK_TOGGLE_BUTTON_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TOGGLE_BUTTON, GtkToggleButtonClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TOGGLE_BUTTON, GtkToggleButtonClass);
}
pub const GTK_TYPE_CHECK_BUTTON = gtk_check_button_get_type();
pub inline fn GTK_CHECK_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CHECK_BUTTON, GtkCheckButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_CHECK_BUTTON, GtkCheckButton);
}
pub inline fn GTK_CHECK_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CHECK_BUTTON, GtkCheckButtonClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_CHECK_BUTTON, GtkCheckButtonClass);
}
pub inline fn GTK_IS_CHECK_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CHECK_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_CHECK_BUTTON);
}
pub inline fn GTK_IS_CHECK_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CHECK_BUTTON)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_CHECK_BUTTON);
}
pub inline fn GTK_CHECK_BUTTON_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CHECK_BUTTON, GtkCheckButtonClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_CHECK_BUTTON, GtkCheckButtonClass);
}
pub const GTK_TYPE_COLOR_BUTTON = gtk_color_button_get_type();
pub inline fn GTK_COLOR_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_BUTTON, GtkColorButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_BUTTON, GtkColorButton);
}
pub inline fn GTK_IS_COLOR_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_BUTTON);
}
pub const GTK_TYPE_COLOR_CHOOSER = gtk_color_chooser_get_type();
pub inline fn GTK_COLOR_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_CHOOSER, GtkColorChooser)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_CHOOSER, GtkColorChooser);
}
pub inline fn GTK_IS_COLOR_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_CHOOSER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_CHOOSER);
}
pub inline fn GTK_COLOR_CHOOSER_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_COLOR_CHOOSER, GtkColorChooserInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_COLOR_CHOOSER, GtkColorChooserInterface);
}
pub const GTK_TYPE_COLOR_CHOOSER_DIALOG = gtk_color_chooser_dialog_get_type();
pub inline fn GTK_COLOR_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_CHOOSER_DIALOG, GtkColorChooserDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_CHOOSER_DIALOG, GtkColorChooserDialog);
}
pub inline fn GTK_IS_COLOR_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_CHOOSER_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_CHOOSER_DIALOG);
}
pub const GTK_TYPE_COLOR_CHOOSER_WIDGET = gtk_color_chooser_widget_get_type();
pub inline fn GTK_COLOR_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_CHOOSER_WIDGET, GtkColorChooserWidget)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COLOR_CHOOSER_WIDGET, GtkColorChooserWidget);
}
pub inline fn GTK_IS_COLOR_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_CHOOSER_WIDGET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COLOR_CHOOSER_WIDGET);
}
pub const GTK_TYPE_COLOR_DIALOG = gtk_color_dialog_get_type();
pub const GTK_TYPE_COLOR_DIALOG_BUTTON = gtk_color_dialog_button_get_type();
pub const GTK_TYPE_SORTER = gtk_sorter_get_type();
pub const GTK_TYPE_SORT_LIST_MODEL = gtk_sort_list_model_get_type();
pub const GTK_TYPE_SELECTION_MODEL = gtk_selection_model_get_type();
pub const GTK_TYPE_COLUMN_VIEW = gtk_column_view_get_type();
pub inline fn GTK_COLUMN_VIEW(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_COLUMN_VIEW, GtkColumnView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_COLUMN_VIEW, GtkColumnView);
}
pub inline fn GTK_COLUMN_VIEW_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_COLUMN_VIEW, GtkColumnViewClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_COLUMN_VIEW, GtkColumnViewClass);
}
pub inline fn GTK_IS_COLUMN_VIEW(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_COLUMN_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_COLUMN_VIEW);
}
pub inline fn GTK_IS_COLUMN_VIEW_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_COLUMN_VIEW)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_COLUMN_VIEW);
}
pub inline fn GTK_COLUMN_VIEW_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_COLUMN_VIEW, GtkColumnViewClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_COLUMN_VIEW, GtkColumnViewClass);
}
pub const GTK_TYPE_LIST_ITEM = gtk_list_item_get_type();
pub const GTK_TYPE_COLUMN_VIEW_CELL = gtk_column_view_cell_get_type();
pub const GTK_TYPE_COLUMN_VIEW_COLUMN = gtk_column_view_column_get_type();
pub inline fn GTK_COLUMN_VIEW_COLUMN(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_COLUMN_VIEW_COLUMN, GtkColumnViewColumn)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_COLUMN_VIEW_COLUMN, GtkColumnViewColumn);
}
pub inline fn GTK_COLUMN_VIEW_COLUMN_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_COLUMN_VIEW_COLUMN, GtkColumnViewColumnClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_COLUMN_VIEW_COLUMN, GtkColumnViewColumnClass);
}
pub inline fn GTK_IS_COLUMN_VIEW_COLUMN(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_COLUMN_VIEW_COLUMN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_COLUMN_VIEW_COLUMN);
}
pub inline fn GTK_IS_COLUMN_VIEW_COLUMN_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_COLUMN_VIEW_COLUMN)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_COLUMN_VIEW_COLUMN);
}
pub inline fn GTK_COLUMN_VIEW_COLUMN_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_COLUMN_VIEW_COLUMN, GtkColumnViewColumnClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_COLUMN_VIEW_COLUMN, GtkColumnViewColumnClass);
}
pub const GTK_TYPE_COLUMN_VIEW_ROW = gtk_column_view_row_get_type();
pub const GTK_TYPE_COLUMN_VIEW_SORTER = gtk_column_view_sorter_get_type();
pub const GTK_TYPE_TREE_SORTABLE = gtk_tree_sortable_get_type();
pub inline fn GTK_TREE_SORTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_SORTABLE, GtkTreeSortable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_SORTABLE, GtkTreeSortable);
}
pub inline fn GTK_IS_TREE_SORTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_SORTABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_SORTABLE);
}
pub inline fn GTK_TREE_SORTABLE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_SORTABLE, GtkTreeSortableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_SORTABLE, GtkTreeSortableIface);
}
pub const GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -@as(c_int, 1);
pub const GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -@as(c_int, 2);
pub const GTK_TYPE_TREE_VIEW_COLUMN = gtk_tree_view_column_get_type();
pub inline fn GTK_TREE_VIEW_COLUMN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_VIEW_COLUMN, GtkTreeViewColumn)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_VIEW_COLUMN, GtkTreeViewColumn);
}
pub inline fn GTK_IS_TREE_VIEW_COLUMN(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_VIEW_COLUMN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_VIEW_COLUMN);
}
pub const GTK_TYPE_EDITABLE = gtk_editable_get_type();
pub inline fn GTK_EDITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EDITABLE, GtkEditable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EDITABLE, GtkEditable);
}
pub inline fn GTK_IS_EDITABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EDITABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EDITABLE);
}
pub inline fn GTK_EDITABLE_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_EDITABLE, GtkEditableInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_EDITABLE, GtkEditableInterface);
}
pub const GTK_TYPE_IM_CONTEXT = gtk_im_context_get_type();
pub inline fn GTK_IM_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IM_CONTEXT, GtkIMContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IM_CONTEXT, GtkIMContext);
}
pub inline fn GTK_IM_CONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_IM_CONTEXT, GtkIMContextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_IM_CONTEXT, GtkIMContextClass);
}
pub inline fn GTK_IS_IM_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IM_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IM_CONTEXT);
}
pub inline fn GTK_IS_IM_CONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_IM_CONTEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_IM_CONTEXT);
}
pub inline fn GTK_IM_CONTEXT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_IM_CONTEXT, GtkIMContextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_IM_CONTEXT, GtkIMContextClass);
}
pub const GTK_ENTRY_BUFFER_MAX_SIZE = G_MAXUSHORT;
pub const GTK_TYPE_ENTRY_BUFFER = gtk_entry_buffer_get_type();
pub inline fn GTK_ENTRY_BUFFER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ENTRY_BUFFER, GtkEntryBuffer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ENTRY_BUFFER, GtkEntryBuffer);
}
pub inline fn GTK_ENTRY_BUFFER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_ENTRY_BUFFER, GtkEntryBufferClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_ENTRY_BUFFER, GtkEntryBufferClass);
}
pub inline fn GTK_IS_ENTRY_BUFFER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ENTRY_BUFFER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ENTRY_BUFFER);
}
pub inline fn GTK_IS_ENTRY_BUFFER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_ENTRY_BUFFER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_ENTRY_BUFFER);
}
pub inline fn GTK_ENTRY_BUFFER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_ENTRY_BUFFER, GtkEntryBufferClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_ENTRY_BUFFER, GtkEntryBufferClass);
}
pub const GTK_TYPE_LIST_STORE = gtk_list_store_get_type();
pub inline fn GTK_LIST_STORE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LIST_STORE, GtkListStore)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LIST_STORE, GtkListStore);
}
pub inline fn GTK_LIST_STORE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_LIST_STORE, GtkListStoreClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_LIST_STORE, GtkListStoreClass);
}
pub inline fn GTK_IS_LIST_STORE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LIST_STORE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LIST_STORE);
}
pub inline fn GTK_IS_LIST_STORE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_LIST_STORE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_LIST_STORE);
}
pub inline fn GTK_LIST_STORE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_LIST_STORE, GtkListStoreClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_LIST_STORE, GtkListStoreClass);
}
pub const GTK_TYPE_TREE_MODEL_FILTER = gtk_tree_model_filter_get_type();
pub inline fn GTK_TREE_MODEL_FILTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilter);
}
pub inline fn GTK_TREE_MODEL_FILTER_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(vtable, GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass)) {
    return G_TYPE_CHECK_CLASS_CAST(vtable, GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass);
}
pub inline fn GTK_IS_TREE_MODEL_FILTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_MODEL_FILTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_MODEL_FILTER);
}
pub inline fn GTK_IS_TREE_MODEL_FILTER_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(vtable, GTK_TYPE_TREE_MODEL_FILTER)) {
    return G_TYPE_CHECK_CLASS_TYPE(vtable, GTK_TYPE_TREE_MODEL_FILTER);
}
pub inline fn GTK_TREE_MODEL_FILTER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_MODEL_FILTER, GtkTreeModelFilterClass);
}
pub const GTK_TYPE_ENTRY_COMPLETION = gtk_entry_completion_get_type();
pub inline fn GTK_ENTRY_COMPLETION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ENTRY_COMPLETION, GtkEntryCompletion)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ENTRY_COMPLETION, GtkEntryCompletion);
}
pub inline fn GTK_IS_ENTRY_COMPLETION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ENTRY_COMPLETION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ENTRY_COMPLETION);
}
pub const GTK_TYPE_IMAGE = gtk_image_get_type();
pub inline fn GTK_IMAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IMAGE, GtkImage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IMAGE, GtkImage);
}
pub inline fn GTK_IS_IMAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IMAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IMAGE);
}
pub const GTK_TYPE_ENTRY = gtk_entry_get_type();
pub inline fn GTK_ENTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ENTRY, GtkEntry)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ENTRY, GtkEntry);
}
pub inline fn GTK_ENTRY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_ENTRY, GtkEntryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_ENTRY, GtkEntryClass);
}
pub inline fn GTK_IS_ENTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ENTRY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ENTRY);
}
pub inline fn GTK_IS_ENTRY_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_ENTRY)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_ENTRY);
}
pub inline fn GTK_ENTRY_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_ENTRY, GtkEntryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_ENTRY, GtkEntryClass);
}
pub const GTK_TYPE_TREE_VIEW = gtk_tree_view_get_type();
pub inline fn GTK_TREE_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_VIEW, GtkTreeView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_VIEW, GtkTreeView);
}
pub inline fn GTK_IS_TREE_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_VIEW);
}
pub inline fn GTK_TREE_VIEW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TREE_VIEW, GtkTreeViewClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TREE_VIEW, GtkTreeViewClass);
}
pub inline fn GTK_IS_TREE_VIEW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TREE_VIEW)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TREE_VIEW);
}
pub inline fn GTK_TREE_VIEW_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_VIEW, GtkTreeViewClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_VIEW, GtkTreeViewClass);
}
pub const GTK_TYPE_COMBO_BOX = gtk_combo_box_get_type();
pub inline fn GTK_COMBO_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COMBO_BOX, GtkComboBox)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COMBO_BOX, GtkComboBox);
}
pub inline fn GTK_COMBO_BOX_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(vtable, GTK_TYPE_COMBO_BOX, GtkComboBoxClass)) {
    return G_TYPE_CHECK_CLASS_CAST(vtable, GTK_TYPE_COMBO_BOX, GtkComboBoxClass);
}
pub inline fn GTK_IS_COMBO_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COMBO_BOX)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COMBO_BOX);
}
pub inline fn GTK_IS_COMBO_BOX_CLASS(vtable: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(vtable, GTK_TYPE_COMBO_BOX)) {
    return G_TYPE_CHECK_CLASS_TYPE(vtable, GTK_TYPE_COMBO_BOX);
}
pub inline fn GTK_COMBO_BOX_GET_CLASS(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(inst, GTK_TYPE_COMBO_BOX, GtkComboBoxClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(inst, GTK_TYPE_COMBO_BOX, GtkComboBoxClass);
}
pub const GTK_TYPE_COMBO_BOX_TEXT = gtk_combo_box_text_get_type();
pub inline fn GTK_COMBO_BOX_TEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COMBO_BOX_TEXT, GtkComboBoxText)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_COMBO_BOX_TEXT, GtkComboBoxText);
}
pub inline fn GTK_IS_COMBO_BOX_TEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COMBO_BOX_TEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_COMBO_BOX_TEXT);
}
pub const GTK_TYPE_CONSTRAINT_TARGET = gtk_constraint_target_get_type();
pub const GTK_TYPE_CONSTRAINT = gtk_constraint_get_type();
pub const __GTK_TYPE_BUILTINS_H__ = "";
pub const GTK_TYPE_ASSISTANT_PAGE_TYPE = gtk_assistant_page_type_get_type();
pub const GTK_TYPE_CELL_RENDERER_STATE = gtk_cell_renderer_state_get_type();
pub const GTK_TYPE_CELL_RENDERER_MODE = gtk_cell_renderer_mode_get_type();
pub const GTK_TYPE_CELL_RENDERER_ACCEL_MODE = gtk_cell_renderer_accel_mode_get_type();
pub const GTK_TYPE_DIALOG_FLAGS = gtk_dialog_flags_get_type();
pub const GTK_TYPE_RESPONSE_TYPE = gtk_response_type_get_type();
pub const GTK_TYPE_FILE_CHOOSER_ACTION = gtk_file_chooser_action_get_type();
pub const GTK_TYPE_FILE_CHOOSER_ERROR = gtk_file_chooser_error_get_type();
pub const GTK_TYPE_FONT_CHOOSER_LEVEL = gtk_font_chooser_level_get_type();
pub const GTK_TYPE_ICON_VIEW_DROP_POSITION = gtk_icon_view_drop_position_get_type();
pub const GTK_TYPE_BUTTONS_TYPE = gtk_buttons_type_get_type();
pub const GTK_TYPE_STYLE_CONTEXT_PRINT_FLAGS = gtk_style_context_print_flags_get_type();
pub const GTK_TYPE_TREE_MODEL_FLAGS = gtk_tree_model_flags_get_type();
pub const GTK_TYPE_TREE_VIEW_DROP_POSITION = gtk_tree_view_drop_position_get_type();
pub const GTK_TYPE_TREE_VIEW_COLUMN_SIZING = gtk_tree_view_column_sizing_get_type();
pub const GTK_TYPE_LICENSE = gtk_license_get_type();
pub const GTK_TYPE_ACCESSIBLE_PLATFORM_STATE = gtk_accessible_platform_state_get_type();
pub const GTK_TYPE_APPLICATION_INHIBIT_FLAGS = gtk_application_inhibit_flags_get_type();
pub const GTK_TYPE_BUILDER_ERROR = gtk_builder_error_get_type();
pub const GTK_TYPE_BUILDER_CLOSURE_FLAGS = gtk_builder_closure_flags_get_type();
pub const GTK_TYPE_DEBUG_FLAGS = gtk_debug_flags_get_type();
pub const GTK_TYPE_DIALOG_ERROR = gtk_dialog_error_get_type();
pub const GTK_TYPE_EDITABLE_PROPERTIES = gtk_editable_properties_get_type();
pub const GTK_TYPE_ENTRY_ICON_POSITION = gtk_entry_icon_position_get_type();
pub const GTK_TYPE_ALIGN = gtk_align_get_type();
pub const GTK_TYPE_ARROW_TYPE = gtk_arrow_type_get_type();
pub const GTK_TYPE_BASELINE_POSITION = gtk_baseline_position_get_type();
pub const GTK_TYPE_CONTENT_FIT = gtk_content_fit_get_type();
pub const GTK_TYPE_DELETE_TYPE = gtk_delete_type_get_type();
pub const GTK_TYPE_DIRECTION_TYPE = gtk_direction_type_get_type();
pub const GTK_TYPE_ICON_SIZE = gtk_icon_size_get_type();
pub const GTK_TYPE_SENSITIVITY_TYPE = gtk_sensitivity_type_get_type();
pub const GTK_TYPE_TEXT_DIRECTION = gtk_text_direction_get_type();
pub const GTK_TYPE_JUSTIFICATION = gtk_justification_get_type();
pub const GTK_TYPE_LIST_TAB_BEHAVIOR = gtk_list_tab_behavior_get_type();
pub const GTK_TYPE_LIST_SCROLL_FLAGS = gtk_list_scroll_flags_get_type();
pub const GTK_TYPE_MESSAGE_TYPE = gtk_message_type_get_type();
pub const GTK_TYPE_MOVEMENT_STEP = gtk_movement_step_get_type();
pub const GTK_TYPE_NATURAL_WRAP_MODE = gtk_natural_wrap_mode_get_type();
pub const GTK_TYPE_SCROLL_STEP = gtk_scroll_step_get_type();
pub const GTK_TYPE_ORIENTATION = gtk_orientation_get_type();
pub const GTK_TYPE_OVERFLOW = gtk_overflow_get_type();
pub const GTK_TYPE_PACK_TYPE = gtk_pack_type_get_type();
pub const GTK_TYPE_POSITION_TYPE = gtk_position_type_get_type();
pub const GTK_TYPE_SCROLL_TYPE = gtk_scroll_type_get_type();
pub const GTK_TYPE_SELECTION_MODE = gtk_selection_mode_get_type();
pub const GTK_TYPE_WRAP_MODE = gtk_wrap_mode_get_type();
pub const GTK_TYPE_SORT_TYPE = gtk_sort_type_get_type();
pub const GTK_TYPE_PRINT_PAGES = gtk_print_pages_get_type();
pub const GTK_TYPE_PAGE_SET = gtk_page_set_get_type();
pub const GTK_TYPE_NUMBER_UP_LAYOUT = gtk_number_up_layout_get_type();
pub const GTK_TYPE_ORDERING = gtk_ordering_get_type();
pub const GTK_TYPE_PAGE_ORIENTATION = gtk_page_orientation_get_type();
pub const GTK_TYPE_PRINT_QUALITY = gtk_print_quality_get_type();
pub const GTK_TYPE_PRINT_DUPLEX = gtk_print_duplex_get_type();
pub const GTK_TYPE_UNIT = gtk_unit_get_type();
pub const GTK_TYPE_TREE_VIEW_GRID_LINES = gtk_tree_view_grid_lines_get_type();
pub const GTK_TYPE_SIZE_GROUP_MODE = gtk_size_group_mode_get_type();
pub const GTK_TYPE_SIZE_REQUEST_MODE = gtk_size_request_mode_get_type();
pub const GTK_TYPE_SCROLLABLE_POLICY = gtk_scrollable_policy_get_type();
pub const GTK_TYPE_STATE_FLAGS = gtk_state_flags_get_type();
pub const GTK_TYPE_BORDER_STYLE = gtk_border_style_get_type();
pub const GTK_TYPE_LEVEL_BAR_MODE = gtk_level_bar_mode_get_type();
pub const GTK_TYPE_INPUT_PURPOSE = gtk_input_purpose_get_type();
pub const GTK_TYPE_INPUT_HINTS = gtk_input_hints_get_type();
pub const GTK_TYPE_PROPAGATION_PHASE = gtk_propagation_phase_get_type();
pub const GTK_TYPE_PROPAGATION_LIMIT = gtk_propagation_limit_get_type();
pub const GTK_TYPE_EVENT_SEQUENCE_STATE = gtk_event_sequence_state_get_type();
pub const GTK_TYPE_PAN_DIRECTION = gtk_pan_direction_get_type();
pub const GTK_TYPE_SHORTCUT_SCOPE = gtk_shortcut_scope_get_type();
pub const GTK_TYPE_PICK_FLAGS = gtk_pick_flags_get_type();
pub const GTK_TYPE_CONSTRAINT_RELATION = gtk_constraint_relation_get_type();
pub const GTK_TYPE_CONSTRAINT_STRENGTH = gtk_constraint_strength_get_type();
pub const GTK_TYPE_CONSTRAINT_ATTRIBUTE = gtk_constraint_attribute_get_type();
pub const GTK_TYPE_CONSTRAINT_VFL_PARSER_ERROR = gtk_constraint_vfl_parser_error_get_type();
pub const GTK_TYPE_SYSTEM_SETTING = gtk_system_setting_get_type();
pub const GTK_TYPE_SYMBOLIC_COLOR = gtk_symbolic_color_get_type();
pub const GTK_TYPE_ACCESSIBLE_ROLE = gtk_accessible_role_get_type();
pub const GTK_TYPE_ACCESSIBLE_STATE = gtk_accessible_state_get_type();
pub const GTK_TYPE_ACCESSIBLE_PROPERTY = gtk_accessible_property_get_type();
pub const GTK_TYPE_ACCESSIBLE_RELATION = gtk_accessible_relation_get_type();
pub const GTK_TYPE_ACCESSIBLE_TRISTATE = gtk_accessible_tristate_get_type();
pub const GTK_TYPE_ACCESSIBLE_INVALID_STATE = gtk_accessible_invalid_state_get_type();
pub const GTK_TYPE_ACCESSIBLE_AUTOCOMPLETE = gtk_accessible_autocomplete_get_type();
pub const GTK_TYPE_ACCESSIBLE_SORT = gtk_accessible_sort_get_type();
pub const GTK_TYPE_EVENT_CONTROLLER_SCROLL_FLAGS = gtk_event_controller_scroll_flags_get_type();
pub const GTK_TYPE_FILTER_MATCH = gtk_filter_match_get_type();
pub const GTK_TYPE_FILTER_CHANGE = gtk_filter_change_get_type();
pub const GTK_TYPE_FONT_LEVEL = gtk_font_level_get_type();
pub const GTK_TYPE_ICON_LOOKUP_FLAGS = gtk_icon_lookup_flags_get_type();
pub const GTK_TYPE_ICON_THEME_ERROR = gtk_icon_theme_error_get_type();
pub const GTK_TYPE_IMAGE_TYPE = gtk_image_type_get_type();
pub const GTK_TYPE_INSCRIPTION_OVERFLOW = gtk_inscription_overflow_get_type();
pub const GTK_TYPE_NOTEBOOK_TAB = gtk_notebook_tab_get_type();
pub const GTK_TYPE_PAD_ACTION_TYPE = gtk_pad_action_type_get_type();
pub const GTK_TYPE_POPOVER_MENU_FLAGS = gtk_popover_menu_flags_get_type();
pub const GTK_TYPE_RECENT_MANAGER_ERROR = gtk_recent_manager_error_get_type();
pub const GTK_TYPE_REVEALER_TRANSITION_TYPE = gtk_revealer_transition_type_get_type();
pub const GTK_TYPE_CORNER_TYPE = gtk_corner_type_get_type();
pub const GTK_TYPE_POLICY_TYPE = gtk_policy_type_get_type();
pub const GTK_TYPE_SHORTCUT_ACTION_FLAGS = gtk_shortcut_action_flags_get_type();
pub const GTK_TYPE_SHORTCUT_TYPE = gtk_shortcut_type_get_type();
pub const GTK_TYPE_SORTER_ORDER = gtk_sorter_order_get_type();
pub const GTK_TYPE_SORTER_CHANGE = gtk_sorter_change_get_type();
pub const GTK_TYPE_SPIN_BUTTON_UPDATE_POLICY = gtk_spin_button_update_policy_get_type();
pub const GTK_TYPE_SPIN_TYPE = gtk_spin_type_get_type();
pub const GTK_TYPE_STACK_TRANSITION_TYPE = gtk_stack_transition_type_get_type();
pub const GTK_TYPE_STRING_FILTER_MATCH_MODE = gtk_string_filter_match_mode_get_type();
pub const GTK_TYPE_COLLATION = gtk_collation_get_type();
pub const GTK_TYPE_TEXT_SEARCH_FLAGS = gtk_text_search_flags_get_type();
pub const GTK_TYPE_TEXT_WINDOW_TYPE = gtk_text_window_type_get_type();
pub const GTK_TYPE_TEXT_VIEW_LAYER = gtk_text_view_layer_get_type();
pub const GTK_TYPE_TEXT_EXTEND_SELECTION = gtk_text_extend_selection_get_type();
pub const GTK_TYPE_PRINT_STATUS = gtk_print_status_get_type();
pub const GTK_TYPE_PRINT_OPERATION_RESULT = gtk_print_operation_result_get_type();
pub const GTK_TYPE_PRINT_OPERATION_ACTION = gtk_print_operation_action_get_type();
pub const GTK_TYPE_PRINT_ERROR = gtk_print_error_get_type();
pub const GTK_TYPE_CONSTRAINT_GUIDE = gtk_constraint_guide_get_type();
pub const GTK_TYPE_CONSTRAINT_LAYOUT = gtk_constraint_layout_get_type();
pub const GTK_TYPE_CONSTRAINT_LAYOUT_CHILD = gtk_constraint_layout_child_get_type();
pub const GTK_CONSTRAINT_VFL_PARSER_ERROR = gtk_constraint_vfl_parser_error_quark();
pub const GTK_TYPE_CSS_PROVIDER = gtk_css_provider_get_type();
pub inline fn GTK_CSS_PROVIDER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_CSS_PROVIDER, GtkCssProvider)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_CSS_PROVIDER, GtkCssProvider);
}
pub inline fn GTK_IS_CSS_PROVIDER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_CSS_PROVIDER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_CSS_PROVIDER);
}
pub const GTK_TYPE_CUSTOM_LAYOUT = gtk_custom_layout_get_type();
pub const GTK_TYPE_CUSTOM_SORTER = gtk_custom_sorter_get_type();
pub inline fn GTK_DEBUG_CHECK(@"type": anytype) @TypeOf(@as(c_int, 0)) {
    _ = @TypeOf(@"type");
    return @as(c_int, 0);
}
pub const GTK_DIALOG_ERROR = gtk_dialog_error_quark();
pub const GTK_TYPE_DIRECTORY_LIST = gtk_directory_list_get_type();
pub const GTK_TYPE_DRAG_ICON = gtk_drag_icon_get_type();
pub const GTK_TYPE_DRAG_SOURCE = gtk_drag_source_get_type();
pub inline fn GTK_DRAG_SOURCE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DRAG_SOURCE, GtkDragSource)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DRAG_SOURCE, GtkDragSource);
}
pub inline fn GTK_DRAG_SOURCE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DRAG_SOURCE, GtkDragSourceClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DRAG_SOURCE, GtkDragSourceClass);
}
pub inline fn GTK_IS_DRAG_SOURCE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DRAG_SOURCE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DRAG_SOURCE);
}
pub inline fn GTK_IS_DRAG_SOURCE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DRAG_SOURCE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DRAG_SOURCE);
}
pub inline fn GTK_DRAG_SOURCE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DRAG_SOURCE, GtkDragSourceClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DRAG_SOURCE, GtkDragSourceClass);
}
pub const GTK_TYPE_DRAWING_AREA = gtk_drawing_area_get_type();
pub inline fn GTK_DRAWING_AREA(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_DRAWING_AREA, GtkDrawingArea)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_DRAWING_AREA, GtkDrawingArea);
}
pub inline fn GTK_DRAWING_AREA_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_DRAWING_AREA, GtkDrawingAreaClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_DRAWING_AREA, GtkDrawingAreaClass);
}
pub inline fn GTK_IS_DRAWING_AREA(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_DRAWING_AREA)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_DRAWING_AREA);
}
pub inline fn GTK_IS_DRAWING_AREA_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_DRAWING_AREA)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_DRAWING_AREA);
}
pub inline fn GTK_DRAWING_AREA_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_DRAWING_AREA, GtkDrawingAreaClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_DRAWING_AREA, GtkDrawingAreaClass);
}
pub const GTK_TYPE_EVENT_CONTROLLER = gtk_event_controller_get_type();
pub inline fn GTK_EVENT_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER, GtkEventController)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER, GtkEventController);
}
pub inline fn GTK_EVENT_CONTROLLER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER, GtkEventControllerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER, GtkEventControllerClass);
}
pub inline fn GTK_IS_EVENT_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER);
}
pub inline fn GTK_EVENT_CONTROLLER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER, GtkEventControllerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER, GtkEventControllerClass);
}
pub const GTK_TYPE_DROP_CONTROLLER_MOTION = gtk_drop_controller_motion_get_type();
pub inline fn GTK_DROP_CONTROLLER_MOTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DROP_CONTROLLER_MOTION, GtkDropControllerMotion)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DROP_CONTROLLER_MOTION, GtkDropControllerMotion);
}
pub inline fn GTK_DROP_CONTROLLER_MOTION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DROP_CONTROLLER_MOTION, GtkDropControllerMotionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DROP_CONTROLLER_MOTION, GtkDropControllerMotionClass);
}
pub inline fn GTK_IS_DROP_CONTROLLER_MOTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DROP_CONTROLLER_MOTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DROP_CONTROLLER_MOTION);
}
pub inline fn GTK_IS_DROP_CONTROLLER_MOTION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DROP_CONTROLLER_MOTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DROP_CONTROLLER_MOTION);
}
pub inline fn GTK_DROP_CONTROLLER_MOTION_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DROP_CONTROLLER_MOTION, GtkDropControllerMotionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DROP_CONTROLLER_MOTION, GtkDropControllerMotionClass);
}
pub const GTK_TYPE_DROP_TARGET = gtk_drop_target_get_type();
pub inline fn GTK_DROP_TARGET(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DROP_TARGET, GtkDropTarget)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DROP_TARGET, GtkDropTarget);
}
pub inline fn GTK_DROP_TARGET_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DROP_TARGET, GtkDropTargetClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DROP_TARGET, GtkDropTargetClass);
}
pub inline fn GTK_IS_DROP_TARGET(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DROP_TARGET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DROP_TARGET);
}
pub inline fn GTK_IS_DROP_TARGET_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DROP_TARGET)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DROP_TARGET);
}
pub inline fn GTK_DROP_TARGET_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DROP_TARGET, GtkDropTargetClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DROP_TARGET, GtkDropTargetClass);
}
pub const GTK_TYPE_DROP_TARGET_ASYNC = gtk_drop_target_async_get_type();
pub inline fn GTK_DROP_TARGET_ASYNC(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DROP_TARGET_ASYNC, GtkDropTargetAsync)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_DROP_TARGET_ASYNC, GtkDropTargetAsync);
}
pub inline fn GTK_DROP_TARGET_ASYNC_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DROP_TARGET_ASYNC, GtkDropTargetAsyncClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_DROP_TARGET_ASYNC, GtkDropTargetAsyncClass);
}
pub inline fn GTK_IS_DROP_TARGET_ASYNC(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DROP_TARGET_ASYNC)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_DROP_TARGET_ASYNC);
}
pub inline fn GTK_IS_DROP_TARGET_ASYNC_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DROP_TARGET_ASYNC)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_DROP_TARGET_ASYNC);
}
pub inline fn GTK_DROP_TARGET_ASYNC_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DROP_TARGET_ASYNC, GtkDropTargetAsyncClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_DROP_TARGET_ASYNC, GtkDropTargetAsyncClass);
}
pub const GTK_TYPE_STRING_FILTER = gtk_string_filter_get_type();
pub const GTK_TYPE_DROP_DOWN = gtk_drop_down_get_type();
pub const GTK_TYPE_EDITABLE_LABEL = gtk_editable_label_get_type();
pub const GTK_TYPE_EMOJI_CHOOSER = gtk_emoji_chooser_get_type();
pub inline fn GTK_EMOJI_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EMOJI_CHOOSER, GtkEmojiChooser)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EMOJI_CHOOSER, GtkEmojiChooser);
}
pub inline fn GTK_EMOJI_CHOOSER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_EMOJI_CHOOSER, GtkEmojiChooserClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_EMOJI_CHOOSER, GtkEmojiChooserClass);
}
pub inline fn GTK_IS_EMOJI_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EMOJI_CHOOSER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EMOJI_CHOOSER);
}
pub inline fn GTK_IS_EMOJI_CHOOSER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_EMOJI_CHOOSER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_EMOJI_CHOOSER);
}
pub inline fn GTK_EMOJI_CHOOSER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_EMOJI_CHOOSER, GtkEmojiChooserClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_EMOJI_CHOOSER, GtkEmojiChooserClass);
}
pub const GTK_TYPE_EVENT_CONTROLLER_FOCUS = gtk_event_controller_focus_get_type();
pub inline fn GTK_EVENT_CONTROLLER_FOCUS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_FOCUS, GtkEventControllerFocus)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_FOCUS, GtkEventControllerFocus);
}
pub inline fn GTK_EVENT_CONTROLLER_FOCUS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_FOCUS, GtkEventControllerFocusClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_FOCUS, GtkEventControllerFocusClass);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_FOCUS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_FOCUS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_FOCUS);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_FOCUS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_FOCUS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_FOCUS);
}
pub inline fn GTK_EVENT_CONTROLLER_FOCUS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_FOCUS, GtkEventControllerFocusClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_FOCUS, GtkEventControllerFocusClass);
}
pub const GTK_TYPE_EVENT_CONTROLLER_KEY = gtk_event_controller_key_get_type();
pub inline fn GTK_EVENT_CONTROLLER_KEY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_KEY, GtkEventControllerKey)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_KEY, GtkEventControllerKey);
}
pub inline fn GTK_EVENT_CONTROLLER_KEY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_KEY, GtkEventControllerKeyClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_KEY, GtkEventControllerKeyClass);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_KEY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_KEY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_KEY);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_KEY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_KEY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_KEY);
}
pub inline fn GTK_EVENT_CONTROLLER_KEY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_KEY, GtkEventControllerKeyClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_KEY, GtkEventControllerKeyClass);
}
pub const GTK_TYPE_EVENT_CONTROLLER_LEGACY = gtk_event_controller_legacy_get_type();
pub inline fn GTK_EVENT_CONTROLLER_LEGACY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_LEGACY, GtkEventControllerLegacy)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_LEGACY, GtkEventControllerLegacy);
}
pub inline fn GTK_EVENT_CONTROLLER_LEGACY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_LEGACY, GtkEventControllerLegacyClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_LEGACY, GtkEventControllerLegacyClass);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_LEGACY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_LEGACY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_LEGACY);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_LEGACY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_LEGACY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_LEGACY);
}
pub inline fn GTK_EVENT_CONTROLLER_LEGACY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_LEGACY, GtkEventControllerLegacyClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_LEGACY, GtkEventControllerLegacyClass);
}
pub const GTK_TYPE_EVENT_CONTROLLER_MOTION = gtk_event_controller_motion_get_type();
pub inline fn GTK_EVENT_CONTROLLER_MOTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_MOTION, GtkEventControllerMotion)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_MOTION, GtkEventControllerMotion);
}
pub inline fn GTK_EVENT_CONTROLLER_MOTION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_MOTION, GtkEventControllerMotionClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_MOTION, GtkEventControllerMotionClass);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_MOTION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_MOTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_MOTION);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_MOTION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_MOTION)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_MOTION);
}
pub inline fn GTK_EVENT_CONTROLLER_MOTION_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_MOTION, GtkEventControllerMotionClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_MOTION, GtkEventControllerMotionClass);
}
pub const GTK_TYPE_EVENT_CONTROLLER_SCROLL = gtk_event_controller_scroll_get_type();
pub inline fn GTK_EVENT_CONTROLLER_SCROLL(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_SCROLL, GtkEventControllerScroll)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_EVENT_CONTROLLER_SCROLL, GtkEventControllerScroll);
}
pub inline fn GTK_EVENT_CONTROLLER_SCROLL_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_SCROLL, GtkEventControllerScrollClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_EVENT_CONTROLLER_SCROLL, GtkEventControllerScrollClass);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_SCROLL(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_SCROLL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_EVENT_CONTROLLER_SCROLL);
}
pub inline fn GTK_IS_EVENT_CONTROLLER_SCROLL_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_SCROLL)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_EVENT_CONTROLLER_SCROLL);
}
pub inline fn GTK_EVENT_CONTROLLER_SCROLL_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_SCROLL, GtkEventControllerScrollClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_EVENT_CONTROLLER_SCROLL, GtkEventControllerScrollClass);
}
pub const GTK_TYPE_EXPANDER = gtk_expander_get_type();
pub inline fn GTK_EXPANDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EXPANDER, GtkExpander)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_EXPANDER, GtkExpander);
}
pub inline fn GTK_IS_EXPANDER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EXPANDER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_EXPANDER);
}
pub const GTK_TYPE_FIXED = gtk_fixed_get_type();
pub inline fn GTK_FIXED(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FIXED, GtkFixed)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FIXED, GtkFixed);
}
pub inline fn GTK_FIXED_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_FIXED, GtkFixedClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_FIXED, GtkFixedClass);
}
pub inline fn GTK_IS_FIXED(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FIXED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FIXED);
}
pub inline fn GTK_IS_FIXED_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_FIXED)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_FIXED);
}
pub inline fn GTK_FIXED_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_FIXED, GtkFixedClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_FIXED, GtkFixedClass);
}
pub const GTK_TYPE_FIXED_LAYOUT = gtk_fixed_layout_get_type();
pub const GTK_TYPE_FIXED_LAYOUT_CHILD = gtk_fixed_layout_child_get_type();
pub const GTK_TYPE_FILE_FILTER = gtk_file_filter_get_type();
pub inline fn GTK_FILE_FILTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_FILTER, GtkFileFilter)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_FILTER, GtkFileFilter);
}
pub inline fn GTK_IS_FILE_FILTER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_FILTER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_FILTER);
}
pub const GTK_TYPE_FILE_CHOOSER = gtk_file_chooser_get_type();
pub inline fn GTK_FILE_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_CHOOSER, GtkFileChooser)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_CHOOSER, GtkFileChooser);
}
pub inline fn GTK_IS_FILE_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_CHOOSER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_CHOOSER);
}
pub const GTK_FILE_CHOOSER_ERROR = gtk_file_chooser_error_quark();
pub const GTK_TYPE_FILE_CHOOSER_DIALOG = gtk_file_chooser_dialog_get_type();
pub inline fn GTK_FILE_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_CHOOSER_DIALOG, GtkFileChooserDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_CHOOSER_DIALOG, GtkFileChooserDialog);
}
pub inline fn GTK_IS_FILE_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_CHOOSER_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_CHOOSER_DIALOG);
}
pub const GTK_TYPE_NATIVE_DIALOG = gtk_native_dialog_get_type();
pub const GTK_TYPE_FILE_CHOOSER_NATIVE = gtk_file_chooser_native_get_type();
pub const GTK_TYPE_FILE_CHOOSER_WIDGET = gtk_file_chooser_widget_get_type();
pub inline fn GTK_FILE_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_CHOOSER_WIDGET, GtkFileChooserWidget)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FILE_CHOOSER_WIDGET, GtkFileChooserWidget);
}
pub inline fn GTK_IS_FILE_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_CHOOSER_WIDGET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FILE_CHOOSER_WIDGET);
}
pub const GTK_TYPE_FILE_DIALOG = gtk_file_dialog_get_type();
pub const GTK_TYPE_FILE_LAUNCHER = gtk_file_launcher_get_type();
pub const GTK_TYPE_FILTER_LIST_MODEL = gtk_filter_list_model_get_type();
pub const GTK_TYPE_CUSTOM_FILTER = gtk_custom_filter_get_type();
pub const GTK_TYPE_FLATTEN_LIST_MODEL = gtk_flatten_list_model_get_type();
pub const GTK_TYPE_FLOW_BOX = gtk_flow_box_get_type();
pub inline fn GTK_FLOW_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FLOW_BOX, GtkFlowBox)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FLOW_BOX, GtkFlowBox);
}
pub inline fn GTK_IS_FLOW_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FLOW_BOX)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FLOW_BOX);
}
pub const GTK_TYPE_FLOW_BOX_CHILD = gtk_flow_box_child_get_type();
pub inline fn GTK_FLOW_BOX_CHILD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FLOW_BOX_CHILD, GtkFlowBoxChild)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FLOW_BOX_CHILD, GtkFlowBoxChild);
}
pub inline fn GTK_FLOW_BOX_CHILD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_FLOW_BOX_CHILD, GtkFlowBoxChildClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_FLOW_BOX_CHILD, GtkFlowBoxChildClass);
}
pub inline fn GTK_IS_FLOW_BOX_CHILD(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FLOW_BOX_CHILD)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FLOW_BOX_CHILD);
}
pub inline fn GTK_IS_FLOW_BOX_CHILD_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_FLOW_BOX_CHILD)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_FLOW_BOX_CHILD);
}
pub const GTK_TYPE_FONT_BUTTON = gtk_font_button_get_type();
pub inline fn GTK_FONT_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_BUTTON, GtkFontButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_BUTTON, GtkFontButton);
}
pub inline fn GTK_IS_FONT_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_BUTTON);
}
pub const GTK_TYPE_FONT_CHOOSER = gtk_font_chooser_get_type();
pub inline fn GTK_FONT_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_CHOOSER, GtkFontChooser)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_CHOOSER, GtkFontChooser);
}
pub inline fn GTK_IS_FONT_CHOOSER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_CHOOSER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_CHOOSER);
}
pub inline fn GTK_FONT_CHOOSER_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_FONT_CHOOSER, GtkFontChooserIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_FONT_CHOOSER, GtkFontChooserIface);
}
pub const GTK_TYPE_FONT_CHOOSER_DIALOG = gtk_font_chooser_dialog_get_type();
pub inline fn GTK_FONT_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_CHOOSER_DIALOG, GtkFontChooserDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_CHOOSER_DIALOG, GtkFontChooserDialog);
}
pub inline fn GTK_IS_FONT_CHOOSER_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_CHOOSER_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_CHOOSER_DIALOG);
}
pub const GTK_TYPE_FONT_CHOOSER_WIDGET = gtk_font_chooser_widget_get_type();
pub inline fn GTK_FONT_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_CHOOSER_WIDGET, GtkFontChooserWidget)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FONT_CHOOSER_WIDGET, GtkFontChooserWidget);
}
pub inline fn GTK_IS_FONT_CHOOSER_WIDGET(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_CHOOSER_WIDGET)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FONT_CHOOSER_WIDGET);
}
pub const GTK_TYPE_FONT_DIALOG = gtk_font_dialog_get_type();
pub const GTK_TYPE_FONT_DIALOG_BUTTON = gtk_font_dialog_button_get_type();
pub const GTK_TYPE_FRAME = gtk_frame_get_type();
pub inline fn GTK_FRAME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FRAME, GtkFrame)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_FRAME, GtkFrame);
}
pub inline fn GTK_FRAME_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_FRAME, GtkFrameClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_FRAME, GtkFrameClass);
}
pub inline fn GTK_IS_FRAME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FRAME)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_FRAME);
}
pub inline fn GTK_IS_FRAME_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_FRAME)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_FRAME);
}
pub inline fn GTK_FRAME_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_FRAME, GtkFrameClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_FRAME, GtkFrameClass);
}
pub const GTK_TYPE_GESTURE = gtk_gesture_get_type();
pub inline fn GTK_GESTURE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE, GtkGesture)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE, GtkGesture);
}
pub inline fn GTK_GESTURE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE, GtkGestureClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE, GtkGestureClass);
}
pub inline fn GTK_IS_GESTURE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE);
}
pub inline fn GTK_IS_GESTURE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE);
}
pub inline fn GTK_GESTURE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE, GtkGestureClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE, GtkGestureClass);
}
pub const GTK_TYPE_GESTURE_SINGLE = gtk_gesture_single_get_type();
pub inline fn GTK_GESTURE_SINGLE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_SINGLE, GtkGestureSingle)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_SINGLE, GtkGestureSingle);
}
pub inline fn GTK_GESTURE_SINGLE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_SINGLE, GtkGestureSingleClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_SINGLE, GtkGestureSingleClass);
}
pub inline fn GTK_IS_GESTURE_SINGLE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_SINGLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_SINGLE);
}
pub inline fn GTK_IS_GESTURE_SINGLE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_SINGLE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_SINGLE);
}
pub inline fn GTK_GESTURE_SINGLE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_SINGLE, GtkGestureSingleClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_SINGLE, GtkGestureSingleClass);
}
pub const GTK_TYPE_GESTURE_CLICK = gtk_gesture_click_get_type();
pub inline fn GTK_GESTURE_CLICK(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_CLICK, GtkGestureClick)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_CLICK, GtkGestureClick);
}
pub inline fn GTK_GESTURE_CLICK_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_CLICK, GtkGestureClickClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_CLICK, GtkGestureClickClass);
}
pub inline fn GTK_IS_GESTURE_CLICK(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_CLICK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_CLICK);
}
pub inline fn GTK_IS_GESTURE_CLICK_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_CLICK)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_CLICK);
}
pub inline fn GTK_GESTURE_CLICK_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_CLICK, GtkGestureClickClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_CLICK, GtkGestureClickClass);
}
pub const GTK_TYPE_GESTURE_DRAG = gtk_gesture_drag_get_type();
pub inline fn GTK_GESTURE_DRAG(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_DRAG, GtkGestureDrag)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_DRAG, GtkGestureDrag);
}
pub inline fn GTK_GESTURE_DRAG_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_DRAG, GtkGestureDragClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_DRAG, GtkGestureDragClass);
}
pub inline fn GTK_IS_GESTURE_DRAG(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_DRAG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_DRAG);
}
pub inline fn GTK_IS_GESTURE_DRAG_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_DRAG)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_DRAG);
}
pub inline fn GTK_GESTURE_DRAG_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_DRAG, GtkGestureDragClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_DRAG, GtkGestureDragClass);
}
pub const GTK_TYPE_GESTURE_LONG_PRESS = gtk_gesture_long_press_get_type();
pub inline fn GTK_GESTURE_LONG_PRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_LONG_PRESS, GtkGestureLongPress)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_LONG_PRESS, GtkGestureLongPress);
}
pub inline fn GTK_GESTURE_LONG_PRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_LONG_PRESS, GtkGestureLongPressClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_LONG_PRESS, GtkGestureLongPressClass);
}
pub inline fn GTK_IS_GESTURE_LONG_PRESS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_LONG_PRESS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_LONG_PRESS);
}
pub inline fn GTK_IS_GESTURE_LONG_PRESS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_LONG_PRESS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_LONG_PRESS);
}
pub inline fn GTK_GESTURE_LONG_PRESS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_LONG_PRESS, GtkGestureLongPressClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_LONG_PRESS, GtkGestureLongPressClass);
}
pub const GTK_TYPE_GESTURE_PAN = gtk_gesture_pan_get_type();
pub inline fn GTK_GESTURE_PAN(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_PAN, GtkGesturePan)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_PAN, GtkGesturePan);
}
pub inline fn GTK_GESTURE_PAN_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_PAN, GtkGesturePanClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_PAN, GtkGesturePanClass);
}
pub inline fn GTK_IS_GESTURE_PAN(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_PAN)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_PAN);
}
pub inline fn GTK_IS_GESTURE_PAN_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_PAN)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_PAN);
}
pub inline fn GTK_GESTURE_PAN_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_PAN, GtkGesturePanClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_PAN, GtkGesturePanClass);
}
pub const GTK_TYPE_GESTURE_ROTATE = gtk_gesture_rotate_get_type();
pub inline fn GTK_GESTURE_ROTATE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_ROTATE, GtkGestureRotate)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_ROTATE, GtkGestureRotate);
}
pub inline fn GTK_GESTURE_ROTATE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_ROTATE, GtkGestureRotateClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_ROTATE, GtkGestureRotateClass);
}
pub inline fn GTK_IS_GESTURE_ROTATE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_ROTATE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_ROTATE);
}
pub inline fn GTK_IS_GESTURE_ROTATE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_ROTATE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_ROTATE);
}
pub inline fn GTK_GESTURE_ROTATE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_ROTATE, GtkGestureRotateClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_ROTATE, GtkGestureRotateClass);
}
pub const GTK_TYPE_GESTURE_STYLUS = gtk_gesture_stylus_get_type();
pub inline fn GTK_GESTURE_STYLUS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_STYLUS, GtkGestureStylus)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_STYLUS, GtkGestureStylus);
}
pub inline fn GTK_GESTURE_STYLUS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_STYLUS, GtkGestureStylusClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_STYLUS, GtkGestureStylusClass);
}
pub inline fn GTK_IS_GESTURE_STYLUS(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_STYLUS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_STYLUS);
}
pub inline fn GTK_IS_GESTURE_STYLUS_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_STYLUS)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_STYLUS);
}
pub inline fn GTK_GESTURE_STYLUS_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_STYLUS, GtkGestureStylusClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_STYLUS, GtkGestureStylusClass);
}
pub const GTK_TYPE_GESTURE_SWIPE = gtk_gesture_swipe_get_type();
pub inline fn GTK_GESTURE_SWIPE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_SWIPE, GtkGestureSwipe)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_SWIPE, GtkGestureSwipe);
}
pub inline fn GTK_GESTURE_SWIPE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_SWIPE, GtkGestureSwipeClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_SWIPE, GtkGestureSwipeClass);
}
pub inline fn GTK_IS_GESTURE_SWIPE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_SWIPE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_SWIPE);
}
pub inline fn GTK_IS_GESTURE_SWIPE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_SWIPE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_SWIPE);
}
pub inline fn GTK_GESTURE_SWIPE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_SWIPE, GtkGestureSwipeClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_SWIPE, GtkGestureSwipeClass);
}
pub const GTK_TYPE_GESTURE_ZOOM = gtk_gesture_zoom_get_type();
pub inline fn GTK_GESTURE_ZOOM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_ZOOM, GtkGestureZoom)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GESTURE_ZOOM, GtkGestureZoom);
}
pub inline fn GTK_GESTURE_ZOOM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_ZOOM, GtkGestureZoomClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GESTURE_ZOOM, GtkGestureZoomClass);
}
pub inline fn GTK_IS_GESTURE_ZOOM(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_ZOOM)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GESTURE_ZOOM);
}
pub inline fn GTK_IS_GESTURE_ZOOM_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_ZOOM)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GESTURE_ZOOM);
}
pub inline fn GTK_GESTURE_ZOOM_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_ZOOM, GtkGestureZoomClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GESTURE_ZOOM, GtkGestureZoomClass);
}
pub const GTK_TYPE_GL_AREA = gtk_gl_area_get_type();
pub inline fn GTK_GL_AREA(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_GL_AREA, GtkGLArea)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_GL_AREA, GtkGLArea);
}
pub inline fn GTK_IS_GL_AREA(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_GL_AREA)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_GL_AREA);
}
pub inline fn GTK_GL_AREA_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_GL_AREA, GtkGLAreaClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_GL_AREA, GtkGLAreaClass);
}
pub inline fn GTK_IS_GL_AREA_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_GL_AREA)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_GL_AREA);
}
pub inline fn GTK_GL_AREA_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_GL_AREA, GtkGLAreaClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_GL_AREA, GtkGLAreaClass);
}
pub const GTK_TYPE_GRID = gtk_grid_get_type();
pub inline fn GTK_GRID(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_GRID, GtkGrid)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_GRID, GtkGrid);
}
pub inline fn GTK_GRID_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_GRID, GtkGridClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_GRID, GtkGridClass);
}
pub inline fn GTK_IS_GRID(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_GRID)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_GRID);
}
pub inline fn GTK_IS_GRID_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_GRID)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_GRID);
}
pub inline fn GTK_GRID_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_GRID, GtkGridClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_GRID, GtkGridClass);
}
pub const GTK_TYPE_GRID_LAYOUT = gtk_grid_layout_get_type();
pub const GTK_TYPE_GRID_LAYOUT_CHILD = gtk_grid_layout_child_get_type();
pub const GTK_TYPE_LIST_BASE = gtk_list_base_get_type();
pub inline fn GTK_LIST_BASE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LIST_BASE, GtkListBase)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LIST_BASE, GtkListBase);
}
pub inline fn GTK_LIST_BASE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_LIST_BASE, GtkListBaseClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_LIST_BASE, GtkListBaseClass);
}
pub inline fn GTK_IS_LIST_BASE(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LIST_BASE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LIST_BASE);
}
pub inline fn GTK_IS_LIST_BASE_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_LIST_BASE)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_LIST_BASE);
}
pub inline fn GTK_LIST_BASE_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_LIST_BASE, GtkListBaseClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_LIST_BASE, GtkListBaseClass);
}
pub const GTK_TYPE_GRID_VIEW = gtk_grid_view_get_type();
pub inline fn GTK_GRID_VIEW(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GRID_VIEW, GtkGridView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_GRID_VIEW, GtkGridView);
}
pub inline fn GTK_GRID_VIEW_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GRID_VIEW, GtkGridViewClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_GRID_VIEW, GtkGridViewClass);
}
pub inline fn GTK_IS_GRID_VIEW(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GRID_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_GRID_VIEW);
}
pub inline fn GTK_IS_GRID_VIEW_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GRID_VIEW)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_GRID_VIEW);
}
pub inline fn GTK_GRID_VIEW_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GRID_VIEW, GtkGridViewClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_GRID_VIEW, GtkGridViewClass);
}
pub const GTK_TYPE_HEADER_BAR = gtk_header_bar_get_type();
pub inline fn GTK_HEADER_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_HEADER_BAR, GtkHeaderBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_HEADER_BAR, GtkHeaderBar);
}
pub inline fn GTK_IS_HEADER_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_HEADER_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_HEADER_BAR);
}
pub const GTK_TYPE_ICON_PAINTABLE = gtk_icon_paintable_get_type();
pub inline fn GTK_ICON_PAINTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ICON_PAINTABLE, GtkIconPaintable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ICON_PAINTABLE, GtkIconPaintable);
}
pub inline fn GTK_IS_ICON_PAINTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ICON_PAINTABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ICON_PAINTABLE);
}
pub const GTK_TYPE_ICON_THEME = gtk_icon_theme_get_type();
pub inline fn GTK_ICON_THEME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ICON_THEME, GtkIconTheme)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ICON_THEME, GtkIconTheme);
}
pub inline fn GTK_IS_ICON_THEME(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ICON_THEME)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ICON_THEME);
}
pub const GTK_ICON_THEME_ERROR = gtk_icon_theme_error_quark();
pub const GTK_TYPE_TOOLTIP = gtk_tooltip_get_type();
pub inline fn GTK_TOOLTIP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TOOLTIP, GtkTooltip)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TOOLTIP, GtkTooltip);
}
pub inline fn GTK_IS_TOOLTIP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TOOLTIP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TOOLTIP);
}
pub const GTK_TYPE_ICON_VIEW = gtk_icon_view_get_type();
pub inline fn GTK_ICON_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ICON_VIEW, GtkIconView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ICON_VIEW, GtkIconView);
}
pub inline fn GTK_IS_ICON_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ICON_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ICON_VIEW);
}
pub const GTK_MAX_COMPOSE_LEN = @as(c_int, 7);
pub const GTK_TYPE_IM_CONTEXT_SIMPLE = gtk_im_context_simple_get_type();
pub inline fn GTK_IM_CONTEXT_SIMPLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IM_CONTEXT_SIMPLE, GtkIMContextSimple)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IM_CONTEXT_SIMPLE, GtkIMContextSimple);
}
pub inline fn GTK_IM_CONTEXT_SIMPLE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_IM_CONTEXT_SIMPLE, GtkIMContextSimpleClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_IM_CONTEXT_SIMPLE, GtkIMContextSimpleClass);
}
pub inline fn GTK_IS_IM_CONTEXT_SIMPLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IM_CONTEXT_SIMPLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IM_CONTEXT_SIMPLE);
}
pub inline fn GTK_IS_IM_CONTEXT_SIMPLE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_IM_CONTEXT_SIMPLE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_IM_CONTEXT_SIMPLE);
}
pub inline fn GTK_IM_CONTEXT_SIMPLE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_IM_CONTEXT_SIMPLE, GtkIMContextSimpleClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_IM_CONTEXT_SIMPLE, GtkIMContextSimpleClass);
}
pub const GTK_TYPE_IM_MULTICONTEXT = gtk_im_multicontext_get_type();
pub inline fn GTK_IM_MULTICONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IM_MULTICONTEXT, GtkIMMulticontext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_IM_MULTICONTEXT, GtkIMMulticontext);
}
pub inline fn GTK_IM_MULTICONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_IM_MULTICONTEXT, GtkIMMulticontextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_IM_MULTICONTEXT, GtkIMMulticontextClass);
}
pub inline fn GTK_IS_IM_MULTICONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IM_MULTICONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_IM_MULTICONTEXT);
}
pub inline fn GTK_IS_IM_MULTICONTEXT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_IM_MULTICONTEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_IM_MULTICONTEXT);
}
pub inline fn GTK_IM_MULTICONTEXT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_IM_MULTICONTEXT, GtkIMMulticontextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_IM_MULTICONTEXT, GtkIMMulticontextClass);
}
pub const GTK_TYPE_INFO_BAR = gtk_info_bar_get_type();
pub inline fn GTK_INFO_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_INFO_BAR, GtkInfoBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_INFO_BAR, GtkInfoBar);
}
pub inline fn GTK_IS_INFO_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_INFO_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_INFO_BAR);
}
pub const GTK_TYPE_INSCRIPTION = gtk_inscription_get_type();
pub const GTK_TYPE_LABEL = gtk_label_get_type();
pub inline fn GTK_LABEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LABEL, GtkLabel)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LABEL, GtkLabel);
}
pub inline fn GTK_IS_LABEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LABEL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LABEL);
}
pub const GTK_TYPE_LEVEL_BAR = gtk_level_bar_get_type();
pub inline fn GTK_LEVEL_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LEVEL_BAR, GtkLevelBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LEVEL_BAR, GtkLevelBar);
}
pub inline fn GTK_IS_LEVEL_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LEVEL_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LEVEL_BAR);
}
pub const GTK_LEVEL_BAR_OFFSET_LOW = "low";
pub const GTK_LEVEL_BAR_OFFSET_HIGH = "high";
pub const GTK_LEVEL_BAR_OFFSET_FULL = "full";
pub const GTK_TYPE_LINK_BUTTON = gtk_link_button_get_type();
pub inline fn GTK_LINK_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LINK_BUTTON, GtkLinkButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LINK_BUTTON, GtkLinkButton);
}
pub inline fn GTK_IS_LINK_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LINK_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LINK_BUTTON);
}
pub const GTK_TYPE_LIST_BOX = gtk_list_box_get_type();
pub inline fn GTK_LIST_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LIST_BOX, GtkListBox)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LIST_BOX, GtkListBox);
}
pub inline fn GTK_IS_LIST_BOX(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LIST_BOX)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LIST_BOX);
}
pub const GTK_TYPE_LIST_BOX_ROW = gtk_list_box_row_get_type();
pub inline fn GTK_LIST_BOX_ROW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LIST_BOX_ROW, GtkListBoxRow)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_LIST_BOX_ROW, GtkListBoxRow);
}
pub inline fn GTK_LIST_BOX_ROW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_LIST_BOX_ROW, GtkListBoxRowClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_LIST_BOX_ROW, GtkListBoxRowClass);
}
pub inline fn GTK_IS_LIST_BOX_ROW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LIST_BOX_ROW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_LIST_BOX_ROW);
}
pub inline fn GTK_IS_LIST_BOX_ROW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_LIST_BOX_ROW)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_LIST_BOX_ROW);
}
pub inline fn GTK_LIST_BOX_ROW_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_LIST_BOX_ROW, GtkListBoxRowClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_LIST_BOX_ROW, GtkListBoxRowClass);
}
pub const GTK_TYPE_LIST_HEADER = gtk_list_header_get_type();
pub const GTK_TYPE_LIST_VIEW = gtk_list_view_get_type();
pub inline fn GTK_LIST_VIEW(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LIST_VIEW, GtkListView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LIST_VIEW, GtkListView);
}
pub inline fn GTK_LIST_VIEW_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_LIST_VIEW, GtkListViewClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_LIST_VIEW, GtkListViewClass);
}
pub inline fn GTK_IS_LIST_VIEW(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LIST_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LIST_VIEW);
}
pub inline fn GTK_IS_LIST_VIEW_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_LIST_VIEW)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_LIST_VIEW);
}
pub inline fn GTK_LIST_VIEW_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_LIST_VIEW, GtkListViewClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_LIST_VIEW, GtkListViewClass);
}
pub const GTK_TYPE_LOCK_BUTTON = gtk_lock_button_get_type();
pub inline fn GTK_LOCK_BUTTON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LOCK_BUTTON, GtkLockButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_LOCK_BUTTON, GtkLockButton);
}
pub inline fn GTK_IS_LOCK_BUTTON(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LOCK_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_LOCK_BUTTON);
}
pub const GTK_PRIORITY_RESIZE = G_PRIORITY_HIGH_IDLE + @as(c_int, 10);
pub const GTK_TYPE_MAP_LIST_MODEL = gtk_map_list_model_get_type();
pub const GTK_TYPE_MEDIA_STREAM = gtk_media_stream_get_type();
pub const GTK_TYPE_MEDIA_CONTROLS = gtk_media_controls_get_type();
pub const GTK_MEDIA_FILE_EXTENSION_POINT_NAME = "gtk-media-file";
pub const GTK_TYPE_MEDIA_FILE = gtk_media_file_get_type();
pub const GTK_TYPE_POPOVER = gtk_popover_get_type();
pub inline fn GTK_POPOVER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_POPOVER, GtkPopover)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_POPOVER, GtkPopover);
}
pub inline fn GTK_POPOVER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_POPOVER, GtkPopoverClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_POPOVER, GtkPopoverClass);
}
pub inline fn GTK_IS_POPOVER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_POPOVER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_POPOVER);
}
pub inline fn GTK_IS_POPOVER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_POPOVER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_POPOVER);
}
pub inline fn GTK_POPOVER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_POPOVER, GtkPopoverClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_POPOVER, GtkPopoverClass);
}
pub const GTK_TYPE_MENU_BUTTON = gtk_menu_button_get_type();
pub inline fn GTK_MENU_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_MENU_BUTTON, GtkMenuButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_MENU_BUTTON, GtkMenuButton);
}
pub inline fn GTK_IS_MENU_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_MENU_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_MENU_BUTTON);
}
pub const GTK_TYPE_MESSAGE_DIALOG = gtk_message_dialog_get_type();
pub inline fn GTK_MESSAGE_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_MESSAGE_DIALOG, GtkMessageDialog)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_MESSAGE_DIALOG, GtkMessageDialog);
}
pub inline fn GTK_IS_MESSAGE_DIALOG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_MESSAGE_DIALOG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_MESSAGE_DIALOG);
}
pub const GTK_TYPE_MOUNT_OPERATION = gtk_mount_operation_get_type();
pub inline fn GTK_MOUNT_OPERATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_MOUNT_OPERATION, GtkMountOperation)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_MOUNT_OPERATION, GtkMountOperation);
}
pub inline fn GTK_MOUNT_OPERATION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_MOUNT_OPERATION, GtkMountOperationClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_MOUNT_OPERATION, GtkMountOperationClass);
}
pub inline fn GTK_IS_MOUNT_OPERATION(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_MOUNT_OPERATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_MOUNT_OPERATION);
}
pub inline fn GTK_IS_MOUNT_OPERATION_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_MOUNT_OPERATION)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_MOUNT_OPERATION);
}
pub inline fn GTK_MOUNT_OPERATION_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_MOUNT_OPERATION, GtkMountOperationClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_MOUNT_OPERATION, GtkMountOperationClass);
}
pub const GTK_TYPE_MULTI_FILTER = gtk_multi_filter_get_type();
pub const GTK_TYPE_ANY_FILTER = gtk_any_filter_get_type();
pub const GTK_TYPE_EVERY_FILTER = gtk_every_filter_get_type();
pub const GTK_TYPE_MULTI_SELECTION = gtk_multi_selection_get_type();
pub const GTK_TYPE_MULTI_SORTER = gtk_multi_sorter_get_type();
pub const GTK_TYPE_NATIVE = gtk_native_get_type();
pub const GTK_TYPE_NO_SELECTION = gtk_no_selection_get_type();
pub const GTK_TYPE_NOTEBOOK = gtk_notebook_get_type();
pub inline fn GTK_NOTEBOOK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_NOTEBOOK, GtkNotebook)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_NOTEBOOK, GtkNotebook);
}
pub inline fn GTK_IS_NOTEBOOK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_NOTEBOOK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_NOTEBOOK);
}
pub const GTK_TYPE_NOTEBOOK_PAGE = gtk_notebook_page_get_type();
pub inline fn GTK_NOTEBOOK_PAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_NOTEBOOK_PAGE, GtkNotebookPage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_NOTEBOOK_PAGE, GtkNotebookPage);
}
pub inline fn GTK_IS_NOTEBOOK_PAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_NOTEBOOK_PAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_NOTEBOOK_PAGE);
}
pub const GTK_TYPE_NUMERIC_SORTER = gtk_numeric_sorter_get_type();
pub const GTK_TYPE_ORIENTABLE = gtk_orientable_get_type();
pub inline fn GTK_ORIENTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ORIENTABLE, GtkOrientable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_ORIENTABLE, GtkOrientable);
}
pub inline fn GTK_IS_ORIENTABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ORIENTABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_ORIENTABLE);
}
pub inline fn GTK_ORIENTABLE_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_ORIENTABLE, GtkOrientableIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_ORIENTABLE, GtkOrientableIface);
}
pub const GTK_TYPE_OVERLAY = gtk_overlay_get_type();
pub inline fn GTK_OVERLAY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_OVERLAY, GtkOverlay)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_OVERLAY, GtkOverlay);
}
pub inline fn GTK_IS_OVERLAY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_OVERLAY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_OVERLAY);
}
pub const GTK_TYPE_OVERLAY_LAYOUT = gtk_overlay_layout_get_type();
pub const GTK_TYPE_OVERLAY_LAYOUT_CHILD = gtk_overlay_layout_child_get_type();
pub const GTK_TYPE_PAD_CONTROLLER = gtk_pad_controller_get_type();
pub inline fn GTK_PAD_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_PAD_CONTROLLER, GtkPadController)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_PAD_CONTROLLER, GtkPadController);
}
pub inline fn GTK_PAD_CONTROLLER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_PAD_CONTROLLER, GtkPadControllerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_PAD_CONTROLLER, GtkPadControllerClass);
}
pub inline fn GTK_IS_PAD_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_PAD_CONTROLLER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_PAD_CONTROLLER);
}
pub inline fn GTK_IS_PAD_CONTROLLER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_PAD_CONTROLLER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_PAD_CONTROLLER);
}
pub inline fn GTK_PAD_CONTROLLER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_PAD_CONTROLLER, GtkPadControllerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_PAD_CONTROLLER, GtkPadControllerClass);
}
pub const GTK_TYPE_PAPER_SIZE = gtk_paper_size_get_type();
pub const GTK_PAPER_NAME_A3 = "iso_a3";
pub const GTK_PAPER_NAME_A4 = "iso_a4";
pub const GTK_PAPER_NAME_A5 = "iso_a5";
pub const GTK_PAPER_NAME_B5 = "iso_b5";
pub const GTK_PAPER_NAME_LETTER = "na_letter";
pub const GTK_PAPER_NAME_EXECUTIVE = "na_executive";
pub const GTK_PAPER_NAME_LEGAL = "na_legal";
pub const GTK_TYPE_PAGE_SETUP = gtk_page_setup_get_type();
pub inline fn GTK_PAGE_SETUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PAGE_SETUP, GtkPageSetup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PAGE_SETUP, GtkPageSetup);
}
pub inline fn GTK_IS_PAGE_SETUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PAGE_SETUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PAGE_SETUP);
}
pub const GTK_TYPE_PANED = gtk_paned_get_type();
pub inline fn GTK_PANED(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PANED, GtkPaned)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PANED, GtkPaned);
}
pub inline fn GTK_IS_PANED(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PANED)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PANED);
}
pub const GTK_TYPE_PASSWORD_ENTRY = gtk_password_entry_get_type();
pub inline fn GTK_PASSWORD_ENTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PASSWORD_ENTRY, GtkPasswordEntry)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PASSWORD_ENTRY, GtkPasswordEntry);
}
pub inline fn GTK_IS_PASSWORD_ENTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PASSWORD_ENTRY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PASSWORD_ENTRY);
}
pub const GTK_TYPE_PASSWORD_ENTRY_BUFFER = gtk_password_entry_buffer_get_type();
pub const GTK_TYPE_PICTURE = gtk_picture_get_type();
pub const GTK_TYPE_POPOVER_MENU = gtk_popover_menu_get_type();
pub inline fn GTK_POPOVER_MENU(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_POPOVER_MENU, GtkPopoverMenu)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_POPOVER_MENU, GtkPopoverMenu);
}
pub inline fn GTK_IS_POPOVER_MENU(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_POPOVER_MENU)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_POPOVER_MENU);
}
pub const GTK_TYPE_POPOVER_MENU_BAR = gtk_popover_menu_bar_get_type();
pub inline fn GTK_POPOVER_MENU_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_POPOVER_MENU_BAR, GtkPopoverMenuBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_POPOVER_MENU_BAR, GtkPopoverMenuBar);
}
pub inline fn GTK_IS_POPOVER_MENU_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_POPOVER_MENU_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_POPOVER_MENU_BAR);
}
pub const GTK_TYPE_PRINT_CONTEXT = gtk_print_context_get_type();
pub inline fn GTK_PRINT_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_CONTEXT, GtkPrintContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_CONTEXT, GtkPrintContext);
}
pub inline fn GTK_IS_PRINT_CONTEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_CONTEXT);
}
pub const GTK_TYPE_PRINT_SETTINGS = gtk_print_settings_get_type();
pub inline fn GTK_PRINT_SETTINGS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_SETTINGS, GtkPrintSettings)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_SETTINGS, GtkPrintSettings);
}
pub inline fn GTK_IS_PRINT_SETTINGS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_SETTINGS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_SETTINGS);
}
pub const GTK_PRINT_SETTINGS_PRINTER = "printer";
pub const GTK_PRINT_SETTINGS_ORIENTATION = "orientation";
pub const GTK_PRINT_SETTINGS_PAPER_FORMAT = "paper-format";
pub const GTK_PRINT_SETTINGS_PAPER_WIDTH = "paper-width";
pub const GTK_PRINT_SETTINGS_PAPER_HEIGHT = "paper-height";
pub const GTK_PRINT_SETTINGS_N_COPIES = "n-copies";
pub const GTK_PRINT_SETTINGS_DEFAULT_SOURCE = "default-source";
pub const GTK_PRINT_SETTINGS_QUALITY = "quality";
pub const GTK_PRINT_SETTINGS_RESOLUTION = "resolution";
pub const GTK_PRINT_SETTINGS_USE_COLOR = "use-color";
pub const GTK_PRINT_SETTINGS_DUPLEX = "duplex";
pub const GTK_PRINT_SETTINGS_COLLATE = "collate";
pub const GTK_PRINT_SETTINGS_REVERSE = "reverse";
pub const GTK_PRINT_SETTINGS_MEDIA_TYPE = "media-type";
pub const GTK_PRINT_SETTINGS_DITHER = "dither";
pub const GTK_PRINT_SETTINGS_SCALE = "scale";
pub const GTK_PRINT_SETTINGS_PRINT_PAGES = "print-pages";
pub const GTK_PRINT_SETTINGS_PAGE_RANGES = "page-ranges";
pub const GTK_PRINT_SETTINGS_PAGE_SET = "page-set";
pub const GTK_PRINT_SETTINGS_FINISHINGS = "finishings";
pub const GTK_PRINT_SETTINGS_NUMBER_UP = "number-up";
pub const GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT = "number-up-layout";
pub const GTK_PRINT_SETTINGS_OUTPUT_BIN = "output-bin";
pub const GTK_PRINT_SETTINGS_RESOLUTION_X = "resolution-x";
pub const GTK_PRINT_SETTINGS_RESOLUTION_Y = "resolution-y";
pub const GTK_PRINT_SETTINGS_PRINTER_LPI = "printer-lpi";
pub const GTK_PRINT_SETTINGS_OUTPUT_DIR = "output-dir";
pub const GTK_PRINT_SETTINGS_OUTPUT_BASENAME = "output-basename";
pub const GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT = "output-file-format";
pub const GTK_PRINT_SETTINGS_OUTPUT_URI = "output-uri";
pub const GTK_PRINT_SETTINGS_WIN32_DRIVER_VERSION = "win32-driver-version";
pub const GTK_PRINT_SETTINGS_WIN32_DRIVER_EXTRA = "win32-driver-extra";
pub const GTK_TYPE_PRINT_OPERATION_PREVIEW = gtk_print_operation_preview_get_type();
pub inline fn GTK_PRINT_OPERATION_PREVIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_OPERATION_PREVIEW, GtkPrintOperationPreview)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_OPERATION_PREVIEW, GtkPrintOperationPreview);
}
pub inline fn GTK_IS_PRINT_OPERATION_PREVIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_OPERATION_PREVIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_OPERATION_PREVIEW);
}
pub inline fn GTK_PRINT_OPERATION_PREVIEW_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_PRINT_OPERATION_PREVIEW, GtkPrintOperationPreviewIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_PRINT_OPERATION_PREVIEW, GtkPrintOperationPreviewIface);
}
pub const GTK_TYPE_PRINT_OPERATION = gtk_print_operation_get_type();
pub inline fn GTK_PRINT_OPERATION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_OPERATION, GtkPrintOperation)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PRINT_OPERATION, GtkPrintOperation);
}
pub inline fn GTK_PRINT_OPERATION_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_PRINT_OPERATION, GtkPrintOperationClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_PRINT_OPERATION, GtkPrintOperationClass);
}
pub inline fn GTK_IS_PRINT_OPERATION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_OPERATION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PRINT_OPERATION);
}
pub inline fn GTK_IS_PRINT_OPERATION_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_PRINT_OPERATION)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_PRINT_OPERATION);
}
pub inline fn GTK_PRINT_OPERATION_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_PRINT_OPERATION, GtkPrintOperationClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_PRINT_OPERATION, GtkPrintOperationClass);
}
pub const GTK_PRINT_ERROR = gtk_print_error_quark();
pub const GTK_TYPE_PROGRESS_BAR = gtk_progress_bar_get_type();
pub inline fn GTK_PROGRESS_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PROGRESS_BAR, GtkProgressBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_PROGRESS_BAR, GtkProgressBar);
}
pub inline fn GTK_IS_PROGRESS_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PROGRESS_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_PROGRESS_BAR);
}
pub const GTK_TYPE_RANGE = gtk_range_get_type();
pub inline fn GTK_RANGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_RANGE, GtkRange)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_RANGE, GtkRange);
}
pub inline fn GTK_RANGE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_RANGE, GtkRangeClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_RANGE, GtkRangeClass);
}
pub inline fn GTK_IS_RANGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_RANGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_RANGE);
}
pub inline fn GTK_IS_RANGE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_RANGE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_RANGE);
}
pub inline fn GTK_RANGE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_RANGE, GtkRangeClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_RANGE, GtkRangeClass);
}
pub const GTK_TYPE_RECENT_INFO = gtk_recent_info_get_type();
pub const GTK_TYPE_RECENT_MANAGER = gtk_recent_manager_get_type();
pub inline fn GTK_RECENT_MANAGER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_RECENT_MANAGER, GtkRecentManager)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_RECENT_MANAGER, GtkRecentManager);
}
pub inline fn GTK_IS_RECENT_MANAGER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_RECENT_MANAGER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_RECENT_MANAGER);
}
pub inline fn GTK_RECENT_MANAGER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_RECENT_MANAGER, GtkRecentManagerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_RECENT_MANAGER, GtkRecentManagerClass);
}
pub inline fn GTK_IS_RECENT_MANAGER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_RECENT_MANAGER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_RECENT_MANAGER);
}
pub inline fn GTK_RECENT_MANAGER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_RECENT_MANAGER, GtkRecentManagerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_RECENT_MANAGER, GtkRecentManagerClass);
}
pub const GTK_RECENT_MANAGER_ERROR = gtk_recent_manager_error_quark();
pub const GTK_TYPE_SNAPSHOT = gtk_snapshot_get_type();
pub inline fn GTK_SNAPSHOT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SNAPSHOT, GtkSnapshot)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SNAPSHOT, GtkSnapshot);
}
pub inline fn GTK_IS_SNAPSHOT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SNAPSHOT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SNAPSHOT);
}
pub const GTK_TYPE_REVEALER = gtk_revealer_get_type();
pub inline fn GTK_REVEALER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_REVEALER, GtkRevealer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_REVEALER, GtkRevealer);
}
pub inline fn GTK_IS_REVEALER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_REVEALER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_REVEALER);
}
pub const GTK_TYPE_ROOT = gtk_root_get_type();
pub const GTK_TYPE_SCALE = gtk_scale_get_type();
pub inline fn GTK_SCALE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCALE, GtkScale)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCALE, GtkScale);
}
pub inline fn GTK_SCALE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_SCALE, GtkScaleClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_SCALE, GtkScaleClass);
}
pub inline fn GTK_IS_SCALE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCALE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCALE);
}
pub inline fn GTK_IS_SCALE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_SCALE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_SCALE);
}
pub inline fn GTK_SCALE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_SCALE, GtkScaleClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_SCALE, GtkScaleClass);
}
pub const GTK_TYPE_SCALE_BUTTON = gtk_scale_button_get_type();
pub inline fn GTK_SCALE_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCALE_BUTTON, GtkScaleButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCALE_BUTTON, GtkScaleButton);
}
pub inline fn GTK_SCALE_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_SCALE_BUTTON, GtkScaleButtonClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_SCALE_BUTTON, GtkScaleButtonClass);
}
pub inline fn GTK_IS_SCALE_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCALE_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCALE_BUTTON);
}
pub inline fn GTK_IS_SCALE_BUTTON_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_SCALE_BUTTON)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_SCALE_BUTTON);
}
pub inline fn GTK_SCALE_BUTTON_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_SCALE_BUTTON, GtkScaleButtonClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_SCALE_BUTTON, GtkScaleButtonClass);
}
pub const GTK_TYPE_SCROLLABLE = gtk_scrollable_get_type();
pub inline fn GTK_SCROLLABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCROLLABLE, GtkScrollable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCROLLABLE, GtkScrollable);
}
pub inline fn GTK_IS_SCROLLABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCROLLABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCROLLABLE);
}
pub inline fn GTK_SCROLLABLE_GET_IFACE(inst: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_SCROLLABLE, GtkScrollableInterface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(inst, GTK_TYPE_SCROLLABLE, GtkScrollableInterface);
}
pub const GTK_TYPE_SCROLLBAR = gtk_scrollbar_get_type();
pub inline fn GTK_SCROLLBAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCROLLBAR, GtkScrollbar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCROLLBAR, GtkScrollbar);
}
pub inline fn GTK_IS_SCROLLBAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCROLLBAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCROLLBAR);
}
pub const GTK_TYPE_SCROLL_INFO = gtk_scroll_info_get_type();
pub const GTK_TYPE_SCROLLED_WINDOW = gtk_scrolled_window_get_type();
pub inline fn GTK_SCROLLED_WINDOW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCROLLED_WINDOW, GtkScrolledWindow)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SCROLLED_WINDOW, GtkScrolledWindow);
}
pub inline fn GTK_IS_SCROLLED_WINDOW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCROLLED_WINDOW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SCROLLED_WINDOW);
}
pub const GTK_TYPE_SEARCH_BAR = gtk_search_bar_get_type();
pub inline fn GTK_SEARCH_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SEARCH_BAR, GtkSearchBar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SEARCH_BAR, GtkSearchBar);
}
pub inline fn GTK_IS_SEARCH_BAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SEARCH_BAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SEARCH_BAR);
}
pub const GTK_TYPE_SEARCH_ENTRY = gtk_search_entry_get_type();
pub inline fn GTK_SEARCH_ENTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SEARCH_ENTRY, GtkSearchEntry)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SEARCH_ENTRY, GtkSearchEntry);
}
pub inline fn GTK_IS_SEARCH_ENTRY(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SEARCH_ENTRY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SEARCH_ENTRY);
}
pub const GTK_TYPE_SECTION_MODEL = gtk_section_model_get_type();
pub const GTK_TYPE_SELECTION_FILTER_MODEL = gtk_selection_filter_model_get_type();
pub const GTK_TYPE_SEPARATOR = gtk_separator_get_type();
pub inline fn GTK_SEPARATOR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SEPARATOR, GtkSeparator)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SEPARATOR, GtkSeparator);
}
pub inline fn GTK_IS_SEPARATOR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SEPARATOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SEPARATOR);
}
pub const GTK_TYPE_SETTINGS = gtk_settings_get_type();
pub inline fn GTK_SETTINGS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SETTINGS, GtkSettings)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SETTINGS, GtkSettings);
}
pub inline fn GTK_IS_SETTINGS(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SETTINGS)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SETTINGS);
}
pub const GTK_TYPE_SHORTCUT_CONTROLLER = gtk_shortcut_controller_get_type();
pub inline fn GTK_SHORTCUT_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_SHORTCUT_CONTROLLER, GtkShortcutController)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_SHORTCUT_CONTROLLER, GtkShortcutController);
}
pub inline fn GTK_SHORTCUT_CONTROLLER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_SHORTCUT_CONTROLLER, GtkShortcutControllerClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_SHORTCUT_CONTROLLER, GtkShortcutControllerClass);
}
pub inline fn GTK_IS_SHORTCUT_CONTROLLER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_SHORTCUT_CONTROLLER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_SHORTCUT_CONTROLLER);
}
pub inline fn GTK_IS_SHORTCUT_CONTROLLER_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_SHORTCUT_CONTROLLER)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_SHORTCUT_CONTROLLER);
}
pub inline fn GTK_SHORTCUT_CONTROLLER_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_SHORTCUT_CONTROLLER, GtkShortcutControllerClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_SHORTCUT_CONTROLLER, GtkShortcutControllerClass);
}
pub const GTK_TYPE_SHORTCUT_LABEL = gtk_shortcut_label_get_type();
pub inline fn GTK_SHORTCUT_LABEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUT_LABEL, GtkShortcutLabel)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUT_LABEL, GtkShortcutLabel);
}
pub inline fn GTK_IS_SHORTCUT_LABEL(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUT_LABEL)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUT_LABEL);
}
pub const GTK_TYPE_SHORTCUT_MANAGER = gtk_shortcut_manager_get_type();
pub const GTK_TYPE_SHORTCUTS_GROUP = gtk_shortcuts_group_get_type();
pub inline fn GTK_SHORTCUTS_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_GROUP, GtkShortcutsGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_GROUP, GtkShortcutsGroup);
}
pub inline fn GTK_IS_SHORTCUTS_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_GROUP);
}
pub const GTK_TYPE_SHORTCUTS_SECTION = gtk_shortcuts_section_get_type();
pub inline fn GTK_SHORTCUTS_SECTION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_SECTION, GtkShortcutsSection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_SECTION, GtkShortcutsSection);
}
pub inline fn GTK_IS_SHORTCUTS_SECTION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_SECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_SECTION);
}
pub const GTK_TYPE_SHORTCUTS_SHORTCUT = gtk_shortcuts_shortcut_get_type();
pub inline fn GTK_SHORTCUTS_SHORTCUT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_SHORTCUT, GtkShortcutsShortcut)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SHORTCUTS_SHORTCUT, GtkShortcutsShortcut);
}
pub inline fn GTK_IS_SHORTCUTS_SHORTCUT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_SHORTCUT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SHORTCUTS_SHORTCUT);
}
pub const GTK_TYPE_SHORTCUT_TRIGGER = gtk_shortcut_trigger_get_type();
pub const GTK_TYPE_NEVER_TRIGGER = gtk_never_trigger_get_type();
pub const GTK_TYPE_KEYVAL_TRIGGER = gtk_keyval_trigger_get_type();
pub const GTK_TYPE_MNEMONIC_TRIGGER = gtk_mnemonic_trigger_get_type();
pub const GTK_TYPE_ALTERNATIVE_TRIGGER = gtk_alternative_trigger_get_type();
pub const GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY = gtk_signal_list_item_factory_get_type();
pub inline fn GTK_SIGNAL_LIST_ITEM_FACTORY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY, GtkSignalListItemFactory)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY, GtkSignalListItemFactory);
}
pub inline fn GTK_SIGNAL_LIST_ITEM_FACTORY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY, GtkSignalListItemFactoryClass)) {
    return G_TYPE_CHECK_CLASS_CAST(k, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY, GtkSignalListItemFactoryClass);
}
pub inline fn GTK_IS_SIGNAL_LIST_ITEM_FACTORY(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY);
}
pub inline fn GTK_IS_SIGNAL_LIST_ITEM_FACTORY_CLASS(k: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY)) {
    return G_TYPE_CHECK_CLASS_TYPE(k, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY);
}
pub inline fn GTK_SIGNAL_LIST_ITEM_FACTORY_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY, GtkSignalListItemFactoryClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_SIGNAL_LIST_ITEM_FACTORY, GtkSignalListItemFactoryClass);
}
pub const GTK_TYPE_SINGLE_SELECTION = gtk_single_selection_get_type();
pub const GTK_TYPE_SLICE_LIST_MODEL = gtk_slice_list_model_get_type();
pub const GTK_TYPE_STACK = gtk_stack_get_type();
pub inline fn GTK_STACK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK, GtkStack)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK, GtkStack);
}
pub inline fn GTK_IS_STACK(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK);
}
pub const GTK_TYPE_STACK_PAGE = gtk_stack_page_get_type();
pub inline fn GTK_STACK_PAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK_PAGE, GtkStackPage)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK_PAGE, GtkStackPage);
}
pub inline fn GTK_IS_STACK_PAGE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK_PAGE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK_PAGE);
}
pub const GTK_TYPE_STACK_SIDEBAR = gtk_stack_sidebar_get_type();
pub inline fn GTK_STACK_SIDEBAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK_SIDEBAR, GtkStackSidebar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK_SIDEBAR, GtkStackSidebar);
}
pub inline fn GTK_IS_STACK_SIDEBAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK_SIDEBAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK_SIDEBAR);
}
pub const GTK_TYPE_SIZE_GROUP = gtk_size_group_get_type();
pub inline fn GTK_SIZE_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SIZE_GROUP, GtkSizeGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SIZE_GROUP, GtkSizeGroup);
}
pub inline fn GTK_IS_SIZE_GROUP(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SIZE_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SIZE_GROUP);
}
pub const GTK_TYPE_SPIN_BUTTON = gtk_spin_button_get_type();
pub inline fn GTK_SPIN_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SPIN_BUTTON, GtkSpinButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SPIN_BUTTON, GtkSpinButton);
}
pub inline fn GTK_IS_SPIN_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SPIN_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SPIN_BUTTON);
}
pub const GTK_INPUT_ERROR = -@as(c_int, 1);
pub const GTK_TYPE_SPINNER = gtk_spinner_get_type();
pub inline fn GTK_SPINNER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SPINNER, GtkSpinner)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SPINNER, GtkSpinner);
}
pub inline fn GTK_IS_SPINNER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SPINNER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SPINNER);
}
pub const GTK_TYPE_STACK_SWITCHER = gtk_stack_switcher_get_type();
pub inline fn GTK_STACK_SWITCHER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK_SWITCHER, GtkStackSwitcher)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STACK_SWITCHER, GtkStackSwitcher);
}
pub inline fn GTK_IS_STACK_SWITCHER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK_SWITCHER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STACK_SWITCHER);
}
pub const GTK_TYPE_STATUSBAR = gtk_statusbar_get_type();
pub inline fn GTK_STATUSBAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STATUSBAR, GtkStatusbar)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_STATUSBAR, GtkStatusbar);
}
pub inline fn GTK_IS_STATUSBAR(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STATUSBAR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_STATUSBAR);
}
pub const GTK_TYPE_STRING_OBJECT = gtk_string_object_get_type();
pub const GTK_TYPE_STRING_LIST = gtk_string_list_get_type();
pub const GTK_TYPE_STRING_SORTER = gtk_string_sorter_get_type();
pub const GTK_TYPE_STYLE_PROVIDER = gtk_style_provider_get_type();
pub inline fn GTK_STYLE_PROVIDER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_STYLE_PROVIDER, GtkStyleProvider)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_STYLE_PROVIDER, GtkStyleProvider);
}
pub inline fn GTK_IS_STYLE_PROVIDER(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_STYLE_PROVIDER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_STYLE_PROVIDER);
}
pub const GTK_STYLE_PROVIDER_PRIORITY_FALLBACK = @as(c_int, 1);
pub const GTK_STYLE_PROVIDER_PRIORITY_THEME = @as(c_int, 200);
pub const GTK_STYLE_PROVIDER_PRIORITY_SETTINGS = @as(c_int, 400);
pub const GTK_STYLE_PROVIDER_PRIORITY_APPLICATION = @as(c_int, 600);
pub const GTK_STYLE_PROVIDER_PRIORITY_USER = @as(c_int, 800);
pub const GTK_TYPE_STYLE_CONTEXT = gtk_style_context_get_type();
pub inline fn GTK_STYLE_CONTEXT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_STYLE_CONTEXT, GtkStyleContext)) {
    return G_TYPE_CHECK_INSTANCE_CAST(o, GTK_TYPE_STYLE_CONTEXT, GtkStyleContext);
}
pub inline fn GTK_STYLE_CONTEXT_CLASS(c: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(c, GTK_TYPE_STYLE_CONTEXT, GtkStyleContextClass)) {
    return G_TYPE_CHECK_CLASS_CAST(c, GTK_TYPE_STYLE_CONTEXT, GtkStyleContextClass);
}
pub inline fn GTK_IS_STYLE_CONTEXT(o: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_STYLE_CONTEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(o, GTK_TYPE_STYLE_CONTEXT);
}
pub inline fn GTK_IS_STYLE_CONTEXT_CLASS(c: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(c, GTK_TYPE_STYLE_CONTEXT)) {
    return G_TYPE_CHECK_CLASS_TYPE(c, GTK_TYPE_STYLE_CONTEXT);
}
pub inline fn GTK_STYLE_CONTEXT_GET_CLASS(o: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_STYLE_CONTEXT, GtkStyleContextClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(o, GTK_TYPE_STYLE_CONTEXT, GtkStyleContextClass);
}
pub const GTK_TYPE_SWITCH = gtk_switch_get_type();
pub inline fn GTK_SWITCH(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SWITCH, GtkSwitch)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_SWITCH, GtkSwitch);
}
pub inline fn GTK_IS_SWITCH(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SWITCH)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_SWITCH);
}
pub const GTK_TYPE_SYMBOLIC_PAINTABLE = gtk_symbolic_paintable_get_type();
pub const GTK_TYPE_TEXT = gtk_text_get_type();
pub inline fn GTK_TEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT, GtkText)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT, GtkText);
}
pub inline fn GTK_IS_TEXT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT);
}
pub const GTK_TYPE_TEXT_TAG = gtk_text_tag_get_type();
pub inline fn GTK_TEXT_TAG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_TAG, GtkTextTag)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_TAG, GtkTextTag);
}
pub inline fn GTK_TEXT_TAG_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_TAG, GtkTextTagClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_TAG, GtkTextTagClass);
}
pub inline fn GTK_IS_TEXT_TAG(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_TAG)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_TAG);
}
pub inline fn GTK_IS_TEXT_TAG_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_TAG)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_TAG);
}
pub inline fn GTK_TEXT_TAG_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_TAG, GtkTextTagClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_TAG, GtkTextTagClass);
}
pub const GTK_TYPE_TEXT_TAG_TABLE = gtk_text_tag_table_get_type();
pub inline fn GTK_TEXT_TAG_TABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_TAG_TABLE, GtkTextTagTable)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_TAG_TABLE, GtkTextTagTable);
}
pub inline fn GTK_IS_TEXT_TAG_TABLE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_TAG_TABLE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_TAG_TABLE);
}
pub const GTK_TYPE_TEXT_CHILD_ANCHOR = gtk_text_child_anchor_get_type();
pub inline fn GTK_TEXT_CHILD_ANCHOR(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_TEXT_CHILD_ANCHOR, GtkTextChildAnchor)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_TEXT_CHILD_ANCHOR, GtkTextChildAnchor);
}
pub inline fn GTK_TEXT_CHILD_ANCHOR_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_CHILD_ANCHOR, GtkTextChildAnchorClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_CHILD_ANCHOR, GtkTextChildAnchorClass);
}
pub inline fn GTK_IS_TEXT_CHILD_ANCHOR(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_TEXT_CHILD_ANCHOR)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_TEXT_CHILD_ANCHOR);
}
pub inline fn GTK_IS_TEXT_CHILD_ANCHOR_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_CHILD_ANCHOR)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_CHILD_ANCHOR);
}
pub inline fn GTK_TEXT_CHILD_ANCHOR_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_CHILD_ANCHOR, GtkTextChildAnchorClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_CHILD_ANCHOR, GtkTextChildAnchorClass);
}
pub const GTK_TYPE_TEXT_ITER = gtk_text_iter_get_type();
pub const GTK_TYPE_TEXT_MARK = gtk_text_mark_get_type();
pub inline fn GTK_TEXT_MARK(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_TEXT_MARK, GtkTextMark)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_TEXT_MARK, GtkTextMark);
}
pub inline fn GTK_TEXT_MARK_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_MARK, GtkTextMarkClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_MARK, GtkTextMarkClass);
}
pub inline fn GTK_IS_TEXT_MARK(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_TEXT_MARK)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_TEXT_MARK);
}
pub inline fn GTK_IS_TEXT_MARK_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_MARK)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_MARK);
}
pub inline fn GTK_TEXT_MARK_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_MARK, GtkTextMarkClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_MARK, GtkTextMarkClass);
}
pub const GTK_TYPE_TEXT_BUFFER = gtk_text_buffer_get_type();
pub inline fn GTK_TEXT_BUFFER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_BUFFER, GtkTextBuffer)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_BUFFER, GtkTextBuffer);
}
pub inline fn GTK_TEXT_BUFFER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_BUFFER, GtkTextBufferClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_BUFFER, GtkTextBufferClass);
}
pub inline fn GTK_IS_TEXT_BUFFER(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_BUFFER)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_BUFFER);
}
pub inline fn GTK_IS_TEXT_BUFFER_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_BUFFER)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_BUFFER);
}
pub inline fn GTK_TEXT_BUFFER_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_BUFFER, GtkTextBufferClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_BUFFER, GtkTextBufferClass);
}
pub const GTK_TYPE_TEXT_VIEW = gtk_text_view_get_type();
pub inline fn GTK_TEXT_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_VIEW, GtkTextView)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TEXT_VIEW, GtkTextView);
}
pub inline fn GTK_TEXT_VIEW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_VIEW, GtkTextViewClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TEXT_VIEW, GtkTextViewClass);
}
pub inline fn GTK_IS_TEXT_VIEW(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_VIEW)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TEXT_VIEW);
}
pub inline fn GTK_IS_TEXT_VIEW_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_VIEW)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TEXT_VIEW);
}
pub inline fn GTK_TEXT_VIEW_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_VIEW, GtkTextViewClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TEXT_VIEW, GtkTextViewClass);
}
pub const GTK_TEXT_VIEW_PRIORITY_VALIDATE = GDK_PRIORITY_REDRAW + @as(c_int, 5);
pub const GTK_TYPE_TREE_ROW_DATA = gtk_tree_row_data_get_type();
pub const GTK_TYPE_TREE_DRAG_SOURCE = gtk_tree_drag_source_get_type();
pub inline fn GTK_TREE_DRAG_SOURCE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_DRAG_SOURCE, GtkTreeDragSource)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_DRAG_SOURCE, GtkTreeDragSource);
}
pub inline fn GTK_IS_TREE_DRAG_SOURCE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_DRAG_SOURCE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_DRAG_SOURCE);
}
pub inline fn GTK_TREE_DRAG_SOURCE_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_DRAG_SOURCE, GtkTreeDragSourceIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_DRAG_SOURCE, GtkTreeDragSourceIface);
}
pub const GTK_TYPE_TREE_DRAG_DEST = gtk_tree_drag_dest_get_type();
pub inline fn GTK_TREE_DRAG_DEST(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_DRAG_DEST, GtkTreeDragDest)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_DRAG_DEST, GtkTreeDragDest);
}
pub inline fn GTK_IS_TREE_DRAG_DEST(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_DRAG_DEST)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_DRAG_DEST);
}
pub inline fn GTK_TREE_DRAG_DEST_GET_IFACE(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_DRAG_DEST, GtkTreeDragDestIface)) {
    return G_TYPE_INSTANCE_GET_INTERFACE(obj, GTK_TYPE_TREE_DRAG_DEST, GtkTreeDragDestIface);
}
pub const GTK_TYPE_TREE_LIST_MODEL = gtk_tree_list_model_get_type();
pub const GTK_TYPE_TREE_LIST_ROW = gtk_tree_list_row_get_type();
pub const GTK_TYPE_TREE_EXPANDER = gtk_tree_expander_get_type();
pub const GTK_TYPE_TREE_LIST_ROW_SORTER = gtk_tree_list_row_sorter_get_type();
pub const GTK_TYPE_TREE_MODEL_SORT = gtk_tree_model_sort_get_type();
pub inline fn GTK_TREE_MODEL_SORT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_MODEL_SORT, GtkTreeModelSort)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_MODEL_SORT, GtkTreeModelSort);
}
pub inline fn GTK_TREE_MODEL_SORT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TREE_MODEL_SORT, GtkTreeModelSortClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TREE_MODEL_SORT, GtkTreeModelSortClass);
}
pub inline fn GTK_IS_TREE_MODEL_SORT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_MODEL_SORT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_MODEL_SORT);
}
pub inline fn GTK_IS_TREE_MODEL_SORT_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TREE_MODEL_SORT)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TREE_MODEL_SORT);
}
pub inline fn GTK_TREE_MODEL_SORT_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_MODEL_SORT, GtkTreeModelSortClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_MODEL_SORT, GtkTreeModelSortClass);
}
pub const GTK_TYPE_TREE_SELECTION = gtk_tree_selection_get_type();
pub inline fn GTK_TREE_SELECTION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_SELECTION, GtkTreeSelection)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_SELECTION, GtkTreeSelection);
}
pub inline fn GTK_IS_TREE_SELECTION(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_SELECTION)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_SELECTION);
}
pub const GTK_TYPE_TREE_STORE = gtk_tree_store_get_type();
pub inline fn GTK_TREE_STORE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_STORE, GtkTreeStore)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_TREE_STORE, GtkTreeStore);
}
pub inline fn GTK_TREE_STORE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TREE_STORE, GtkTreeStoreClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_TREE_STORE, GtkTreeStoreClass);
}
pub inline fn GTK_IS_TREE_STORE(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_STORE)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_TREE_STORE);
}
pub inline fn GTK_IS_TREE_STORE_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TREE_STORE)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_TREE_STORE);
}
pub inline fn GTK_TREE_STORE_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_STORE, GtkTreeStoreClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_TREE_STORE, GtkTreeStoreClass);
}
pub const GTK_TYPE_URI_LAUNCHER = gtk_uri_launcher_get_type();
pub const __GTK_VERSION_H__ = "";
pub const GTK_MAJOR_VERSION = @as(c_int, 4);
pub const GTK_MINOR_VERSION = @as(c_int, 12);
pub const GTK_MICRO_VERSION = @as(c_int, 4);
pub const GTK_BINARY_AGE = @as(c_int, 1204);
pub const GTK_INTERFACE_AGE = @as(c_int, 4);
pub inline fn GTK_CHECK_VERSION(major: anytype, minor: anytype, micro: anytype) @TypeOf(((GTK_MAJOR_VERSION > major) or ((GTK_MAJOR_VERSION == major) and (GTK_MINOR_VERSION > minor))) or (((GTK_MAJOR_VERSION == major) and (GTK_MINOR_VERSION == minor)) and (GTK_MICRO_VERSION >= micro))) {
    return ((GTK_MAJOR_VERSION > major) or ((GTK_MAJOR_VERSION == major) and (GTK_MINOR_VERSION > minor))) or (((GTK_MAJOR_VERSION == major) and (GTK_MINOR_VERSION == minor)) and (GTK_MICRO_VERSION >= micro));
}
pub const GTK_TYPE_VIDEO = gtk_video_get_type();
pub const GTK_TYPE_VIEWPORT = gtk_viewport_get_type();
pub inline fn GTK_VIEWPORT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_VIEWPORT, GtkViewport)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_VIEWPORT, GtkViewport);
}
pub inline fn GTK_IS_VIEWPORT(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_VIEWPORT)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_VIEWPORT);
}
pub const GTK_TYPE_VOLUME_BUTTON = gtk_volume_button_get_type();
pub inline fn GTK_VOLUME_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_VOLUME_BUTTON, GtkVolumeButton)) {
    return G_TYPE_CHECK_INSTANCE_CAST(obj, GTK_TYPE_VOLUME_BUTTON, GtkVolumeButton);
}
pub inline fn GTK_IS_VOLUME_BUTTON(obj: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_VOLUME_BUTTON)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(obj, GTK_TYPE_VOLUME_BUTTON);
}
pub const GTK_TYPE_WIDGET_PAINTABLE = gtk_widget_paintable_get_type();
pub const GTK_TYPE_WINDOW_CONTROLS = gtk_window_controls_get_type();
pub const GTK_TYPE_WINDOW_GROUP = gtk_window_group_get_type();
pub inline fn GTK_WINDOW_GROUP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_WINDOW_GROUP, GtkWindowGroup)) {
    return G_TYPE_CHECK_INSTANCE_CAST(object, GTK_TYPE_WINDOW_GROUP, GtkWindowGroup);
}
pub inline fn GTK_WINDOW_GROUP_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_WINDOW_GROUP, GtkWindowGroupClass)) {
    return G_TYPE_CHECK_CLASS_CAST(klass, GTK_TYPE_WINDOW_GROUP, GtkWindowGroupClass);
}
pub inline fn GTK_IS_WINDOW_GROUP(object: anytype) @TypeOf(G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_WINDOW_GROUP)) {
    return G_TYPE_CHECK_INSTANCE_TYPE(object, GTK_TYPE_WINDOW_GROUP);
}
pub inline fn GTK_IS_WINDOW_GROUP_CLASS(klass: anytype) @TypeOf(G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_WINDOW_GROUP)) {
    return G_TYPE_CHECK_CLASS_TYPE(klass, GTK_TYPE_WINDOW_GROUP);
}
pub inline fn GTK_WINDOW_GROUP_GET_CLASS(obj: anytype) @TypeOf(G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_WINDOW_GROUP, GtkWindowGroupClass)) {
    return G_TYPE_INSTANCE_GET_CLASS(obj, GTK_TYPE_WINDOW_GROUP, GtkWindowGroupClass);
}
pub const GTK_TYPE_WINDOW_HANDLE = gtk_window_handle_get_type();
pub const tm = struct_tm;
pub const timespec = struct_timespec;
pub const itimerspec = struct_itimerspec;
pub const sigval = union_sigval;
pub const sigevent = struct_sigevent;
pub const __locale_data = struct___locale_data;
pub const __locale_struct = struct___locale_struct;
pub const _GDoubleIEEE754 = union__GDoubleIEEE754;
pub const _GFloatIEEE754 = union__GFloatIEEE754;
pub const _GTimeVal = struct__GTimeVal;
pub const _GBytes = struct__GBytes;
pub const _GArray = struct__GArray;
pub const _GByteArray = struct__GByteArray;
pub const _GPtrArray = struct__GPtrArray;
pub const __va_list_tag = struct___va_list_tag;
pub const _GError = struct__GError;
pub const _GDebugKey = struct__GDebugKey;
pub const timeval = struct_timeval;
pub const __pthread_internal_list = struct___pthread_internal_list;
pub const __pthread_internal_slist = struct___pthread_internal_slist;
pub const __pthread_mutex_s = struct___pthread_mutex_s;
pub const __pthread_rwlock_arch_t = struct___pthread_rwlock_arch_t;
pub const __pthread_cond_s = struct___pthread_cond_s;
pub const random_data = struct_random_data;
pub const drand48_data = struct_drand48_data;
pub const _GThread = struct__GThread;
pub const _GMutex = union__GMutex;
pub const _GRecMutex = struct__GRecMutex;
pub const _GRWLock = struct__GRWLock;
pub const _GCond = struct__GCond;
pub const _GPrivate = struct__GPrivate;
pub const _GOnce = struct__GOnce;
pub const _GAsyncQueue = struct__GAsyncQueue;
pub const _fpx_sw_bytes = struct__fpx_sw_bytes;
pub const _fpreg = struct__fpreg;
pub const _fpxreg = struct__fpxreg;
pub const _xmmreg = struct__xmmreg;
pub const _fpstate = struct__fpstate;
pub const sigcontext = struct_sigcontext;
pub const _xsave_hdr = struct__xsave_hdr;
pub const _ymmh_state = struct__ymmh_state;
pub const _xstate = struct__xstate;
pub const _libc_fpxreg = struct__libc_fpxreg;
pub const _libc_xmmreg = struct__libc_xmmreg;
pub const _libc_fpstate = struct__libc_fpstate;
pub const _GTimeZone = struct__GTimeZone;
pub const _GDateTime = struct__GDateTime;
pub const _GBookmarkFile = struct__GBookmarkFile;
pub const _GChecksum = struct__GChecksum;
pub const _GIConv = struct__GIConv;
pub const _GData = struct__GData;
pub const _GDate = struct__GDate;
pub const dirent = struct_dirent;
pub const __dirstream = struct___dirstream;
pub const _GDir = struct__GDir;
pub const _GMemVTable = struct__GMemVTable;
pub const _GNode = struct__GNode;
pub const _GList = struct__GList;
pub const _GHashTable = struct__GHashTable;
pub const _GHashTableIter = struct__GHashTableIter;
pub const _GHmac = struct__GHmac;
pub const _GHook = struct__GHook;
pub const _GHookList = struct__GHookList;
pub const _GPollFD = struct__GPollFD;
pub const _GSList = struct__GSList;
pub const _GMainContext = struct__GMainContext;
pub const _GMainLoop = struct__GMainLoop;
pub const _GSourceCallbackFuncs = struct__GSourceCallbackFuncs;
pub const _GSourceFuncs = struct__GSourceFuncs;
pub const _GSourcePrivate = struct__GSourcePrivate;
pub const _GSource = struct__GSource;
pub const _GString = struct__GString;
pub const _GIOFuncs = struct__GIOFuncs;
pub const _GIOChannel = struct__GIOChannel;
pub const _GKeyFile = struct__GKeyFile;
pub const _GMappedFile = struct__GMappedFile;
pub const _GMarkupParseContext = struct__GMarkupParseContext;
pub const _GMarkupParser = struct__GMarkupParser;
pub const _GVariantType = struct__GVariantType;
pub const _GVariant = struct__GVariant;
pub const _GVariantIter = struct__GVariantIter;
pub const _GVariantBuilder = struct__GVariantBuilder;
pub const _GVariantDict = struct__GVariantDict;
pub const _GLogField = struct__GLogField;
pub const _GOptionContext = struct__GOptionContext;
pub const _GOptionGroup = struct__GOptionGroup;
pub const _GOptionEntry = struct__GOptionEntry;
pub const _GPathBuf = struct__GPathBuf;
pub const _GPatternSpec = struct__GPatternSpec;
pub const _GQueue = struct__GQueue;
pub const _GRand = struct__GRand;
pub const _GRegex = struct__GRegex;
pub const _GMatchInfo = struct__GMatchInfo;
pub const _GScannerConfig = struct__GScannerConfig;
pub const _GTokenValue = union__GTokenValue;
pub const _GScanner = struct__GScanner;
pub const _GSequence = struct__GSequence;
pub const _GSequenceNode = struct__GSequenceNode;
pub const _GStringChunk = struct__GStringChunk;
pub const _GStrvBuilder = struct__GStrvBuilder;
pub const _GThreadPool = struct__GThreadPool;
pub const _GTimer = struct__GTimer;
pub const _GTrashStack = struct__GTrashStack;
pub const _GTree = struct__GTree;
pub const _GTreeNode = struct__GTreeNode;
pub const _GUri = struct__GUri;
pub const _GUriParamsIter = struct__GUriParamsIter;
pub const _GAllocator = struct__GAllocator;
pub const _GMemChunk = struct__GMemChunk;
pub const _GCache = struct__GCache;
pub const _GCompletion = struct__GCompletion;
pub const _GRelation = struct__GRelation;
pub const _GTuples = struct__GTuples;
pub const _GThreadFunctions = struct__GThreadFunctions;
pub const sched_param = struct_sched_param;
pub const __jmp_buf_tag = struct___jmp_buf_tag;
pub const _pthread_cleanup_buffer = struct__pthread_cleanup_buffer;
pub const __cancel_jmp_buf_tag = struct___cancel_jmp_buf_tag;
pub const __pthread_cleanup_frame = struct___pthread_cleanup_frame;
pub const _GStaticRecMutex = struct__GStaticRecMutex;
pub const _GStaticRWLock = struct__GStaticRWLock;
pub const _GStaticPrivate = struct__GStaticPrivate;
pub const _GValue = struct__GValue;
pub const _GTypeCValue = union__GTypeCValue;
pub const _GTypePlugin = struct__GTypePlugin;
pub const _GTypeClass = struct__GTypeClass;
pub const _GTypeInterface = struct__GTypeInterface;
pub const _GTypeInstance = struct__GTypeInstance;
pub const _GTypeValueTable = struct__GTypeValueTable;
pub const _GTypeInfo = struct__GTypeInfo;
pub const _GTypeFundamentalInfo = struct__GTypeFundamentalInfo;
pub const _GInterfaceInfo = struct__GInterfaceInfo;
pub const _GTypeQuery = struct__GTypeQuery;
pub const _GParamSpec = struct__GParamSpec;
pub const _GParamSpecClass = struct__GParamSpecClass;
pub const _GParameter = struct__GParameter;
pub const _GParamSpecPool = struct__GParamSpecPool;
pub const _GParamSpecTypeInfo = struct__GParamSpecTypeInfo;
pub const _GClosure = struct__GClosure;
pub const _GClosureNotifyData = struct__GClosureNotifyData;
pub const _GCClosure = struct__GCClosure;
pub const _GSignalQuery = struct__GSignalQuery;
pub const _GSignalInvocationHint = struct__GSignalInvocationHint;
pub const _GObject = struct__GObject;
pub const _GObjectConstructParam = struct__GObjectConstructParam;
pub const _GObjectClass = struct__GObjectClass;
pub const _GBinding = struct__GBinding;
pub const _GBindingGroup = struct__GBindingGroup;
pub const _GEnumValue = struct__GEnumValue;
pub const _GEnumClass = struct__GEnumClass;
pub const _GFlagsValue = struct__GFlagsValue;
pub const _GFlagsClass = struct__GFlagsClass;
pub const _GParamSpecChar = struct__GParamSpecChar;
pub const _GParamSpecUChar = struct__GParamSpecUChar;
pub const _GParamSpecBoolean = struct__GParamSpecBoolean;
pub const _GParamSpecInt = struct__GParamSpecInt;
pub const _GParamSpecUInt = struct__GParamSpecUInt;
pub const _GParamSpecLong = struct__GParamSpecLong;
pub const _GParamSpecULong = struct__GParamSpecULong;
pub const _GParamSpecInt64 = struct__GParamSpecInt64;
pub const _GParamSpecUInt64 = struct__GParamSpecUInt64;
pub const _GParamSpecUnichar = struct__GParamSpecUnichar;
pub const _GParamSpecEnum = struct__GParamSpecEnum;
pub const _GParamSpecFlags = struct__GParamSpecFlags;
pub const _GParamSpecFloat = struct__GParamSpecFloat;
pub const _GParamSpecDouble = struct__GParamSpecDouble;
pub const _GParamSpecString = struct__GParamSpecString;
pub const _GParamSpecParam = struct__GParamSpecParam;
pub const _GParamSpecBoxed = struct__GParamSpecBoxed;
pub const _GParamSpecPointer = struct__GParamSpecPointer;
pub const _GParamSpecValueArray = struct__GParamSpecValueArray;
pub const _GParamSpecObject = struct__GParamSpecObject;
pub const _GParamSpecOverride = struct__GParamSpecOverride;
pub const _GParamSpecGType = struct__GParamSpecGType;
pub const _GParamSpecVariant = struct__GParamSpecVariant;
pub const _GSignalGroup = struct__GSignalGroup;
pub const _GTypeModule = struct__GTypeModule;
pub const _GTypeModuleClass = struct__GTypeModuleClass;
pub const _GTypePluginClass = struct__GTypePluginClass;
pub const _GValueArray = struct__GValueArray;
pub const _GtkCssLocation = struct__GtkCssLocation;
pub const _GTlsPasswordFlags = enum__GTlsPasswordFlags;
pub const _GAppLaunchContextPrivate = struct__GAppLaunchContextPrivate;
pub const _GAppLaunchContext = struct__GAppLaunchContext;
pub const _GAppInfo = struct__GAppInfo;
pub const _GAsyncResult = struct__GAsyncResult;
pub const _GAsyncInitable = struct__GAsyncInitable;
pub const _GInputStreamPrivate = struct__GInputStreamPrivate;
pub const _GInputStream = struct__GInputStream;
pub const _GFilterInputStream = struct__GFilterInputStream;
pub const _GBufferedInputStreamPrivate = struct__GBufferedInputStreamPrivate;
pub const _GBufferedInputStream = struct__GBufferedInputStream;
pub const _GOutputStreamPrivate = struct__GOutputStreamPrivate;
pub const _GOutputStream = struct__GOutputStream;
pub const _GFilterOutputStream = struct__GFilterOutputStream;
pub const _GBufferedOutputStreamPrivate = struct__GBufferedOutputStreamPrivate;
pub const _GBufferedOutputStream = struct__GBufferedOutputStream;
pub const _GCancellablePrivate = struct__GCancellablePrivate;
pub const _GCancellable = struct__GCancellable;
pub const _GCharsetConverter = struct__GCharsetConverter;
pub const _GConverter = struct__GConverter;
pub const _GConverterInputStreamPrivate = struct__GConverterInputStreamPrivate;
pub const _GConverterInputStream = struct__GConverterInputStream;
pub const _GConverterOutputStreamPrivate = struct__GConverterOutputStreamPrivate;
pub const _GConverterOutputStream = struct__GConverterOutputStream;
pub const _GDatagramBased = struct__GDatagramBased;
pub const _GDataInputStreamPrivate = struct__GDataInputStreamPrivate;
pub const _GDataInputStream = struct__GDataInputStream;
pub const _GSimplePermission = struct__GSimplePermission;
pub const _GZlibCompressor = struct__GZlibCompressor;
pub const _GZlibDecompressor = struct__GZlibDecompressor;
pub const _GSimpleActionGroupPrivate = struct__GSimpleActionGroupPrivate;
pub const _GSimpleActionGroup = struct__GSimpleActionGroup;
pub const _GRemoteActionGroup = struct__GRemoteActionGroup;
pub const _GDBusActionGroup = struct__GDBusActionGroup;
pub const _GActionMap = struct__GActionMap;
pub const _GActionGroup = struct__GActionGroup;
pub const _GPropertyAction = struct__GPropertyAction;
pub const _GSimpleAction = struct__GSimpleAction;
pub const _GAction = struct__GAction;
pub const _GApplicationPrivate = struct__GApplicationPrivate;
pub const _GApplication = struct__GApplication;
pub const _GApplicationCommandLinePrivate = struct__GApplicationCommandLinePrivate;
pub const _GApplicationCommandLine = struct__GApplicationCommandLine;
pub const _GSettingsBackend = struct__GSettingsBackend;
pub const _GSettingsPrivate = struct__GSettingsPrivate;
pub const _GSettings = struct__GSettings;
pub const _GPermissionPrivate = struct__GPermissionPrivate;
pub const _GPermission = struct__GPermission;
pub const _GMenuModelPrivate = struct__GMenuModelPrivate;
pub const _GMenuModel = struct__GMenuModel;
pub const _GNotification = struct__GNotification;
pub const _GDrive = struct__GDrive;
pub const _GFileEnumeratorPrivate = struct__GFileEnumeratorPrivate;
pub const _GFileEnumerator = struct__GFileEnumerator;
pub const _GFileMonitorPrivate = struct__GFileMonitorPrivate;
pub const _GFileMonitor = struct__GFileMonitor;
pub const _GFile = struct__GFile;
pub const _GFileInfo = struct__GFileInfo;
pub const _GFileAttributeMatcher = struct__GFileAttributeMatcher;
pub const _GFileAttributeInfo = struct__GFileAttributeInfo;
pub const _GFileAttributeInfoList = struct__GFileAttributeInfoList;
pub const _GFileDescriptorBased = struct__GFileDescriptorBased;
pub const _GFileInputStreamPrivate = struct__GFileInputStreamPrivate;
pub const _GFileInputStream = struct__GFileInputStream;
pub const _GFileOutputStreamPrivate = struct__GFileOutputStreamPrivate;
pub const _GFileOutputStream = struct__GFileOutputStream;
pub const _GIOStreamPrivate = struct__GIOStreamPrivate;
pub const _GIOStream = struct__GIOStream;
pub const _GFileIOStreamPrivate = struct__GFileIOStreamPrivate;
pub const _GFileIOStream = struct__GFileIOStream;
pub const _GFileIcon = struct__GFileIcon;
pub const _GFilenameCompleter = struct__GFilenameCompleter;
pub const _GIcon = struct__GIcon;
pub const _GInetAddressPrivate = struct__GInetAddressPrivate;
pub const _GInetAddress = struct__GInetAddress;
pub const _GInetAddressMaskPrivate = struct__GInetAddressMaskPrivate;
pub const _GInetAddressMask = struct__GInetAddressMask;
pub const _GSocketAddress = struct__GSocketAddress;
pub const _GInetSocketAddressPrivate = struct__GInetSocketAddressPrivate;
pub const _GInetSocketAddress = struct__GInetSocketAddress;
pub const _GNativeSocketAddressPrivate = struct__GNativeSocketAddressPrivate;
pub const _GNativeSocketAddress = struct__GNativeSocketAddress;
pub const _GInitable = struct__GInitable;
pub const _GIOModule = struct__GIOModule;
pub const _GIOExtensionPoint = struct__GIOExtensionPoint;
pub const _GIOExtension = struct__GIOExtension;
pub const _GIOSchedulerJob = struct__GIOSchedulerJob;
pub const _GIOStreamAdapter = struct__GIOStreamAdapter;
pub const _GLoadableIcon = struct__GLoadableIcon;
pub const _GBytesIcon = struct__GBytesIcon;
pub const _GMemoryInputStreamPrivate = struct__GMemoryInputStreamPrivate;
pub const _GMemoryInputStream = struct__GMemoryInputStream;
pub const _GMemoryOutputStreamPrivate = struct__GMemoryOutputStreamPrivate;
pub const _GMemoryOutputStream = struct__GMemoryOutputStream;
pub const _GMount = struct__GMount;
pub const _GMountOperationPrivate = struct__GMountOperationPrivate;
pub const _GMountOperation = struct__GMountOperation;
pub const _GNetworkAddressPrivate = struct__GNetworkAddressPrivate;
pub const _GNetworkAddress = struct__GNetworkAddress;
pub const _GNetworkMonitor = struct__GNetworkMonitor;
pub const _GNetworkServicePrivate = struct__GNetworkServicePrivate;
pub const _GNetworkService = struct__GNetworkService;
pub const _GSimpleIOStream = struct__GSimpleIOStream;
pub const _GPollableInputStream = struct__GPollableInputStream;
pub const _GPollableOutputStream = struct__GPollableOutputStream;
pub const _GResolverPrivate = struct__GResolverPrivate;
pub const _GResolver = struct__GResolver;
pub const _GResource = struct__GResource;
pub const _GSeekable = struct__GSeekable;
pub const _GSimpleAsyncResult = struct__GSimpleAsyncResult;
pub const _GSocketPrivate = struct__GSocketPrivate;
pub const _GSocket = struct__GSocket;
pub const _GSocketControlMessagePrivate = struct__GSocketControlMessagePrivate;
pub const _GSocketControlMessage = struct__GSocketControlMessage;
pub const _GSocketClientPrivate = struct__GSocketClientPrivate;
pub const _GSocketClient = struct__GSocketClient;
pub const _GSocketConnectionPrivate = struct__GSocketConnectionPrivate;
pub const _GSocketConnection = struct__GSocketConnection;
pub const _GSocketListenerPrivate = struct__GSocketListenerPrivate;
pub const _GSocketListener = struct__GSocketListener;
pub const _GSocketServicePrivate = struct__GSocketServicePrivate;
pub const _GSocketService = struct__GSocketService;
pub const _GSocketAddressEnumerator = struct__GSocketAddressEnumerator;
pub const _GSocketConnectable = struct__GSocketConnectable;
pub const _GSrvTarget = struct__GSrvTarget;
pub const _GTask = struct__GTask;
pub const _GTcpConnectionPrivate = struct__GTcpConnectionPrivate;
pub const _GTcpConnection = struct__GTcpConnection;
pub const _GTcpWrapperConnectionPrivate = struct__GTcpWrapperConnectionPrivate;
pub const _GTcpWrapperConnection = struct__GTcpWrapperConnection;
pub const _GThreadedSocketServicePrivate = struct__GThreadedSocketServicePrivate;
pub const _GThreadedSocketService = struct__GThreadedSocketService;
pub const _GDtlsConnection = struct__GDtlsConnection;
pub const _GDtlsClientConnection = struct__GDtlsClientConnection;
pub const _GDtlsServerConnection = struct__GDtlsServerConnection;
pub const _GThemedIcon = struct__GThemedIcon;
pub const _GTlsCertificatePrivate = struct__GTlsCertificatePrivate;
pub const _GTlsCertificate = struct__GTlsCertificate;
pub const _GTlsClientConnection = struct__GTlsClientConnection;
pub const _GTlsConnectionPrivate = struct__GTlsConnectionPrivate;
pub const _GTlsConnection = struct__GTlsConnection;
pub const _GTlsDatabasePrivate = struct__GTlsDatabasePrivate;
pub const _GTlsDatabase = struct__GTlsDatabase;
pub const _GTlsFileDatabase = struct__GTlsFileDatabase;
pub const _GTlsInteractionPrivate = struct__GTlsInteractionPrivate;
pub const _GTlsInteraction = struct__GTlsInteraction;
pub const _GTlsPasswordPrivate = struct__GTlsPasswordPrivate;
pub const _GTlsPassword = struct__GTlsPassword;
pub const _GTlsServerConnection = struct__GTlsServerConnection;
pub const _GVfs = struct__GVfs;
pub const _GProxyResolver = struct__GProxyResolver;
pub const _GProxy = struct__GProxy;
pub const _GProxyAddressPrivate = struct__GProxyAddressPrivate;
pub const _GProxyAddress = struct__GProxyAddress;
pub const _GProxyAddressEnumeratorPrivate = struct__GProxyAddressEnumeratorPrivate;
pub const _GProxyAddressEnumerator = struct__GProxyAddressEnumerator;
pub const _GVolume = struct__GVolume;
pub const _GVolumeMonitor = struct__GVolumeMonitor;
pub const _GInputVector = struct__GInputVector;
pub const _GInputMessage = struct__GInputMessage;
pub const _GOutputVector = struct__GOutputVector;
pub const _GOutputMessage = struct__GOutputMessage;
pub const _GCredentials = struct__GCredentials;
pub const _GUnixCredentialsMessagePrivate = struct__GUnixCredentialsMessagePrivate;
pub const _GUnixCredentialsMessage = struct__GUnixCredentialsMessage;
pub const _GUnixFDListPrivate = struct__GUnixFDListPrivate;
pub const _GUnixFDList = struct__GUnixFDList;
pub const _GDBusMessage = struct__GDBusMessage;
pub const _GDBusConnection = struct__GDBusConnection;
pub const _GDBusProxyPrivate = struct__GDBusProxyPrivate;
pub const _GDBusProxy = struct__GDBusProxy;
pub const _GDBusMethodInvocation = struct__GDBusMethodInvocation;
pub const _GDBusServer = struct__GDBusServer;
pub const _GDBusAuthObserver = struct__GDBusAuthObserver;
pub const _GDBusErrorEntry = struct__GDBusErrorEntry;
pub const _GDBusInterfaceVTable = struct__GDBusInterfaceVTable;
pub const _GDBusAnnotationInfo = struct__GDBusAnnotationInfo;
pub const _GDBusArgInfo = struct__GDBusArgInfo;
pub const _GDBusMethodInfo = struct__GDBusMethodInfo;
pub const _GDBusSignalInfo = struct__GDBusSignalInfo;
pub const _GDBusPropertyInfo = struct__GDBusPropertyInfo;
pub const _GDBusInterfaceInfo = struct__GDBusInterfaceInfo;
pub const _GDBusSubtreeVTable = struct__GDBusSubtreeVTable;
pub const _GDBusNodeInfo = struct__GDBusNodeInfo;
pub const _GDBusInterface = struct__GDBusInterface;
pub const _GDBusInterfaceSkeletonPrivate = struct__GDBusInterfaceSkeletonPrivate;
pub const _GDBusInterfaceSkeleton = struct__GDBusInterfaceSkeleton;
pub const _GDBusObject = struct__GDBusObject;
pub const _GDBusObjectSkeletonPrivate = struct__GDBusObjectSkeletonPrivate;
pub const _GDBusObjectSkeleton = struct__GDBusObjectSkeleton;
pub const _GDBusObjectProxyPrivate = struct__GDBusObjectProxyPrivate;
pub const _GDBusObjectProxy = struct__GDBusObjectProxy;
pub const _GDBusObjectManager = struct__GDBusObjectManager;
pub const _GDBusObjectManagerClientPrivate = struct__GDBusObjectManagerClientPrivate;
pub const _GDBusObjectManagerClient = struct__GDBusObjectManagerClient;
pub const _GDBusObjectManagerServerPrivate = struct__GDBusObjectManagerServerPrivate;
pub const _GDBusObjectManagerServer = struct__GDBusObjectManagerServer;
pub const _GTestDBus = struct__GTestDBus;
pub const _GSubprocess = struct__GSubprocess;
pub const _GSubprocessLauncher = struct__GSubprocessLauncher;
pub const _GActionInterface = struct__GActionInterface;
pub const _GActionGroupInterface = struct__GActionGroupInterface;
pub const _GActionMapInterface = struct__GActionMapInterface;
pub const _GActionEntry = struct__GActionEntry;
pub const _GAppLaunchContextClass = struct__GAppLaunchContextClass;
pub const _GAppInfoIface = struct__GAppInfoIface;
pub const _GAppInfoMonitor = struct__GAppInfoMonitor;
pub const _GApplicationClass = struct__GApplicationClass;
pub const _GApplicationCommandLineClass = struct__GApplicationCommandLineClass;
pub const _GInitableIface = struct__GInitableIface;
pub const _GAsyncInitableIface = struct__GAsyncInitableIface;
pub const _GAsyncResultIface = struct__GAsyncResultIface;
pub const _GInputStreamClass = struct__GInputStreamClass;
pub const _GFilterInputStreamClass = struct__GFilterInputStreamClass;
pub const _GBufferedInputStreamClass = struct__GBufferedInputStreamClass;
pub const _GOutputStreamClass = struct__GOutputStreamClass;
pub const _GFilterOutputStreamClass = struct__GFilterOutputStreamClass;
pub const _GBufferedOutputStreamClass = struct__GBufferedOutputStreamClass;
pub const _GCancellableClass = struct__GCancellableClass;
pub const _GConverterIface = struct__GConverterIface;
pub const _GCharsetConverterClass = struct__GCharsetConverterClass;
pub const _GConverterInputStreamClass = struct__GConverterInputStreamClass;
pub const _GConverterOutputStreamClass = struct__GConverterOutputStreamClass;
pub const _GCredentialsClass = struct__GCredentialsClass;
pub const _GDatagramBasedInterface = struct__GDatagramBasedInterface;
pub const _GDataInputStreamClass = struct__GDataInputStreamClass;
pub const _GDataOutputStreamPrivate = struct__GDataOutputStreamPrivate;
pub const _GDataOutputStream = struct__GDataOutputStream;
pub const _GDataOutputStreamClass = struct__GDataOutputStreamClass;
pub const _GDBusInterfaceIface = struct__GDBusInterfaceIface;
pub const _GDBusInterfaceSkeletonClass = struct__GDBusInterfaceSkeletonClass;
pub const _GDBusMenuModel = struct__GDBusMenuModel;
pub const _GDBusObjectIface = struct__GDBusObjectIface;
pub const _GDBusObjectManagerIface = struct__GDBusObjectManagerIface;
pub const _GDBusObjectManagerClientClass = struct__GDBusObjectManagerClientClass;
pub const _GDBusObjectManagerServerClass = struct__GDBusObjectManagerServerClass;
pub const _GDBusObjectProxyClass = struct__GDBusObjectProxyClass;
pub const _GDBusObjectSkeletonClass = struct__GDBusObjectSkeletonClass;
pub const _GDBusProxyClass = struct__GDBusProxyClass;
pub const _GDebugController = struct__GDebugController;
pub const _GDebugControllerInterface = struct__GDebugControllerInterface;
pub const _GDebugControllerDBus = struct__GDebugControllerDBus;
pub const _GDebugControllerDBusClass = struct__GDebugControllerDBusClass;
pub const _GDriveIface = struct__GDriveIface;
pub const _GDtlsConnectionInterface = struct__GDtlsConnectionInterface;
pub const _GDtlsClientConnectionInterface = struct__GDtlsClientConnectionInterface;
pub const _GDtlsServerConnectionInterface = struct__GDtlsServerConnectionInterface;
pub const _GIconIface = struct__GIconIface;
pub const _GEmblem = struct__GEmblem;
pub const _GEmblemClass = struct__GEmblemClass;
pub const _GEmblemedIconPrivate = struct__GEmblemedIconPrivate;
pub const _GEmblemedIcon = struct__GEmblemedIcon;
pub const _GEmblemedIconClass = struct__GEmblemedIconClass;
pub const _GFileIface = struct__GFileIface;
pub const _GFileEnumeratorClass = struct__GFileEnumeratorClass;
pub const _GFileIconClass = struct__GFileIconClass;
pub const _GFileInfoClass = struct__GFileInfoClass;
pub const _GFileInputStreamClass = struct__GFileInputStreamClass;
pub const _GIOStreamClass = struct__GIOStreamClass;
pub const _GFileIOStreamClass = struct__GFileIOStreamClass;
pub const _GFileMonitorClass = struct__GFileMonitorClass;
pub const _GFilenameCompleterClass = struct__GFilenameCompleterClass;
pub const _GFileOutputStreamClass = struct__GFileOutputStreamClass;
pub const _GInetAddressClass = struct__GInetAddressClass;
pub const _GInetAddressMaskClass = struct__GInetAddressMaskClass;
pub const _GSocketAddressClass = struct__GSocketAddressClass;
pub const _GInetSocketAddressClass = struct__GInetSocketAddressClass;
pub const _GModule = struct__GModule;
pub const _GIOModuleScope = struct__GIOModuleScope;
pub const _GIOModuleClass = struct__GIOModuleClass;
pub const _GListModel = struct__GListModel;
pub const _GListModelInterface = struct__GListModelInterface;
pub const _GListStore = struct__GListStore;
pub const _GLoadableIconIface = struct__GLoadableIconIface;
pub const _GMemoryInputStreamClass = struct__GMemoryInputStreamClass;
pub const _GMemoryMonitor = struct__GMemoryMonitor;
pub const _GMemoryMonitorInterface = struct__GMemoryMonitorInterface;
pub const _GMemoryOutputStreamClass = struct__GMemoryOutputStreamClass;
pub const _GMenuAttributeIterPrivate = struct__GMenuAttributeIterPrivate;
pub const _GMenuAttributeIter = struct__GMenuAttributeIter;
pub const _GMenuLinkIterPrivate = struct__GMenuLinkIterPrivate;
pub const _GMenuLinkIter = struct__GMenuLinkIter;
pub const _GMenuModelClass = struct__GMenuModelClass;
pub const _GMenuAttributeIterClass = struct__GMenuAttributeIterClass;
pub const _GMenuLinkIterClass = struct__GMenuLinkIterClass;
pub const _GMenuItem = struct__GMenuItem;
pub const _GMenu = struct__GMenu;
pub const _GMountIface = struct__GMountIface;
pub const _GMountOperationClass = struct__GMountOperationClass;
pub const _GNativeSocketAddressClass = struct__GNativeSocketAddressClass;
pub const _GVolumeMonitorClass = struct__GVolumeMonitorClass;
pub const _GNativeVolumeMonitor = struct__GNativeVolumeMonitor;
pub const _GNativeVolumeMonitorClass = struct__GNativeVolumeMonitorClass;
pub const _GNetworkAddressClass = struct__GNetworkAddressClass;
pub const _GNetworkMonitorInterface = struct__GNetworkMonitorInterface;
pub const _GNetworkServiceClass = struct__GNetworkServiceClass;
pub const _GPermissionClass = struct__GPermissionClass;
pub const _GPollableInputStreamInterface = struct__GPollableInputStreamInterface;
pub const _GPollableOutputStreamInterface = struct__GPollableOutputStreamInterface;
pub const _GPowerProfileMonitor = struct__GPowerProfileMonitor;
pub const _GPowerProfileMonitorInterface = struct__GPowerProfileMonitorInterface;
pub const _GProxyInterface = struct__GProxyInterface;
pub const _GProxyAddressClass = struct__GProxyAddressClass;
pub const _GSocketAddressEnumeratorClass = struct__GSocketAddressEnumeratorClass;
pub const _GProxyAddressEnumeratorClass = struct__GProxyAddressEnumeratorClass;
pub const _GProxyResolverInterface = struct__GProxyResolverInterface;
pub const _GRemoteActionGroupInterface = struct__GRemoteActionGroupInterface;
pub const _GResolverClass = struct__GResolverClass;
pub const _GStaticResource = struct__GStaticResource;
pub const _GSeekableIface = struct__GSeekableIface;
pub const _GSettingsSchemaSource = struct__GSettingsSchemaSource;
pub const _GSettingsSchema = struct__GSettingsSchema;
pub const _GSettingsSchemaKey = struct__GSettingsSchemaKey;
pub const _GSettingsClass = struct__GSettingsClass;
pub const _GSimpleActionGroupClass = struct__GSimpleActionGroupClass;
pub const _GSimpleAsyncResultClass = struct__GSimpleAsyncResultClass;
pub const _GSimpleProxyResolverPrivate = struct__GSimpleProxyResolverPrivate;
pub const _GSimpleProxyResolver = struct__GSimpleProxyResolver;
pub const _GSimpleProxyResolverClass = struct__GSimpleProxyResolverClass;
pub const _GSocketClass = struct__GSocketClass;
pub const _GSocketClientClass = struct__GSocketClientClass;
pub const _GSocketConnectableIface = struct__GSocketConnectableIface;
pub const _GSocketConnectionClass = struct__GSocketConnectionClass;
pub const _GSocketControlMessageClass = struct__GSocketControlMessageClass;
pub const _GSocketListenerClass = struct__GSocketListenerClass;
pub const _GSocketServiceClass = struct__GSocketServiceClass;
pub const _GTaskClass = struct__GTaskClass;
pub const _GTcpConnectionClass = struct__GTcpConnectionClass;
pub const _GTcpWrapperConnectionClass = struct__GTcpWrapperConnectionClass;
pub const _GThemedIconClass = struct__GThemedIconClass;
pub const _GThreadedSocketServiceClass = struct__GThreadedSocketServiceClass;
pub const _GTlsBackend = struct__GTlsBackend;
pub const _GTlsBackendInterface = struct__GTlsBackendInterface;
pub const _GTlsCertificateClass = struct__GTlsCertificateClass;
pub const _GTlsConnectionClass = struct__GTlsConnectionClass;
pub const _GTlsClientConnectionInterface = struct__GTlsClientConnectionInterface;
pub const _GTlsDatabaseClass = struct__GTlsDatabaseClass;
pub const _GTlsFileDatabaseInterface = struct__GTlsFileDatabaseInterface;
pub const _GTlsInteractionClass = struct__GTlsInteractionClass;
pub const _GTlsPasswordClass = struct__GTlsPasswordClass;
pub const _GTlsServerConnectionInterface = struct__GTlsServerConnectionInterface;
pub const _GUnixConnectionPrivate = struct__GUnixConnectionPrivate;
pub const _GUnixConnection = struct__GUnixConnection;
pub const _GUnixConnectionClass = struct__GUnixConnectionClass;
pub const _GUnixCredentialsMessageClass = struct__GUnixCredentialsMessageClass;
pub const _GUnixFDListClass = struct__GUnixFDListClass;
pub const _GUnixSocketAddressPrivate = struct__GUnixSocketAddressPrivate;
pub const _GUnixSocketAddress = struct__GUnixSocketAddress;
pub const _GUnixSocketAddressClass = struct__GUnixSocketAddressClass;
pub const _GVfsClass = struct__GVfsClass;
pub const _GVolumeIface = struct__GVolumeIface;
pub const _GZlibCompressorClass = struct__GZlibCompressorClass;
pub const _GZlibDecompressorClass = struct__GZlibDecompressorClass;
pub const _GtkCssSection = struct__GtkCssSection;
pub const _cairo = struct__cairo;
pub const _cairo_surface = struct__cairo_surface;
pub const _cairo_device = struct__cairo_device;
pub const _cairo_matrix = struct__cairo_matrix;
pub const _cairo_pattern = struct__cairo_pattern;
pub const _cairo_user_data_key = struct__cairo_user_data_key;
pub const _cairo_status = enum__cairo_status;
pub const _cairo_content = enum__cairo_content;
pub const _cairo_format = enum__cairo_format;
pub const _cairo_dither = enum__cairo_dither;
pub const _cairo_rectangle_int = struct__cairo_rectangle_int;
pub const _cairo_operator = enum__cairo_operator;
pub const _cairo_antialias = enum__cairo_antialias;
pub const _cairo_fill_rule = enum__cairo_fill_rule;
pub const _cairo_line_cap = enum__cairo_line_cap;
pub const _cairo_line_join = enum__cairo_line_join;
pub const _cairo_rectangle = struct__cairo_rectangle;
pub const _cairo_rectangle_list = struct__cairo_rectangle_list;
pub const _cairo_scaled_font = struct__cairo_scaled_font;
pub const _cairo_font_face = struct__cairo_font_face;
pub const _cairo_text_cluster_flags = enum__cairo_text_cluster_flags;
pub const _cairo_font_slant = enum__cairo_font_slant;
pub const _cairo_font_weight = enum__cairo_font_weight;
pub const _cairo_subpixel_order = enum__cairo_subpixel_order;
pub const _cairo_hint_style = enum__cairo_hint_style;
pub const _cairo_hint_metrics = enum__cairo_hint_metrics;
pub const _cairo_color_mode = enum__cairo_color_mode;
pub const _cairo_font_options = struct__cairo_font_options;
pub const _cairo_font_type = enum__cairo_font_type;
pub const _cairo_path_data_type = enum__cairo_path_data_type;
pub const _cairo_path_data_t = union__cairo_path_data_t;
pub const cairo_path = struct_cairo_path;
pub const _cairo_device_type = enum__cairo_device_type;
pub const _cairo_surface_type = enum__cairo_surface_type;
pub const _cairo_pattern_type = enum__cairo_pattern_type;
pub const _cairo_extend = enum__cairo_extend;
pub const _cairo_filter = enum__cairo_filter;
pub const _cairo_region = struct__cairo_region;
pub const _cairo_region_overlap = enum__cairo_region_overlap;
pub const _hb_var_int_t = union__hb_var_int_t;
pub const _hb_var_num_t = union__hb_var_num_t;
pub const hb_language_impl_t = struct_hb_language_impl_t;
pub const _PangoCoverage = struct__PangoCoverage;
pub const _PangoLogAttr = struct__PangoLogAttr;
pub const _PangoEngine = struct__PangoEngine;
pub const _PangoEngineLang = struct__PangoEngineLang;
pub const _PangoEngineShape = struct__PangoEngineShape;
pub const _PangoFont = struct__PangoFont;
pub const _PangoFontMap = struct__PangoFontMap;
pub const _PangoRectangle = struct__PangoRectangle;
pub const _PangoContext = struct__PangoContext;
pub const _PangoLanguage = struct__PangoLanguage;
pub const _PangoMatrix = struct__PangoMatrix;
pub const _PangoScriptIter = struct__PangoScriptIter;
pub const _PangoFontDescription = struct__PangoFontDescription;
pub const _PangoFontMetrics = struct__PangoFontMetrics;
pub const _PangoFontFace = struct__PangoFontFace;
pub const _PangoFontFamily = struct__PangoFontFamily;
pub const _PangoFontFamilyClass = struct__PangoFontFamilyClass;
pub const _PangoFontFaceClass = struct__PangoFontFaceClass;
pub const _PangoFontClass = struct__PangoFontClass;
pub const _PangoColor = struct__PangoColor;
pub const _PangoAttrClass = struct__PangoAttrClass;
pub const _PangoAttribute = struct__PangoAttribute;
pub const _PangoAttrString = struct__PangoAttrString;
pub const _PangoAttrLanguage = struct__PangoAttrLanguage;
pub const _PangoAttrInt = struct__PangoAttrInt;
pub const _PangoAttrSize = struct__PangoAttrSize;
pub const _PangoAttrFloat = struct__PangoAttrFloat;
pub const _PangoAttrColor = struct__PangoAttrColor;
pub const _PangoAttrFontDesc = struct__PangoAttrFontDesc;
pub const _PangoAttrShape = struct__PangoAttrShape;
pub const _PangoAttrFontFeatures = struct__PangoAttrFontFeatures;
pub const _PangoAttrList = struct__PangoAttrList;
pub const _PangoAttrIterator = struct__PangoAttrIterator;
pub const _PangoAnalysis = struct__PangoAnalysis;
pub const _PangoItem = struct__PangoItem;
pub const _PangoFontset = struct__PangoFontset;
pub const _PangoFontsetClass = struct__PangoFontsetClass;
pub const _PangoFontMapClass = struct__PangoFontMapClass;
pub const _PangoContextClass = struct__PangoContextClass;
pub const _PangoGlyphGeometry = struct__PangoGlyphGeometry;
pub const _PangoGlyphVisAttr = struct__PangoGlyphVisAttr;
pub const _PangoGlyphInfo = struct__PangoGlyphInfo;
pub const _PangoGlyphString = struct__PangoGlyphString;
pub const _PangoEngineClass = struct__PangoEngineClass;
pub const _PangoEngineLangClass = struct__PangoEngineLangClass;
pub const _PangoEngineShapeClass = struct__PangoEngineShapeClass;
pub const _PangoEngineScriptInfo = struct__PangoEngineScriptInfo;
pub const _PangoEngineInfo = struct__PangoEngineInfo;
pub const _PangoFontsetSimple = struct__PangoFontsetSimple;
pub const _PangoFontsetSimpleClass = struct__PangoFontsetSimpleClass;
pub const _PangoGlyphItem = struct__PangoGlyphItem;
pub const _PangoGlyphItemIter = struct__PangoGlyphItemIter;
pub const _PangoTabArray = struct__PangoTabArray;
pub const _PangoLayout = struct__PangoLayout;
pub const _PangoLayoutClass = struct__PangoLayoutClass;
pub const _PangoLayoutLine = struct__PangoLayoutLine;
pub const _PangoLayoutIter = struct__PangoLayoutIter;
pub const _PangoRendererPrivate = struct__PangoRendererPrivate;
pub const _PangoRenderer = struct__PangoRenderer;
pub const _PangoRendererClass = struct__PangoRendererClass;
pub const _G_fpos_t = struct__G_fpos_t;
pub const _G_fpos64_t = struct__G_fpos64_t;
pub const _IO_marker = struct__IO_marker;
pub const _IO_codecvt = struct__IO_codecvt;
pub const _IO_wide_data = struct__IO_wide_data;
pub const _IO_FILE = struct__IO_FILE;
pub const _IO_cookie_io_functions_t = struct__IO_cookie_io_functions_t;
pub const _GdkRGBA = struct__GdkRGBA;
pub const _GdkContentFormats = struct__GdkContentFormats;
pub const _GdkContentProvider = struct__GdkContentProvider;
pub const _GdkCursor = struct__GdkCursor;
pub const _GdkTexture = struct__GdkTexture;
pub const _GdkTextureDownloader = struct__GdkTextureDownloader;
pub const _GdkDevice = struct__GdkDevice;
pub const _GdkDrag = struct__GdkDrag;
pub const _GdkDrop = struct__GdkDrop;
pub const _GdkClipboard = struct__GdkClipboard;
pub const _GdkDisplayManager = struct__GdkDisplayManager;
pub const _GdkDisplay = struct__GdkDisplay;
pub const _GdkSurface = struct__GdkSurface;
pub const _GdkAppLaunchContext = struct__GdkAppLaunchContext;
pub const _GdkSeat = struct__GdkSeat;
pub const _GdkSnapshot = struct__GdkSnapshot;
pub const _GdkDrawContext = struct__GdkDrawContext;
pub const _GdkCairoContext = struct__GdkCairoContext;
pub const _GdkGLContext = struct__GdkGLContext;
pub const _GdkVulkanContext = struct__GdkVulkanContext;
pub const _GdkKeymapKey = struct__GdkKeymapKey;
pub const _GdkPixbuf = struct__GdkPixbuf;
pub const _GdkPixbufAnimation = struct__GdkPixbufAnimation;
pub const _GdkPixbufAnimationIter = struct__GdkPixbufAnimationIter;
pub const _GdkPixbufSimpleAnim = struct__GdkPixbufSimpleAnim;
pub const _GdkPixbufSimpleAnimClass = struct__GdkPixbufSimpleAnimClass;
pub const _GdkPixbufFormat = struct__GdkPixbufFormat;
pub const _GdkPixbufLoader = struct__GdkPixbufLoader;
pub const _GdkPixbufLoaderClass = struct__GdkPixbufLoaderClass;
pub const _PangoCairoFont = struct__PangoCairoFont;
pub const _PangoCairoFontMap = struct__PangoCairoFontMap;
pub const _GdkContentDeserializer = struct__GdkContentDeserializer;
pub const _GdkContentFormatsBuilder = struct__GdkContentFormatsBuilder;
pub const _GdkFileList = struct__GdkFileList;
pub const _GdkContentProviderClass = struct__GdkContentProviderClass;
pub const _GdkContentSerializer = struct__GdkContentSerializer;
pub const _GdkDeviceTool = struct__GdkDeviceTool;
pub const _GdkTimeCoord = struct__GdkTimeCoord;
pub const _GdkDevicePad = struct__GdkDevicePad;
pub const _GdkDevicePadInterface = struct__GdkDevicePadInterface;
pub const _GdkEventSequence = struct__GdkEventSequence;
pub const _GdkEvent = struct__GdkEvent;
pub const _GdkButtonEvent = struct__GdkButtonEvent;
pub const _GdkCrossingEvent = struct__GdkCrossingEvent;
pub const _GdkDeleteEvent = struct__GdkDeleteEvent;
pub const _GdkDNDEvent = struct__GdkDNDEvent;
pub const _GdkFocusEvent = struct__GdkFocusEvent;
pub const _GdkGrabBrokenEvent = struct__GdkGrabBrokenEvent;
pub const _GdkKeyEvent = struct__GdkKeyEvent;
pub const _GdkMotionEvent = struct__GdkMotionEvent;
pub const _GdkPadEvent = struct__GdkPadEvent;
pub const _GdkProximityEvent = struct__GdkProximityEvent;
pub const _GdkScrollEvent = struct__GdkScrollEvent;
pub const _GdkTouchEvent = struct__GdkTouchEvent;
pub const _GdkTouchpadEvent = struct__GdkTouchpadEvent;
pub const _GdkFrameTimings = struct__GdkFrameTimings;
pub const _GdkFrameClock = struct__GdkFrameClock;
pub const _GdkFrameClockPrivate = struct__GdkFrameClockPrivate;
pub const _GdkFrameClockClass = struct__GdkFrameClockClass;
pub const _GdkMonitor = struct__GdkMonitor;
pub const _GdkMonitorClass = struct__GdkMonitorClass;
pub const _GdkPopupLayout = struct__GdkPopupLayout;
pub const _GdkSurfaceClass = struct__GdkSurfaceClass;
pub const _GdkDragSurface = struct__GdkDragSurface;
pub const _GdkDragSurfaceInterface = struct__GdkDragSurfaceInterface;
pub const _GdkDragSurfaceSize = struct__GdkDragSurfaceSize;
pub const _GdkTextureClass = struct__GdkTextureClass;
pub const _GdkGLTexture = struct__GdkGLTexture;
pub const _GdkGLTextureClass = struct__GdkGLTextureClass;
pub const _GdkGLTextureBuilder = struct__GdkGLTextureBuilder;
pub const _GdkGLTextureBuilderClass = struct__GdkGLTextureBuilderClass;
pub const _GdkMemoryTexture = struct__GdkMemoryTexture;
pub const _GdkMemoryTextureClass = struct__GdkMemoryTextureClass;
pub const _GdkPaintable = struct__GdkPaintable;
pub const _GdkPaintableInterface = struct__GdkPaintableInterface;
pub const _GdkPopup = struct__GdkPopup;
pub const _GdkPopupInterface = struct__GdkPopupInterface;
pub const _GdkSnapshotClass = struct__GdkSnapshotClass;
pub const _GdkToplevelLayout = struct__GdkToplevelLayout;
pub const _GdkToplevel = struct__GdkToplevel;
pub const _GdkToplevelInterface = struct__GdkToplevelInterface;
pub const _GdkToplevelSize = struct__GdkToplevelSize;
pub const _graphene_vec2_t = struct__graphene_vec2_t;
pub const _graphene_vec3_t = struct__graphene_vec3_t;
pub const _graphene_vec4_t = struct__graphene_vec4_t;
pub const _graphene_matrix_t = struct__graphene_matrix_t;
pub const _graphene_point_t = struct__graphene_point_t;
pub const _graphene_size_t = struct__graphene_size_t;
pub const _graphene_rect_t = struct__graphene_rect_t;
pub const _graphene_point3d_t = struct__graphene_point3d_t;
pub const _graphene_quad_t = struct__graphene_quad_t;
pub const _graphene_quaternion_t = struct__graphene_quaternion_t;
pub const _graphene_euler_t = struct__graphene_euler_t;
pub const _graphene_plane_t = struct__graphene_plane_t;
pub const _graphene_frustum_t = struct__graphene_frustum_t;
pub const _graphene_sphere_t = struct__graphene_sphere_t;
pub const _graphene_box_t = struct__graphene_box_t;
pub const _graphene_triangle_t = struct__graphene_triangle_t;
pub const _graphene_ray_t = struct__graphene_ray_t;
pub const _GskRenderer = struct__GskRenderer;
pub const _GskTransform = struct__GskTransform;
pub const _GskRoundedRect = struct__GskRoundedRect;
pub const _GskShaderArgsBuilder = struct__GskShaderArgsBuilder;
pub const _GskGLShader = struct__GskGLShader;
pub const _GskRenderNode = struct__GskRenderNode;
pub const _GskColorStop = struct__GskColorStop;
pub const _GskShadow = struct__GskShadow;
pub const _GskParseLocation = struct__GskParseLocation;
pub const _GskDebugNode = struct__GskDebugNode;
pub const _GskColorNode = struct__GskColorNode;
pub const _GskTextureNode = struct__GskTextureNode;
pub const _GskTextureScaleNode = struct__GskTextureScaleNode;
pub const _GskLinearGradientNode = struct__GskLinearGradientNode;
pub const _GskRepeatingLinearGradientNode = struct__GskRepeatingLinearGradientNode;
pub const _GskRadialGradientNode = struct__GskRadialGradientNode;
pub const _GskRepeatingRadialGradientNode = struct__GskRepeatingRadialGradientNode;
pub const _GskConicGradientNode = struct__GskConicGradientNode;
pub const _GskBorderNode = struct__GskBorderNode;
pub const _GskInsetShadowNode = struct__GskInsetShadowNode;
pub const _GskOutsetShadowNode = struct__GskOutsetShadowNode;
pub const _GskCairoNode = struct__GskCairoNode;
pub const _GskContainerNode = struct__GskContainerNode;
pub const _GskTransformNode = struct__GskTransformNode;
pub const _GskOpacityNode = struct__GskOpacityNode;
pub const _GskColorMatrixNode = struct__GskColorMatrixNode;
pub const _GskRepeatNode = struct__GskRepeatNode;
pub const _GskClipNode = struct__GskClipNode;
pub const _GskRoundedClipNode = struct__GskRoundedClipNode;
pub const _GskShadowNode = struct__GskShadowNode;
pub const _GskBlendNode = struct__GskBlendNode;
pub const _GskCrossFadeNode = struct__GskCrossFadeNode;
pub const _GskTextNode = struct__GskTextNode;
pub const _GskBlurNode = struct__GskBlurNode;
pub const _GskMaskNode = struct__GskMaskNode;
pub const _GskGLShaderNode = struct__GskGLShaderNode;
pub const _GskRendererClass = struct__GskRendererClass;
pub const _GskCairoRenderer = struct__GskCairoRenderer;
pub const _GskCairoRendererClass = struct__GskCairoRendererClass;
pub const _GtkAdjustment = struct__GtkAdjustment;
pub const _GtkATContext = struct__GtkATContext;
pub const _GtkBitset = struct__GtkBitset;
pub const _GtkBuilder = struct__GtkBuilder;
pub const _GtkBuilderScope = struct__GtkBuilderScope;
pub const _GtkCssStyleChange = struct__GtkCssStyleChange;
pub const _GtkEventController = struct__GtkEventController;
pub const _GtkGesture = struct__GtkGesture;
pub const _GtkLayoutManager = struct__GtkLayoutManager;
pub const _GtkListItem = struct__GtkListItem;
pub const _GtkListItemFactory = struct__GtkListItemFactory;
pub const _GtkNative = struct__GtkNative;
pub const _GtkRequisition = struct__GtkRequisition;
pub const _GtkRoot = struct__GtkRoot;
pub const _GtkScrollInfo = struct__GtkScrollInfo;
pub const _GtkSettings = struct__GtkSettings;
pub const _GtkShortcut = struct__GtkShortcut;
pub const _GtkShortcutAction = struct__GtkShortcutAction;
pub const _GtkShortcutTrigger = struct__GtkShortcutTrigger;
pub const _GtkStyleContext = struct__GtkStyleContext;
pub const _GtkTooltip = struct__GtkTooltip;
pub const _GtkWidgetPrivate = struct__GtkWidgetPrivate;
pub const _GtkWidget = struct__GtkWidget;
pub const _GtkWindow = struct__GtkWindow;
pub const _GtkShortcutActionClass = struct__GtkShortcutActionClass;
pub const _GtkNothingAction = struct__GtkNothingAction;
pub const _GtkNothingActionClass = struct__GtkNothingActionClass;
pub const _GtkCallbackAction = struct__GtkCallbackAction;
pub const _GtkCallbackActionClass = struct__GtkCallbackActionClass;
pub const _GtkMnemonicAction = struct__GtkMnemonicAction;
pub const _GtkMnemonicActionClass = struct__GtkMnemonicActionClass;
pub const _GtkActivateAction = struct__GtkActivateAction;
pub const _GtkActivateActionClass = struct__GtkActivateActionClass;
pub const _GtkSignalAction = struct__GtkSignalAction;
pub const _GtkSignalActionClass = struct__GtkSignalActionClass;
pub const _GtkNamedAction = struct__GtkNamedAction;
pub const _GtkNamedActionClass = struct__GtkNamedActionClass;
pub const _GtkWidgetClassPrivate = struct__GtkWidgetClassPrivate;
pub const _GtkWidgetClass = struct__GtkWidgetClass;
pub const _GtkApplication = struct__GtkApplication;
pub const _GtkApplicationClass = struct__GtkApplicationClass;
pub const _GtkWindowClass = struct__GtkWindowClass;
pub const _GtkWindowGroupPrivate = struct__GtkWindowGroupPrivate;
pub const _GtkWindowGroup = struct__GtkWindowGroup;
pub const _GtkWindowGroupClass = struct__GtkWindowGroupClass;
pub const _GtkAboutDialog = struct__GtkAboutDialog;
pub const _GtkAccessible = struct__GtkAccessible;
pub const _GtkAccessibleInterface = struct__GtkAccessibleInterface;
pub const _GtkAccessibleRange = struct__GtkAccessibleRange;
pub const _GtkAccessibleRangeInterface = struct__GtkAccessibleRangeInterface;
pub const _GtkActionable = struct__GtkActionable;
pub const _GtkActionableInterface = struct__GtkActionableInterface;
pub const _GtkActionBar = struct__GtkActionBar;
pub const _GtkAdjustmentClass = struct__GtkAdjustmentClass;
pub const _GtkAlertDialog = struct__GtkAlertDialog;
pub const _GtkAppChooser = struct__GtkAppChooser;
pub const _GtkDialog = struct__GtkDialog;
pub const _GtkDialogClass = struct__GtkDialogClass;
pub const _GtkAppChooserDialog = struct__GtkAppChooserDialog;
pub const _GtkAppChooserWidget = struct__GtkAppChooserWidget;
pub const _GtkAppChooserButton = struct__GtkAppChooserButton;
pub const _GtkShortcutsWindow = struct__GtkShortcutsWindow;
pub const _GtkApplicationWindowClass = struct__GtkApplicationWindowClass;
pub const _GtkApplicationWindow = struct__GtkApplicationWindow;
pub const _GtkAspectFrame = struct__GtkAspectFrame;
pub const _GtkAssistant = struct__GtkAssistant;
pub const _GtkAssistantPage = struct__GtkAssistantPage;
pub const _GtkATContextClass = struct__GtkATContextClass;
pub const _GtkLayoutChild = struct__GtkLayoutChild;
pub const _GtkLayoutChildClass = struct__GtkLayoutChildClass;
pub const _GtkLayoutManagerClass = struct__GtkLayoutManagerClass;
pub const _GtkBinLayout = struct__GtkBinLayout;
pub const _GtkBitsetIter = struct__GtkBitsetIter;
pub const _GtkBookmarkList = struct__GtkBookmarkList;
pub const _GtkExpression = struct__GtkExpression;
pub const _GtkExpressionWatch = struct__GtkExpressionWatch;
pub const _GtkPropertyExpression = struct__GtkPropertyExpression;
pub const _GtkConstantExpression = struct__GtkConstantExpression;
pub const _GtkObjectExpression = struct__GtkObjectExpression;
pub const _GtkClosureExpression = struct__GtkClosureExpression;
pub const _GtkCClosureExpression = struct__GtkCClosureExpression;
pub const _GtkFilter = struct__GtkFilter;
pub const _GtkFilterClass = struct__GtkFilterClass;
pub const _GtkBoolFilter = struct__GtkBoolFilter;
pub const _GtkBorder = struct__GtkBorder;
pub const _GtkBoxLayout = struct__GtkBoxLayout;
pub const _GtkBox = struct__GtkBox;
pub const _GtkBoxClass = struct__GtkBoxClass;
pub const _GtkBuilderScopeInterface = struct__GtkBuilderScopeInterface;
pub const _GtkBuilderCScopeClass = struct__GtkBuilderCScopeClass;
pub const _GtkBuilderCScope = struct__GtkBuilderCScope;
pub const _GtkBuilderClass = struct__GtkBuilderClass;
pub const _GtkBuildable = struct__GtkBuildable;
pub const _GtkBuildableParseContext = struct__GtkBuildableParseContext;
pub const _GtkBuildableParser = struct__GtkBuildableParser;
pub const _GtkBuildableIface = struct__GtkBuildableIface;
pub const _GtkListItemFactoryClass = struct__GtkListItemFactoryClass;
pub const _GtkBuilderListItemFactory = struct__GtkBuilderListItemFactory;
pub const _GtkBuilderListItemFactoryClass = struct__GtkBuilderListItemFactoryClass;
pub const _GtkButton = struct__GtkButton;
pub const _GtkButtonPrivate = struct__GtkButtonPrivate;
pub const _GtkButtonClass = struct__GtkButtonClass;
pub const _GtkCalendar = struct__GtkCalendar;
pub const _GtkCellEditable = struct__GtkCellEditable;
pub const _GtkCellEditableIface = struct__GtkCellEditableIface;
pub const _GtkCellRendererPrivate = struct__GtkCellRendererPrivate;
pub const _GtkCellRenderer = struct__GtkCellRenderer;
pub const _GtkCellRendererClass = struct__GtkCellRendererClass;
pub const _GtkCellRendererClassPrivate = struct__GtkCellRendererClassPrivate;
pub const _GtkTreeIter = struct__GtkTreeIter;
pub const _GtkTreePath = struct__GtkTreePath;
pub const _GtkTreeRowReference = struct__GtkTreeRowReference;
pub const _GtkTreeModel = struct__GtkTreeModel;
pub const _GtkTreeModelIface = struct__GtkTreeModelIface;
pub const _GtkCellArea = struct__GtkCellArea;
pub const _GtkCellAreaContext = struct__GtkCellAreaContext;
pub const _GtkCellAreaClass = struct__GtkCellAreaClass;
pub const _GtkCellAreaBox = struct__GtkCellAreaBox;
pub const _GtkCellAreaContextPrivate = struct__GtkCellAreaContextPrivate;
pub const _GtkCellAreaContextClass = struct__GtkCellAreaContextClass;
pub const _GtkCellLayout = struct__GtkCellLayout;
pub const _GtkCellLayoutIface = struct__GtkCellLayoutIface;
pub const _GtkCellRendererText = struct__GtkCellRendererText;
pub const _GtkCellRendererTextClass = struct__GtkCellRendererTextClass;
pub const _GtkCellRendererAccel = struct__GtkCellRendererAccel;
pub const _GtkCellRendererCombo = struct__GtkCellRendererCombo;
pub const _GtkCellRendererPixbuf = struct__GtkCellRendererPixbuf;
pub const _GtkCellRendererProgress = struct__GtkCellRendererProgress;
pub const _GtkCellRendererSpin = struct__GtkCellRendererSpin;
pub const _GtkCellRendererSpinner = struct__GtkCellRendererSpinner;
pub const _GtkCellRendererToggle = struct__GtkCellRendererToggle;
pub const _GtkCellView = struct__GtkCellView;
pub const _GtkCenterBox = struct__GtkCenterBox;
pub const _GtkCenterBoxClass = struct__GtkCenterBoxClass;
pub const _GtkCenterLayout = struct__GtkCenterLayout;
pub const _GtkToggleButton = struct__GtkToggleButton;
pub const _GtkToggleButtonClass = struct__GtkToggleButtonClass;
pub const _GtkCheckButton = struct__GtkCheckButton;
pub const _GtkCheckButtonClass = struct__GtkCheckButtonClass;
pub const _GtkColorButton = struct__GtkColorButton;
pub const _GtkColorChooser = struct__GtkColorChooser;
pub const _GtkColorChooserInterface = struct__GtkColorChooserInterface;
pub const _GtkColorChooserDialog = struct__GtkColorChooserDialog;
pub const _GtkColorChooserWidget = struct__GtkColorChooserWidget;
pub const _GtkColorDialog = struct__GtkColorDialog;
pub const _GtkColorDialogButton = struct__GtkColorDialogButton;
pub const _GtkSorter = struct__GtkSorter;
pub const _GtkSorterClass = struct__GtkSorterClass;
pub const _GtkSortListModel = struct__GtkSortListModel;
pub const _GtkSelectionModel = struct__GtkSelectionModel;
pub const _GtkSelectionModelInterface = struct__GtkSelectionModelInterface;
pub const _GtkColumnView = struct__GtkColumnView;
pub const _GtkColumnViewClass = struct__GtkColumnViewClass;
pub const _GtkColumnViewColumn = struct__GtkColumnViewColumn;
pub const _GtkListItemClass = struct__GtkListItemClass;
pub const _GtkColumnViewCell = struct__GtkColumnViewCell;
pub const _GtkColumnViewCellClass = struct__GtkColumnViewCellClass;
pub const _GtkColumnViewColumnClass = struct__GtkColumnViewColumnClass;
pub const _GtkColumnViewRow = struct__GtkColumnViewRow;
pub const _GtkColumnViewRowClass = struct__GtkColumnViewRowClass;
pub const _GtkColumnViewSorter = struct__GtkColumnViewSorter;
pub const _GtkTreeSortable = struct__GtkTreeSortable;
pub const _GtkTreeSortableIface = struct__GtkTreeSortableIface;
pub const _GtkTreeViewColumn = struct__GtkTreeViewColumn;
pub const _GtkEditable = struct__GtkEditable;
pub const _GtkEditableInterface = struct__GtkEditableInterface;
pub const _GtkIMContext = struct__GtkIMContext;
pub const _GtkIMContextClass = struct__GtkIMContextClass;
pub const _GtkEntryBuffer = struct__GtkEntryBuffer;
pub const _GtkEntryBufferClass = struct__GtkEntryBufferClass;
pub const _GtkListStorePrivate = struct__GtkListStorePrivate;
pub const _GtkListStore = struct__GtkListStore;
pub const _GtkListStoreClass = struct__GtkListStoreClass;
pub const _GtkTreeModelFilterPrivate = struct__GtkTreeModelFilterPrivate;
pub const _GtkTreeModelFilter = struct__GtkTreeModelFilter;
pub const _GtkTreeModelFilterClass = struct__GtkTreeModelFilterClass;
pub const _GtkEntryCompletion = struct__GtkEntryCompletion;
pub const _GtkImage = struct__GtkImage;
pub const _GtkEntry = struct__GtkEntry;
pub const _GtkEntryClass = struct__GtkEntryClass;
pub const _GtkTreeView = struct__GtkTreeView;
pub const _GtkTreeViewClass = struct__GtkTreeViewClass;
pub const _GtkTreeSelection = struct__GtkTreeSelection;
pub const _GtkComboBox = struct__GtkComboBox;
pub const _GtkComboBoxClass = struct__GtkComboBoxClass;
pub const _GtkComboBoxText = struct__GtkComboBoxText;
pub const _GtkConstraintTarget = struct__GtkConstraintTarget;
pub const _GtkConstraintTargetInterface = struct__GtkConstraintTargetInterface;
pub const _GtkConstraint = struct__GtkConstraint;
pub const _GtkConstraintGuide = struct__GtkConstraintGuide;
pub const _GtkConstraintLayoutChild = struct__GtkConstraintLayoutChild;
pub const _GtkConstraintLayout = struct__GtkConstraintLayout;
pub const _GtkCssProvider = struct__GtkCssProvider;
pub const _GtkCssProviderClass = struct__GtkCssProviderClass;
pub const _GtkCssProviderPrivate = struct__GtkCssProviderPrivate;
pub const _GtkCustomLayout = struct__GtkCustomLayout;
pub const _GtkCustomSorter = struct__GtkCustomSorter;
pub const _GtkDirectoryList = struct__GtkDirectoryList;
pub const _GtkDragIcon = struct__GtkDragIcon;
pub const _GtkDragSource = struct__GtkDragSource;
pub const _GtkDragSourceClass = struct__GtkDragSourceClass;
pub const _GtkDrawingArea = struct__GtkDrawingArea;
pub const _GtkDrawingAreaClass = struct__GtkDrawingAreaClass;
pub const _GtkEventControllerClass = struct__GtkEventControllerClass;
pub const _GtkDropControllerMotion = struct__GtkDropControllerMotion;
pub const _GtkDropControllerMotionClass = struct__GtkDropControllerMotionClass;
pub const _GtkDropTarget = struct__GtkDropTarget;
pub const _GtkDropTargetClass = struct__GtkDropTargetClass;
pub const _GtkDropTargetAsync = struct__GtkDropTargetAsync;
pub const _GtkDropTargetAsyncClass = struct__GtkDropTargetAsyncClass;
pub const _GtkStringFilter = struct__GtkStringFilter;
pub const _GtkDropDown = struct__GtkDropDown;
pub const _GtkEditableLabel = struct__GtkEditableLabel;
pub const _GtkEmojiChooser = struct__GtkEmojiChooser;
pub const _GtkEmojiChooserClass = struct__GtkEmojiChooserClass;
pub const _GtkEventControllerFocus = struct__GtkEventControllerFocus;
pub const _GtkEventControllerFocusClass = struct__GtkEventControllerFocusClass;
pub const _GtkEventControllerKey = struct__GtkEventControllerKey;
pub const _GtkEventControllerKeyClass = struct__GtkEventControllerKeyClass;
pub const _GtkEventControllerLegacy = struct__GtkEventControllerLegacy;
pub const _GtkEventControllerLegacyClass = struct__GtkEventControllerLegacyClass;
pub const _GtkEventControllerMotion = struct__GtkEventControllerMotion;
pub const _GtkEventControllerMotionClass = struct__GtkEventControllerMotionClass;
pub const _GtkEventControllerScroll = struct__GtkEventControllerScroll;
pub const _GtkEventControllerScrollClass = struct__GtkEventControllerScrollClass;
pub const _GtkExpander = struct__GtkExpander;
pub const _GtkFixed = struct__GtkFixed;
pub const _GtkFixedClass = struct__GtkFixedClass;
pub const _GtkFixedLayout = struct__GtkFixedLayout;
pub const _GtkFixedLayoutChild = struct__GtkFixedLayoutChild;
pub const _GtkFileFilter = struct__GtkFileFilter;
pub const _GtkFileChooser = struct__GtkFileChooser;
pub const _GtkFileChooserDialog = struct__GtkFileChooserDialog;
pub const _GtkNativeDialog = struct__GtkNativeDialog;
pub const _GtkNativeDialogClass = struct__GtkNativeDialogClass;
pub const _GtkFileChooserNative = struct__GtkFileChooserNative;
pub const _GtkFileChooserWidget = struct__GtkFileChooserWidget;
pub const _GtkFileDialog = struct__GtkFileDialog;
pub const _GtkFileLauncher = struct__GtkFileLauncher;
pub const _GtkFilterListModel = struct__GtkFilterListModel;
pub const _GtkCustomFilter = struct__GtkCustomFilter;
pub const _GtkFlattenListModel = struct__GtkFlattenListModel;
pub const _GtkFlowBox = struct__GtkFlowBox;
pub const _GtkFlowBoxChild = struct__GtkFlowBoxChild;
pub const _GtkFlowBoxChildClass = struct__GtkFlowBoxChildClass;
pub const _GtkFontButton = struct__GtkFontButton;
pub const _GtkFontChooser = struct__GtkFontChooser;
pub const _GtkFontChooserIface = struct__GtkFontChooserIface;
pub const _GtkFontChooserDialog = struct__GtkFontChooserDialog;
pub const _GtkFontChooserWidget = struct__GtkFontChooserWidget;
pub const _GtkFontDialog = struct__GtkFontDialog;
pub const _GtkFontDialogButton = struct__GtkFontDialogButton;
pub const _GtkFrame = struct__GtkFrame;
pub const _GtkFrameClass = struct__GtkFrameClass;
pub const _GtkGestureClass = struct__GtkGestureClass;
pub const _GtkGestureSingle = struct__GtkGestureSingle;
pub const _GtkGestureSingleClass = struct__GtkGestureSingleClass;
pub const _GtkGestureClick = struct__GtkGestureClick;
pub const _GtkGestureClickClass = struct__GtkGestureClickClass;
pub const _GtkGestureDrag = struct__GtkGestureDrag;
pub const _GtkGestureDragClass = struct__GtkGestureDragClass;
pub const _GtkGestureLongPress = struct__GtkGestureLongPress;
pub const _GtkGestureLongPressClass = struct__GtkGestureLongPressClass;
pub const _GtkGesturePan = struct__GtkGesturePan;
pub const _GtkGesturePanClass = struct__GtkGesturePanClass;
pub const _GtkGestureRotate = struct__GtkGestureRotate;
pub const _GtkGestureRotateClass = struct__GtkGestureRotateClass;
pub const _GtkGestureStylus = struct__GtkGestureStylus;
pub const _GtkGestureStylusClass = struct__GtkGestureStylusClass;
pub const _GtkGestureSwipe = struct__GtkGestureSwipe;
pub const _GtkGestureSwipeClass = struct__GtkGestureSwipeClass;
pub const _GtkGestureZoom = struct__GtkGestureZoom;
pub const _GtkGestureZoomClass = struct__GtkGestureZoomClass;
pub const _GtkGLArea = struct__GtkGLArea;
pub const _GtkGLAreaClass = struct__GtkGLAreaClass;
pub const _GtkGrid = struct__GtkGrid;
pub const _GtkGridClass = struct__GtkGridClass;
pub const _GtkGridLayout = struct__GtkGridLayout;
pub const _GtkGridLayoutChild = struct__GtkGridLayoutChild;
pub const _GtkListBase = struct__GtkListBase;
pub const _GtkListBaseClass = struct__GtkListBaseClass;
pub const _GtkGridView = struct__GtkGridView;
pub const _GtkGridViewClass = struct__GtkGridViewClass;
pub const _GtkHeaderBar = struct__GtkHeaderBar;
pub const _GtkIconPaintable = struct__GtkIconPaintable;
pub const _GtkIconTheme = struct__GtkIconTheme;
pub const _GtkIconView = struct__GtkIconView;
pub const _GtkIMContextSimplePrivate = struct__GtkIMContextSimplePrivate;
pub const _GtkIMContextSimple = struct__GtkIMContextSimple;
pub const _GtkIMContextSimpleClass = struct__GtkIMContextSimpleClass;
pub const _GtkIMMulticontextPrivate = struct__GtkIMMulticontextPrivate;
pub const _GtkIMMulticontext = struct__GtkIMMulticontext;
pub const _GtkIMMulticontextClass = struct__GtkIMMulticontextClass;
pub const _GtkInfoBar = struct__GtkInfoBar;
pub const _GtkInscription = struct__GtkInscription;
pub const _GtkLabel = struct__GtkLabel;
pub const _GtkLevelBar = struct__GtkLevelBar;
pub const _GtkLinkButton = struct__GtkLinkButton;
pub const _GtkListBox = struct__GtkListBox;
pub const _GtkListBoxRow = struct__GtkListBoxRow;
pub const _GtkListBoxRowClass = struct__GtkListBoxRowClass;
pub const _GtkListHeader = struct__GtkListHeader;
pub const _GtkListHeaderClass = struct__GtkListHeaderClass;
pub const _GtkListView = struct__GtkListView;
pub const _GtkListViewClass = struct__GtkListViewClass;
pub const _GtkLockButton = struct__GtkLockButton;
pub const _GtkMapListModel = struct__GtkMapListModel;
pub const _GtkMediaStream = struct__GtkMediaStream;
pub const _GtkMediaStreamClass = struct__GtkMediaStreamClass;
pub const _GtkMediaControls = struct__GtkMediaControls;
pub const _GtkMediaFile = struct__GtkMediaFile;
pub const _GtkMediaFileClass = struct__GtkMediaFileClass;
pub const _GtkPopover = struct__GtkPopover;
pub const _GtkPopoverClass = struct__GtkPopoverClass;
pub const _GtkMenuButton = struct__GtkMenuButton;
pub const _GtkMessageDialog = struct__GtkMessageDialog;
pub const _GtkMessageDialogClass = struct__GtkMessageDialogClass;
pub const _GtkMountOperationPrivate = struct__GtkMountOperationPrivate;
pub const _GtkMountOperation = struct__GtkMountOperation;
pub const _GtkMountOperationClass = struct__GtkMountOperationClass;
pub const _GtkMultiFilter = struct__GtkMultiFilter;
pub const _GtkMultiFilterClass = struct__GtkMultiFilterClass;
pub const _GtkAnyFilter = struct__GtkAnyFilter;
pub const _GtkAnyFilterClass = struct__GtkAnyFilterClass;
pub const _GtkEveryFilter = struct__GtkEveryFilter;
pub const _GtkEveryFilterClass = struct__GtkEveryFilterClass;
pub const _GtkMultiSelection = struct__GtkMultiSelection;
pub const _GtkMultiSorter = struct__GtkMultiSorter;
pub const _GtkNativeInterface = struct__GtkNativeInterface;
pub const _GtkNoSelection = struct__GtkNoSelection;
pub const _GtkNotebookPage = struct__GtkNotebookPage;
pub const _GtkNotebook = struct__GtkNotebook;
pub const _GtkNumericSorter = struct__GtkNumericSorter;
pub const _GtkOrientable = struct__GtkOrientable;
pub const _GtkOrientableIface = struct__GtkOrientableIface;
pub const _GtkOverlay = struct__GtkOverlay;
pub const _GtkOverlayLayout = struct__GtkOverlayLayout;
pub const _GtkOverlayLayoutChild = struct__GtkOverlayLayoutChild;
pub const _GtkPadController = struct__GtkPadController;
pub const _GtkPadControllerClass = struct__GtkPadControllerClass;
pub const _GtkPadActionEntry = struct__GtkPadActionEntry;
pub const _GtkPaperSize = struct__GtkPaperSize;
pub const _GtkPageSetup = struct__GtkPageSetup;
pub const _GtkPaned = struct__GtkPaned;
pub const _GtkPasswordEntry = struct__GtkPasswordEntry;
pub const _GtkPasswordEntryClass = struct__GtkPasswordEntryClass;
pub const _GtkPasswordEntryBuffer = struct__GtkPasswordEntryBuffer;
pub const _GtkPicture = struct__GtkPicture;
pub const _GtkPopoverMenu = struct__GtkPopoverMenu;
pub const _GtkPopoverMenuBar = struct__GtkPopoverMenuBar;
pub const _GtkPrintContext = struct__GtkPrintContext;
pub const _GtkPrintSettings = struct__GtkPrintSettings;
pub const _GtkPageRange = struct__GtkPageRange;
pub const _GtkPrintOperationPreview = struct__GtkPrintOperationPreview;
pub const _GtkPrintOperationPreviewIface = struct__GtkPrintOperationPreviewIface;
pub const _GtkPrintOperationPrivate = struct__GtkPrintOperationPrivate;
pub const _GtkPrintOperation = struct__GtkPrintOperation;
pub const _GtkPrintOperationClass = struct__GtkPrintOperationClass;
pub const _GtkProgressBar = struct__GtkProgressBar;
pub const _GtkRange = struct__GtkRange;
pub const _GtkRangeClass = struct__GtkRangeClass;
pub const _GtkRecentInfo = struct__GtkRecentInfo;
pub const _GtkRecentData = struct__GtkRecentData;
pub const _GtkRecentManagerPrivate = struct__GtkRecentManagerPrivate;
pub const _GtkRecentManager = struct__GtkRecentManager;
pub const _GtkRecentManagerClass = struct__GtkRecentManagerClass;
pub const _GtkSnapshotClass = struct__GtkSnapshotClass;
pub const _GtkRevealer = struct__GtkRevealer;
pub const _GtkRootInterface = struct__GtkRootInterface;
pub const _GtkScale = struct__GtkScale;
pub const _GtkScaleClass = struct__GtkScaleClass;
pub const _GtkScaleButton = struct__GtkScaleButton;
pub const _GtkScaleButtonClass = struct__GtkScaleButtonClass;
pub const _GtkScrollable = struct__GtkScrollable;
pub const _GtkScrollableInterface = struct__GtkScrollableInterface;
pub const _GtkScrollbar = struct__GtkScrollbar;
pub const _GtkScrolledWindow = struct__GtkScrolledWindow;
pub const _GtkSearchBar = struct__GtkSearchBar;
pub const _GtkSearchEntry = struct__GtkSearchEntry;
pub const _GtkSectionModel = struct__GtkSectionModel;
pub const _GtkSectionModelInterface = struct__GtkSectionModelInterface;
pub const _GtkSelectionFilterModel = struct__GtkSelectionFilterModel;
pub const _GtkSeparator = struct__GtkSeparator;
pub const _GtkShortcutController = struct__GtkShortcutController;
pub const _GtkShortcutControllerClass = struct__GtkShortcutControllerClass;
pub const _GtkShortcutLabel = struct__GtkShortcutLabel;
pub const _GtkShortcutLabelClass = struct__GtkShortcutLabelClass;
pub const _GtkShortcutManager = struct__GtkShortcutManager;
pub const _GtkShortcutManagerInterface = struct__GtkShortcutManagerInterface;
pub const _GtkShortcutsGroup = struct__GtkShortcutsGroup;
pub const _GtkShortcutsGroupClass = struct__GtkShortcutsGroupClass;
pub const _GtkShortcutsSection = struct__GtkShortcutsSection;
pub const _GtkShortcutsSectionClass = struct__GtkShortcutsSectionClass;
pub const _GtkShortcutsShortcut = struct__GtkShortcutsShortcut;
pub const _GtkShortcutsShortcutClass = struct__GtkShortcutsShortcutClass;
pub const _GtkShortcutTriggerClass = struct__GtkShortcutTriggerClass;
pub const _GtkNeverTrigger = struct__GtkNeverTrigger;
pub const _GtkNeverTriggerClass = struct__GtkNeverTriggerClass;
pub const _GtkKeyvalTrigger = struct__GtkKeyvalTrigger;
pub const _GtkKeyvalTriggerClass = struct__GtkKeyvalTriggerClass;
pub const _GtkMnemonicTrigger = struct__GtkMnemonicTrigger;
pub const _GtkMnemonicTriggerClass = struct__GtkMnemonicTriggerClass;
pub const _GtkAlternativeTrigger = struct__GtkAlternativeTrigger;
pub const _GtkAlternativeTriggerClass = struct__GtkAlternativeTriggerClass;
pub const _GtkSignalListItemFactory = struct__GtkSignalListItemFactory;
pub const _GtkSignalListItemFactoryClass = struct__GtkSignalListItemFactoryClass;
pub const _GtkSingleSelection = struct__GtkSingleSelection;
pub const _GtkSliceListModel = struct__GtkSliceListModel;
pub const _GtkStack = struct__GtkStack;
pub const _GtkStackPage = struct__GtkStackPage;
pub const _GtkStackSidebar = struct__GtkStackSidebar;
pub const _GtkSizeGroup = struct__GtkSizeGroup;
pub const _GtkRequestedSize = struct__GtkRequestedSize;
pub const _GtkSpinButton = struct__GtkSpinButton;
pub const _GtkSpinner = struct__GtkSpinner;
pub const _GtkStackSwitcher = struct__GtkStackSwitcher;
pub const _GtkStatusbar = struct__GtkStatusbar;
pub const _GtkStringObject = struct__GtkStringObject;
pub const _GtkStringList = struct__GtkStringList;
pub const _GtkStringSorter = struct__GtkStringSorter;
pub const _GtkStyleProvider = struct__GtkStyleProvider;
pub const _GtkStyleContextClass = struct__GtkStyleContextClass;
pub const _GtkSwitch = struct__GtkSwitch;
pub const _GtkSymbolicPaintable = struct__GtkSymbolicPaintable;
pub const _GtkSymbolicPaintableInterface = struct__GtkSymbolicPaintableInterface;
pub const _GtkText = struct__GtkText;
pub const _GtkTextIter = struct__GtkTextIter;
pub const _GtkTextTagTable = struct__GtkTextTagTable;
pub const _GtkTextTagPrivate = struct__GtkTextTagPrivate;
pub const _GtkTextTag = struct__GtkTextTag;
pub const _GtkTextTagClass = struct__GtkTextTagClass;
pub const _GtkTextChildAnchor = struct__GtkTextChildAnchor;
pub const _GtkTextChildAnchorClass = struct__GtkTextChildAnchorClass;
pub const _GtkTextBufferPrivate = struct__GtkTextBufferPrivate;
pub const _GtkTextBuffer = struct__GtkTextBuffer;
pub const _GtkTextMark = struct__GtkTextMark;
pub const _GtkTextMarkClass = struct__GtkTextMarkClass;
pub const _GtkTextBufferClass = struct__GtkTextBufferClass;
pub const _GtkTextViewPrivate = struct__GtkTextViewPrivate;
pub const _GtkTextView = struct__GtkTextView;
pub const _GtkTextViewClass = struct__GtkTextViewClass;
pub const _GtkTreeDragSource = struct__GtkTreeDragSource;
pub const _GtkTreeDragSourceIface = struct__GtkTreeDragSourceIface;
pub const _GtkTreeDragDest = struct__GtkTreeDragDest;
pub const _GtkTreeDragDestIface = struct__GtkTreeDragDestIface;
pub const _GtkTreeListModel = struct__GtkTreeListModel;
pub const _GtkTreeListRow = struct__GtkTreeListRow;
pub const _GtkTreeExpander = struct__GtkTreeExpander;
pub const _GtkTreeListRowSorter = struct__GtkTreeListRowSorter;
pub const _GtkTreeModelSortPrivate = struct__GtkTreeModelSortPrivate;
pub const _GtkTreeModelSort = struct__GtkTreeModelSort;
pub const _GtkTreeModelSortClass = struct__GtkTreeModelSortClass;
pub const _GtkTreeStorePrivate = struct__GtkTreeStorePrivate;
pub const _GtkTreeStore = struct__GtkTreeStore;
pub const _GtkTreeStoreClass = struct__GtkTreeStoreClass;
pub const _GtkUriLauncher = struct__GtkUriLauncher;
pub const _GtkVideo = struct__GtkVideo;
pub const _GtkViewport = struct__GtkViewport;
pub const _GtkVolumeButton = struct__GtkVolumeButton;
pub const _GtkWidgetPaintable = struct__GtkWidgetPaintable;
pub const _GtkWindowControls = struct__GtkWindowControls;
pub const _GtkWindowHandle = struct__GtkWindowHandle;
